{
  "name" : "1401.5850.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The Logical Difference for the Lightweight Description Logic EL",
    "authors" : [ "Boris Konev", "Michel Ludwig", "Dirk Walther", "Frank Wolter" ],
    "emails" : [ "konev@liverpool.ac.uk", "michel.ludwig@liverpool.ac.uk", "dirk.walther@upm.es", "wolter@liverpool.ac.uk" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Terminologies are lightweight ontologies that are used to provide a common vocabulary for a domain of interest together with descriptions of the meaning of terms built from the vocabulary and relationships between them. They are being used in areas such as medical informatics, bio-informatics, and the semantic web to capture domain semantics and promote interoperability. Terminologies are often large and complex. For example, the widely used medical terminology Snomed CT (Systematized Nomenclature of Medicine Clinical Terms) contains more than 300 000 term definitions (IHTSDO, 2008). Another example is the National Cancer Institute ontology (NCI) consisting of more than 60 000 axioms (Golbeck, Fragaso, Hartel, Hendler, Oberhaler, & Parsia, 2003). Engineering, maintaining, and using such terminologies is a complex and laborious task, which is practically unfeasible without appropriate tool support. In this article, we focus on a principled logic-based approach to support for terminology versioning.\nDealing with multiple versions of the same information unit is nothing new in computing, and version control is a well established computer technology. Although modern version control systems provide a range of operations including support for collaborative development, branching, merging, etc., these operations extend and rely on the basic operations of\nc©2012 AI Access Foundation. All rights reserved.\nKonev, Ludwig, Walther, & Wolter\ndetecting and representing the differences between versions. In this paper, we focus on this basic problem of versioning.\nThe need for versioning support is recognised by the ontology research community and ontology users, and a large number of approaches and tools have been developed. In our review of currently existing support for ontology versioning, we distinguish three approaches and describe them according to the difference between ontologies they compute:\n1. versioning based on syntactic difference (syntactic diff);\n2. versioning based on structural difference (structural diff);\n3. versioning based on logical difference (logical diff).\nThe syntactic diff underlies most existing version control systems used in software development (Conradi & Westfechtel, 1998) (such as, for example, RCS, CVS, SCCS). It works with text files and represents the difference between versions as blocks of text present in one version but not another, ignoring any meta-information about the document. As observed already in the work of Noy and Musen (2002), ontology versioning cannot rely on a purely syntactic diff operation since many syntactic differences (e.g., the order of ontology axioms) do not affect the semantics of ontologies. Therefore, ontology versioning based on syntactic difference is essentially limited to comparing rather informal change logs (Oliver, Shahar, Shortliffe, & Musen, 1999).\nThe structural diff extends the syntactic diff by taking into account information about the structure of ontologies. It has been suggested for dealing with structured and hierarchical documents such as UML diagrams, database schemas, or XML documents (see, e.g., Ohst, Welle, & Kelter, 2003, and references within). For ontologies, the main characteristic of the structural diff is that it regards them as structured objects, such as an is-a taxonomy (Noy & Musen, 2002), a set of RDF triplets (Klein, Fensel, Kiryakov, & Ognyanov, 2002) or a set of class defining axioms (Redmond, Smith, Drummond, & Tudorache, 2008; Jiménez-Ruiz, Cuenca Grau, Horrocks, & Llavori, 2011). Changes to ontologies are mostly described in terms of structural operations, for example, adding or deleting a class, extending a class, renaming slots, moving a class from one place in the hierarchy to another, adding or deleting an axiom, class renaming, etc.; sometimes basic logical properties of ontologies, e.g., the equivalence of different structural forms of concepts, are also taken into account (Palma, Haase, Corcho, & Gómez-Pérez, 2009; Jiménez-Ruiz et al., 2011). Ontology versioning based on structural diff of some form is available in most current ontology editors and ontology management systems either natively or through plugins (Noy & Musen, 2002; Klein et al., 2002; Jiménez-Ruiz et al., 2011).\nThough very helpful, the structural diff still has the deficiency of having no unambiguous semantic foundation and being syntax dependent. Moreover, it is tailored towards applications of ontologies which are based on the induced concept hierarchy (or some mild extension of it), but does not capture modern applications such as ontology based data access (OBDA) (Poggi, Lembo, Calvanese, Giacomo, Lenzerini, & Rosati, 2008; Lutz, Toman, & Wolter, 2009) in which ontologies are used to provide a user-oriented view of the data\nThe Logical Difference for the Lightweight Description Logic EL\nand make it accessible via queries formulated solely in the language of the ontology without any knowledge of the actual structure of the data.1\nThe logical diff has only been recently introduced (Konev, Walther, & Wolter, 2008; Kontchakov, Wolter, & Zakharyaschev, 2010) and completely abstracts from the representation of the ontology. Here, an ontology is regarded as a set of axioms formulated in a logical language with a formal and unambiguous semantics. Under this view, ontologies provide answers to queries about some vocabulary of interest. Typical queries include subsumption queries between concepts and, if the ontology is used to access instance data, instance and conjunctive queries. The logical diff is motivated by this view. If two versions of an ontology give the same answers to a class of queries relevant to an application domain, they may be deemed to have no difference regardless of their syntactic or structural form; and queries producing different answers from the versions may be considered as a characterisation of the difference itself. In this way one can, for example, define exactly the differences visible when querying instance data or exactly the differences expressed by subsumptions between concepts.\nTo make this approach work in practice, at least two problems have to be addressed:\n• For most ontology languages and classes of queries the computational complexity of even detecting if two ontology versions differ over a certain vocabulary is at least one exponential harder than ontology classification and is sometimes undecidable; and even if the computational complexity does not increase, searching for differences between ontologies within a certain vocabulary requires techniques that are very different from those used for standard reasoning (Lutz, Walther, & Wolter, 2007; Lutz & Wolter, 2010; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008).\n• If the set of queries producing different answers from the two versions is not empty, it is typically infinite and, therefore, cannot be presented to the user as such. Thus, techniques to succinctly characterise its elements and present them to the user are required.\nThe aim of this paper is to provide first steps toward solutions to these problems for terminologies (aka classical TBoxes) given in the description logic ELHr that extends the description logic EL underlying the OWL 2 EL profile with role inclusions and domain and range restrictions (Baader, Brandt, & Lutz, 2008). Our main contributions are as follows:\n1. It has been argued that syntax-dependence should be regarded as an advantage rather than a deficiency in the context of versioning (Gonçalves, Parsia, & Sattler, 2011; Jiménez-Ruiz et al., 2011). For example, Jiménez-Ruiz et al. argue that logical equivalence between ontologies can be too permissive: “even if O ≡ O′ – the strongest assumption from a semantic point of view – conflicts may still exist. This might result from the presence of incompatible annotations (statements that act as comments and do not carry logical meaning), or a mismatch in modelling styles; for example, O may be written in a simple language such as the OWL 2 EL profile and contain α = (A v BuC), while O′ may contain β = (¬Bt¬C v ¬A). Even though α ≡ β, the explicit use of negation and disjunction means that O′ is outside the EL profile.” We agree with Jiménez-Ruiz et al. and Gonçalves et al. that there are various applications in which a structural rather than logical difference is appropriate. Even a syntactic diff has applications in ontology versioning. In practice, we see logic-based approaches as complementary to structural approaches. An interesting analysis of NCI versions taking into account both structural and logical differences is given in the work of Gonçalves et al.\nKonev, Ludwig, Walther, & Wolter\n• for subsumption, instance, and conjunctive queries, we present polynomial-time algorithms that decide whether two ELHr-terminologies give different answers to some query from the respective class of queries over a given signature of concept and role names (note that we use the terms signature and vocabulary synonymously).\n• Besides of a polynomial-time decision procedure detecting differences, we also develop a succinct presentation of the (typically infinite) difference. This presentation can be computed in polynomial time as well.\n• We present two different types of polynomial-time algorithms for deciding the existence of logical differences between terminologies and for computing a succinct representation of it: the first type of algorithms is conceptually more transparent as it keeps the two input terminologies separate and reduces (a substantial part of) the difference problem to an instance checking problem for an ABox. Such algorithms are, however, not sufficiently efficient on very large inputs. For example, substantial performance problems occur when computing the differences between versions of Snomed CT on their joint signature since the constructed ABox is typically of quadratic size in the input terminologies. The second variant of algorithms, which is based on dynamic programming, is more efficient in practice. It is developed in detail for acyclic ELHr-terminologies. •We present an implementation, CEX2, that is based on the second type of algorithms and computes a succinct representation of the difference between acyclic ELHr-terminologies for the concept and instance query case. In addition, a prototype implementation of the ABox-based algorithm is used to estimate its efficiency.\n• As an important tool in our investigation, we present description logics, ELran and ELran,u,u, that capture as subsumption differences the instance and query difference between ELHr-terminologies. This result is presented for general ELHr-TBoxes and can, therefore, be exploited in future work on versioning for general ELHr-TBoxes. • We present experiments using CEX2 that illustrate the efficiency of the algorithms and potential applications to terminologies such as Snomed CT and NCI. A plugin for Protégé is discussed. CEX2 extends the functionality of the first version of CEX (Konev, Walther, & Wolter, 2008) and of the OwlDiff plugin (Křemen, Šmı́d, & Kouba, 2011), which implements the algorithms developed by Konev, Walther, and Wolter. Based on Snomed CT, we also investigate the performance of the ABox-based algorithms in practice.\nThis paper is based on, and extends the work of Konev, Walther, and Wolter (2008). To improve readability, a number of proofs have been deferred to an appendix."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "Let NC, NR, and NI be countably infinite and mutually disjoint sets of concept names, role names, and individual names. EL-concepts C are built according to the rule\nC := A | > | C uD | ∃r.C,\nwhere A ∈ NC, r ∈ NR, and C,D range over EL-concepts. The set of ELHr-inclusions consists of\n• concept inclusions C v D, ran(r) v D and ran(r) u C v D,\nThe Logical Difference for the Lightweight Description Logic EL\n• concept equations C ≡ D, and\n• role inclusions r v s,\nwhere C and D are EL-concepts and r, s ∈ NR. An ELHr-TBox T is a finite set of ELHrinclusions. Inclusions of the form ran(r) v D and ran(r)uC v D are also referred to as range restrictions, and inclusions of the form ∃r.> v D are referred to as domain restrictions.\nAn ELHr-TBox is called an ELHr-terminology if all its concept inclusions and equations are of the form\n• A v C and A ≡ C,\n• ran(r) v C, and\n• ∃r.> v C,\nwhere A ∈ NC and r ∈ NR, C is an EL-concept such that C 6= >, C 6= > u >, etc., and no concept name occurs more than once on the left-hand side. Note that, in concept inclusions of the form ∃r.> v C, the concept ∃r.> is often denoted dom(r). A terminology is acyclic (or unfoldable) if the process of exhaustively substituting definitions in place of the defined concept names terminates. For example, if a terminology contains a concept inclusion\nMother v ∃hasMother.Mother\nit is not acyclic. Formally, consider the relation ≺T between concept names by setting A ≺T B if there exists an ELHr-inclusion of the form A ≡ C or A v C in T such that B occurs in C. A terminology T is acyclic if the transitive closure ≺+T of ≺T is irreflexive.\nIn description logic, instance data are represented by ABox assertions of the form >(a), A(a) and r(a, b), where a, b ∈ NI, A ∈ NC, and r ∈ NR. An ABox A is a non-empty finite set of ABox-assertions. A is said to be a singleton ABox if it contains exactly one ABox assertion. By obj(A) we denote the set of individual names in A. A knowledge base K (KB) is a pair (T ,A) consisting of a TBox T and an ABox A. Assertions of the form C(a) and r(a, b), where a, b ∈ NI, C an EL-concept, and r ∈ NR, are called instance assertions. Note that instance assertions of the form C(a) with C not a concept name nor C = > do not occur in ABoxes.\nThe semantics of ELHr is given by interpretations I = (∆I , ·I), where the domain ∆I is a non-empty set, and ·I is a function mapping each concept name A to a subset AI of ∆I , each role name r to a binary relation rI ⊆ ∆I ×∆I , and each individual name a to an element aI ∈ ∆I . The extension CI of a concept C is defined by induction as follows:\n>I := ∆I (C uD)I := CI ∩DI\n(∃r.C)I := {d ∈ ∆I | ∃e ∈ CI : (d, e) ∈ rI} ran(r)I := {d ∈ ∆I | ∃e : (e, d) ∈ rI}"
    }, {
      "heading" : "I satisfies",
      "text" : "• a concept inclusion C v D, in symbols I |= C v D, if CI ⊆ DI ;\nKonev, Ludwig, Walther, & Wolter\n• a concept equation C ≡ D, in symbols I |= C ≡ D, if CI = DI ;\n• a role inclusion r v s, in symbols I |= r v s, if rI ⊆ sI ;\n• an assertion C(a), in symbols I |= C(a), if aI ∈ CI ,\n• an assertion r(a, b), in symbols I |= r(a, b), if (aI , bI) ∈ rI .\nWe say that an interpretation I is a model of a TBox T (ABox A) if I |= α for all α ∈ T (α ∈ A). An ELHr-inclusion α follows from a TBox T if every model of T is a model of α, in symbols T |= α. |= α is used to denote that α follows from the empty TBox and we sometimes write r vT s for T |= r v s. An instance assertion α follows from a KB (T ,A) if every individual name that occurs in α also occurs in obj(A) and every model of (T ,A) is a model of α, in symbols (T ,A) |= α. The most important ways of querying ELHr-TBoxes and KBs are\n• subsumption: check whether T |= α, for an ELHr-inclusion α and TBox T ,\n• instance checking: check whether (T ,A) |= α, for an instance assertion α and KB (T ,A), and\n• conjunctive query answering.\nTo define the latter, call a first-order formula q(~x) a conjunctive query if it is of the form ∃~yψ(~x, ~y), where ψ is a conjunction of expressions A(t), A ∈ NC, and r(t1, t2), r ∈ NR, with t, t1, t2 drawn from NI and the sequences of variables ~x and ~y. Let ~x = x1, . . . , xk. Let I be an interpretation and π be a mapping from ~x∪ ~y into ∆I . Set π(a) = aI for all a ∈ obj(A). We say that a vector ~a = a1, . . . , ak is a π-match of q(~x) and I if π satisfies the following conditions:\n• π(t) ∈ AI for every conjunct A(t) of ψ;\n• (π(t1), π(t2)) ∈ rI for every conjunct r(t1, t2) of ψ;\n• π(xi) = aIi for 1 ≤ i ≤ k.\nWe set I |= q[~a] if, and only if, there exists a π such that ~a is a π-match of q(~x) and I. Let (T ,A) be a KB. Then a sequence ~a of members of obj(A) is a certain answer to q(~x) of a KB (T ,A), in symbols (T ,A) |= q(~a), if I |= q[~a], for every model I of (T ,A).\nAll three types of querying ELHr-TBoxes have been studied extensively. The complexity of subsumption and instance checking is in PTime (Baader et al., 2008). The combined complexity of answering Boolean conjunctive queries (i.e., deciding whether (T ,A) |= q for a conjunctive query q without free variables) is coNP-complete (Rosati, 2007) and its data complexity is in PTime (Rosati, 2007). Information on reasoners for subsumption checking for ELHr can be found in the work of Delaitre and Kazakov (2009), Kazakov, Krötzsch, and Simancik (2011), and Mendez and Suntisrivaraporn (2009). Lutz et al. (2009) present an approach to efficient conjunctive query answering for ELHr.\nThe Logical Difference for the Lightweight Description Logic EL"
    }, {
      "heading" : "2.1 Normal Form",
      "text" : "It is often convenient to consider normalised ELHr-terminologies. Let T be an ELHrterminology and A a concept name. Call A\n• primitive in T if A ∈ NC \\ ({A ∈ NC | A ≡ C ∈ T } ∪ {A ∈ NC | A v C ∈ T });\n• pseudo-primitive in T if A ∈ NC \\ {A ∈ NC | A ≡ C ∈ T }.\nNote that concept names that do not occur in T are primitive and pseudo-primitive in T . Call a concept name A non-conjunctive in T if it is pseudo-primitive in T or there exists a concept of the form ∃r.C such that A ≡ ∃r.C ∈ T . Otherwise, A is called conjunctive in T . Thus, A is conjunctive in T if, and only if, there exists a concept name B such that A ≡ B ∈ T or there exist C1, . . . , Cn, n ≥ 2, such that A ≡ C1 u · · · u Cn ∈ T . Let X be a finite set of concepts. We say that a concept F is a conjunction of concepts in X if F is of the form d D∈X D. Any D ∈ X is then called a conjunct of F and, if D is a concept name, then it is called an atomic conjunct of F . We sometimes write D ∈ F instead of D ∈ X. An ELHr-terminology T is normalised if it consists of ELHr-inclusions of the following\nform:\n• A ≡ ∃r.B, or A ≡ F , where A, B are concept names and F is a non-empty conjunction of concept names such that every conjunct B′ of F is non-conjunctive in T ;\n• E v ∃r.B, E v ∃r.>, or E v F , where B is a concept name, E is either a concept name, or is of the form ∃s.>, or ran(s), and F is a non-empty conjunction of concept names such that every conjunct B′ of F is non-conjunctive in T .\nAs the following lemma shows, any ELHr-terminology can be normalised yielding a model conservative extension of the original terminology.\nLemma 1. For every ELHr-terminology T , one can construct in polynomial time a normalised terminology T ′ of polynomial size in |T | such that sig(T ) ⊆ sig(T ′), T ′ |= T , and for every model I of T there exists a model J of T ′ such that ∆I = ∆J and XI = XJ for every X ∈ sig(T ). Moreover, T ′ is acyclic if T is acyclic.\nNormalised terminologies in the sense defined above are a minor modification of normalised terminologies as defined by Baader (2003). The straightforward extension of the proof given by Baader is provided in the appendix."
    }, {
      "heading" : "2.2 Canonical Model",
      "text" : "We define a canonical model, IK, for ELHr-knowledge bases K. IK can be constructed in polynomial time and gives the same answers to instance queries as K; i.e., IK |= α if, and only if, K |= α, for any instance assertion α. The construction is similar to the canonical model introduced by Lutz et al. (2009).\nLet sub(T ) denote the set of all subconcepts of concepts used in T , rol(T ) the set of all role names occurring in T . Take fresh individual names xran(r),D for every r ∈ rol(T ) and D ∈ sub(T ) and set\nNIaux := {xran(r),D | r ∈ rol(T ) and D ∈ sub(T )}.\nKonev, Ludwig, Walther, & Wolter\nNow define the generating interpretation WK of a KB K = (T ,A) as follows:\n∆WK := obj(A) ∪ NIaux; AWK := {a ∈ obj(A) | K |= A(a)} ∪ {xran(r),D ∈ NIaux | T |= ran(r) uD v A}; rWK := {(a, b) ∈ obj(A)× obj(A) | s(a, b) ∈ A and T |= s v r} ∪\n{(a, xran(s),D) ∈ obj(A)× NIaux | K |= ∃s.D(a) and T |= s v r} ∪ {(xran(s),D, xran(s′),D′) ∈ NIaux × NIaux | T |= ran(s) uD v ∃s′.D′, T |= s′ v r};\naWK := a, for all a ∈ obj(A).\nA path inWK is a finite sequence d0r1d1 · · · rndn, n ≥ 0, where d0 ∈ obj(A) and, for all i < n, (di, di+1) ∈ rWKi+1 . We use paths(WK) to denote the set of all paths inWK. If p ∈ paths(WK), then tail(p) denotes the last element dn in p.\nThe canonical model IK of a knowledge base K is the restriction of WK to all domain elements d such that there is a path in WK with tail d. The following result summarises the main properties of IK.\nTheorem 2. Let K = (T ,A) be an ELHr-KB. Then\n1. IK is a model of K;\n2. IK can be computed in polynomial time in the size of K;\n3. for all xran(s),D ∈ ∆IK and all a ∈ obj(A), if C is an EL-concept or C = ran(r), then\n• K |= C(a) if, and only if, aIK ∈ CIK. • T |= ran(s) uD v C if, and only if, xran(s),D ∈ CIK.\nThe proof of Theorem 2 is given in the appendix. It follows from Point 3 that IK gives the same answers to instance queries as K itself."
    }, {
      "heading" : "3. Logical Difference",
      "text" : "In this section, we introduce three notions of logical difference between TBoxes and the derived notion of Σ-inseparability. Intuitively, the logical difference between two TBoxes T1 and T2 should be the set of all ‘relevant formulas’ ϕ such that T1 |= ϕ and T2 6|= ϕ or vice versa. Of course, which formulas ϕ are relevant depends on the application domain. In many applications only subsumptions between concepts are relevant, but if TBoxes are employed to access instance data, then answers to instance or even conjunctive queries can be relevant as well. In addition, in applications of large-scale terminologies such as Snomed CT and NCI typically only a very small subset of the vocabulary of the terminology is relevant. Thus, a meaningful notion of logical difference should take into account only those formulas that are given in a certain signature of interest, where a signature Σ is a subset of NC ∪NR. Given a concept, role, concept inclusion, TBox, ABox, or query E, we denote by sig(E) the signature of E, that is, the set of concept and role names occurring in it. We call E a Σ-concept, Σ-concept inclusion, Σ-TBox, Σ-ABox, or Σ-query, respectively, if sig(E) ⊆ Σ. Similarly, an ELΣ-concept C is an EL-concept such that sig(C) ⊆ Σ and an ELHrΣ-inclusion α is an ELHr-inclusion such that sig(α) ⊆ Σ.\nThe first notion of logical difference we introduce corresponds to applications in which only subsumptions are relevant.\nThe Logical Difference for the Lightweight Description Logic EL\nDefinition 3 (Σ-concept difference). The Σ-concept difference between ELHr-TBoxes T1 and T2 is the set cDiffΣ(T1, T2) of all ELHrΣ-inclusions α such that T1 |= α and T2 6|= α. We say that T1 and T2 are Σ-concept inseparable, in symbols T1 ≡CΣ T2, if cDiffΣ(T1, T2) = cDiffΣ(T2, T1) = ∅.\nΣ-concept inseparability between T1 and T2 means that T1 can be replaced by T2 in any application that is only concerned with ELHrΣ-inclusions.2 As the following example shows, however, Σ-concept inseparable terminologies can give different answers for the same instance query and data.\nExample 4. Let T1 = {ran(r) v A1, ran(s) v A2, B ≡ A1 u A2}, T2 = ∅,Σ = {r, s, B}. One can show that T1 and T2 are Σ-concept inseparable. However, for the Σ-ABox A = {r(a, c), s(b, c)} we have (T1,A) |= B(c) but (T2,A) 6|= B(c).\nTo take into account the differences between TBoxes that are relevant if TBoxes are used to access instance data, we consider the Σ-instance difference.\nDefinition 5 (Σ-instance difference). The Σ-instance difference between TBoxes T1 and T2 is the set iDiffΣ(T1, T2) of pairs of the form (A, α), where A is a Σ-ABox and α a Σ-instance assertion such that (T1,A) |= α and (T2,A) 6|= α. We say that T1 and T2 are Σ-instance inseparable, in symbols T1 ≡iΣ T2, if iDiffΣ(T1, T2) = iDiffΣ(T2, T1) = ∅.\nIn contrast to ELHr, it has been shown by Lutz and Wolter (2010) that for EL-TBoxes there is no difference between Σ-concept inseparability and Σ-instance inseparability. In this paper we extend this result to ELHr-TBoxes without range restrictions (the proof is given after Corollary 37):\nTheorem 6. Let T1 and T2 be ELHr-TBoxes without range restrictions and Σ a signature. Then T1 ≡CΣ T2 if, and only if, T1 ≡iΣ T2.\nSometimes, instance queries are not sufficiently expressive, and conjunctive queries are employed. In that case, the following notion of difference is appropriate.\nDefinition 7 (Σ-query-difference). The Σ-query difference between TBoxes T1 and T2 is the set qDiffΣ(T1, T2) of pairs of the form (A, q(~a)), where A is a Σ-ABox, q(~x) a Σconjunctive query, and ~a a tuple of individual names in A such that (T1,A) |= q(~a) and (T2,A) 6|= q(~a). We say that T1 and T2 are Σ-query inseparable, in symbols T1 ≡qΣ T , if qDiffΣ(T1, T2) = qDiffΣ(T2, T1) = ∅.\nAs observed by Lutz and Wolter (2010) already, even for EL Σ-instance inseparability does not imply Σ-query inseparability. The following is a simple example.\nExample 8. Let T1 = {A v ∃r.B}, T2 = ∅,Σ = {A,B}. Then T1 and T2 are Σ-instance inseparable, but they are not Σ-query inseparable. Consider the Σ-ABox A = {A(a)} and the Σ-query q = ∃x.B(x). Then (T1,A) |= q but (T2,A) 6|= q.\n2. We refer the reader to the conclusion of this paper for a brief discussion of this claim.\nKonev, Ludwig, Walther, & Wolter\nIt is shown by Lutz and Wolter (2010) that Example 8 is essentially the only situation in which there is a difference between Σ-instance inseparability and Σ-query inseparability in EL: the two notions become equivalent for EL if the universal role is admitted in instance queries (e.g., in Example 8, the conjunctive query ∃x.B(x) corresponds to the instance query ∃u.B(a) for the universal role u). In contrast, for ELHr there are more subtle differences between the instance and the query case.\nExample 9. Let T1 = {A v ∃s.>, s v r1, s v r2}, T2 = {A v ∃r1.> u ∃r2.>},Σ = {A, r1, r2}. Then T1 and T2 are Σ-concept and Σ-instance inseparable, but they are not Σ-query inseparable. To show the latter, let A = {A(a)} and let q = ∃x(r1(a, x)∧ r2(a, x)). Then (T1,A) |= q but (T2,A) 6|= q.\nWe have seen that Σ-concept inseparability does not imply Σ-instance inseparability and that Σ-instance inseparability does not imply Σ-query inseparability. The converse implications, however, hold:\nLemma 10. For all ELHr-TBoxes T1 and T2 and all signatures Σ:\nT1 ≡qΣ T2 ⇒ T1 ≡ i Σ T2 ⇒ T1 ≡CΣ T2.\nProof. The first implication follows from the observation that every instance query can be regarded as a conjunctive query. For the second implication, note first that if s v r ∈ cDiffΣ(T1, T2), then ({s(a, b)}, r(a, b)) ∈ iDiffΣ(T1, T2). Now let C v D ∈ cDiffΣ(T1, T2). One can construct a Σ-ABox AC with individual a such that for all EL-concepts D′: (T ,AC) |= D′(a) if, and only if, T |= C v D′ (cf. Lemma 36). Thus (AC , D(a)) ∈ iDiffΣ(T1, T2).\nHaving introduced three notions of difference between ELHr-TBoxes, we now investigate two problems: (i) how to detect whether there is any difference between two ELHrterminologies and, if so, (ii) how to represent the differences.\nIn what follows we assume that the fresh symbols used in the normalised form of terminologies do not occur in the signature Σ for which we compute the difference between terminologies. Then we obtain the following lemma as a direct corollary of Lemma 1.\nLemma 11. For any ELHr-terminologies T1, T2 and their normalised forms T ′1 , T ′2 as defined in Lemma 1, we have that the following hold:\n• cDiffΣ(T1, T2) = cDiffΣ(T ′1 , T ′2 );\n• iDiffΣ(T1, T2) = iDiffΣ(T ′1 , T ′2 );\n• qDiffΣ(T1, T2) = qDiffΣ(T ′1 , T ′2 ).\nFrom now on, unless stated otherwise, we consider normalised terminologies only.\nThe Logical Difference for the Lightweight Description Logic EL\n4. The Case of EL-Terminologies\nBefore investigating the logical difference for ELHr-terminologies, we illustrate the main ideas behind the proofs by considering the Σ-concept difference for EL-terminologies. An EL-terminology is an ELHr-terminology consisting of EL-inclusions only, that is, concept inclusions of the form A v C and concept equations of the form A ≡ C. We start with the observation that even for acyclic EL-terminologies there are T1 and T2 in which cDiffΣ(T1, T2) contains inclusions of at least exponential size only. Thus, when searching for witness inclusions in cDiffΣ(T1, T2), one has to deal with the case in which all witness inclusions have at least exponential size.\nExample 12. Consider\nT1 = {A0 v B0, A1 ≡ Bn} ∪ {Bi+1 ≡ ∃r.Bi u ∃s.Bi | 0 ≤ i < n} T2 = {A1 v F0} ∪ {Fi v ∃r.Fi+1 u ∃s.Fi+1 | 0 ≤ i < n}\nand Σ = {A0, A1, r, s}. Then a concept inclusion in cDiffΣ(T1, T2) of minimal size is given by Cn v A1, where\nC0 = A0 and Ci+1 = ∃r.Ci u ∃s.Ci, for i ≥ 0.\nClearly, Cn is of exponential size. Note, however, that if we use structure sharing and define the size of Cn as the number of its subconcepts, then Cn is only of polynomial size.\nWe now derive basic properties of EL-terminologies using a sequent calculus."
    }, {
      "heading" : "4.1 Proof System for EL",
      "text" : "We derive basic properties of EL from the Gentzen-style sequent calculus presented by Hofmann (2005); see Figure 1. The calculus operates on sequents of the form C v D, where C,D are EL-concepts; here the symbol v is treated as a syntactic separator. A derivation (or, equivalently, a proof ) of a sequent C v D is a finite rooted tree whose nodes are labelled with sequents, whose root is labelled with C v D, whose leaves are labelled with axioms (instances of Ax or AxTop) and whose internal nodes are labelled with the result of an application of one of the inference rules to the labels of their children. The length of a derivation is the number of rule applications in the derivation.\nExample 13. Let T = {A ≡ B1uB2, F v B1}. A derivation D of the sequent ∃r.(FuB2) v ∃r.A is shown below. The root of the derivation D is labelled with ∃r.(F uB2) v ∃r.A and the two leaves with B1 v B1 and B2 v B2, respectively.\nB1 v B1 (Ax)\nF v B1 (PDefL)\nF uB2 v B1 (AndL1)\nB2 v B2 (Ax)\nF uB2 v B2 (AndL2)\nF uB2 v B1 uB2 (AndR)\nF uB2 v A (DefR)\n∃r.(F uB2) v ∃r.A (Ex)\nNotice that the basic calculus of Hofmann (2005) considers EL without the constant > and for terminologies without concept inclusions. To take care of >, we have added the rule (AxTop), and (PDefL) is the rule representing inclusions of the form A v C. Cutelimination, completeness, and correctness can now be shown in a straightforward extension of the proof given by Hofmann.\nFor a terminology T and concepts C,D, we write T ` C v D if, and only if, there exists a proof of C v D in the calculus of Figure 1.\nTheorem 14 (Hofmann). For all EL-terminologies T and concepts C,D, it holds that T |= C v D if, and only if, T ` C v D.\nWe apply this calculus to derive a description of the syntactic form of concepts C such that T |= C v D, where D is non-conjunctive in T .\nLemma 15. Let T be a normalised EL-terminology, r a role name, A a concept name and D an EL-concept.\n1. Assume\nT |= l\n1≤i≤n Ai u\nl\n1≤j≤m ∃rj .Cj v A,\nwhere A is pseudo-primitive in T , Ai are concept names for 1 ≤ i ≤ n, Cj are ELconcepts for 1 ≤ j ≤ m, and m,n ≥ 0. Then there exists Ai, 1 ≤ i ≤ n, such that T |= Ai v A.\n2. Assume now\nT |= l\n1≤i≤n Ai u\nl\n1≤j≤m ∃rj .Cj v ∃r.D,\nwhere Ai are concept names for 1 ≤ i ≤ n, Cj are EL-concepts for 1 ≤ j ≤ m, and m,n ≥ 0. Then\n• there exists Ai, 1 ≤ i ≤ n, such that T |= Ai v ∃r.D or • there exists rj, 1 ≤ j ≤ m, such that rj = r and T |= Cj v D.\nThe Logical Difference for the Lightweight Description Logic EL\nProof. We use Theorem 14. First, we prove Point 1. Let C = d 1≤i≤nAi u d\n1≤j≤m ∃rj .Cj and assume T |= C v A, where A is pseudo-primitive in T . Let D be a proof of C v A. Note that, since A is pseudo-primitive in T (and a concept name), by inspecting the form of the conclusions of the inference rules, one can see that the root of the derivation D can only have been derived by either Ax, AndL1, AndL2, DefL, or PDefL. We now show that there exists Ai, 1 ≤ i ≤ n, such that T |= Ai v A by induction on n + m, i.e. the number of conjuncts in C. It is easy to see that n+m ≥ 1 as T 6|= > v A by definition of terminologies T .\nThe base case of n+m = 1 is trivial: the root of D can only have been derived by one of Ax, DefL, or PDefL; so, we can conclude that C = A1; i.e. n = 1, m = 0, and we set Ai = A1.\nAssume n + m > 1. Then the root of D can only have been derived by either AndL1 or AndL2. In both cases, the premise used in the application of either inference rule is a sequent C ′ v A such that either C = C ′ u D or C = D u C ′ for an EL-concept D. Thus, C ′ contains less conjuncts than C (but still at least one). We can also conclude that T |= C ′ v A holds by Theorem 14. By applying the induction hypothesis, there hence exists a concept name Ai which is a conjunct of C\n′ such that T |= Ai v A. Finally, we still note that Ai is also a conjunct of C.\nWe now prove Point 2. Let C = d 1≤i≤nAiu d\n1≤j≤m ∃rj .Cj and assume T |= C v ∃r.D. LetD be a proof of C v ∃r.D. Note that due to the form of the right-hand side of the sequent C v ∃r.D, the rule used to derive the root of D can only have been one of Ax, AndL1, AndL2, DefL, PDefL, or Ex. We now prove that either there exists Ai, 1 ≤ i ≤ n, such that T |= Ai v ∃r.D, or there exists rj , 1 ≤ j ≤ m, with rj = r and T |= Cj v D by induction on n+m again. Similarly to above, we have n+m ≥ 1.\nIf n+m = 1, the rule used to derive the root of D can only have been one of Ax, DefL, PDefL, or Ex. We have two subcases:\n• the root of D was derived with DefL or PDefL: then n = 1, m = 0 and C = A1; i.e. T |= Ai v ∃r.D for Ai = A1.\n• the root of D was derived with Ax or Ex: then n = 0, m = 1, C = ∃r1.C1, and r1 = r. If C1 = D, then obviously T |= C1 v D holds. Otherwise, the rule Ex was used to derive the root of D and T ` C1 v D holds, which implies that T |= C1 v D. Thus, in any case, rj = r and T |= Cj v D holds for j = 1.\nThe case n+m > 1 can be proved by induction analogously to the proof of Point 1 above.\nWe apply Lemma 15 to elements of cDiffΣ(T1, T2).\nTheorem 16 (Primitive witness for EL). Let T1 and T2 be EL-terminologies and Σ a signature. If ϕ ∈ cDiffΣ(T1, T2), then either C v A or A v D is a member of cDiffΣ(T1, T2), where A ∈ sig(ϕ) is a concept name and C, D are EL-concepts occurring in ϕ.\nProof. Let ϕ = C v D ∈ cDiffΣ(T1, T2). The proof is by induction on the construction of D. We have D 6= > as T2 |= C v >. If D = D1 uD2, then one of C v Di, i = 1, 2, is in cDiffΣ(T1, T2) and we can apply the induction hypothesis. If D = ∃r.D1 then, by Lemma 15,\nKonev, Ludwig, Walther, & Wolter\neither (i) there exists a conjunct A of C, A a concept name, such that T1 |= A v D, or (ii) there exists a conjunct ∃r.C1 of C with T1 |= C1 v D1.\nIn case (i) it follows that T2 6|= A v D as otherwise T2 |= C v D and C v D 6∈ cDiffΣ(T1, T2) due to |= C v A. Hence, A v D ∈ cDiffΣ(T1, T2).\nFinally, for case (ii) we obtain T2 6|= C1 v D1 as otherwise |= C v ∃r.C1, T2 |= ∃r.C1 v D and C v D 6∈ cDiffΣ(T1, T2) again. Thus, C1 v D1 ∈ cDiffΣ(T1, T2) and we can apply the induction hypothesis.\nBy Theorem 16, every inclusion C v D in the Σ-concept difference of T1 and T2 “contains” a basic witness inclusion that has a concept name either on the right-hand side or the left-hand side. We define\n• the set of left-hand Σ-concept difference witnesses, cWtnlhsΣ (T1, T2), as the set of all A ∈ Σ ∩ NC such that there exists a concept D with A v D ∈ cDiffΣ(T1, T2) and\n• the set of right-hand Σ-concept difference witnesses, cWtnrhsΣ (T1, T2), as the set of all A ∈ Σ ∩ NC such that there exists a concept C with C v A ∈ cDiffΣ(T1, T2).\nWe regard the concept names in cWtnlhsΣ (T1, T2) and cWtnrhsΣ (T1, T2) as a succinct and, in a certain sense, complete representation of the Σ-concept difference between T1 and T2 and define the set of all Σ-concept difference witnesses as\ncWtnΣ(T1, T2) = (cWtnlhsΣ (T1, T2), cWtnrhsΣ (T1, T2)).\nIn what follows, we first present a polytime algorithm computing cWtnrhsΣ (T1, T2). A polytime algorithm computing cWtnlhsΣ (T1, T2) has already been given by Lutz and Wolter (2010) (for EL-TBoxes). We briefly present it since an extension will be developed when we consider ELHr-terminologies. Both algorithms together decide Σ-concept inseparability since, by Theorem 16, T1 and T2 are Σ-concept inseparable if, and only if, cWtnΣ(T1, T2) = cWtnΣ(T2, T1) = (∅, ∅).\n4.2 Computing cWtnrhsΣ (T1, T2)\nLet A ∈ Σ and assume we want to decide whether A ∈ cWtnrhsΣ (T1, T2). Thus, we want to decide whether there exists a Σ-concept C such that T1 |= C v A and T2 6|= C v A. Our general strategy is as follows. Let\nnoimplyT2,Σ(A) = {C | T2 6|= C v A, C an ELΣ-concept}.\nWe aim at an algorithm that checks whether noimplyT2,Σ(A) contains some C with T1 |= C v A. For two sets C and D of concepts we call C a cover of D if C ⊆ D and for all D ∈ D there exists a C ∈ C such that |= C v D. Thus, C ⊆ noimplyT2,Σ(A) is a cover of noimplyT2,Σ(A) if for all D ∈ noimplyT2,Σ(A) there exists a C ∈ C such that |= C v D. Note that if C is a cover of noimplyT2,Σ(A), then there exists some Σ-concept C such that C v A ∈ cDiffΣ(T1, T2) if, and only if, there exists some C ∈ C such that T1 |= C v A. Thus we have reduced the original problem to the construction of an appropriate cover C and deciding the subsumption problem T1 |= C v A, for C ∈ C. Unfortunately, in general, no finite cover exists. The following example illustrates the situation.\nThe Logical Difference for the Lightweight Description Logic EL\nExample 17. (1) Let Σ = {A,B, r} and T2 = ∅. Then noimplyT2,Σ(A) contains all Σconcepts that do not have A as an atomic conjunct. Clearly, noimplyT2,Σ(A) contains no finite cover.\n(2) Let Σ′ = {A,B, r} and T ′2 = {A ≡ ∃r.A}. Then noimplyT ′2 ,Σ′(A) contains all Σ′ \\ {A}-concepts and contains no finite cover.\n(3) Let Σ′′ = {A,B1, B2} and T ′′2 = {A ≡ B1 u B2}. Then {B1, B2} is a cover of noimplyT ′′2 ,Σ′′(A).\nAs a consequence, instead of directly constructing a cover of noimplyT2,Σ(A), we first construct transparent and small covers of\nnoimplyT2,Σ(A) ∩ {C | depth(C) ≤ n},\nfor all n ≥ 0, where depth(C) is the role-depth of C; i.e., the number of nestings of existential restrictions in C.3 Those covers are denoted noimplynT2,Σ(A), n ≥ 0, and are singleton sets if A is non-conjunctive in T2 and finite sets containing at most k concepts if A ≡ B1u· · ·uBk ∈ T2. Based on this sequence, we present two distinct algorithms for computing cWtnrhsΣ (T1, T2):\n1. we encode the infinite sequence noimplynT2,Σ(A), n ≥ 0, into a polynomial-size ABox AT2,Σ. In this way we obtain a reduction of the original problem to an instance checking problem for the knowledge base (T1,AT2,Σ). In a certain sense, the ABox AT2,Σ encodes a (in general infinite) cover of noimplyT2,Σ(A).\n2. we employ the terminology T1 in a dynamic programming approach to decide which concepts in noimplynT2,Σ(A) are relevant for deciding whether A ∈ cWtn rhs Σ (T1, T2).\nAlthough less transparent, for large terminologies the latter approach is considerably more efficient. We develop it for acyclic terminologies.\nFor an EL-terminology T , a concept name A and a signature Σ, set\npreΣT (A) = {B ∈ Σ | T |= B v A}.\nThe finite covers noimplynT2,Σ(A), n ≥ 0, are defined in Figure 2. For n = 0, the set noimplynT2,Σ(A) consists of concepts without role names. We distinguish between conjunctive and non-conjunctive A. Note that if A is non-conjunctive, then noimplynT2,Σ(A) is a singleton set. Example 17 (3) shows that this is not always the case for conjunctive A. For n + 1, we distinguish between pseudo-primitive concept names, conjunctive concept names, and those that have a definition of the form A ≡ ∃r.C. Again, for nonconjunctive A, noimplyn+1T2,Σ(A) is a singleton set. Note that the concepts all n Σ are covers of {C | depth(C) ≤ n, C an ELΣ-concept}, for all n ≥ 0. We illustrate the definitions using the EL-terminologies from Example 17.\nExample 18. (1) Let Σ = {A,B, r} and T2 = ∅. Then A and B are non-conjunctive in T2 and noimply0T2,Σ(A) = {B} and noimply 0 T2,Σ(B) = {A}. A and B are also pseudo-primitive in T2, and so noimply1T2,Σ(A) = {B u ∃r.(A uB)} and noimply 1 T2,Σ(B) = {A u ∃r.(A uB)}.\n3. More precisely depth(A) = 0, depth(C1 u C2) = max{depth(C1), depth(C2)}, and depth(∃r.D) = depth(D) + 1.\nKonev, Ludwig, Walther, & Wolter\n(2) Let Σ′ = {A,B, r} and T ′2 = {A ≡ ∃r.A}. Then A and B are non-conjunctive in T ′2 and noimply0T ′2 ,Σ′ (A) = {B} and noimply0T ′2 ,Σ′(B) = {A}. B is pseudo-primitive in T ′ 2 and so noimply1T2,Σ(B) = {A u ∃r.(A uB)}. A ≡ ∃r.A ∈ T ′ 2 and so noimplyT ′2 ,Σ′(A) = {B u ∃r.B}.\n(3) Let Σ′′ = {A,B1, B2} and T ′′2 = {A ≡ B1 uB2}. B1 and B2 are non-conjunctive in T ′′2 and so noimply0T ′′2 ,Σ′′(B1) = {B2} and noimply 0 T ′′2 ,Σ′′ (B2) = {B1}. A is conjunctive in T ′′2\nThe Logical Difference for the Lightweight Description Logic EL\nand, by definition, noimply0T ′′2 ,Σ′′ (A) = {B1, B2}. Since Σ does not contain any role names, we have noimply0T ′′2 ,Σ′′ (X) = noimplynT ′′2 ,Σ′′ (X), for all X ∈ {A,B1, B2} and n > 0.\nThe following lemma shows the correctness of the definition of noimplynT2,Σ(A).\nLemma 19. Let T2 be a normalised EL-terminology, Σ be a signature, and A ∈ NC. Then noimplynT2,Σ(A) is a cover of noimplyT2,Σ(A) ∩ {C | depth(C) ≤ n}. Namely, for all n ≥ 0,\nC1. T2 6|= C v A, for all C ∈ noimplynT2,Σ(A).\nC2. For all ELΣ-concepts D with n = depth(D), if T2 6|= D v A, then |= C v D for some C ∈ noimplynT2,Σ(A).\nIn particular, ⋃ n≥0 noimply n T2,Σ(A) is a cover of noimplyT2,Σ(A).\nProof. C1. Assume first that A is pseudo-primitive in T2. Then noimplynT2,Σ(A) consists of C =\nd A′∈(Σ\\preΣT2 (A))\nA′ u F , where F is a (possibly empty) conjunction of concepts of the form ∃s.Fi. By Lemma 15, T2 6|= C v A because the only atomic conjuncts of C are in Σ \\ preΣT2(A).\nWe now prove C1 for concept names A which are not pseudo-primitive in T2. The proof is by induction on n. For n = 0 and A ≡ ∃r.B ∈ T2, assume T2 |=\nd A′∈(Σ\\preΣT2 (A))\nA′ v A. As A ≡ ∃r.B ∈ T2, we have by Lemma 15 that there must exist A′ ∈ Σ \\ preΣT2(A) with T2 |= A′ v A. But this contradicts the definition of the set preΣT2(A)). For n = 0 and A conjunctive with A ≡ F ∈ T2, let C ∈ noimplynT2,Σ(A) = ⋃ B∈F noimply n T2,Σ(B). There hence exists an atomic conjunct B of F such that C ∈ noimplynT2,Σ(B). As T2 is normalised, B is non-conjunctive, i.e. property C1 has already been proved above for B. Thus, T2 6|= C v B, which implies that T2 6|= C v A as otherwise T2 |= C v B would hold.\nFor the induction step, assume C1 has been proved for n ≥ 0. Let A ≡ ∃r.B ∈ T2 and let Cn+1T2,Σ be the only element of noimply n+1 T2,Σ(A). Assume\nT2 |= Cn+1T2,Σ v A. By Lemma 15 there are two possibilities:\n• T2 |= d A′∈(Σ\\preΣT2 (A))\nA′ v ∃r.B. Similarly to above, the claim follows from Lemma 15 and the fact that A ≡ ∃r.B ∈ T2.\n• r ∈ Σ and there exists E ∈ noimplynT2,Σ(B) such that T2 |= E v B. This is excluded by the induction hypothesis.\nWe have derived a contradiction. The case A ≡ F ∈ T2, A conjunctive in T2, is considered analogously to the case n = 0.\nC2. Let n = 0 and assume first that A is non-conjunctive. Let D be a Σ-concept with depth(D) = 0 and T2 6|= D v A. Then all conjuncts of D are in Σ \\ preΣT2(A) and we obtain |=\nd A′∈Σ\\preΣT2 (A)\nA′ v D. Now assume A is conjunctive in T2 and A ≡ F ∈ T2. Let D be a Σ-concept with depth(D) = 0 and T2 6|= D v A. Then T2 6|= D v B, for some conjunct B of F . By induction, |= C v D for the (unique as B must be non-conjunctive) C ∈ noimply0T2,Σ(B), and therefore |= C v D for some C ∈ noimply 0 T2,Σ(A).\nFor the induction step, assume that C2 has been shown for n. Let D be a Σ-concept with T2 6|= D v A and depth(D) = n+ 1.\nKonev, Ludwig, Walther, & Wolter\n(a) Let A be pseudo-primitive in T2. Then the atomic conjuncts of D are included in Σ \\ preΣT2(A). Now |= C v D follows immediately for C = d A′∈Σ\\preΣT2 (A) A′ u d s∈Σ ∃s.all n Σ.\n(b) Let A ≡ ∃r.B ∈ T2. Let Cn+1T2,Σ be the only element of noimply n+1 T2,Σ(A) and assume\nD = l\nE∈Q0\nE u l\n(s,D′)∈Q1\n∃s.D′.\nThen Q0 ⊆ Σ \\ preΣT2(A). Hence, |= C n+1 T2,Σ v d E∈Q0 E. Now consider a conjunct ∃s.D\n′ of D. We distinguish two cases:\n• if s 6= r, then |= Cn+1T2,Σ v ∃s.D ′, as required.\n• if s = r, then s ∈ Σ and it is sufficient to show that there exists E ∈ noimplynT2,Σ(B) such that |= E v D′. Suppose there does not exist such an E. Then, by (the contraposition of) the induction hypothesis, T2 |= D′ v B. But this contradicts T2 6|= D v A (as A ≡ ∃r.B ∈ T2).\n(c) A is conjunctive in T2 and A ≡ F ∈ T2. This case is analogous to the case in which A is conjunctive in T2 and n = 0.\nCorollary 20. For all normalised EL-terminologies T1 and T2 and all A ∈ NC the following conditions are equivalent:\n• there exists an ELΣ-concept C such that T1 |= C v A and T2 6|= C v A;\n• there exists n ≥ 0 and C ∈ noimplynT2,Σ(A) such that T1 |= C v A.\nObserve that a direct application of Corollary 20 does not yield a procedure for computing cWtnrhsΣ (T1, T2) as it gives no bound on n for the set noimplynT2,Σ(A). At this point we present two ways of avoiding this problem (as well as the problem that concepts in noimplynT2,Σ(A) can be of exponential size). Firstly, instead of working with covers we construct an ABox encoding covers. In contrast to concepts, ABoxes admit the encoding of structure sharing and cycles and so, intuitively, admit the polynomial reconstruction of the ‘infinite concept’\nd n≥0,C∈noimplynT2,Σ(A) C.\nThe ABox AT2,Σ is constructed in Figure 3, where for a normalised EL-terminology T and a concept name A ∈ sig(T ), we set\nnon-conjT (A) = { {A}, A is non-conjunctive in T {B1, . . . , Bn}, A ≡ B1 u · · · uBn ∈ T\nNote that the construction of AT2,Σ is very similar to the construction of noimplynT2,Σ(A). The assertions for the individual ξΣ play the role of the concepts all n Σ, n ≥ 0, and the assertions for the individuals ξA play the role of the sets noimply n T2,Σ(A), n ≥ 0. In fact, one can readily show that AT2,Σ |= C(ξA) for any C ∈ noimplynT2,Σ(A) and A non-conjunctive in T2 and, conversely, (a more involved proof) shows that whenever AT2,Σ |= D(ξA) for some EL-concept D, then there exist n ≥ 0 and C ∈ noimplynT2,Σ(A) such that |= C v D. We illustrate the construction of AT2,Σ using the EL-terminologies from Example 17.\nThe Logical Difference for the Lightweight Description Logic EL\nExample 21. (1) Let Σ = {A,B, r} and T2 = ∅. Then\nAT2,Σ = {A(ξB), B(ξA), r(ξA, ξΣ), r(ξB, ξΣ)} ∪ AΣ,\nwhere AΣ = {A(ξΣ), B(ξΣ), r(ξΣ, ξΣ)}. (2) Let Σ′ = {A,B, r} and T ′2 = {A ≡ ∃r.A}. Then\nAT ′2 ,Σ′ = {A(ξB), B(ξA), r(ξA, ξA), r(ξB, ξΣ′)} ∪ AΣ′ ,\nwhere AΣ′ = {A(ξΣ′), B(ξΣ′), r(ξΣ′ , ξΣ′)}. (3) Let Σ′′ = {A,B1, B2} and T ′′2 = {A ≡ B1 uB2}. Then\nAT ′′2 ,Σ′′ = {B1(ξB2), B2(ξB1)} ∪ AΣ′′ ,\nwhere AΣ′′ = {A(ξΣ′′), B1(ξΣ′′), B2(ξΣ′′)}.\nWe now obtain the following characterisation of cWtnrhsΣ (T1, T2).\nTheorem 22. Let T1 and T2 be normalised EL-terminologies and Σ a signature. Then the following conditions are equivalent for any A ∈ Σ:\n• A ∈ cWtnrhsΣ (T1, T2);\n• there exist n ≥ 0 and C ∈ noimplynT2,Σ(A) such that T1 |= C v A;\nKonev, Ludwig, Walther, & Wolter\n• (T1,AT2,Σ) |= A(ξB) for some B ∈ non-conjT2(A).\nThe equivalence of Points 1 and 2 follows from Corollary 20. We do not give a detailed proof of the equivalence of Points 2 and 3 as this follows from the more general results for ELHr-terminologies we present below.\nExample 23. For a normalised form of the terminologies from Example 12,\nT1 = {A0 v B0, A1 ≡ Bn} ∪ {Bi+1 ≡ B′i+1 uB′′i+1 | 0 ≤ i < n} ∪ {B′i+1 ≡ ∃r.Bi | 0 ≤ i < n} ∪ {B′′i+1 ≡ ∃s.Bi | 0 ≤ i < n} T2 = {A1 v F0} ∪ {Fi ≡ F ′i u F ′′i | 0 ≤ i < n} ∪ {F ′i v ∃r.Fi+1 | 0 ≤ i < n} ∪ {F ′′i v ∃s.Fi+1 | 0 ≤ i < n},\nand Σ = {A0, A1, r, s}, the ABox AT2,Σ can be graphically represented as\n· · · ξΣ\nA0,A1\nξA1 A0\nξA0 A1 ξF ′0\nA0\nξF ′′0 A0\nξF ′1 A0,A1\nξF ′′1 A0,A1\nξF ′n A0,A1\nξF ′′n A0,A1r, s\nr, s\nr, s\nr, s\nr, s\nr, s\nr, s\nr, s\nr, s\nIt should be clear that (T1,AT2,Σ) |= A1(ξA1). In fact, (T1,A) |= A1(ξA1) holds already for the restriction A of AT2,Σ to the individuals {ξA1 , ξΣ}.\nTheorem 24. For EL-terminologies T1 and T2 and a signature Σ, the set cWtnrhsΣ (T1, T2) can be computed in polynomial time.\nProof. It suffices to give a polynomial time algorithm that decides for every A ∈ Σ whether A ∈ cWtnrhsΣ (T1, T2). First, the ABox AT2,Σ can be computed in polynomial time and is of quadratic size in T2. By Theorem 22, A ∈ cWtnrhsΣ (T1, T2) iff (T1,AT2,Σ) |= A(ξB) for some B ∈ non-conjT2(A), and the latter condition can be checked in polynomial time since instance checking is in polynomial time for EL-TBoxes.\nRegarding the efficiency of this approach, observe that for typical terminologies and large Σ, the ABox AT2,Σ is indeed of quadratic size in T2 since Σ \\ preΣT2(A) will typically contain most of the concept names in Σ. Thus, for very large terminologies and Σ a straightforward implementation of this rather elegant algorithm does not work efficiently as one would have to store an ABox of quadratic size and do instance checking for it. We refer the reader to Table 3 and its discussion where a prototype implementation of this approach is applied to modules of Snomed CT.\nWe now describe our second approach for computing cWtnrhsΣ (T1, T2), which only works for acyclic EL-terminologies. Recall that A ∈ cWtnrhsΣ (T1, T2) if, and only if, there exists an ELΣ-concept C such that T2 6|= C v A and T1 |= C v A. Thus, we have A 6∈ cWtnrhsΣ (T1, T2) if, and only if, for every ELΣ-concept C with C ∈ noimplyT2,Σ(A)\nThe Logical Difference for the Lightweight Description Logic EL\nit holds that C ∈ noimplyT1,Σ(A). Our approach is now based on computing a ‘not witness’ relation NW ⊆ ((sig(T1) ∪ Σ) ∩ NC)× ((sig(T2) ∪ Σ) ∩ NC), which is defined as follows:\n(E,A) ∈ NW if, and only if, (†) noimplyT2,Σ(A) ⊆ noimplyT1,Σ(E)\nObserve that A ∈ cWtnrhsΣ (T1, T2) if, and only if, (A,A) 6∈ NW; hence, to compute the set cWtnrhsΣ (T1, T2) it is sufficient to compute the relation NW. In practice, it is crucial to compute the relation NW rather than its complement: in typical terminologies most concept names are unrelated in the sense that they do not subsume each other. Thus, the relation NW is much smaller than its complement (which contains, among others, all pairs (E,A) that do not subsume each other in T1 and T2).\nTo determine the pairs (E,A) ∈ NW, we aim at computing for every concept name E ∈ sig(T1) ∪ Σ the set of concept names A ∈ sig(T2) ∪ Σ for which the property (†) holds. This set will be called NotWitness(E) and is computed in Figure 4, with the following modifications: (1) we only consider those A ∈ sig(T2) ∪ Σ which are non-conjunctive in T2 and take conjunctive concept names into account later. (2) We consider a fresh concept name All not occurring in Σ ∪ sig(T1) ∪ sig(T2) – informally standing for ‘all possible Σconcepts’.\nThus, the procedure, NotWitness(E) given in Figure 4 recursively associates with every E ∈ sig(T1) ∪ Σ a subset of the set\nΞ = {All} ∪ {A | A ∈ (sig(T2) ∪ Σ), A is non-conjunctive in T2 }\nand NW is a relation over\n((sig(T1) ∪ Σ) ∩ NC)× (((sig(T2) ∪ Σ) ∩ NC) ∪ {All}).\nKonev, Ludwig, Walther, & Wolter\nNote that unlike in the approach for computing cWtnrhsΣ (T1, T2) that was presented previously, the approach described here does not handle the two terminologies separately. In the previous approach the ABox AT2,Σ could be precomputed for T2 and then be re-used to compare T2 against any other terminology T1, whereas here both terminologies are analysed simultaneously. We now prove the correctness of the procedure NotWitness(E).\nLemma 25. For any normalised acyclic EL-terminologies T1 and T2, any signature Σ, any E ∈ sig(T1) ∪ Σ and any A ∈ Ξ the following holds: A ∈ NotWitness(E) if, and only if, (E,A) ∈ NW.\nProof. We prove that for any E ∈ sig(T1) ∪ Σ and any A ∈ Ξ the following two conditions are equivalent:\n• A ∈ NotWitness(E);\n• for all n ≥ 0 and all C ∈ noimplynT2,Σ(A): T1 6|= C v E. This is sufficient since ⋃ n≥0 noimply n T2,Σ(A) is a cover of noimplyT2,Σ(A) (Lemma 19).\nFor E 6∈ sig(T1) the claim is trivial. For E ∈ sig(T1) the proof is by induction relative to the relation T1 ⊆ sig(T1) × sig(T1) (whose definition can be found on page 637). Note that since the considered terminologies are acyclic and sig(T1) is finite, the relation T1 is well-founded.\nWe distinguish between the possible definitions of E in T1. Suppose E is pseudoprimitive in T1. For A ∈ Ξ, it follows from the definition of noimplynT2,Σ(A) and from Lemma 15 that there exist n ≥ 0 and C ∈ noimplynT2,Σ(A) such that T1 |= C v E if, and only if, T1 |= B v E for some B ∈ (Σ \\ preΣT2(A)). Note that for all B ∈ (Σ \\ pre Σ T2(A)), T1 6|= B v E holds if, and only if, for every B ∈ Σ, T1 |= B v E implies that B ∈ preΣT2(A). Thus, for every n and C ∈ noimplynT2,Σ(A), T1 6|= C v E if, and only if, pre Σ T1(E) ⊆ pre Σ T2(A) if, and only if, A ∈ NotWitness(E). Assume that E ≡ E1 u · · · u Ek ∈ T1. Then, for any concept C, T1 6|= C v E if, and only if, T1 6|= C v Ei for some 1 ≤ i ≤ k. Hence, by applying the induction hypothesis we obtain for every n and C ∈ noimplynT2,Σ(A), T1 6|= C v E if, and only if, A ∈ NotWitness(Ei) for some 1 ≤ i ≤ k, if, and only if, A ∈ NotWitness(E).\nFinally, assume that E ≡ ∃r.E′ ∈ T1. Notice that, since All /∈ (Σ ∪ sig(T1) ∪ sig(T2)) (in particular, All is pseudo-primitive in T2), we have preΣT2(All) = ∅. Thus, by definition for every n ≥ 0, noimplynT2,Σ(All) = {all n Σ}. By applying the induction hypothesis we can assume that the lemma holds for E′, which implies that All /∈ NotWitness(E′) if, and only if, for some n ≥ 0, T1 |= allnΣ v E′. We now distinguish between the following cases, analogously to the case distinction in procedure NotWitness(E) (see Figure 4).\nIf r /∈ Σ, for any Σ-concept of the form ∃s.G, where s ∈ NR ∩ Σ, we have r 6= s and T1 6|= ∃s.G v ∃r.E′. Similarly, if All ∈ NotWitness(E′), it holds for every n ≥ 0 that T1 6|= allnΣ v E′. Hence, for any Σ-concept of the form ∃s.G, we obtain T1 6|= ∃s.G v ∃r.E′ as otherwise T1 |= allnΣ v E′ would hold for n = depth(∃s.G) (where depth(∃s.G) is the role-depth of ∃s.G). So, by Lemma 15, these two cases are analogous to the case of E being pseudo-primitive considered above.\nAssume now that r ∈ Σ and All /∈ NotWitness(E′), that is, for some n0 ≥ 0 we have T1 |= alln0Σ v E′.\nThe Logical Difference for the Lightweight Description Logic EL\nFirst, we observe that if A does not have a definition of the form A ≡ ∃r.A′ in T2, then for the unique C ∈ noimplyn0+1T2,Σ (A) we have T1 |= C v E as ∃r.all n0 Σ is a conjunct of C (and as A is non-conjunctive in T2 by definition of the set Ξ). IfA has a definition of the formA ≡ ∃r.A′ in T2, for any n ≥ 0 and C ∈ noimplynT2,Σ(A), we have by Lemma 15 that T1 6|= C v E if, and only if, preΣT1(E) ⊆ pre Σ T2(A), and, if n > 0, for every C ′ ∈ noimplyn−1T2,Σ(A ′) we have T1 6|= C ′ v A′. We can conclude that in case r ∈ Σ and All /∈ NotWitness(E′), for any A ∈ Ξ, any n ≥ 0, and any C ∈ noimplynT2,Σ(A), we have T1 6|= C v E, if, and only if, A ≡ ∃r.A ′ ∈ T2, preΣT1(E) ⊆ pre Σ T2(A) and for any m ≥ 0 and any C ′ ∈ noimplymT2,Σ(A ′) we have\nT1 6|= C ′ v E′. Notice further that, by definition for any m ≥ 0, noimplymT2,Σ(A ′) =⋃\nB∈non-conjT2 (A ′) noimply\nm T2,Σ(B). Thus, for any m ≥ 0 and any C ′ ∈ noimplymT2,Σ(A ′),\nT1 6|= C ′ v E′ holds if, and only if, for any m ≥ 0, any B ∈ non-conjT2(A ′) and any C ′ ∈ noimplymT2,Σ(B), T1 6|= C ′ v E′, if, and only if, for any B ∈ non-conjT2(A\n′), B ∈ NotWitness(E′) holds by applying the induction hypothesis.\nThus, T1 6|= C v E, for any n ≥ 0 and C ∈ noimplynT2,Σ(A), if, and only if, A ∈ NotWitness(E).\nCorollary 26. Let T1 and T2 be normalised acyclic EL-terminologies and Σ a signature. Then cWtnrhsΣ (T1, T2) = {A ∈ sig(T1) ∩ Σ | ∃B ∈ non-conjT2(A) with B 6∈ NotWitness(A) }.\nProof. First, we observe that if A ∈ cWtnrhsΣ (T1, T2), A ∈ sig(T1) must hold as otherwise for any Σ-concept C we have T1 |= C v A if, and only if, |= C v A, and thus A 6∈ cWtnrhsΣ (T1, T2). Now, for all A ∈ NC we have:\nA ∈ cWtnrhsΣ (T1, T2) iff A ∈ sig(T1) ∩ Σ (by our observation) and, by definition, there exists a Σ-concept C with T2 6|= C v A and T1 |= C v A\niff A ∈ sig(T1) ∩ Σ and there exists B ∈ non-conjT2(A) and a Σ-concept C with T2 6|= C v B and T1 |= C v A (as otherwise T2 |= C v A would hold) iff A ∈ sig(T1) ∩ Σ and there exists B ∈ non-conjT2(A) with (A,B) 6∈ NW (by definition of the relation NW) iff A ∈ sig(T1) ∩ Σ and there exists B ∈ non-conjT2(A) with B 6∈ NotWitness(A), by Lemma 25.\nFor acyclic terminologies, we now obtain an alternative proof of Theorem 24.\nTheorem 27. For acyclic EL-terminologies T1 and T2 and a signature Σ, cWtnrhsΣ (T1, T2) can be computed in polynomial time using the procedure NotWitness(E).\nProof. To compute the set cWtnrhsΣ (T1, T2), it is sufficient by Corollary 26 to compute the sets NotWitness(E) for every E ∈ sig(T1). Assuming that T1 and T2 are classified and the result of classification is cached, NotWitness(E) can be computed for all E ∈ sig(T1), in the worst case, in time O((|T1|+ |T2|)3).\nExample 28. For the acyclic terminologies T1, T2 and the signature Σ from Example 23,\nNotWitness(A0) = {A0}, NotWitness(B0) = {A0}\nKonev, Ludwig, Walther, & Wolter\nand for all other concept names X ∈ sig(T1), NotWitness(X) = ∅. In particular A1 /∈ NotWitness(A1), so we conclude that A1 is a concept difference witness.\n4.3 Computing cWtnlhsΣ (T1, T2)\nRecall that the set of left-hand Σ-concept difference witnesses, cWtnlhsΣ (T1, T2), is the set of all A ∈ Σ ∩ NC such that there exists a concept C with A v C ∈ cDiffΣ(T1, T2). The tractability of computing cWtnlhsΣ (T1, T2) for EL has been proved by Lutz and Wolter (2010) for arbitrary EL-TBoxes by reduction to simulation checking. Here we formulate the main steps again because we employ the same technique when dealing with the logical difference for ELHr-terminologies.\nFor any two interpretations I1 and I2 we say that a relation S between I1 and I2 is a Σ-simulation if, and only if, the following conditions hold:\n• if (d, e) ∈ S and d ∈ AI1 with A ∈ Σ, then e ∈ AI2 ;\n• if (d, e) ∈ S and (d, d′) ∈ rI1 with r ∈ Σ, then there exists e′ with (d′, e′) ∈ S and (e, e′) ∈ rI2 .\nFor d ∈ ∆I1 and e ∈ ∆I2 we write (I1, d) ≤Σ (I2, e) if there exists a Σ-simulation relation S between I1 and I2 such that (d, e) ∈ S. It can be checked in polynomial time whether (I1, d) ≤Σ (I2, e) and various polynomial-time algorithms checking the existence of simulations have been developed (Clarke & Schlingloff, 2001; Crafa, Ranzato, & Tapparo, 2011; van Glabbeek & Ploeger, 2008). Simulations characterise the expressive power of EL-concepts in the following sense.\nLemma 29 (Lutz & Wolter, 2010). Let I1 and I2 be interpretations, Σ a signature, d ∈ ∆I1, and e ∈ ∆I2. Then\n(I1, d) ≤Σ (I2, e) ⇔ for all ELΣ-concepts C: d ∈ CI1 ⇒ e ∈ CI2 .\nIt follows that for any A ∈ Σ, we have\nA ∈ cWtnlhsΣ (T1, T2) ⇔ (IK1 , a) 6≤Σ (IK2 , a)\nwhere Ki = (Ti,A) for A = {A(a)} and IKi is the canonical model for Ki, i = 1, 2. To see this, recall that by Theorem 2 for every EL-concept C, a ∈ CIKi if, and only if, (Ti,A) |= C(a). The latter condition is equivalent to Ti |= A v C. We have, therefore, proved:\nTheorem 30 (Lutz & Wolter, 2010). For EL-TBoxes T1 and T2 and signatures Σ, the set cWtnlhsΣ (T1, T2) can be computed in polynomial time.\nThe following example illustrates the use of simulations between canonical models to determine cWtnlhsΣ (T1, T2).\nExample 31. Let Σ = {A, r,B1, B2} and\nT1 = {A v ∃r.F0, F0 v F1 u F2, F1 v ∃r.B1, F2 v ∃r.B2}, T2 = {A v G1 uG2, G1 v ∃r.G′1, G2 v ∃r.G′2, G′1 v ∃r.B1, G′2 v ∃r.B2}\nThe Logical Difference for the Lightweight Description Logic EL\nTo check whether A ∈ cWtnlhsΣ (T1, T2) consider the KBs K1 = (T1, {A(a)}) and K2 = (T2, {A(a)}). Then A ∈ cWtnlhsΣ (T1, T2) iff (IK1 , a) 6≤Σ (IK2 , a), for the canonical models IK1 and IK2 of K1 and K2, respectively. Illustrations of the canonical models IK1 and IK2 are shown below.\nIK1 A a\nxran(r),F0\nxran(r),B1 B1\nxran(r),B2 B2\nr\nr r\nIK2A a\nxran(r),G′1 xran(r),G′2\nxran(r),B1 B1\nxran(r),B2 B2\nrr\nr r\nBut (IK1 , a) 6≤Σ (IK2 , a) because the point xran(r),F0 is neither Σ-simulated by xran(r),G′1 nor Σ-simulated by xran(r),G′2 . A concept inclusion in cDiffΣ(T1, T2) with A on the left-hand side is given by A v ∃r.((∃r.B1) u (∃r.B2)).\n5. ELHr-Instance Difference\nOur polynomial-time algorithms for inseparability and logical difference in ELHr are based on extensions of the ideas used in Section 4 for EL. There is, however, one important difference: we introduce new logics, ELran and ELran,u,u, for which the concept difference captures exactly the instance and, respectively, query difference in ELHr. To prove an analogue of Theorem 16 for those languages and, thereby, for the instance and query difference for ELHr, we introduce a sequent calculus which characterises all ELran-consequences of ELHr-terminologies. We start our investigation with the instance difference case since it is more transparent than the concept difference case (recall that for EL there is no difference between the instance and the concept difference).\n5.1 ELran-Concept Difference\nRecall Example 4 showing that ELHr Σ-concept inseparability does not imply Σ-instance inseparability:\nT1 = {ran(r) v A1, ran(s) v A2, B ≡ A1 uA2}, T2 = ∅, Σ = {r, s, B}.\nNotice that for the ABox A = {r(a, c), s(b, c)}, exhibiting the instance difference between T1 and T2, c is in the range of both r and s. This example suggests that if ran(r) and ran(s) could be used in complex concepts, this kind of difference can be made visible for a concept language.\nDefinition 32 (ELran). Cran-concepts are constructed using the following syntax rule\nC := A | ran(r) | C uD | ∃r.C,\nwhere A ∈ NC, C,D range over Cran-concepts and r ∈ NR. The set of ELran-inclusions consists of all concept inclusions C v D and role inclusions r v s, where C is a Cranconcept, D an EL-concept, and r, s ∈ NR.\nKonev, Ludwig, Walther, & Wolter\nClearly, every ELHr-inclusion is an ELran-inclusion. Additionally, in ELran-inclusions the concept ran(r) can occur everywhere in concepts on the left-hand side of inclusions. This gives us additional concept inclusions for the Σ-concept difference.\nExample 33. For T1 and T2 from Example 4, we have T1 |= ran(r) u ran(s) v B, but T2 6|= ran(r) u ran(s) v B. Thus, using the Cran-concept ran(r) u ran(s) we can simulate the ABox {r(a, c), s(b, c)} from Example 4 and make the Σ-difference that could not be observed in ELHr visible in ELran.\nWe now show that Example 33 can be generalised to arbitrary TBoxes. To this end, we consider the following straightforward generalisation of the Σ-concept difference to differences over ELran.\nDefinition 34 (ELranΣ -difference). The ELranΣ -difference between ELHr-TBoxes T1 and T2 is the set cDiffranΣ (T1, T2) of all ELranΣ -inclusions α such that T1 |= α and T2 6|= α.\nTo prove the equivalence between Σ-instance difference in ELHr and Σ-concept difference in ELran, we first associate with every ABox A and individual a in A a set CranA,a of Cran-concepts. Assume A is given. Let, inductively, for a ∈ obj(A):\nC0,ranA,a = ( l\nA(a)∈A\nA) u ( l\nr(b,a)∈A\nran(r));\nand Cn+1,ranA,a = ( l\nA(a)∈A\nA) u ( l\nr(b,a)∈A\nran(r)) u ( l\nr(a,b)∈A\n∃r.Cn,ranA,b ),\nand set CranA,a = {C n,ran A,a | n ≥ 0}\nObserve that A |= Cn,ranA,a (a) for all n > 0. Moreover, the lemma below shows that, intuitively, the infinite conjunction d CranA,a is the most specific “concept” with A |= d CranA,a(a).\nConversely, we associate an ABox with a Cran-concept. The construction is straightforward; however, some care has to be taken since we do not introduce structure sharing but associate distinct individual names with distinct occurrences of subconcepts. Given a Cran-concept C, we first define a path in C as a finite sequence C0 · r1 · C1 · · · · · rn · Cn, where C0 = C, n ≥ 0, and ∃ri+1.Ci+1 is a conjunct of Ci, for 0 ≤ i < n. We use paths(C) to denote the set of all paths in C. If p ∈ paths(C), then tail(p) denotes the last element Cn in p.\nNow, let aran and ap for p ∈ paths(C) be individual names and set inductively:\nAC = { s(ap, aq) | p, q ∈ paths(C); q = p · s · C ′, for some C ′ } ∪ {A(ap) | A is a conjunct of tail(p), p ∈ paths(C) } ∪ {>(ap) | > is a conjunct of tail(p), p ∈ paths(C) } ∪ { r(aran, ap) | ran(r) is a conjunct of tail(p), p ∈ paths(C) }\nExample 35. Let C = (∃r.(A u ran(v))) u (∃s.((∃t.(A u ran(v))) u (∃t.(B u ran(s))))) be a Cran-concept. Then AC can be represented graphically as follows.\nThe Logical Difference for the Lightweight Description Logic EL\naC\nA\naran\nA B\nsr\nt t\nv\nv\ns\nWe only indicate aC and aran; other individuals are identified by paths in C. Note that different occurrences of A u ran(v) in C correspond to different individuals in AC .\nLemma 36. Let T be an ELHr-TBox, A be an ABox, C0 and D0 be Cran-concepts, and let a0 ∈ obj(A). Then\n• (T ,A) |= D0(a0) if, and only if, there exists n ≥ 0 such that T |= Cn,ranA,a0 v D0;\n• T |= C0 v D0 if, and only if, (T ,AC0) |= D0(aC0).\nBelow, we will employ this lemma to transfer an analogue of Theorem 16 for ELran to ELHr-instance differences. For now, we only note the following consequence:\nCorollary 37. For any two ELHr-TBoxes T1 and T2, cDiffranΣ (T1, T2) = ∅ if, and only if, iDiffΣ(T1, T2) = ∅.\nProof. If (A, D0(a0)) ∈ iDiffΣ(T1, T2), then there exists an n ≥ 0 such that Cn,ranA,a0 v D0 ∈ cDiffranΣ (T1, T2). Conversely, if C0 v D0 ∈ cDiffranΣ (T1, T2), then (AC0 , D0(aC0)) ∈ iDiffΣ(T1, T2).\nNote that Theorem 6 follows from Corollary 37 since for any ELHr-TBox T without range restrictions T |= C v D if, and only if, T |= C ′ v D, where C ′ is obtained from C by replacing any concept of the form ran(r) in C by >.\n5.2 Proof System for ELHr\nThe Gentzen-style proof system for ELHr consists of the rules given in Figures 1 and 5. Cut elimination, correctness, and completeness of the proof system can be shown similarly to the corresponding proofs given by Hofmann (2005).\nTheorem 38. For all ELHr-terminologies T and Cran-concepts C and D, it holds that T |= C v D if, and only if, T ` C v D.\nWe now generalise Lemma 15 to ELHr-terminologies.\nLemma 39. Let T be an ELHr-terminology, A a concept name and ∃r.D an EL-concept. Assume\nT |= l\n1≤i≤l ran(si) u\nl\n1≤j≤n Aj u\nl\n1≤k≤m ∃rk.Ck v ∃r.D,\nwhere Ck, 1 ≤ k ≤ m, are Cran-concepts and l,m, n ≥ 0. Then at least one of the following conditions holds:\n(e1) there exists rk, 1 ≤ k ≤ m, such that T |= rk v r and T |= Ck u ran(rk) v D; (e2) there exists Aj, 1 ≤ j ≤ n, such that T |= Aj v ∃r.D; (e3) there exists rk, 1 ≤ k ≤ m, such that T |= ∃rk.> v ∃r.D; (e4) there exists si, 1 ≤ i ≤ l, such that T |= ran(si) v ∃r.D.\nNow assume that A is pseudo-primitive and\nT |= l\n1≤i≤l ran(si) u\nl\n1≤j≤n Aj u\nl\n1≤k≤m ∃rk.Ck v A,\nwhere Ck, 1 ≤ k ≤ m, are Cran-concepts and l,m, n ≥ 0. Then at least one of the following conditions holds:\n(a1) there exists Aj, 1 ≤ j ≤ n such that T |= Aj v A; (a2) there exists rk, 1 ≤ k ≤ m such that T |= ∃rk.> v A; (a3) there exists si, 1 ≤ i ≤ l such that T |= ran(si) v A.\nProof. We prove the first part of the lemma, the second part can then be proved analogously.\nLet C = d 1≤i≤l ran(si) u d 1≤j≤nAj u d\n1≤k≤m ∃rk.Ck and assume that T |= C v ∃r.D holds. Then, we have T ` C v ∃r.D by Theorem 38, which implies that there exists a derivation D of the sequent C v ∃r.D. The proof now proceeds by induction on the depth of D, i.e. the maximal length of any path from the root to one of the leaves of D.\nNotice that if l + n + m ≥ 2, the root of D can only have been derived by AndL1 or AndL2. The lemma follows then from the induction hypothesis.\nOtherwise, we have l + n + m = 1. Note that l + m + n = 0 is not possible since T 6|= > v ∃r.D by definition of the terminology T . If C = A1 or C = ran(s1), then (e2) or (e4), respectively, hold already. It remains to consider the case where C = ∃r1.C1. Then, the rule used to derive the root of D can only have been one of Ax, Ex, ExRan, Dom or Sub. We consider those cases one by one:\nThe Logical Difference for the Lightweight Description Logic EL\n• the root of D was derived with Ax: then by considering the form of the inference rule, r1 = r and C1 = D. Hence T |= r1 v r and T |= C1 u ran(r1) v D, which implies that (e1) holds.\n• the root of D was derived with Ex: then r1 = r and T ` C1 v D. Hence, T |= r1 v r and T |= C1 v D holds by Theorem 38. Thus, T |= C1 u ran(r1) v D and we can infer that (e1) holds again.\n• the root of D was derived with Dom: we have T ` B v ∃r.D and ∃r1.> v B ∈ T . Then by Theorem 38, T |= B v ∃r.D and hence, T |= ∃r1.> v ∃r.D, that is, (e3) holds.\n• the root of D was derived with ExRan: we obtain T ` ∃r1.(C1 u ran(r1)) v ∃r.D. Since the sequent ∃r1.(C1 u ran(r1)) v ∃r.D has a derivation that is of shorter length than D, we can apply the induction hypothesis. Hence, either T |= ∃r1.> v ∃r.D, that is, (e3) holds, or T |= r1 v r and T |= (C1 u ran(r1))u ran(r1) v D. Hence (e1) holds as |= C1 u ran(r1) v (C1 u ran(r1)) u ran(r1).\n• the root of D was derived with Sub: we obtain T ` ∃s.C1 v ∃r.D and r1 v s ∈ T . By the induction hypothesis, either T |= ∃s.> v ∃r.D, or T |= s v r and T |= C1 u ran(s) v D. It can be seen that T |= ∃r1.> v ∃r.D, or T |= r1 v r and T |= C1 u ran(r1) v D, respectively. Hence (e3) or (e1) holds.\nWe now prove an extension of Theorem 16 to ELran-consequences of ELHr-terminologies. We give a rather detailed description of the simple witness inclusions contained in members of cDiffranΣ (T1, T2) since we are going to use this result again when analysing the concept difference in ELHr.\nTheorem 40 (Primitive witness for ELran-differences). Let T1 and T2 be ELHr-terminologies and Σ a signature. If ϕ ∈ cDiffranΣ (T1, T2), then either there exist {r, s} ⊆ sig(ϕ) with r v s ∈ cDiffranΣ (T1, T2) or ϕ is of the form C v D, and one of\n1. C ′ v A or ran(r) u C ′ v A,\n2. A v D′, ∃r.> v D′ or ran(r) v D′\nis a member of cDiffranΣ (T1, T2), where r ∈ sig(ϕ), A ∈ sig(ϕ) is a concept name, C ′ is a subconcept of C and D′ is a subconcept of D.\nProof. Let C v D ∈ cDiffranΣ (T1, T2), where C is a Cran-concept and D an EL-concept. We prove the theorem by induction on the structure of D.\nNotice that D 6= > as T2 |= C v >. If D is a concept name, then an inclusion from Point 1 exists. If D = D1 u D2, then one of C v Di, i = 1, 2, is in cDiffranΣ (T1, T2). We can apply the induction hypothesis and we can infer that an inclusion from Point 1 or Point 2 exists. If D = ∃r.D1, let C = d 1≤i≤l ran(si) u d 1≤j≤nAj u d 1≤k≤m ∃rk.Ck. Then, by Lemma 39, one of (e1)–(e4) holds. Cases (e2)–(e4) directly entail that an inclusion from Point 1 or Point 2 exists. In case of (e1), either rk v r ∈ cDiffranΣ (T1, T2)\nKonev, Ludwig, Walther, & Wolter\nor T1 |= Ck u ran(rk) v D1 but T2 6|= Ck u ran(rk) v D1 (as otherwise T2 |= C v D would hold). Now we can apply the induction hypothesis to D1 and conclude that an inclusion from Point 1 or Point 2 exists."
    }, {
      "heading" : "5.3 Instance Difference Witnesses",
      "text" : "Similarly to Theorem 16 for the concept difference between EL-terminologies and derived from its extension, Theorem 40, for ELran, we show that every member (A, α) of iDiffΣ(T1, T2) gives rise to a basic witness in which either the ABox or the instance query are atomic. To keep the formulation succinct we give an abstract description of the relationship between (A, α) ∈ iDiffΣ(T1, T2) and its witness using only the signature of (A, α). The interested reader will have no problem to derive a stronger relationship between (A, α) and its witness from the proof.\nTheorem 41 (Primitive witness for ELHr-instance differences). Let T1 and T2 be ELHrterminologies and Σ a signature. If ϕ ∈ iDiffΣ(T1, T2), then at least one of the following conditions holds:\n1. ({r(a, b)}, s(a, b)) ∈ iDiffΣ(T1, T2), for some r, s ∈ sig(ϕ);\n2. (A, A(b)) ∈ iDiffΣ(T1, T2), for some concept name A ∈ sig(ϕ), individual b, and ABox A with sig(A) ⊆ sig(ϕ).\n3. (A, D(b)) ∈ iDiffΣ(T1, T2), for some singleton ABox A, individual b in A, and ELconcept D such that sig(A), sig(D) ⊆ sig(ϕ);\nProof. Let (A, α) ∈ iDiffΣ(T1, T2). We distinguish the following cases. (a) If α = s(a, b), then (T1,A) |= s(a, b) if, and only if, for some r(a, b) ∈ A we have T1 |= r v s. As (T2,A) 6|= s(a, b) we obtain T2 6|= r v s. Thus, ({r(a, b)}, s(a, b)) ∈ iDiffΣ(T1, T2) and Point 1 holds.\n(b) Assume α = D(b) for some EL-concept D. By Lemma 36, for some n ≥ 0 we have T1 |= Cn,ranA,b v D and T2 6|= C n,ran A,b v D. By Theorem 40, one of (i) r v s, (ii) A v D\n′, (iii) ∃r.> v D′, (iv) ran(r) v D′, (v) C v A, or (vi) ran(r)uC v A is a member of cDiffranΣ (T1, T2), where r ∈ sig(ϕ), A ∈ sig(ϕ) is a concept name, C is a subconcept of Cn,ranA,b and D\n′ is a subconcept of D. If (i) r v s ∈ cDiffranΣ (T1, T2), then ({r(a, b)}, s(a, b)) ∈ iDiffΣ(T1, T2) and Point 1 holds.\nNow let F v G denote the member of cDiffranΣ (T1, T2) in the cases (ii)-(vi) above. Consider the ABox AF associated with the Cran-concept F in Point 2 of Lemma 36. Then sig(AF ) ⊆ sig(ϕ) and (AF , G(aF )) ∈ iDiffΣ(T1, T2).\nIn case (ii), we obtain that F = A is a concept name. Hence AF = {A(aF )} and Point 3 holds. For case (iii), we obtain AF = {r(aF , a>),>(a>)} and Point 3 of the lemma applies again (after removing >(a>) from AF ). Similarly, if (iv), then AF = {r(aran, aF )}, and Point 3 of the lemma holds. Finally, for the cases (v) and (vi), G ∈ sig(ϕ) is a concept name. Hence Point 2 of the lemma applies.\nTheorem 41 justifies the following finite representation of the Σ-instance difference between ELHr-terminologies. It corresponds exactly to the three distinct points of the theorem. Assume T1 and T2 are given. Let\nThe Logical Difference for the Lightweight Description Logic EL\n• the set of role Σ-instance difference witnesses, iWtnRΣ(T1, T2), consist of all r v s such that T1 |= r v s and T2 6|= r v s;\n• the set of right-hand Σ-instance difference witnesses, iWtnrhsΣ (T1, T2), consist of all A ∈ Σ such that there exists A with (A, A(a)) ∈ iDiffΣ(T1, T2);\n• the set of left-hand Σ-instance difference witnesses, iWtnlhsΣ (T1, T2), consist of all A ∈ Σ such that there exists C(a) with ({A(a)}, C(a)) ∈ iDiffΣ(T1, T2) and all r ∈ Σ such that there exists C(c) with c = a or c = b such that ({r(a, b)}, C(c)) ∈ iDiffΣ(T1, T2).\nThe set of all Σ-instance difference witnesses is defined as\niWtnΣ(T1, T2) = (iWtnRΣ(T1, T2), iWtnrhsΣ (T1, T2), iWtnlhsΣ (T1, T2)).\nBy Theorem 41, observe that iWtnΣ(T1, T2) = (∅, ∅, ∅) if, and only if, iDiffΣ(T1, T2) = ∅. The set iWtnRΣ(T1, T2) can be easily computed in polynomial time and will not be analysed further in this paper. Thus, our aim now is to present polynomial-time algorithms computing iWtnrhsΣ (T1, T2) and iWtnlhsΣ (T1, T2).\n5.4 Computing iWtnrhsΣ (T1, T2)\nWe compute iWtnrhsΣ (T1, T2) in two different ways: first, we present the more transparent ABox approach that works for arbitrary ELHr-terminologies, and second we present the more efficient dynamic programming approach that works for acyclic ELHr-terminologies only. Both approaches have been introduced in Section 4.2 for EL-terminologies. We start with the ABox approach and exhibit a Σ-ABox AT2,Σ depending on T2 and Σ only such that for non-conjunctive A ∈ Σ there exists an ABox A such that (A, A(d)) ∈ iDiffΣ(T1, T2) if, and only if, (T1,AT2,Σ) |= A(ξA) for a certain individual name ξA. The case of conjunctive A is reduced to this condition for its defining concept names.\nTo deal with ELHr-terminologies rather than with EL-terminologies we have to extend the structure of AT2,Σ significantly. To describe the model-theoretic properties of AT2,Σ, we require the notion of a Σ-range simulation. They capture model-theoretically the expressive power of Cran-concepts (the concepts that have been used to describe the Σ-instance difference in terms of subsumption, cf. Lemma 36). For any two ABoxes A1,A2 with designated individual names a1 and a2, we say that a relation S between obj(A1) and obj(A2) is a Σ-simulation if, and only if,\n(S1) (a1, a2) ∈ S;\n(S2) for all A ∈ Σ: if (a, b) ∈ S and A(a) ∈ A1, then A(b) ∈ A2;\n(S3) for all r ∈ Σ: if (a, b) ∈ S and r(a, a′) ∈ A1, then there exists b′ with (a′, b′) ∈ S and r(b, b′) ∈ A2.\nWe say that S is a Σ-range simulation if, in addition,\n(RS) for all r ∈ Σ: if (a, b) ∈ S and there exists c such that r(c, a) ∈ A1, then there exists c′ with r(c′, b) ∈ A2.\nIn what follows we write\nKonev, Ludwig, Walther, & Wolter\n• (A1, a1) ≤Σ (A2, a2) if there exists a Σ-simulation between (A1, a1) and (A2, a2); and\n• (A1, a1) ≤ranΣ (A2, a2) if there exists a Σ-range simulation between (A1, a1) and (A2, a2).\nThe following lemma shows that range simulations characterise Cran-concepts.\nLemma 42. Let A1 and A2 be Σ-ABoxes with designated individual names a1 and a2. If (A1, a1) ≤ranΣ (A2, a2), then (T ,A1) |= C(a1) implies (T ,A2) |= C(a2) for all Cran-concepts C.\nProof. We apply Lemma 36. Let S be a Σ-range simulation between A1 and A2 with (a1, a2) ∈ S. One can prove by induction on n that for all n ≥ 0, for all a ∈ obj(A1) and for all b ∈ obj(A2),\n(∗) If (a, b) ∈ S, then A2 |= Cn,ranA1,a (b).\nNow assume that (A1, a1) ≤ranΣ (A2, a2) and that (T ,A1) |= C(a1) holds for a Cranconcept C. Then, by Lemma 36, there exists n ≥ 0 such that T |= Cn,ranA1,a1 v C. Moreover, as (A1, a1) ≤ranΣ (A2, a2), we have by (∗) that A2 |= C n,ran A1,a1(a2), which then implies that (T ,A2) |= C(a2), as required.\nThe construction of AT ,Σ is now given in Figure 6, where T is a normalised ELHrterminology and Σ a signature. We advise the reader to recall the definition of AT ,Σ given in Figure 3 for EL-terminologies T and then consider the additional ingredients required for ELHr-terminologies. We remind the reader of the definition of non-conjT (A) from Section 4.2:\nnon-conjT (A) = { {A}, A is non-conjunctive in T {B1, . . . , Bn}, A ≡ B1 u · · · uBn ∈ T\nIn Figure 6, we also use the following sets, for A ∈ NC and r ∈ NR:\n• preCΣT (A) = {B ∈ Σ ∩ NC | T |= B v A },\n• preDomΣT (A) = { r ∈ Σ ∩ NR | T |= ∃r.> v A },\n• preRanΣT (A) = { r ∈ Σ ∩ NR | T |= ran(r) v A },\n• preRoleΣT (r) = { s ∈ Σ ∩ NR | T |= s v r }.\nThe following example illustrates the definition of AT ,Σ.\nExample 43. For T1 = {ran(r) v A1, ran(s) v A2, B ≡ A1uA2}, T2 = ∅, and Σ = {r, s, B} defined as in Example 4, we have\nAT2,Σ = {B(ξΣ), r(ξΣ, ξΣ), s(ξΣ, ξΣ), r(ξB, ξΣ), s(ξB, ξΣ), r(ξΣ, ξB), s(ξΣ, ξB)}.\nIt holds that (T1,AT2,Σ) |= B(ξB) and (T2,AT2,Σ) 6|= B(ξB).\nThe Logical Difference for the Lightweight Description Logic EL\nLemma 44. For every normalised ELHr-terminology T and signature Σ the following conditions are equivalent for all Σ-ABoxes A, A ∈ sig(T ) ∪ Σ non-conjunctive in T , and all a ∈ obj(A):\n1. (T ,A) 6|= A(a);\n2. ξA ∈ obj(AT ,Σ) and (A, a) ≤ranΣ (AT ,Σ, ξA).\nLemma 44 is proved in the appendix.\nLemma 45. Let T1 and T2 be normalised ELHr-terminologies, Σ a signature and A ∈ Σ. Let AT2,Σ be the ABox constructed in Figure 6. Then the following conditions are equivalent:\n• there exists a Σ-ABox A such that (T1,A) |= A(a) and (T2,A) 6|= A(a);\n• (T1,AT2,Σ) |= A(ξB) for some B ∈ non-conjT2(A).\nKonev, Ludwig, Walther, & Wolter\nProof. Assume there exists a Σ-ABox A and a ∈ obj(A) with (T1,A) |= A(a) and (T2,A) 6|= A(a). Then, as (T2,A) 6|= A(a), for some B ∈ non-conjT2(A), (T2,A) 6|= B(a). Hence, by Lemma 44, (A, a) ≤ranΣ (AT2,Σ, ξB). But then, by Lemma 42, (T1,AT2,Σ) |= A(ξB), as required.\nConversely, suppose that (T1,AT2,Σ) |= A(ξB) for some B ∈ non-conjT2(A) with ξB ∈ obj(AT2,Σ). Notice that, by Lemma 44, (T2,AT2,Σ) 6|= B(ξB). Hence (T2,AT2,Σ) 6|= A(ξB) and so AT2,Σ and ξB witness Point 1.\nTheorem 46. Let T1 and T2 be normalised ELHr-terminologies and Σ a signature. Then iWtnrhsΣ (T1, T2) can be computed in polynomial time.\nProof. By Lemma 45, A ∈ iWtnrhsΣ (T1, T2) if, and only if, for some B ∈ non-conjT2(A) we have (T1,AT2,Σ) |= A(ξB). It remains to observe that AT2,Σ can be constructed in polynomial time and checking whether (T1,AT2,Σ) |= A(ξB) is in polynomial time.\nWe now briefly describe how the dynamic programming approach for computing the set iWtnrhsΣ (T1, T2) for acyclic terminologies is extended from EL to ELHr. The extension of the NotWitness(E) algorithm from Figure 4 to ELHr is given in Figure 7. As in Figure 4, the procedure NotWitness(E) recursively associates with every E ∈ sig(T1) ∪ Σ a subset of\nΞ = {All} ∪ {A | A ∈ (sig(T2) ∪ Σ), A is non-conjunctive in T2 }.\nThe conditions for A ∈ NotWitness(E) become more complex since now one has to take into account the sets preRanΣT (E) and preDom Σ T (E). To prove the correctness of the NotWitness algorithm, we observe the following consequence of Lemma 36.\nCorollary 47. Let T1 and T2 be normalised acyclic ELHr-terminologies and Σ a signature. Then iWtnrhsΣ (T1, T2) = {A ∈ Σ | ∃ Cran-concept C such that C v A ∈ cDiffranΣ (T1, T2) }.\nProof. First, let A ∈ iWtnrhsΣ (T1, T2). Then there exists a Σ-ABox A such that (T1,A) |= A(a) and (T2,A) 6|= A(a). Hence, by Point 1 of Lemma 36 there exists n ≥ 0 such that Cn,ranA,a v A ∈ cDiff ran Σ (T1, T2). Note that C n,ran A,a is a Cran-concept. Conversely, assume A ∈ Σ such that there exists a Cran-concept C with C v A ∈ cDiffranΣ (T1, T2). Then by Point 2 of Lemma 36, (AC , A(aC)) ∈ iDiffΣ(T1, T2), i.e. A ∈ iWtnrhsΣ (T1, T2).\nWe now formulate the correctness of the NotWitness algorithm in the same way as in Corollary 26.\nTheorem 48. Let T1 and T2 be normalised acyclic ELHr-terminologies and Σ a signature. Then iWtnrhsΣ (T1, T2) = {A ∈ sig(T1) ∩ Σ | ∃B ∈ non-conjT2(A) with B 6∈ NotWitness(A) }.\nThe proof is an extension of the proofs of Lemma 25 and Corollary 26. Namely, one can show that for all A ∈ sig(T1) ∪ Σ and all B ∈ sig(T2) ∪ Σ such that B is non-conjunctive in T2 the following conditions are equivalent:\n• B ∈ NotWitness(A);\n• for all CranΣ -concepts C: T2 6|= C v B implies T1 6|= C v A.\nUsing Corollary 47, we thus obtain for every A ∈ Σ: A ∈ iWtnrhsΣ (T1, T2) if, and only if, there exists a CranΣ -concept C with T2 6|= C v A and T1 |= C v A if, and only if, there exists B ∈ non-conjT2(A) with B 6∈ NotWitness(A).\nThe Logical Difference for the Lightweight Description Logic EL\n5.5 Tractability of iWtnlhsΣ (T1, T2)\nWe prove the tractability of iWtnlhsΣ (T1, T2) by the same reduction to simulation checking as in the case of EL-terminologies (Theorem 30).\nTheorem 49. Let T1 and T2 be ELHr-TBoxes and let Σ be a signature. Then the set iWtnlhsΣ (T1, T2) can be computed in polynomial time.\nProof. For any concept name A ∈ Σ we have\nA ∈ iWtnlhsΣ (T1, T2) ⇔ (IK1 , a) 6≤Σ (IK2 , a)\nKonev, Ludwig, Walther, & Wolter\nwhere Ki = (Ti,A) for A = {A(a)} and IKi is the canonical model for Ki, i = 1, 2. Indeed, ({A(a)}, C(a)) ∈ iDiffΣ(T1, T2), for some ELΣ-concept C, if, and only if, by Theorem 2, a ∈ CIK1 and a /∈ CIK2 . But this condition is, by Lemma 29, equivalent to (IK1 , a) 6≤Σ (IK2 , a). The latter condition can be checked in polynomial time.\nSimilarly, for any role name r ∈ Σ we have\nr ∈ iWtnlhsΣ (T1, T2) ⇔ (IK1 , a) 6≤Σ (IK2 , a) or (IK1 , b) 6≤Σ (IK2 , b)\nwhere Ki = (Ti,A), A = {r(a, b)}, and IKi is the canonical model for Ki, i = 1, 2. Again, the latter condition can be checked in polynomial time.\n6. ELHr-Concept Difference\nIn this section we present polynomial-time algorithms deciding Σ-concept inseparability and computing a succinct representation of the concept difference between ELHr-terminologies. The algorithms are essentially by reduction to the instance difference case.\nWe start by introducing the succinct representation of the Σ-concept difference. Let T1 and T2 be ELHr-terminologies. Since cDiffΣ(T1, T2) ⊆ cDiffranΣ (T1, T2), it follows from Theorem 40 for C v D ∈ cDiffΣ(T1, T2) that there exists an inclusion of at least one of the following forms\n(i) C ′ v A, (ii) ran(r) u C ′ v A, (iii) A v D′, (iv) ∃r.> v D′, or (v) ran(r) v D′\nin cDiffΣ(T1, T2), where r ∈ sig(ϕ), A ∈ sig(ϕ) is a concept name, C ′ is a subconcept of C and D′ is a subconcept of D. Notice in particular for case (ii) that C ′ is an EL-concept. Hence, just as in the case of the Σ-instance difference, we obtain the following representation of the Σ-concept difference. Assume T1 and T2 are given. Let\n• the set of role inclusion Σ-concept difference witnesses, cWtnRΣ(T1, T2), consist of all r v s such that T1 |= r v s and T2 6|= r v s;\n• the set of right-hand Σ-concept difference witnesses, cWtnrhsΣ (T1, T2), consist of all A ∈ Σ such that there exists an EL-concept C with either C v A ∈ cDiffΣ(T1, T2) or there additionally exists a role name r ∈ Σ such that ran(r)uC v A ∈ cDiffΣ(T1, T2).\n• the set of left-hand Σ-concept difference witnesses, cWtnlhsΣ (T1, T2), consist of all A ∈ Σ such that there exists an EL-concept C with A v C ∈ cDiffΣ(T1, T2), and of all role names r ∈ Σ such that there exists an EL-concept C with either ∃r.> v C ∈ cDiffΣ(T1, T2) or ran(r) v C ∈ cDiffΣ(T1, T2).\nThe set of all Σ-concept difference witnesses is defined as\ncWtnΣ(T1, T2) = (cWtnRΣ(T1, T2), cWtnrhsΣ (T1, T2), cWtnlhsΣ (T1, T2)).\nThe Logical Difference for the Lightweight Description Logic EL\nObserve that cWtnΣ(T1, T2) = (∅, ∅, ∅) if, and only if, cDiffΣ(T1, T2) = ∅. We also obtain that the sets cWtnRΣ(T1, T2) and cWtnlhsΣ (T1, T2) coincide with the corresponding witness sets for the instance difference, which allows us to re-use some results that we have developed for detecting instance differences.\nLemma 50. Let T1 and T2 be normalised ELHr-terminologies and Σ a signature. Then the following holds:\n1. cWtnRΣ(T1, T2) = iWtnRΣ(T1, T2),\n2. cWtnlhsΣ (T1, T2) = iWtnlhsΣ (T1, T2)\n3. cWtnrhsΣ (T1, T2) ⊆ iWtnrhsΣ (T1, T2)\nProof. Point 1 follows directly from the definition. Proving cWtnlhsΣ (T1, T2) ⊆ iWtnlhsΣ (T1, T2) and cWtnrhsΣ (T1, T2) ⊆ iWtnrhsΣ (T1, T2) is similar to Lemma 10. Finally, to prove that iWtnlhsΣ (T1, T2) ⊆ cWtnlhsΣ (T1, T2), assume that A ∈ iWtnlhsΣ (T1, T2). Then there exists an ELconcept D(a) with ({A(a)}, D(a)) ∈ iDiffΣ(T1, T2). But then T1 |= A v D and T2 6|= A v D and, therefore, A ∈ cWtnlhsΣ (T1, T2). The argument for r ∈ iWtnlhsΣ (T1, T2) is similar.\nWe have presented polynomial-time algorithms which can compute iWtnlhsΣ (T1, T2) and iWtnRΣ(T1, T2). Thus, it remains to analyse cWtnrhsΣ (T1, T2).\n6.1 Tractability of cWtnrhsΣ (T1, T2)\nWe prove tractability of cWtnrhsΣ (T1, T2) by modifying the ABox AT2,Σ that has been introduced to prove tractability of iWtnrhsΣ (T1, T2). Recall thatA ∈ iWtnrhsΣ (T1, T2) iff (T1,AT2,Σ) |= A(ξB) for some B ∈ non-conjT2(A) (cf. Lemma 45). Not all A satisfying this condition are in cWtnrhsΣ (T1, T2) since the ABox AT2,Σ cannot always be “captured” by a set of EL-concepts (cf. Example 4). Our modification of AT2,Σ is motivated by the observation that if an ABox A does not contain any individual in the range of two distinct role names, then EL-concepts rather than Cran-concepts are sufficient to capture the consequences of the ABox. Thus, we are going to modify AT2,Σ in a minimal way so that the resulting ABox does not contain any individual name in the range of two distinct role names.\nDefinition 51. An ABox A is role-splitting if there is no pair of assertions r(a, c), s(b, c) ∈ A, for individual names a, b, c and distinct role names r, s.\nThe following lemma states the main property of role-splitting ABoxes.\nLemma 52. Let T1 and T2 be normalised ELHr-terminologies, Σ a signature with A ∈ Σ and let A be a role-splitting Σ-ABox such that (T1,A) |= A(a) and (T2,A) 6|= A(a). Then A ∈ cWtnrhsΣ (T1, T2).\nProof. By Lemma 36, there exists n ≥ 0 such that T1 |= Cn,ranA,a v A and T2 6|= C n,ran A,a v A. Assume first that there does not exist b ∈ obj(A) and r ∈ Σ such that r(b, a) ∈ A. Then, by definition and since A is role-splitting, ran(r) only occurs in Cn,ranA,a in the direct scope of the existential restriction ∃r. Hence Cn,ranA,a is equivalent to an ELΣ-concept, and we are done. Now assume there exists r(b, a) ∈ A. Then, again since A is role-splitting, Cn,ranA,a is equivalent to a concept ran(r) u C, where C is an ELΣ-concept. In this case T1 |= ran(r) u C v A and T2 6|= ran(r) u C v A, as required.\nKonev, Ludwig, Walther, & Wolter\nFor a Σ-ABox A such that sig(A) ∩ NR 6= ∅, we define its role-splitting unfolding A with individuals { ar | a ∈ obj(A), r ∈ sig(A) ∩ NR } by setting\nA = {A(ar) | A(a) ∈ A, r ∈ sig(A) ∩ NR } ∪ { r(as, br) | r(a, b) ∈ A, s ∈ sig(A) ∩ NR }.\nExample 53. Consider T1 = {ran(r) v A1, ran(s) v A2, B ≡ A1 u A2}, T2 = ∅, Σ = {r, s, B} and A = {r(a, c), s(b, c)} from Example 4. We have (T1,A) |= B(c) but (T2,A) 6|= B(c). Notice that the role-splitting unfolding A = {r(ar, cr), r(as, cr), s(br, cs), s(bs, cs)} does not contain any individual in the range of more than one role\nA\na\nc\nb\nr s A\nar br\ncr\nas bs\ncs\nr\nr s\ns\nand (T1,A ) 6|= B(cr), (T1,A ) 6|= B(cs).\nWe apply the role-splitting unfolding to the ABox AT ,Σ from Figure 6. The following result is the concept version of Lemma 44 and is proved in the appendix by a reduction to Lemma 44. The ABox AC corresponding to an EL-concept C has been introduced before Lemma 36. For simplicity, we consider signatures Σ containing at least one role name.\nLemma 54. For every normalised ELHr-terminology T , signature Σ such that Σ∩NR 6= ∅, concept name A that is non-conjunctive in T , role name r ∈ Σ, and ELΣ-concepts C the following conditions are equivalent for D = C and D = ran(r) u C:\n• T 6|= D v A;\n• for some r ∈ Σ ∩ NR, (ξA)r ∈ obj(A T ,Σ) and (AD, aD) ≤ranΣ (A T ,Σ, (ξA)r).\nThe following lemma can now be proved similarly to Lemma 45, using Lemma 54 instead of Lemma 44.\nLemma 55. Let T1 and T2 be normalised ELHr-terminologies, Σ a signature with A ∈ Σ such that Σ ∩ NR 6= ∅. Then the following conditions are equivalent:\n• A ∈ cWtnrhsΣ (T1, T2);\n• there exists r ∈ Σ such that (T1,A T2,Σ) |= A((ξB)r) for some B ∈ non-conjT2(A).\nProof. Assume that A ∈ cWtnrhsΣ (T1, T2). Then, there either exists an ELΣ-concept C with T1 |= C v A and T2 6|= C v A, or there additionally exists r ∈ Σ such that T1 |= ran(r) u C v A and T2 6|= ran(r) u C v A. Hence, for D = C and D = ran(r) u C, respectively, T2 6|= D v B, for some B ∈ non-conjT2(A), and by Lemma 54, there exists r ∈ Σ with (ξA)r ∈ obj(A T ,Σ) and (AD, aD) ≤ranΣ (A T2,Σ, (ξB)r). But then, by Lemma 42 (T1,A T2,Σ) |= A((ξB)r) as (T1,AD) |= A(aD) holds by Lemma 36.\nFor the converse direction, it is easy to see that (ξB)r ∈ obj(A T2,Σ), ξB ∈ obj(AT2,Σ), and (A T2,Σ, (ξB)r) ≤ ran Σ (AT2,Σ, ξB), which implies that (T2,A T2,Σ) 6|= A((ξB)r) by Lemma 44. Consequently, we obtain A ∈ cWtnrhsΣ (T1, T2) by applying Lemma 52 and by using the fact that the ABox A T2,Σ is role-splitting.\nThe Logical Difference for the Lightweight Description Logic EL\nFinally, we obtain the tractability result.\nTheorem 56. Let T1 and T2 be ELHr-terminologies and Σ a signature. Then the set cWtnrhsΣ (T1, T2) can be computed in polynomial time.\nProof. If Σ ∩ NR = ∅, then cWtnrhsΣ (T1, T2) = iWtnrhsΣ (T1, T2), which can be computed in polynomial time by Theorem 46.\nOtherwise Σ ∩ NR 6= ∅ and the result follows from Lemma 55 and the fact that A T2,Σ can be constructed in polynomial time in the size of T2.\n7. ELHr-Query Difference\nTo investigate the query difference between ELHr-terminologies, we introduce the language ELran,u,u that extends ELran with the universal role and intersections of roles. We show that concept differences in ELran,u,u correspond to query differences in ELHr. For ELran,u,u we can prove an analogue of Theorem 40, which states that any inclusion in the concept difference “contains” an inclusion in which either the left-hand side or the right-hand side is atomic. Using the correspondence between concept difference in ELran,u,u and query difference in ELHr we then obtain a meaningful definition of a succinct representation of the query difference qDiffΣ(T1, T2). Finally, we provide polynomial-time algorithms deciding Σ-query inseparability and computing the succinct representation of the query difference.\n7.1 ELran,u,u-Concept Difference\nWe start this section by defining the language ELran,u,u.\nDefinition 57 (ELran,u,u). Let u (the universal role) be a fresh logical symbol. Cu,uconcepts are constructed using the following syntax rule\nC := A | C uD | ∃R.C | ∃u.C,\nwhere A ∈ NC, C,D range over Cu,u-concepts and R = r1 u · · · u rn with r1, . . . , rn ∈ NR for some n ≥ 1. The set of ELran,u,u-inclusions consists of concept inclusions C v D and role inclusions r v s, where C is a Cran-concept, D a Cu,u-concept, and r, s ∈ NR.\nThe semantics of the additional constructors is straightforward by setting, for any interpretation I,\n• (r1 u · · · u rn)I = rI1 ∩ · · · ∩ rIn;\n• uI = ∆I ×∆I .\nNote that we regard the universal role u as a logical symbol; i.e., u 6∈ NR and sig(∃u.C) = sig(C) for any concept C. Assuming that u is a logical symbol reflects the fact that its firstorder translation uses no non-logical symbols. For example, the signature of the first-order translation ∃x.A(x) of ∃u.A does not contain any non-logical symbols with the exception of A itself.\nIt will be convenient to decompose Cu,u-concepts. The set of Cu-concepts is defined as the set of all Cu,u-concepts without the universal role. Every Cu,u-concept C is equivalent\nKonev, Ludwig, Walther, & Wolter\nto a concept of the form D0 u ∃u.D1 u · · · u ∃u.Dk, where D0, . . . , Dk are Cu-concepts. To see this, observe that any concept C with a subconcept ∃u.D is equivalent to ∃u.D u C ′, where C ′ is obtained from C by replacing all occurrences of ∃u.D by >. For example, A u ∃r.(B u ∃u.E) is equivalent to the concept ∃u.E uA u ∃r.(B u >).\nIn the following we denote by Cu,uΣ (CuΣ) the set of all Cu,u (Cu) concepts whose signature is contained in Σ.\nClearly, every ELran-inclusion is an ELran,u,u-inclusion. In addition, role conjunctions and the universal role in ELran,u,u-inclusions can be used to capture differences between ELHr-TBoxes that cannot be captured by ELHr-inclusions.\nExample 58. We first reconsider Example 8. Recall that\nT1 = ∅, T2 = {A v ∃r.B}, Σ = {A,B}.\nThen T2 |= A v ∃u.B but T1 6|= A v ∃u.B and, as the universal role is regarded as a logical symbol, sig(A v ∃u.B) ⊆ Σ. Thus, by employing the universal role ELran,u,u we can simulate the query difference ({A(a)}, ∃x.B(x)) using the subsumption A v ∃u.B.\nSecond, we reconsider Example 9. Recall that\nT1 = {A v ∃s.>, s v r1, s v r2}, T2 = {A v ∃r1.> u ∃r2.>}, Σ = {A, r1, r2}.\nThen T1 |= A v ∃(r1 u r2).> and T2 6|= A v ∃(r1 u r2).>. Thus, we can simulate the query difference ({A(a)},∃x.(r1(a, x) ∧ r2(a, x))) using the subsumption A v ∃(r1 u r2).>.\nWe introduce the appropriate notion of Σ-concept difference for ELran,u,u.\nDefinition 59 (ELran,u,uΣ -difference). The EL ran,u,u Σ -difference between ELH r-TBoxes T1 and T2 is the set cDiffran,u,uΣ (T1, T2) of all EL ran,u,u Σ -inclusions α such that T1 |= α and T2 6|= α.\nWe now extend Lemma 39 for concepts that use the universal role or conjunctions of roles.\nLemma 60. Let T be an ELHr-terminology and ∃R.D a Cu-concept with R = t1 u · · · u tq a conjunction of role names. Assume\nT |= l\n1≤i≤l ran(si) u\nl\n1≤j≤n Aj u\nl\n1≤k≤m ∃rk.Ck v ∃R.D,\nwhere Ck, 1 ≤ k ≤ m, are Cran-concepts and l,m, n ≥ 0. Then at least one of the following conditions holds:\n(e1u) there exists rk, 1 ≤ k ≤ m, such that rk vT t1,. . . , rk vT tq, and T |= Ckuran(rk) v D;\n(e2u) there exists Aj, 1 ≤ j ≤ n, such that T |= Aj v ∃R.D; (e3u) there exists rk, 1 ≤ k ≤ m, such that T |= ∃rk.> v ∃R.D; (e4u) there exists si, 1 ≤ i ≤ l, such that T |= ran(si) v ∃R.D.\nThe Logical Difference for the Lightweight Description Logic EL\nIf u is the universal role and T |= C v ∃u.D, where C is a Cran-concept and D is a Cu-concept, then at least one of the following holds:\n(e1u) there exists a subconcept ∃r.C ′ of C such that T |= C ′ u ran(r)v D; (e2u) there exists a concept name A in C such that T |= A v ∃u.D; (e3u) there exists a role name r in C such that T |= ∃r.> v ∃u.D; (e4u) there exists a role name r in C such that T |= ran(r) v ∃u.D; (e5u) T |= C v D; (e6u) there exists a subconcept (ran(r) u C ′) of C such that T |= ∃r.C ′ v D.\nTheorem 61 (Primitive witnesses for ELran,u,u). Let T1 and T2 be ELHr-terminologies and Σ a signature. If ϕ ∈ cDiffran,u,uΣ (T1, T2), then either there exist {r, s} ⊆ sig(ϕ) with r v s ∈ cDiffran,u,uΣ (T1, T2) or ϕ is of the form C v D, and one of\n1. C ′ v A\n2. A v D′, ∃r.> v D′ or ran(r) v D′\nis a member of cDiffran,u,uΣ (T1, T2), where A ∈ sig(ϕ) is a concept name, r ∈ sig(ϕ) is a role name, C ′ is a Cran-concept, D′ is a Cu,u-concept, and sig(C ′), sig(D′) ⊆ sig(ϕ).\nProof. Let C v D ∈ cDiffran,u,uΣ (T1, T2), where C is a Cran-concept and D a Cu,u-concept. We prove the result by induction on the structure of D. The proof is very similar to the proof of Theorem 40 and so we consider the case D = ∃u.D1 only. Let C = d 1≤i≤l ran(si)ud\n1≤j≤nAj u d\n1≤k≤m ∃rk.Ck. Then, by Lemma 60, one of (e1u)–(e6u) holds. Cases (e2u)–(e4u) directly entail the existence of an inclusion from Point 2 of the theorem. In case (e1u) there exists a subconcept ∃r.C ′ of C such that T1 |= C ′uran(r) v D1. We have that T2 6|= C ′ u ran(r) v D1 as otherwise we have T2 |= ∃r.C ′ v ∃r.D1, i.e. T2 |= C v D would hold. Thus, C ′ u ran(r) v D1 ∈ cDiffran,u,uΣ (T1, T2). We can apply the induction hypothesis to D1 and infer that an inclusion from Point 1 or Point 2 exists.\nSimilarly, for case (e5u), we have C v D1 ∈ cDiffran,u,uΣ (T1, T2) as otherwise T2 |= C v D1, i.e. T2 |= C v D due to D = ∃u.D1. By applying the induction hypothesis to D1, we obtain that an inclusion from Point 1 or Point 2 exists.\nFinally, in case (e6u) there exists a subconcept ran(r)uC ′ of C such that T1 |= ∃r.C ′ v D1. Observe first that for every model I of T2 and for every d ∈ CI , there exists d′ ∈ (ran(r) u C ′)I , which implies that there exists d′′ ∈ (∃r.C ′)I . If we now assume that T2 |= ∃r.C ′ v D1, it would follow that for every model I of T2 and for every d ∈ CI , there exists d′′ ∈ DI1 , i.e. T2 |= C v ∃u.D1 would hold. We can infer that ∃r.C ′ v D1 ∈ cDiffran,u,uΣ (T1, T2) and by applying the induction hypothesis to D1, we conclude that an inclusion from Point 1 or Point 2 exists."
    }, {
      "heading" : "7.2 Query Difference Witnesses",
      "text" : "We start by connecting concept differences in ELran,u,u with query differences between ELHr-terminologies. The direction from query differences in ELHr to concept differences in ELran,u,u is straightforward: observe that every assertion C(a) with C a Cu,u-concept can\nKonev, Ludwig, Walther, & Wolter\nbe regarded as a Boolean conjunctive query qC,a. For example, the assertion (∃u.Au∃r.B)(a) is equivalent to the conjunctive query ∃x∃y.(A(x)∧r(a, y)∧B(y)) (details of the translation are provided in the appendix). We obtain (where AC is the ABox defined before Lemma 36):\nLemma 62. For any two ELHr-TBoxes T1 and T2 and signature Σ, we have C v D ∈ cDiffran,u,uΣ (T1, T2) if, and only if, (AC , qD,aC ) ∈ qDiffΣ(T1, T2).\nIn what follows we will not distinguish between an assertion C(a) with C a Cu,u-concept and the conjunctive query qC,a. It follows from Lemma 62 that if qDiffΣ(T1, T2) = ∅, then cDiffran,u,uΣ (T1, T2) = ∅.\nWe come to the (considerably more involved) direction from query differences to concept differences in ELran,u,u. The following lemma provides a rather abstract description of how inclusions in qDiffΣ(T1, T2) are reflected by members of cDiff ran,u,u Σ (T1, T2) by stating that they are given in the same signature.\nLemma 63. For any two ELHr-TBoxes T1 and T2 and signature Σ, if ϕ ∈ qDiffΣ(T1, T2), then there exists ϕ′ ∈ cDiffran,u,uΣ (T1, T2) with sig(ϕ′) ⊆ sig(ϕ).\nThe interested reader can extract a more detailed description from the proof given in the appendix. The proof of Lemma 63 given in the appendix is model-theoretic and employs the close relationship between conjunctive query entailment and homomorphisms (Chandra & Merlin, 1977). The intuition behind the result, however, is rather straightforward: if (T ,A) |= q[~a] for a conjunctive query q(~x) = ∃~yψ(~x, ~y) and ELHr-TBox T , then for every model I of (T ,A) there is a mapping π from the variables ~x and ~y into ∆I such that ~a is a π-match of q(~x) and I. (T ,A) has models that are essentially forest-shaped: they consist of tree-shaped models attached to the ABox individuals in A (cf. Lutz et al., 2009). In such forest-shaped models, the individuals from ~y that are not mapped to individuals in A are mapped to the trees attached to the ABox individuals. Such a mapping, however, exists already for a conjunctive query q′ such that q is a homomorphic image of q′ and q′ is essentially forest-shaped: the individuals not mapped to ABox individuals form trees that are attached to the core of q′ that is mapped to the ABox individuals. In other words, we obtain q′ by partitioning q into a core and into subsets that correspond to Cu,u-concepts! Now, if there exists a Σ-ABox A and a conjunctive Σ-query q(~a) such that (T2,A) |= q[~a] and (T1,A) 6|= q[~a], then we find such a conjunctive Σ-query q′ with the same behaviour as q that is essentially forest-shaped. From (A, q′) one can then obtain the required ELran,u,uinclusion C v D, where D captures some subtree of the query q′ (a Cu,u-concept) and C (a Cran-concept) the ABox A. The intuition for the last step is exactly the same as for Lemma 36.\nWe note that the result holds for general TBoxes and not only terminologies. From Lemma 63 and Theorem 61, we directly obtain the following description of primitive witnesses for query differences.\nTheorem 64 (Primitive witness for ELHr-query differences). Let T1 and T2 be ELHrterminologies and Σ a signature. If ϕ ∈ qDiffΣ(T1, T2), then at least one of the following conditions holds (for some individual names a, b):\n1. ({r(a, b)}, s(a, b)) ∈ qDiffΣ(T1, T2), for some r, s ∈ sig(ϕ);\nThe Logical Difference for the Lightweight Description Logic EL\n2. (A, A(b)) ∈ qDiffΣ(T1, T2), for some concept name A ∈ sig(ϕ) and ABox A with sig(A) ⊆ sig(ϕ);\n3. (A, D(b)) ∈ qDiffΣ(T1, T2), for some singleton ABox A and Cu,u-concept D such that sig(A), sig(D) ⊆ sig(ϕ).\nObserve that Theorem 64 coincides with Theorem 41 with the exception that in Point 3 the concept D can now be a Cu,u-concept. We can, therefore, define the following finite representation of the Σ-query difference. Assume T1 and T2 are given. Define the set\n• qWtnRΣ(T1, T2) of role Σ-query difference witnesses as the set of role Σ-instance difference witnesses; i.e., qWtnRΣ(T1, T2) = iWtnRΣ(T1, T2);\n• qWtnrhsΣ (T1, T2) of right-hand Σ-query difference witnesses as the set of right-hand Σ-instance difference witnesses; i.e., qWtnrhsΣ (T1, T2) = iWtnrhsΣ (T1, T2);\n• qWtnlhsΣ (T1, T2) of left-hand Σ-instance difference witnesses as the set of all A ∈ Σ such that there exists a Cu,u-concept C with ({A(a)}, C(a)) ∈ qDiff lhsΣ (T1, T2) and all r ∈ Σ such that there exists a Cu,u-concept C such that ({r(a, b)}, C(c)) ∈ qDiffΣ(T1, T2) for c = a or c = b.\nThe set of all Σ-query difference witnesses is defined as\nqWtnΣ(T1, T2) = (qWtnRΣ(T1, T2), qWtnrhsΣ (T1, T2), qWtnlhsΣ (T1, T2)).\nBy Theorem 64, qWtnΣ(T1, T2) = (∅, ∅, ∅) if, and only if, qDiffΣ(T1, T2) = ∅. Algorithms computing qWtnRΣ(T1, T2) and qWtnrhsΣ (T1, T2) have been presented in the section on instance difference. It thus remains to consider qWtnlhsΣ (T1, T2).\n7.3 Tractability of qWtnlhsΣ (T1, T2)\nTo prove tractability of qWtnlhsΣ (T1, T2) we first capture the expressive power of Cu,u-concepts using a stronger form of simulation between interpretations. Let I1 and I2 be interpretations. A Σ-simulation S between I1 and I2 is called a global intersection preserving Σ-simulation if, in addition,\n• for every d ∈ ∆I1 there exists a d′ ∈ ∆I2 with (d, d′) ∈ S;\n• if (d, e) ∈ S, d′ ∈ ∆I1 , and R = {r ∈ Σ | (d, d′) ∈ rI1} 6= ∅, then there exists e′ with (e, e′) ∈ S and (d′, e′) ∈ rI2 for all r ∈ R.\nWe write (I1, d) ≤∩Σ (I2, e) if there exists a global intersection preserving Σ-simulation S between I1 and I2 such that (d, e) ∈ S.\nLemma 65. Let I1 and I2 be finite interpretations, Σ a signature, d ∈ ∆I1, and e ∈ ∆I2. Then\n(I1, d) ≤∩Σ (I2, e) ⇔ for all C ∈ C u,u Σ : d ∈ CI1 ⇒ e ∈ CI2 .\nIt can be checked in polynomial time whether (I1, d) ≤∩Σ (I2, e).\nKonev, Ludwig, Walther, & Wolter\nThe proof is a straightforward extension of the proof of Lemma 29 and the polynomialtime algorithm deciding the existence of Σ-simulations.\nWe observe that Theorem 2 about the properties of the canonical model IK of a KB K can be extended to Cu,u-concepts (in the appendix, the proof is given for Cu,u-concepts as well). Namely, we have for all Cu,u-concepts C0:\n• K |= C0(a) if, and only if, aIK ∈ CIK0 .\n• T |= C uD v C0 if, and only if, xC,D ∈ CIK0 .\nIt follows that for any concept name A ∈ Σ, we have\nA ∈ qWtnlhsΣ (T1, T2) ⇔ (IK1 , a) 6≤∩Σ (IK2 , a),\nwhere Ki = (Ti,A) and A = {A(a)}, for i = 1, 2. We also have for every role name r ∈ Σ that\nr ∈ qWtnlhsΣ (T1, T2) ⇔ (IK1 , a) 6≤∩Σ (IK2 , a) or (IK1 , b) 6≤∩Σ (IK2 , b)\nwhere Ki = (Ti,A) and A = {r(a, b)}, for i = 1, 2. Thus, we obtain the following tractability result:\nTheorem 66. Let T1 and T2 be ELHr-terminologies and Σ a signature. Then the set qWtnlhsΣ (T1, T2) can be computed in polynomial time."
    }, {
      "heading" : "8. Implementation and Experiments",
      "text" : "In this section, we describe an experimental evaluation of the theoretical work developed above. Our experiments employ the CEX2 tool.4 In CEX2, we have implemented polynomial-time algorithms which, given acyclic ELHr-terminologies T1 and T2 and a signature Σ as input, compute witnesses for the concept difference cDiffΣ(T1, T2) and the instance difference iDiffΣ(T1, T2).5\nCEX2 is written in OCaml and the reasoner CB (Kazakov, 2009) is internally used as classification engine. In the implementation of CEX2, we have employed the algorithms developed in this paper. In more detail, for the instance difference case for acyclic ELHrterminologies T1 and T2,\n• to compute iWtnRΣ(T1, T2), CEX2 performs a straightforward comparison of the role inclusion chains entailed by the terminologies T1 and T2;\n• to compute iWtnrhsΣ (T1, T2), CEX2 uses the NotWitness algorithm in Figure 7 and then employs Theorem 48;\n• to compute iWtnlhsΣ (T1, T2), CEX2 checks for the existence of a Σ-simulation between the canonical models (Theorem 49).\n4. Available under an open-source license at http://www.csc.liv.ac.uk/~michel/software/cex2/ 5. An extended version of CEX2 computing witnesses for the query difference qDiffΣ(T1, T2) as well is\npresented by (Konev, Ludwig, & Wolter, 2012). In addition, Konev et al. describe experiments comparing query difference witnesses with concept and instance difference witnesses that are not presented in this paper.\nThe Logical Difference for the Lightweight Description Logic EL\nThe output for iWtnlhsΣ (T1, T2) is partitioned into three sets:\n• the set of left-hand atomic Σ-instance difference witnesses, iWtnlhs,AΣ (T1, T2), which is defined as the set of all concept names A ∈ Σ such that there exists an EL-concept C such that ({A(a)}, C(a)}) ∈ iDiffΣ(T1, T2) (equivalently A v C ∈ cDiffΣ(T1, T2));\n• the set of left-hand domain Σ-instance difference witnesses, iWtnlhs,domΣ (T1, T2), which is defined as the set of all role names r ∈ Σ such that there exists an EL-concept C with ({r(a, b)}, C(a)) ∈ iDiffΣ(T1, T2) (equivalently, ∃r.> v C ∈ cDiffΣ(T1, T2)); and\n• the set of left-hand range Σ-instance difference witnesses, iWtnlhs,ranΣ (T1, T2), which is defined as the set of all role names r ∈ Σ such that there exists an EL-concept C with ({r(a, b)}, C(b)) ∈ iDiffΣ(T1, T2) (equivalently, ran(r) v C ∈ cDiffΣ(T1, T2)).\nObviously, it holds that:\niWtnlhsΣ (T1, T2) = iWtn lhs,A Σ (T1, T2) ∪ iWtn lhs,dom Σ (T1, T2) ∪ iWtn lhs,ran Σ (T1, T2).\nFor the concept difference case, recall that\ncWtnRΣ(T1, T2) = iWtnRΣ(T1, T2), cWtnlhsΣ (T1, T2) = iWtnlhsΣ (T1, T2),\nand so we use the same algorithms as in the instance case. We also set\ncWtnlhs,XΣ (T1, T2) = iWtn lhs,X(T1, T2)\nfor X ∈ {A, dom, ran}. To compute iWtnrhsΣ (T1, T2), CEX2 exploits that cWtnrhsΣ (T1, T2) ⊆ iWtnrhsΣ (T1, T2) (Lemma 50) and first computes iWtnrhsΣ (T1, T2) and then checks using a straightforward variant of the NotWitness algorithm for concept differences whether A ∈ cWtnrhsΣ (T1, T2).\nIn the following three subsections we describe the experiments that we have conducted. The experimental settings were as follows. All programs were run on PCs equipped with an Intel Core 2 Duo E6400 CPU and 3 GiB of main memory. Version 2.0.1 of CEX2 was used."
    }, {
      "heading" : "8.1 Comparing Different Versions of Snomed CT",
      "text" : "We applied CEX2 to compare a January 2009 (SM09a) and a July 2009 (SM09b) version of Snomed CT. SM09a and SM09b contain 310013 and 307693 concept names, respectively. Both versions use the same 62 role names, and they contain role inclusions but no domain or range restrictions are present. Consequently, one can infer from Corollary 47 that iWtnΣ(SM09b,SM09a) = cWtnΣ(SM09b,SM09a). In what follows we consider cWtnΣ(SM09b,SM09a) only.\nFor our experiments we used signatures ranging over so called Snomed CT subsets, which are employed in the UK for the deployment of Snomed CT in specific areas. We compared SM09a with SM09b on 159 such signatures Σ by computing cWtnΣ(SM09b,SM09a) for each of these sets Σ. The considered signatures always contain all of the 62 Snomed CT role names. The comparisons which resulted in a non-empty difference are reproduced\nKonev, Ludwig, Walther, & Wolter\nin Table 2. In none of the cases, differences regarding role inclusions have been detected. In Table 2, the second column gives the number of concept names in the respective subset Σ, and the third and fifth column the number of concept witness differences. Observe that the number of differences does not correlate with the size of the considered signatures Σ, i.e. there exist signatures that are somewhat comparable in size, but induce a greatly varying number of difference witnesses (see e.g. the subsets “Diagnosis” and “Manumat”).\nIn order to determine how many difference witnesses computed by CEX2 can be obtained from a straightforward comparison of the class hierarchies already, we have also computed the sets\nclsWtnlhsΣ (SM09b,SM09a) = {A ∈ Σ | ∃B ∈ Σ: A v B ∈ cDiffΣ(SM09b, SM09a) }\nand\nclsWtnrhsΣ (SM09b,SM09a) = {B ∈ Σ | ∃A ∈ Σ: A v B ∈ cDiffΣ(SM09b, SM09a) }\nfor each of the considered comparison signatures Σ. The results that we have obtained are also depicted in Table 2. One can see that often a great number of differences cannot be detected by considering the classification difference only.\nIn the last three columns of Table 2, we give the CPU times required for computing all concept witnesses:\n• first, the times are given when CEX2 is directly applied to the full terminologies SM09a and SM09b;\n• second, the times are given when one first extracts Σ-modules using the module extraction tool MEX (Konev, Lutz, Walther, & Wolter, 2008) from SM09a and, respectively, SM09b and then applies CEX2 to the extracted Σ-modules. Observe that a Σ-module extracted by MEX is Σ-query (and, therefore, Σ-concept and Σ-instance) inseparable from the whole terminology. Thus, the computed concept witnesses are the same.\n• finally, the times are given if, in addition to computing concept witnesses from the full terminologies SM09a and SM09b, CEX2 also computes examples of concept inclusions in the logical difference that explain the witnesses. We discuss this feature of CEX2 below.\nOne can observe that extracting MEX modules leads to a significant improvement of the performance of CEX2. Of course, if the signature is very large (e.g., for “Diagnosis” and “Finding”), the resulting modules are almost as large as Snomed CT itself and the effect is less significant. Secondly, one can observe that the additional computation of example concept inclusions in the logical difference roughly doubles the times needed for the comparison.\nFinally, to evaluate the practical feasibility of using the ABox approach to compute the sets iWtnrhsΣ (SM09b,SM09a), we have implemented the computation of ABoxes AT ,Σ together with an ABox reasoning algorithm for checking the second condition of Lemma 45. We have then tested our implementation on the subsets Σ of Snomed CT used for evaluating the performance of CEX2. To limit the size of the ABoxes AT ,Σ and to speed up computations, we first computed modules using MEX. The results that we obtained are\nThe Logical Difference for the Lightweight Description Logic EL\nshown in Table 3. The size of the Σ-modules computed by MEX, i.e. T1 of SM09b and T2 of SM09a, is shown in columns two and three, respectively. As expected from the definition of AT ,Σ, one can observe that the number of concept and role membership assertions present in the ABoxes AT2,Σ can grow very large, even for modules and signatures with only a few thousand concept names.\nFor 8 of the 41 considered subsets our implementation ran out of available physical memory (indicated by a time value ‘-’) when all possible concept membership consequences of the ABox were to be computed. Overall, we observed the longest execution time of over 5 hours for the set “Specmatyp”. In conclusion, one can see that a straightforward implementation of the ABox approach is practically useful “only” for terminologies and signatures of a few thousand concept names."
    }, {
      "heading" : "8.2 Comparing Different Versions of the NCI Thesaurus",
      "text" : "We have also used the CEX2 tool to compare distinct versions of the NCI Thesaurus. Most distributed releases of the NCI Thesaurus contain language constructs which are not part of ELHr (such as disjunction and value restriction). To obtain ELHr-terminologies, we have removed all inclusions that contain a non-ELHr constructor from the original terminologies. Typically, this affected 5%-8% of the inclusions present in each of the distributed NCI versions. Most of the ELHr-versions generated in this way contain role inclusions as well as domain and range restrictions.\nSimilarly to the work of Gonçalves et al. (2011), we have compared 71 consecutive ELHr-versions of the NCI Thesaurus ranging between the versions 03.10J and 10.02d, with the exception of 05.03F and 05.04d, which could not be parsed correctly. Version 10.03h and some later versions of the NCI Thesaurus are not acyclic, and hence, they could not be handled by the CEX2 tool.\nFor any two consecutive versions NCIn and NCIn+1 within the considered range, we computed the sets cWtnΣ(NCIn+1,NCIn) and iWtnΣ(NCIn+1,NCIn) on signatures Σ = sig(NCIn) ∩ sig(NCIn+1). An overview of the set sizes for cWtnrhsΣ (NCIn+1,NCIn) and cWtnlhs,AΣ (NCIn+1,NCIn) that we obtained can be found in Figure 8. The comparisons are sorted chronologically along the x-axis according to the release dates of the NCI ontology versions, whereas the corresponding number of left-hand atomic difference witnesses or right-hand difference witnesses can be found on the y-axis. One can see the number of righthand difference witnesses remained fairly low throughout the different versions. However, occasional spikes occurred in the number of left-hand atomic difference witnesses with a maximum value of 33487 for comparing the versions 05.01d and 05.03d. Moreover, in none of the comparisons except for those shown in Figure 9 left-hand role domain or left-hand role range difference witnesses were identified. Overall, no witnesses regarding role inclusions were detected and we found that for every two considered consecutive versions NCIn and NCIn+1 on Σ = sig(NCIn) ∩ sig(NCIn+1),\ncWtnΣ(NCIn+1,NCIn) = iWtnΣ(NCIn+1,NCIn).\nA running time of 140 seconds and 228 MiB of memory were required on average for computing witnesses and example inclusions for iDiffΣ(NCIn+1,NCIn). Computing witnesses and example inclusions for cDiffΣ(NCIn+1,NCIn) on average took 157 seconds and used 228 MiB of memory.\nKonev, Ludwig, Walther, & Wolter\nThe Logical Difference for the Lightweight Description Logic EL\nKonev, Ludwig, Walther, & Wolter\nThe Logical Difference for the Lightweight Description Logic EL\nThe peaks in atomic left-hand difference witnesses mostly resulted from changes to a few very general concepts. As mentioned above already, Gonçalves et al. (2011) provide an indepth analysis of NCI versions. A systematic comparison of the methods used by Gonçalves et al. with the logical diff introduced in this paper would be very interesting, but is beyond the scope of this paper. One interesting observation that can be made is, however, that the peak of atomic left-hand witnesses that we observed between the versions 05.01d and 05.03d correlates with the fact that according to Gonçalves et al. a large number of non-redundant axioms were added to version 05.03d. However, a comparable number of non-redundant axioms were also added to version 04.12g, but no peak in atomic left-hand or right-hand witnesses was observed in our analysis."
    }, {
      "heading" : "8.3 Scalability Analysis",
      "text" : "We demonstrated in the previous sections that CEX2 is capable of finding the logical difference between two unmodified versions of Snomed CT and between distinct versions of the NCI thesaurus restricted to ELHr. In order to see how CEX2’s performance scales, we have also tested it on randomly generated acyclic terminologies of various sizes. Each randomly generated terminology contains a certain number of defined- and primitive concept names and role names. The ratio between concept equations and concept inclusions is fixed, as is the ratio between existential restrictions and conjunctions. The random terminologies were generated for a varying number of defined concept names using the parameters of SM09a: 62 role names; the equality-inclusion ratio is 0.525; and the exists-conjunction ratio is 0.304. For every chosen size, we generated 10 samples consisting of two random terminologies as described above. We then applied CEX2 to find the logical difference of the two terminologies over their joint signature. Figure 10 shows the average memory consumption of CEX2 over 10 randomly generated terminologies of various sizes. In 10(a) the maximum length of conjunctions was fixed as two (M=2), and in 10(b) the number of conjuncts in each conjunction is randomly selected between two and M. It can be seen that the performance of CEX2 crucially depends on the length of conjunctions. In 10(b), the curves break off at the point where CEX2 runs out of physical memory6. For instance, in the case of M=22, this happens for terminologies with more than 7 500 defined concept names. Finally, we note that the time required by CEX2 to compare two such random terminologies highly varied across the different samples. The maximum time required by CEX2 was 11 333 seconds."
    }, {
      "heading" : "8.4 Additional User Support for Analysing Differences",
      "text" : "So far we have discussed experiments with CEX2 in which one computes the set of concept and instance difference witnesses between two terminologies. Clearly, such witnesses do not provide sufficient information for a detailed analysis of the logical difference between two terminologies. For a more thorough analysis, it is required to consider examples α from cDiffΣ(T1, T2) and iDiffΣ(T1, T2) that show why certain concept names are concept/instance difference witnesses. Thus, whenever it searches for concept names A such that there exists a C with C v A ∈ cDiffΣ(T1, T2), CEX2 can output example concept inclusions C v A ∈ cDiffΣ(T1, T2). Similarly, if requested, CEX2 can also compute example inclusions\n6. In some cases the classification of the terminologies through CB already requires more than 3 GiB of memory.\nKonev, Ludwig, Walther, & Wolter\nillustrating left-hand concept differences A v C, ∃r.> v C, or ran(r) v C, and examples for the instance difference case. We know from Example 12 that even minimal such examples can be of exponential size in the input terminologies. In practice, however, for Snomed CT and NCI the additional computation of an example inclusion for every concept/instance difference witness “only” doubles the times required for the computation. As described above already, this can be observed in Table 2, where the computation times with examples are shown in the last column and the computation times without examples are shown in the 7th column. The examples computed by CEX2 are often of reasonable size. For instance, if we consider the subset “Specimen Material Type” (Specmatyp) from Table 2, it holds that\n(i) there exist 10 right-hand Σ-concept witnesses, i.e. |cWtnrhsΣ (SM09b,SM09a)| = 10;\n(ii) the set of left-hand atomic Σ-concept difference witnesses, cWtnlhs,AΣ (SM09b,SM09a), contains 46 concept names.\nIn Point (i) and (ii), the longest concepts C, D for C v A ∈ cDiffΣ(SM09b,SM09a) and A v D ∈ cDiffΣ(SM09b, SM09a) that were computed by CEX2 had twelve concept and role name occurrences (thus were far smaller than the exponential worst case suggests).\nHaving computed not only difference witnesses but also example concept inclusions for witnesses, it is of interest to explain why an example concept inclusion is entailed by one terminology but not the other. Computing minimal subsets of a terminology that entail an example concept inclusion is a promising approach to explaining logical differences that is also known as axiom pinpointing or justification. It is not supported by CEX2, but has been investigated extensively for various description logics including EL (Schlobach & Cornet, 2003; Baader, Peñaloza, & Suntisrivaraporn, 2007; Kalyanpur, Parsia, Horridge, & Sirin, 2007; Horridge, Parsia, & Sattler, 2010; Peñaloza & Sertkaya, 2010). To illustrate this approach, consider again the subset “Specimen Material Type” (Specmatyp) from Table 2. CEX2 outputs\nVenipunctureForBloodTest ∈ cWtnlhs,AΣ (SM09b,SM09a).\nThe Logical Difference for the Lightweight Description Logic EL\nIt also computes the following concept inclusion (slightly simplified by hand) as a member of cDiffΣ(SM09b, SM09a):\n(∗) VenipunctureForBloodTestv ∃roleGroup.∃hasFocus.EvaluationProcedure\nUsing axiom pinpointing one can then compute a minimal set of inclusions from SM09b which entails the concept inclusion above; such a set is shown in Figure 11. Axioms 2 and 3 are in both terminologies, but SM09a contains\nLaboratoryTest v LaboratoryProcedure\ninstead of Axiom 1, which explains this difference between the two terminologies. Note that concept and role names from Σ are shaded in grey. It can be seen that the interaction between Σ-concepts heavily depends on inclusions that are built up mainly from non-Σconcepts; actually none of inclusions required to derive (∗) is a Σ-inclusion.\nWe finally note that CEX2 is a text-based tool. In order to make it more accessible to ontology users, a Protégé plugin, LogDiffViz7, was created, which calls CEX2 and visualises both ontology versions and the differences as a hierarchical structure. LogDiffViz also provides basic axiom pinpointing. The plugin is distributed as a self-contained Java archive file (JAR) in which CEX2 is bundled."
    }, {
      "heading" : "9. Related Work",
      "text" : "We describe the relationship between the work presented in this paper and existing work on logical difference and inseparability of ontologies. Related work on versioning and the distinction between syntactical, structural, and logic-based approaches to versioning have been discussed in the introduction already and will not be presented again here. The problem of deciding whether two ontologies are Σ-inseparable for some signature Σ has been investigated for many ontology languages and different notions of inseparability such as concept inseparability, instance inseparability, conjunctive query inseparability, and model-theoretic inseparability (i.e., the Σ-reducts of models of the first ontology coincide with the Σ-reducts of models of the second ontology). Inseparability is also closely related to the notion of conservative extensions since one ontology is a conservative extension of another ontology if it contains the other ontology as a subset and both are inseparable w.r.t. the signature of\n7. Available at http://protegewiki.stanford.edu/wiki/Logical_Difference_Vizualiser_(LogDiffViz)\nKonev, Ludwig, Walther, & Wolter\nthe smaller ontology. Thus, algorithmic results on deciding conservativity are directly relevant for inseparability as well. The tractability results presented in this paper are in sharp contrast to most other known results. We start with general EL-TBoxes: for general ELTBoxes deciding inseparability and conservative extensions are ExpTime complete problems for concept, instance and conjunctive queries. Both problems are undecidable for modeltheoretic inseparability and model-theoretic conservative extensions (Lutz & Wolter, 2010). (We note, however, that in the model-theoretic case unexpected positive algorithmic results have been obtained in Konev, Lutz, et al., 2008, for acyclic EL and ALC and their extensions with inverse roles.) For ALC and its standard extensions without nominals deciding concept inseparability and conservative extensions is 2ExpTime-complete (Ghilardi, Lutz, & Wolter, 2006; Lutz et al., 2007; Lutz & Wolter, 2011) and for ALCQIO deciding concept inseparability and conservative extensions becomes undecidable (Lutz et al., 2007; Cuenca Grau et al., 2008). Nothing is known for ALC about the complexity of inseparability for instance and conjunctive queries. For DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, & Rosati, 2006), the complexity of concept, instance, and query inseparability ranges from PSpace-hard (and in ExpTime) for the description logic underlying the OWL 2 QL standard, NP-complete for DL-Litehorn, and Π p 2-complete for DL-Litebool (Konev, Kontchakov, Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010). For DLLitebool model-theoretic inseparability is decidable (Kontchakov et al., 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al., 2011). In contrast to the work presented in this paper, however, no attempt is made to present the logical difference to the user if two ontology are not inseparable. As mentioned above, in the work of Konev et al. (2012), CEX2 is extended to the conjunctive query difference case between acyclic ELHr-terminologies and various experiments based on the NCI thesaurus are discussed.\nThe work discussed so far is concerned with the logical difference and inseparability between description logic TBoxes. The difference between description logic concepts has been investigated, for example, in the work of Teege (1994), and of Brandt, Küsters, and Turhan (2002) but besides of the interest in some kind of difference the problems considered as well as the techniques employed are rather different. Inseparability and conservativity between ontologies given in ontology languages that are more expressive than description logics (including first-order logic) have been considered in the work of Kutz and Mossakowski (2008, 2011). Similar relationships between theories have also been investigated in answer set programming (Pearce & Valverde, 2004; Eiter, Fink, & Woltran, 2007; Pearce & Valverde, 2012).\nFinally, we note that Lemma 15 and the ABox constructed in Figure 3 appear to capture and describe fundamental properties of EL and ELHr-terminologies. Both have been applied to investigate seemingly unrelated problems such as query containment for ontology based data access using EL-terminologies (Bienvenu, Lutz, & Wolter, 2012b) and first-order rewritability of instance queries (Bienvenu, Lutz, & Wolter, 2012a)."
    }, {
      "heading" : "10. Conclusion",
      "text" : "In this paper, we have presented polytime algorithms that decide concept, instance, and query-inseparability w.r.t. a signature Σ for ELHr-terminologies and compute a represen-\nThe Logical Difference for the Lightweight Description Logic EL\ntation of the difference if it is non-empty. Experiments using CEX2 based on SNOMED CT and NCI show that the outputs given by our algorithm are mostly of reasonable size and can be analysed by users. Many extensions, applications, and open problems remain to be explored. Here we mention some of them:\n(1) We have motivated the study of Σ-inseparability between terminologies by the problem of comparing different versions of a terminology regarding “what they say” about a certain signature. Other potential and promising applications can be found in the area of decomposing and composing ontologies. For example, when importing an ontology T into an ontology T ′ (i.e., forming T ∪ T ′) it is often important to ensure that T ′ does not interfere with the signature of T . In other words, T ∪T ′ should be a conservative extension of T in the sense that the consequences of T ∪ T ′ in the signature of T should coincide with the consequences of T itself (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo, Parsia, Sattler, & Schneider, 2011). As observed above already, Σ-inseparability generalises conservative extensions and, therefore, our algorithms can be used to check whether one terminology is a conservative extension of another terminology. Algorithms checking conservative extensions can also be used to extract modules from ontologies (Cuenca Grau et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009; Konev et al., 2011). It would be of interest to explore applications of our inseparability testing algorithms to extract modules of terminologies and check conservativity.\n(2) Inseparability as defined in this paper does not mean that one terminology can be replaced by another terminology in every context. In various applications of inseparability for modularity it is important to ensure that if T1 and T2 are Σ-inseparable, then T1 ∪ T and T2 ∪ T are Σ-inseparable as well, for any ontology T . This is called the replacement property by Konev, Lutz, Walther, and Wolter (2009) and has been exploited and discussed, for example, in the work of Cuenca Grau et al. (2008) and of Kontchakov et al. (2010). The notions of inseparability introduced in this paper do not have the replacement property. To see this, let Σ = {A,A′, B,B′} and\nT1 = {\nA v ∃r.B A′ ≡ ∃r.B′\n} and T2 = { A v ∃r.B A′ v ∃r.B′ } .\nT1 and T2 are Σ-query inseparable (and, therefore, Σ-concept and Σ-instance inseparable), but T1 ∪ T is not even Σ-concept inseparable from T2 ∪ T , for T = {B v B′}. Indeed, observe that (T1 ∪ T ) |= A v A′, but (T2 ∪ T ) 6|= A v A′.\nIt is an important open research problem to determine the complexity of, and to develop algorithms for strong versions of inseparability with the replacement property for EL and ELHr-terminologies.\n(3) ELHr is a rather weak description logic. It would be of great interest to explore in how far techniques developed for ELHr can be applied to ontologies which contain additional constructors, but still consist mainly of ELHr-inclusions. It is unlikely that tractable sound and complete algorithms for interesting extensions exist, but it seems worth exploring algorithms that are sound and incomplete extensions of the algorithms presented in this paper. Some results in that direction have been presented by Gonçalves, Parsia, and Sattler (2012).\nKonev, Ludwig, Walther, & Wolter"
    }, {
      "heading" : "Acknowledgments",
      "text" : "This research was supported by EPSRC grant EP/H043594/1. We would like to thank William Gatens for the development of the LogDiffViz Protégé plugin and three anonymous reviewers for their helpful comments."
    }, {
      "heading" : "Appendix A. Proofs for Section 2",
      "text" : "Lemma 1 For every terminology T , one can construct in polynomial time a normalised terminology T ′ of polynomial size in |T | such that sig(T ) ⊆ sig(T ′), T ′ |= T , and for every model I of T there exists a model J of T ′ such that ∆I = ∆J and XI = XJ for every X ∈ sig(T ). Moreover, T ′ is acyclic if T is acyclic.\nProof. Given a terminology T , construct a normalised terminology T ′ in five steps as follows: First, remove all occurrences of > in conjunctions, and replace C in each occurrence of ∃r.C, where C is not a concept name or >, with a fresh concept name A and add the concept definition A ≡ C to the terminology. Repeat the last step exhaustively.\nSecond, replace every ∃ri.Bi in each inclusion with a right-hand side of the form F u ∃r1.B1 u · · · u ∃rm.Bm (m ≥ 1), where each Bi is either a concept name or Bi = >, and F is a conjunction of concept names such that F 6= > or m ≥ 2, with a fresh concept name B′i and add the concept definition B ′ i ≡ ∃ri.Bi to the terminology.\nThird, replace every inclusion of the form A ≡ ∃r.> with two inclusions A v ∃r.> and ∃r.> v A in the terminology.\nFourth, consider any concept name A such that there are sequences B0, . . . , Bn−1 and F0, . . . , Fn, where the Fi are conjunctions of concept names, such that the terminology contains the concept definitions A ≡ F0 and Bi ≡ Fi+1, for i < n, where Bi is a conjunct of Fi and A a conjunct of Fn. Let F ′ n be the conjunction of concept names in Fn except A. Let, recursively, F ′i−1 be the result of replacing the conjunct Bi−1 in Fi−1 with the conjunction F ′i , for 1 ≤ i ≤ n. Replace the concept definition A ≡ F0 in the terminology with the primitive concept definition A v F ′0.\nFifth, for each inclusion A ≡ F , A v F , ∃r.> v F , or ran(r) v F , where F is a conjunction of concept names, replace every conjunct B in F for which there is a B ≡ F ′ in the terminology, where F ′ is a conjunction of non-conjunctive concept names, with F ′.\nTo see that the construction indeed yields a normalised terminology T ′, observe that the steps 1, 2, and 3 ensure that each inclusion has one of the following forms: A ≡ ∃r.B, A ≡ F , E v ∃r.B, E v ∃r.>, or E v F , where B is a concept name, E is either a concept name, or is of the form ∃s.>, or ran(s), and F is a conjunction of (possibly conjunctive) concept names. Step 4 breaks cycles in concept definitions and Step 5 takes care that all conjuncts of the conjunction of concept names F in the right-hand side of each inclusion of the form A ≡ F , A v F , ∃r.> v F , or ran(r) v F are non-conjunctive concept names. It is readily verified that T ′ is acyclic if T is acyclic as none of the above steps introduces cycles in concept definitions.\nWe now show that T ′ can be obtained in polynomial time and that T ′ is of polynomial size in |T |. Let n be the number of inclusions in T and c the maximal length of an inclusion’s right-hand side in T . Clearly, the steps 1, 2 and 3 each do not increase the number of inclusions by more than c ·n, raising the total number of inclusions to at most 4nc. Steps 4\nThe Logical Difference for the Lightweight Description Logic EL\nand 5 do not increase the number of inclusions, but the length of their right-hand sides. The length of the right-hand side of an inclusion can increase to at most the sum of the lengths of the right-hand sides of all inclusions, i.e., 4nc2 is an upper bound for each right-hand side. The upper bound of the running time for each of the steps in the construction is therefore 16n2c3. Hence, the size of T ′ and the running time of the construction are both in O(n2 · c3).\nNotice that every new concept name occurs on the left-hand side of a unique concept definition A ≡ C in T ′. Thus, every model I of T can be expanded to a model J of T ′ by interpreting the fresh concept names in sig(T ′) \\ sig(T ) by setting AJ = CI .\nMoreover, it is readily checked that T ′ |= T .\nWe prove an extended version of Theorem 2 according to which not only EL-concepts and concepts of the form ran(r) are evaluated “correctly” in the canonical model IK, but also Cu,u-concepts (which are introduced in Definition 57).\nTheorem 2[Extended Version] Let K = (T ,A) be an ELHr-KB. Then\n1. IK is a model of K;\n2. IK can be computed in polynomial time in the size of K;\n3. for all xC,D ∈ ∆IK and all a ∈ obj(A), if C0 is a Cu,u-concept or of the form ran(r), then\n• K |= C0(a) if, and only if, aIK ∈ CIK0 . • T |= C uD v C0 if, and only if, xC,D ∈ CIK0 .\nProof. Point 2 follows from the fact that instance checking in ELHr can be done in polynomial time.\nWe first prove Point 3 for EL-concepts C0 ∈ sub(T ). The proof is by simultaneous induction on the construction of C0. The interesting step is for C0 = ∃r.D0.\nWe start with the proof of the direction from left to right. Assume first that K |= C0(a). Then (a, xran(r),D0) ∈ rIK . We have T |= (ran(r) u D0) v D0. Thus, by the induction hypothesis, xran(r),D0 ∈ D IK 0 . But then a ∈ C IK 0 , as required. Now assume T |= CuD v C0. Then (xC,D, xran(r),D0) ∈ rIK . We have T |= (ran(r) u D0) v D0. By the induction hypothesis, xran(r),D0 ∈ D IK 0 . But then xC,D ∈ C IK 0 , as required.\nConversely, assume that aIK ∈ CIK0 . There exists d ∈ ∆IK such that (aIK , d) ∈ rIK and d ∈ DIK0 . Assume first that d = b ∈ obj(A). By the induction hypothesis, K |= D0(b). There exists s such that s(a, b) ∈ A and s vT r. Thus, K |= C0(a), as required. Assume now that d = xran(s),F . Then K |= ∃s.F (a), s vT r and xran(s),F ∈ DIK0 . By the induction hypothesis, T |= ran(s) u F v D0. Thus, K |= C0(a), as required.\nNow assume xC,D ∈ CIK0 . There exists xran(s),F with T |= C uD v ∃s.F , s vT r and xran(s),F ∈ DIK0 . By the induction hypothesis, T |= ran(s) u F v D0. Thus T |= C uD v ∃r.D0, as required.\nWe now prove Point 3 for concepts of the form C0 = ran(r). Assume K |= (ran(r))(a). Then there exist b and s with s(b, a) ∈ A and s vT r. But then a ∈ ran(r)IK . Conversely,\nKonev, Ludwig, Walther, & Wolter\nassume that a ∈ ran(r)IK . Then, by definition of IK, there exist b and s with s(b, a) ∈ A and s vT r. Hence K |= (ran(r))(a), as required.\nAssume T |= C u D v ran(r). Then we have, for C = ran(s), s vT r. Then xC,D ∈ ran(r)IK since there is a path in WK with tail xC,D. The converse direction is similar.\nIt follows from what has been proved so far that IK is a model of (T ,A). Thus we have proved Point 1, and it remains to prove Point 3.\nWe prove Point 3 for arbitrary Cu,u-concepts C0. The interesting step is for C0 = ∃S.D0, where S = r1 u · · · u rn.\nAssume first that K |= C0(a). Then a ∈ CIK0 since IK is a model of K. Similarly, if T |= C uD v C0, then xC,D ∈ CIK0 since xC,D ∈ (C uD)IK and IK is a model of T .\nConversely, assume that a ∈ CIK0 . There exists d ∈ ∆IK such that (aIK , d) ∈ SIK and d ∈ DIK0 . Assume first that d = b ∈ obj(A). By the induction hypothesis, K |= D0(b). For every ri, 1 ≤ i ≤ n, there exists si with si(a, b) ∈ A and si vT ri. Thus, K |= C0(a), as required.\nAssume now that d = xran(s),F . Then K |= ∃s.F (a), s vT ri for 1 ≤ i ≤ n and xran(s),F ∈ DIK0 . By the induction hypothesis, T |= ran(s) u F v D0. Thus, K |= C0(a), as required.\nNow assume xC,D ∈ CIK0 . There exists xran(s),F with T |= C u D v ∃s.F , s vT ri, 1 ≤ i ≤ n, and xran(s),F ∈ DIK0 . By the induction hypothesis, T |= ran(s) u F v D0. Thus T |= C uD v ∃S.D0, as required."
    }, {
      "heading" : "Appendix B. Proofs for Section 5",
      "text" : "In some proofs, we require models for infinite sets of concepts. We introduce some notation and a well known result about the existence of “minimal” models. Let Γ be a (possibly infinite) set of Cran-concepts (which are introduced in Definition 32), T an ELHr-TBox, and D either a Cu,u-concept (which are introduced in Definition 57) or a Cran-concept. We write T ∪Γ |= D and say that Γ is included in D w.r.t. T if, for every model I of T and d ∈ ∆I , d ∈ DI follows from d ∈ CI for all C ∈ Γ. The following observation follows from the fact that all Cu,u and Cran-concepts are equivalent to Horn formulas (in the sense of Chang and Keisler, 1990):\nLemma 67. For all ELHr-TBoxes T and sets Γ of Cran-concepts there exists a model I of T and d ∈ ∆I such that the following are equivalent, for all Cu,u ∪ Cran-concepts D:\n• T ∪ Γ |= D;\n• d ∈ DI .\nWe now come to the proof of Lemma 36. For the convenience of the reader we formulate the result again.\nLemma 36. For every ELHr-TBox T , ABox A, and all Cran-concepts C0 and D0, and a0 ∈ obj(A):\n• (T ,A) |= D0(a0) if, and only if, there exists n ≥ 0 such that T |= Cn,ranA,a0 v D0;\nThe Logical Difference for the Lightweight Description Logic EL\n• T |= C0 v D0 if, and only if, (T ,AC0) |= D0(aC0).\nProof. We prove Point 1. For the direction from right to left observe that A |= Cn,ranA,a0 (a0) for all n ≥ 0. Thus, T |= Cn,ranA,a0 v D0 implies (T ,A) |= D0(a0).\nNow assume (T ,A) |= D0(a0). We show that T ∪CranA,a0 |= D0. Then, using compactness, we find an n ≥ 0 such that T |= Cn,ranA,a0 v D0, as required.\nAssume T ∪ CranA,a0 6|= D0. Take, for every a ∈ obj(A), a model Ia of T with a point da ∈ ∆Ia such that for all Cran-concepts C: da ∈ CIa if, and only if, T ∪ CranA,a |= C. Such models exist by Lemma 67. We may assume that they are mutually disjoint. Take the following union I of the models Ia:\n• ∆I = ⋃ a∈obj(A) ∆ Ia ;\n• AI = ⋃ a∈obj(A)A Ia , for A ∈ NC;\n• rI = ⋃ a∈obj(A) r Ia ∪ {(da, db) | r′(a, b) ∈ A, r′ vT r}, for r ∈ NR;\n• aI = da, for a ∈ obj(A).\nClaim 1. For all Cran-concepts C and all a ∈ obj(A) the following holds for all d ∈ ∆Ia :\nd ∈ CIa iff d ∈ CI .\nThe proof is by induction on the construction of C. The interesting cases are C = ran(r) and C = ∃r.D and the direction from right to left.\nLet d ∈ CI and assume first that C = ran(r). Let d ∈ CI ∩∆Ia and (d′, d) ∈ rI . For (d′, d) ∈ ⋃ a∈obj(A) r Ia , the claim follows from the definition. Otherwise, d = da, d ′ = db for some b with r′(b, a) ∈ A and r′ vT r. Thus, ran(r′) ∈ Cn,ranA,a for every n ≥ 0. Hence, T ∪ CranA,a |= ran(r) and we obtain d ∈ CIa .\nAssume now that C = ∃r.D and d ∈ CI ∩∆Ia . Take d′ with (d, d′) ∈ rI and d′ ∈ DI . For (d, d′) ∈ ⋃ a′∈obj(A) r\nIa′ , d ∈ CIa follows immediately from the induction hypothesis. Otherwise, d = da and d ′ = db for some b with r ′(a, b) ∈ A and r′ vT r. By the induction hypothesis, d′ ∈ DIb . Hence, T ∪CranA,b |= D. By compactness, there exists a concept E ∈ CranA,b such that T |= E v D. From r′(a, b) ∈ A, we obtain ∃r′.E ∈ Cn,ranA,a for every n > 0. But then, T ∪ CranA,a |= ∃r′.D and we obtain da ∈ CIa using r′ vT r. This finishes the proof of the claim.\nNow, for C v D ∈ T , let d ∈ ∆I with d ∈ CI , i.e. d ∈ ∆Ia for some a ∈ obj(A). By Claim 1 we have d ∈ CIa , which implies that d ∈ DIa as CIa ⊆ DIa . We can conclude that d ∈ DI by applying Claim 1 again. Similarly, one can show that CI = DI for every C ≡ D ∈ T and rI ⊆ sI for every r v s ∈ T . It follows that I is a model of T . By construction of I, we have (aI , bI) ∈ rI for every r(a, b) ∈ A. Moreover, for A(a) ∈ A with a ∈ obj(A), it holds that T ∪ CranA,a |= A, which implies that da ∈ AIa and aI ∈ AI by our claim. We can thus infer that I is a model of (T ,A) and I 6|= D0(a0) as T ∪ CranA,a0 6|= D0, which implies that da0 6∈ D Ia0 0 and a I 0 6∈ DI0 , by Claim 1. Hence, (T ,A) 6|= D0(a0) and we have derived a contradiction. The proof of Point 2 is a simple application of the definition.\nKonev, Ludwig, Walther, & Wolter\nNow we prove cut elimination, correctness, and completeness of the calculus for ELHr given in Figures 1 and 5. We start with some basic observations, which can be easily proved by induction on the length of derivations.\nLemma 68. For any ELHr-terminology T , Cran-concepts C, D and any role names r, s we have\n1. if T ` > v D, then T ` C v D;\n2. if T ` C v A and A v CA ∈ T or A ≡ CA ∈ T , then T ` C v CA;\n3. if T ` C v ∃r.D then T ` C v ∃r.(D u ran(r));\n4. if T ` C v ∃r.D, and ∃r.> v B ∈ T , then T ` C v B;\n5. if T ` C v ran(r) and ran(r) v A ∈ T , then T ` C v A;\n6. if T ` C v ∃r.D, and r v s ∈ T , then T ` C v ∃s.D;\n7. if T ` C v ran(r) and r v s ∈ T , then T ` C v ran(s).\nLemma 69 (Cut elimination). For any ELHr-terminology T , Cran-concepts C, D, and E, if T ` C v D and T ` D v E then T ` C v E.\nProof. Let D1 be the derivation of C v D and D2 be the derivation of D v E. Let Li be the length of Di, i = 1, 2. The proof of the lemma is by induction on the lexicographical ordering on pairs (L2, L1).\nThe case when L2 = 0 or L1 = 0, as well as the cases when L2 ends with one of AndL1, AndL2, AndR, Ex, DefL, DefR or PDefL are virtually the same as in the proof of Hofmann (2005). Assume D2 ends with Dom, and so its last sequent is of the form ∃r.D′ v E, and the sequent above it is B v E. By Lemma 68, Item 4, T ` C v ∃r.D′ implies T ` C v B, so by the induction hypothesis, T ` C v E.\nThe cases when D2 ends with ExRan, Ran, Sub, or RanSub can be dealt with in the similar way using Lemma 68, Items 3, 5–7.\nTheorem 38. Let T be an ELHr-terminology; C0 and D0 be Cran-concepts. Then T |= C0 v D0 if, and only if, T ` C0 v D0.\nProof. It can be easily checked that the proof system rules are sound and so if T ` C0 v D0, then T |= C0 v D0.\nConversely, assume that T |= C0 v D0. To prove T ` C0 v D0 we construct an interpretation I based on the derivability of sequents from T . We show that I is a model of T . As a consequence we obtain CI0 ⊆ DI0 and conclude that T ` C0 v D0 based on the properties of I.\nThe domain ∆I is the set of all well-formed pairs x = 〈C,RC〉, where C is a Cran-concept and RC is a finite set of role names such that\n∀s ∈ NR : if T ` (C u l\nr∈RC\nran(r)) v ran(s), then s ∈ RC .\nThe Logical Difference for the Lightweight Description Logic EL\nWe introduce the following abbreviation. Let\nRan(RC) = l\nr∈RC\nran(r).\nCran-concepts C are interpreted as\nI(C) = {〈D,RD〉 ∈ ∆I | T ` (D u Ran(RD)) v C},\nand r ∈ NR are interpreted as\nI(r) = {(〈C,RC〉 , 〈D,RD〉) ∈ ∆I ×∆I | r ∈ RD and T ` (C u Ran(RC)) v ∃r.(D u Ran(RD))}.\nNote that I(C) is nonempty for every C: consider R0C = {s ∈ NR | T ` C v ran(s)}. As T is finite, R0C is finite. Notice that, by Ax and AndR, T ` C v C u Ran(R0C) so, by Lemma 69, if T ` (Cu\nd r∈R0C\nran(r)) v ran(s), for some s, then T ` C v ran(s), so s ∈ R0C . That is, 〈 C,R0C 〉 is a well-formed pair and, obviously, 〈 C,R0C 〉 ∈ I(C).\nWe now show that I(C) = CI for all Cran-concepts C. The proof is by induction on the construction of C. 1. I(>) = ∆I . For any well-formed pair 〈C,RC〉, T ` C u Ran(RC) v > is an axiom. 2. I(C uD) = I(C) ∩ I(D). Let 〈C,RC〉 ∈ I(D1uD2), that is T ` (C uRan(RC)) v (D1uD2). Since T ` (D1uD2) v D1, by Lemma 69, we have T ` (C u Ran(RC)) v D1, that is, 〈C,RC〉 ∈ I(D1). Similarly, 〈C,RC〉 ∈ I(D2).\nConversely, suppose 〈C,RC〉 ∈ I(D1) and 〈C,RC〉 ∈ I(D2) holds, that is, T ` (C u Ran(RC)) v D1 and T ` (CuRan(RC)) v D2. By AndR, T ` (CuRan(RC)) v (D1uD2), that is, 〈C,RC〉 ∈ I(D1 uD2). 3. I(∃r.C) = {x ∈ ∆I | ∃y ∈ I(C) : (x, y) ∈ I(r)}. Suppose for some well-formed pair 〈D,RD〉 we have 〈D,RD〉 ∈ I(∃r.C), that is T ` (DuRan(RD)) v ∃r.C. Then, by Lemma 68, Item 3, T ` (DuRan(RD)) v ∃r.(Cu ran(r)). Consider RrC = {s ∈ NR | T ` (C u ran(r)) v ran(s)}. Clearly, r ∈ RrC and, similarly to the argument for R0C above, 〈C,RrC〉 is a well-formed pair. By Ax and AndR, T ` Curan(r) v CuRan(RrC), by Ex, T ` ∃r.(Curan(r)) v ∃r.(CuRan(RrC)) and by Lemma 69, T ` (D u Ran(RD)) v ∃r.(C u Ran(RrC)). Then, by definition, (〈D,RD〉 , 〈C,RrC〉) ∈ I(r) and, since T ` (C u Ran(RrC)) v C, we have 〈C,RrC〉 ∈ I(C).\nConversely, let (〈D1,RD1〉 , 〈D2,RD2〉) ∈ I(r) and 〈D2,RD2〉 ∈ I(C), that is, T ` (D1u Ran(RD1)) v ∃r.(D2uRan(RD2)), r ∈ RD2 , and T ` (D2uRan(RD2)) v C. By Ex we have T ` ∃r.(D2uRan(RD2)) v ∃r.C, and, by Lemma 69, we have T ` (D1uRan(RD1)) v ∃r.C, that is, 〈D1,RD1〉 ∈ I(∃r.C). 4. I(ran(r)) = {y ∈ ∆I | ∃x : (x, y) ∈ I(r)}. First we show that I(ran(r)) = {〈C,RC〉 ∈ ∆I | r ∈ RC}. If r ∈ RC , we have T ` C u Ran(RC) v ran(r), that is, I(ran(r)) ⊇ {〈C,RC〉 ∈ ∆I | r ∈ RC}. Suppose 〈C,RC〉 ∈ I(ran(r)), that is, T ` (C u Ran(RC)) v ran(r). Then, since 〈C,RC〉 is a well-formed pair, r ∈ RC , that is, I(ran(r)) ⊆ {〈C,RC〉 ∈ ∆I | r ∈ RC}.\nKonev, Ludwig, Walther, & Wolter\nSuppose now that 〈C,RC〉 ∈ I(ran(r)), that is, 〈C,RC〉 is such that r ∈ RC . Let D denote (CuRan(RC)). By induction on the length of derivations one can see that a sequent of the form ∃r.D v ran(s) is not derivable for any s ∈ NR. Therefore, 〈∃r.D, ∅〉 is a wellformed pair and (〈∃r.D, ∅〉 , 〈C,RC〉) ∈ I(r). Conversely, let (〈D1,RD1〉 , 〈D2,RD2〉) ∈ I(r) then, in particular, r ∈ RD2 . That is, 〈D2,RD2〉 ∈ I(ran(r)).\nNow we show that I is a model of T . We need to show that all axioms of T are true in I. 1. I(X) ⊆ I(CX), whenever X ≡ CX ∈ T or X v CX ∈ T . Let 〈C,RC〉 ∈ I(X), that is, T ` (C u Ran(RC)) v X. By Lemma 68, Item 2, T ` (C u Ran(RC)) v CX , that is, 〈C,RC〉 ∈ I(CX). 2. I(CX) ⊆ I(X), whenever X ≡ CX ∈ T . Let 〈C,RC〉 ∈ I(CX), that is, T ` (C u Ran(RC)) v CX . Since by Ax and DefR T ` CX v X, by Lemma 69, T ` (C u Ran(RC)) v X, that is 〈C,RC〉 ∈ I(X). 3. (x, y) ∈ I(r)⇒ y ∈ I(A), whenever ran(r) v A ∈ T . Let (〈C,RC〉 , 〈D,RD〉) ∈ I(r), that is, T ` (C u Ran(RC)) v ∃r.(D u Ran(RD)) and r ∈ RD. Since r ∈ RD and, as, by Ax and Ran, T ` ran(r) v A, by AndL1, AndL2 we have T ` (D u Ran(RD)) v A, that is, 〈D,RD〉 ∈ I(A). 4. (x, y) ∈ I(r)⇒ x ∈ I(B), whenever ∃r.> v B ∈ T . Let (〈C,RC〉 , 〈D,RD〉) ∈ I(r), that is, T ` (C u Ran(RC)) v ∃r.(D u Ran(RD)) and r ∈ RD. Notice that, by Lemma 68, Item 4, we have T ` (C u Ran(RC)) v B, that is, 〈C,RC〉 ∈ I(B). 5. I(s) ⊆ I(r), whenever s v r ∈ T . Let (〈C,RC〉 , 〈D,RD〉 ∈ I(r)), that is T ` (CuRan(RC)) v ∃r.(DuRan(RD)) and r ∈ RD. By Lemma 68, Item 6, T ` (C u Ran(RC)) v ∃s.(D u Ran(RD)). Since r v s ∈ T , by Ax and RanSub, T ` ran(r) v ran(s) and T ` (D u Ran(RD)) v ran(s) by AndL1 and AndL2. Since 〈D,RD〉 is well-formed, s ∈ RD. Thus, (〈C,RC〉 , 〈D,RD〉) ∈ I(s)\nAs T |= C0 v D0, we have I(C0) ⊆ I(D0). Since 〈 C0,R0C0 〉 ∈ I(C0), we have〈\nC0,R0C0 〉 ∈ I(D0), that is T ` (C0 u Ran(R0C0)) v D0. As T ` C0 v C0 u Ran(R 0 C0\n), we have T ` C0 v D0 by Lemma 69.\nProof of Lemma 44. Let T be a normalised ELHr-terminology and Σ a signature. Additionally, let A be a Σ-ABox, A ∈ sig(T ) ∪ Σ non-conjunctive in T and a ∈ obj(A).\nFor the direction “(1.) ⇒ (2.)”, it is a direct consequence of the construction of AT ,Σ that for all b ∈ obj(A) and B ∈ sig(T ) ∪ Σ non-conjunctive in T if (T ,A) 6|= B(b) then ξB ∈ obj(AT ,Σ). Assume that (T ,A) 6|= A(a). Then ξA ∈ obj(AT ,Σ). We now define a Σ-range simulation S by setting,\n• for b ∈ obj(A) and for B ∈ sig(T ) ∪ Σ non-conjunctive in T with ξB ∈ obj(AT ,Σ) : (b, ξB) ∈ S if, and only if, (T ,A) 6|= B(b),\n• (b, ξΣ) ∈ S for all b ∈ obj(A).\nWe show that S is indeed a Σ-range simulation with (a, ξA) ∈ S by verifying that the conditions (S1)–(S3) and (RS) introduced on page 663 hold.\nThe Logical Difference for the Lightweight Description Logic EL\n(S1) As (T ,A) 6|= A(a) and ξA ∈ obj(AT ,Σ), it immediately follows that (a, ξA) ∈ S.\n(S2) Let now (b, ξ) ∈ S and B̃(b) ∈ A with B̃ ∈ Σ. We have to prove that B̃(ξ) ∈ AT ,Σ. For ξ = ξB with B ∈ sig(T ) ∪ Σ non-conjunctive in T , we obtain from the definition of S that (T ,A) 6|= B(b). Moreover, it holds that B̃ 6∈ preCΣT (B) as otherwise (T ,A) |= B(b). Thus, by the definition of AT ,Σ(B) we have B̃(ξB) ∈ AT ,Σ. For ξ = ξΣ, it immediately follows that B̃(ξΣ) ∈ AT ,Σ by the definition of AT ,Σ.\n(S3) Now, let (b, ξ) ∈ S and r(b, b′) ∈ A with r ∈ Σ. We have to prove that there exists ξ′ ∈ obj(AT ,Σ) with (b′, ξ′) ∈ S and r(ξ, ξ′) ∈ AT ,Σ. For ξ = ξΣ, it immediately follows from the definition of AT ,Σ that r(ξΣ, ξΣ) ∈ AT ,Σ and (b′, ξΣ) ∈ S holds by the definition of S.\nFor ξ = ξB with B ∈ sig(T ) ∪ Σ non-conjunctive in T it follows from the definition of S that (T ,A) 6|= B(b). Additionally, we can infer that r 6∈ preDomΣT (B) as otherwise (T ,A) |= (∃r.>)(b) would imply that (T ,A) |= B(b).\nConsider cases how B is defined in T . If B is pseudo-primitive in T , we obtain from the definition of AT ,Σ(B) that r(ξB, ξΣ) ∈ AT ,Σ and it holds that (b′, ξΣ) ∈ S by the definition of S.\nFor B ≡ ∃r′.B′ ∈ T , we have to distinguish between the following two cases. If r 6∈ preRoleΣT (r\n′), we obtain r ∈ Σ \\ (preRoleΣT (r′) ∪ preDomΣT (B)) and thus r(ξB, ξΣ) ∈ AT ,Σ by the definition of AT ,Σ and it holds again that (b′, ξΣ) ∈ S by the definition of S. In the case where r ∈ preRoleΣT (r′), we have r ∈ preRoleΣT (r′) \\ preDomΣT (B). Furthermore, as (T ,A) 6|= B(b) and so (T ,A) 6|= (∃r′.B′)(b), it is easy to see that there must exist B′′i ∈ non-conjT (B′) with r 6∈ preRanΣT (B′′i ) and (T ,A) 6|= B′′i (b′). Then we have r(ξB, ξB′′i ) ∈ AT ,Σ by the definition of AT ,Σ(B) and (b′, ξB′′i ) ∈ S by the definition of S.\n(RS) Let now (b, ξ) ∈ S such that r(c, b) ∈ A for r ∈ Σ. We have to show that there exists ξ′ with r(ξ′, ξ) ∈ AT ,Σ. For ξ = ξB with B ∈ sig(T ) ∪ Σ non-conjunctive in T , we obtain again from the definition of S that (T ,A) 6|= B(b). Furthermore, we have r 6∈ preRanΣT (B) as otherwise (T ,A) |= B(b). Thus, by the definition of AT ,Σ(B) we have r(ξΣ, ξB) ∈ AT ,Σ. For ξ = ξΣ, it follows by the definition of AT ,Σ that r(ξΣ, ξΣ) ∈ AT ,Σ.\nFor the converse direction “(2.) ⇒ (1.)”, we assume that ξA ∈ obj(AT ,Σ) and (A, a) ≤ranΣ (AT ,Σ, ξA). It is then sufficient to show for all n that\nT 6|= Cn,ranAT ,Σ,ξA v A\nas this implies that (T ,AT ,Σ) 6|= A(ξA) by Lemma 36. We then obtain from Lemma 42 that (T ,A) 6|= A(a) holds.\nThus, we now prove by induction on n that for every concept name B ∈ sig(T ) ∪ Σ non-conjunctive in T with ξB ∈ obj(AT ,Σ), we have T 6|= Cn,ranAT ,Σ,ξB v B.\nLet n = 0 and B ∈ sig(T )∪Σ non-conjunctive in T with ξB ∈ obj(AT ,Σ). It then follows that\nC0,ranAT ,Σ,ξB = l\nB′∈Σ\\preCΣT (B)\nB′ u l\ns∈Σ\\preRanΣT (B)\nran(s) u l\nÃ≡∃r̃.B̃∈T B∈non-conjT (B̃)\ns∈preRoleΣT (r̃)\\(preDom Σ T (Ã)∪preRan Σ T (B))\nran(s)\nKonev, Ludwig, Walther, & Wolter\nHence, one can see that for every subconcept of the form ran(s) that occurs in C0,ranAT ,Σ,ξB , we obtain that s 6∈ preRanΣT (B). As B it non-conjunctive in T , it holds that either B is pseudo-primitive in T or that B ≡ ∃r′.B′ ∈ T . Hence, by Lemma 39 we can conclude that T 6|= C0,ranAT ,Σ,ξB v B.\nFor n > 0, let again B ∈ sig(T )∪Σ non-conjunctive in T with ξB ∈ obj(AT ,Σ). We then distinguish between the following two cases. If B is pseudo-primitive in T , we obtain\nCn,ranAT ,Σ,ξB = l\nB′∈Σ\\preCΣT (B)\nB′ u l\ns∈Σ\\preRanΣT (B)\nran(s) u l\nÃ≡∃r̃.B̃∈T B∈non-conjT (B̃)\ns∈preRoleΣT (r̃)\\(preDom Σ T (Ã)∪preRan Σ T (B))\nran(s)\nu l\ns∈Σ\\preDomΣT (B)\n∃s.Cs\nfor Cran-concepts Cs. It follows again from Lemma 39 that T 6|= Cn,ranAT ,Σ,ξB v B. For B ≡ ∃r′.B′, we obtain\nCn,ranAT ,Σ,ξB = l\nB′∈Σ\\preCΣT (B)\nB′ u l\ns∈Σ\\preRanΣT (B)\nran(s) u l\nÃ≡∃r̃.B̃∈T B∈non-conjT (B̃)\ns∈preRoleΣT (r̃)\\(preDom Σ T (Ã)∪preRan Σ T (B))\nran(s)\nu l\ns∈Σ\\(preRoleΣT (r′)∪preDom Σ T (B))\n∃s.Cs u l\nB′′∈non-conjT (B′) s∈preRoleΣT (r′)\\(preDom Σ T (B)∪preRan Σ T (B ′′))\n∃s.Cn−1,ranAT ,Σ,ξB′′\nfor Cran-concepts Cs. It is easy to see that the conditions (e2), (e3) and (e4) of Lemma 39 do not hold. Thus, for T |= Cn,ranAT ,Σ,ξB v B to hold, condition (e1) would have to be fulfilled. We observe that for every subconcept ∃s.Cn−1,ranAT ,Σ,ξB′′ of C n,ran AT ,Σ,ξB with B\n′′ ∈ non-conjT (B′) and s ∈ preRoleΣT (r′) \\ (preDomΣT (B) ∪ preRanΣT (B′′)), we obtain T 6|= C n−1,ran AT ,Σ,ξB′′\nv B′′ from the induction hypothesis. Thus, we have T 6|= Cn−1,ranAT ,Σ,ξB′′ u ran(s) v B ′ by Lemma 39 for every such B′′ and s. We can infer that condition (e1) does not hold and, therefore, T 6|= Cn,ranAT ,Σ,ξB v B."
    }, {
      "heading" : "Appendix C. Proofs for Section 6",
      "text" : "Proof of Lemma 54. Let T be a normalised ELHr-terminology and Σ a signature such that Σ ∩ NR 6= ∅. Additionally, let A ∈ NC be a concept name that is non-conjunctive in T , let r ∈ Σ be a role name, and let C be an ELΣ-concept. Finally, let D = C or D = ran(r) u C.\nFirst observe that we obtain from Lemma 36 that T 6|= D v A holds if, and only if, (T ,AD) 6|= A(aD). Additionally, by Lemma 44, we have (T ,AD) 6|= A(aD) if, and only if, ξA ∈ obj(AT ,Σ) and (AD, aD) ≤ranΣ (AT ,Σ, ξA). Thus, it is sufficient to show the following equivalence:\n(AD, aD) ≤ranΣ (AT ,Σ, ξA) ⇔ ∃ r ∈ Σ: (ξA)r ∈ obj(A T ,Σ) and (AD, aD) ≤ranΣ (A T ,Σ, (ξA)r)\nThe Logical Difference for the Lightweight Description Logic EL\nNext note that the ABox AD is role-splitting as C is an EL-concept and if D = ran(r)uC, then { s(b, aD) ∈ AD | b ∈ obj(AD), s ∈ sig(AD) } = {r(aran, aD)}.\nAssume first ξA ∈ obj(AT ,Σ), (AD, aD) ≤ranΣ (AT ,Σ, ξA) and let S ⊆ obj(AD)×obj(AT ,Σ) be the corresponding Σ-range simulation. We define a relation S∗ ⊆ obj(AD) × obj(A T ,Σ) by setting for every a ∈ obj(AD), every ξ ∈ obj(AT ,Σ) and every role name r ∈ Σ such that ξr ∈ obj(A T ,Σ):\n(a, ξr) ∈ S∗ ⇔ (a, ξ) ∈ S and if s(c, a) ∈ AD for some s ∈ sig(AD) and c ∈ obj(AD), then s = r\nNote that S∗ is well-defined as AD is role-splitting. To show that S∗ is a Σ-range simulation such that there exists r ∈ sig(AΣ,T ) with (ξA)r ∈ obj(A T ,Σ) and (aD, (ξA)r) ∈ S∗, we prove that the conditions (S1)–(S3) and condition (RS) from page 663 hold.\n(S1) If there exists s(c, aD) ∈ AD for some s ∈ sig(AD) ⊆ Σ and c ∈ obj(AD), then there exists ξ′ ∈ obj(AT ,Σ) with s(ξ′, ξA) ∈ AT ,Σ as (aD, ξA) ∈ S and S is a Σ-range simulation, i.e. s((ξ′)s, (ξA)s) ∈ A T ,Σ and (ξA)s ∈ obj(A T ,Σ). Hence, (aD, (ξA)s) ∈ S∗.\nOtherwise, it is easy to see that there exists r ∈ Σ with (ξA)r ∈ obj(A T ,Σ) as ξA ∈ obj(AT ,Σ) and sig(AT ,Σ) ⊆ Σ. Thus, as (aD, ξA) ∈ S, we have (aD, (ξA)r) ∈ S∗.\n(S2) Let (a, ξr) ∈ S∗ and A(a) ∈ AD for a ∈ obj(AD), ξ ∈ obj(AT ,Σ), A ∈ Σ and r ∈ sig(AT ,Σ). It follows from the definition of S∗ that (a, ξ) ∈ S. Hence, as S is a Σ-range simulation, we have A(ξ) ∈ AT ,Σ, which implies that A(ξr) ∈ A T ,Σ by the definition of A T ,Σ.\n(S3) Let (a, ξr) ∈ S∗ and s(a, a′) ∈ AD for a, a′ ∈ obj(AD), ξ ∈ obj(AT ,Σ), r ∈ sig(AT ,Σ) and s ∈ Σ. From the definition of S∗ we obtain (a, ξ) ∈ S. Additionally, as S is a Σ-range simulation, there exists ξ′ ∈ obj(AT ,Σ) such that (a′, ξ′) ∈ S and s(ξ, ξ′) ∈ AT ,Σ. Thus, we have s(ξr, ξ ′ s) ∈ A T ,Σ by the definition of A T ,Σ and (a′, ξ′s) ∈ S∗ by the definition of S∗ as AD is role-splitting.\n(RS) Let (a, ξr) ∈ S∗ and s(c, a) ∈ AD for a, c ∈ obj(AD), ξ ∈ obj(AT ,Σ), r ∈ sig(AT ,Σ) and s ∈ Σ. By the definition of S∗, (a, ξ) ∈ S holds and r = s. As S is a Σ-range simulation, there exists ξ′ ∈ obj(AT ,Σ) with s(ξ′, ξ) = r(ξ′, ξ) ∈ AT ,Σ. Hence, r(ξ′r, ξr) ∈ A T ,Σ holds by the definition of A T ,Σ.\nFor the converse direction, we assume that there exists r̃ ∈ Σ such that (ξA)r̃ ∈ obj(A T ,Σ) and (AD, aD) ≤ranΣ (A T ,Σ, (ξA)r̃) holds. Let S∗ ⊆ obj(AD)×obj(A T ,Σ) be the corresponding Σ-range simulation. We define a relation S ⊆ obj(AD) × obj(AT ,Σ) by setting for every a ∈ obj(AD) and every ξ ∈ obj(AT ,Σ):\n(a, ξ) ∈ S ⇔ ∃ r ∈ sig(AT ,Σ) : (a, ξr) ∈ S∗.\nIt is straightforward to verify that ξA ∈ obj(AT ,Σ) and that S is a Σ-range simulation with (aD, ξA) ∈ S.\nKonev, Ludwig, Walther, & Wolter"
    }, {
      "heading" : "Appendix D. Proofs for Section 7",
      "text" : "Proof of Lemma 60. We require some preliminary observations. Let AC be the ABox associated with a Cran-concept C (Lemma 36). Then, for any ELHr-terminology T , Cranconcept C and Cu,u concept D, we have T |= C v D if, and only if K |= D(aC), where K = (T ,AC). By Theorem 2 (extended version),\n• T |= C v D if, and only if, IK |= D(aC), where IK is the canonical model for K.\nNote that T |= C v ∃u.D if, and only if, DIK 6= ∅ and that for any d, d′ ∈ ∆IK and R = t1 u · · · u tn, we have (d, d′) ∈ RIK if, and only if, there exists a role name s such that (d, d′) ∈ sIK and s vT ti, for i = 1, . . . , n. We summarise the consequences we require in the proof below:\n(i) if D is a Cu-concept with occurrences Si = ri,1 u . . . u ri,mi of intersections of roles, 1 ≤ i ≤ k, then T |= C v D if, and only if, there exist role names si, 1 ≤ i ≤ k, such that si vT ri,j for 1 ≤ i ≤ k, 1 ≤ j ≤ mi and T |= C v D′, where D′ is obtained from D by replacing Si with si.\n(ii) If D is a Cu-concept, then T |= C v ∃u.D if, and only if, there exists a sequence r′1, . . . , r ′ n such that IK |= (∃r′1. · · · ∃r′n.D)(aran) or IK |= (∃r′1. · · · ∃r′n.D)(aC). In\nthe first case, there exists a subconcept (ran(r) u C ′) of C (up to commutativity and associativity of u) such that T |= ∃r.C ′ v ∃r′1. · · · ∃r′n.D. In the second case T |= C v ∃r′1. · · · ∃r′n.D.\nNow assume that C = d 1≤i≤l ran(si)u d 1≤j≤nAju d\n1≤k≤m ∃rk.Ck and T |= C v ∃R1.D. Let R1, . . . , Rk be all the occurrences of role intersections in ∃R1.D, where Ri = ri,1 u . . .u ri,mi , for 1 ≤ i ≤ k. By (i), we find role names si, 1 ≤ i ≤ k, such that si vT ri,j for 1 ≤ i ≤ k, 1 ≤ j ≤ mi and T |= C v D′, where D′ is obtained from D by replacing Ri with si. By applying Lemma 39 to T |= C v ∃s1.D′ and by using that t1 vT r1,j , for 1 ≤ j ≤ m1 and T |= D′ v D, we obtain that one of the conditions (e1u), (e2u), (e3u), or (e4u) must hold.\nFor the second part of the lemma, we first prove by induction on n ≥ 1 for every Cranconcept C and for every Cu-concept D with T |= C v ∃r1. · · · ∃rn.D that at least one of the following conditions holds\n(e1n) there exists a subconcept ∃r.C ′ of C such that T |= C ′ u ran(r)v D; (e2n) there exists a concept name A in C such that T |= A v ∃u.D; (e3n) there exists a role name r in C such that T |= ∃r.> v ∃u.D; (e4n) there exists a role name r in C such that T |= ran(r) v ∃u.D.\nFor n = 1, let C be a Cran concept and D be a Cu-concept with T |= C v ∃r1.D. We then obtain that at least one of the conditions (e1u), (e2u), (e3u), or (e4u) must hold from the first part of the lemma, and hence, one of (e1n), (e2n), (e3n), or (e4n) is satisfied. For n > 1, let C now be a Cran concept and D be a Cu-concept such that T |= C v ∃r1. · · · ∃rn.D. We can apply the first part of the lemma again, and if conditions (e2u), (e3u), or (e4u) are fulfilled, then we can conclude that conditions (e2n), (e3n), or (e4n) are also satisfied. In the\nThe Logical Difference for the Lightweight Description Logic EL\ncase where (e1u) holds, there exists a subconcept ∃r.C ′ of C such that T |= C ′ u ran(r) v ∃r2. · · · ∃rn.D. From the induction hypothesis we obtain that at least one of the conditions (e1n), (e2n), (e3n), or (e4n) is fulfilled for T |= C ′ u ran(r) v ∃r2. · · · ∃rn.D, and thus also for T |= C v ∃r1. · · · ∃rn.D as r ∈ sig(C) and as every subconcept of C ′ is also a subconcept of C.\nNow, if T |= C v ∃u.D for a Cran-concept C and a Cu-concept D, then by (ii) we have to distinguish between the following two cases:\n• There exists a subconcept ran(r) u C ′ of C and a sequence r′1, . . . , r′n′ such that T |= ∃r.C ′ v ∃r′1. · · · ∃r′n′ .D. For n′ = 0, we have T |= ∃r.C ′ v D and condition (e6u) holds. For n′ ≥ 1 we obtain that at least one of the conditions (e1n), (e2n), (e3n), or (e4n) is satisfied. If (e1n) holds, then there exists a subconcept ∃r′.C ′′ of ∃r.C ′ such that T |= C ′′ u ran(r′) v D. If ∃r.C ′ = ∃r′.C ′′, we have T |= C ′ u ran(r) v D. If (C ′ u ran(r)) occurs at the top-level of the concept C, then T |= C v D holds, and thus, condition (e5u). Otherwise, there exists a subconcept ∃s.((C ′ u ran(r)) u E) in C and (e1u) is satisfied as T |= C ′u ran(r)uEu ran(s) v D. If ∃r.C ′ 6= ∃r′.C ′′, ∃r′.C ′′ is a subconcept of C ′ (thus, of C) and so condition (e1u) holds. Finally, if one of the conditions (e2n), (e3n), or (e4n) is satisfied, then one of (e2u), (e3u), or (e4u) holds by (ii).\n• There exists a sequence r′1, . . . , r′n′ with T |= C v ∃r′1. · · · ∃r′n′ .D. For n′ = 0 condition (e5u) holds. If n\n′ ≥ 1, then at least one of the conditions (e1n), (e2n), (e3n), or (e4n) holds. Then, by (ii), we can conclude that one of the conditions (e1u), (e2u), (e3u), or (e4u) is satisfied as well.\nWe give the translation of Cu,u-assertions to conjunctive queries. It is similar to the construction of an ABox from a Cran-concept given in Section 5.1. First, given a Cu-concept C, we define a path in C as a finite sequence C0 ·R1 · C1 . . . Rn · Cn, where C0 = C, n ≥ 0, and ∃Ri+1.Ci+1 is a conjunct of Ci, for 1 ≤ i < n (Ri are conjunctions of role names). Let xp for p ∈ paths(C) be pairwise distinct variable names and set\nXC = { s(xp, xq) | p, q ∈ paths(C); q = p ·R · C ′, s conjunct of R } ∪ {A(xp) | A is a conjunct of tail(p), p ∈ paths(C) }\nLet ~x be the sequence of all variables in XC except xC . Then the conjunctive query qC,a is obtained from ∃~x. ∧ ϕ∈XC ϕ by replacing xC with a. Finally, for D = D0u∃u.D1u· · ·u∃u.Dk\nwe obtain the conjunctive query qD,a from ∃~x.( ∧ 0≤i≤k ∧ ϕ∈XDi ϕ), (we assume that distinct variables are used in every XDi , 0 ≤ i ≤ k, and that ~x is a sequence of all variables except xD0) by replacing xD0 with a.\nTo prove Lemma 63 we require some preparation. Query answering is closely related to the existence of certain homomorphisms between interpretations. Let Σ be a signature, O a set of individual names, and I1, I2 interpretations. A function f : ∆I1 → ∆I2 is called a (O,Σ)-homomorphism if\n• f(aI1) = f(aI2) for all a ∈ O;\nKonev, Ludwig, Walther, & Wolter\n• d ∈ AI1 implies f(d) ∈ AI2 for all A ∈ Σ;\n• (d1, d2) ∈ rI1 implies (f(d1), f(d2)) ∈ rI2 for all r ∈ Σ.\nIt is known (Chandra & Merlin, 1977) that if there exists a (O,Σ)-homomorphism from I1 to I2 and I1 |= q[~a] for a conjunctive Σ-query q using only individual names from O and ~a = a1, . . . , ak from O, then I2 |= q[~a].\nFor the proof below we slightly refine the notion of an (O,Σ)-homomorphism by considering partial (O,Σ)-homomorphisms with domains that satisfy certain conditions. Namely, for every n ≥ 0, we will call a partial (O,Σ)-homomorphism a level n homomorphism if its domain contains all elements reachable by a Σ-role chain of length at most n from either a named individual or from an element without a Σ-predecessor. We then prove that if for every ELran,u,u-inclusion C v D with depth(C), depth(D) ≤ n, T1 |= C v D implies T2 |= C v D, then there exists a such a partial level n homomorphism from a certain model of (T1,A) to a certain model of (T2,A).\nWe consider such partial homomorphisms on certain interpretations only, which we introduce first. Let O be a finite set of individual names and I an interpretation. d ∈ ∆I is called O-named if there exists a ∈ O with d = aI . A model I is called an O-forest if\n(F1) for every d ∈ ∆I which is not O-named, there exists at most one d′ ∈ ∆I such that (d′, d) ∈ ⋃ r∈NR r I ;\n(F2) there are no infinite sequences d0, d1, . . . with (di+1, di) ∈ ⋃ r∈NR r\nI for all i ≥ 0 such that no di is O-named.\n(F3) if (d, d′) ∈ ⋃ r∈NR r I and d′ is O-named, then d is O-named.\nLet O be a finite set of individual names, n ≥ 0, and Σ a signature. A partial function f from an O-forest I to a model I ′ is called an (O,n,Σ)-homomorphism if\n(H1) for all a ∈ O: aI is in the domain of f and f(aI) = aI′ ;\n(H2) for all d, d′ in the domain of f and r ∈ Σ: (d, d′) ∈ rI implies (f(d), f(d′)) ∈ rI′ ;\n(H3) for all d in the domain of f and A ∈ Σ: d ∈ AI implies f(d) ∈ AI′ ;\n(H4) for all d if there does not exist a chain d1, . . . , dm = d with (di, di+1) ∈ ⋃ r∈Σ r\nI of length m > n of not O-named di, then d is in the domain of f .\nNow one can prove the following\nLemma 70. Suppose I is an O-forest, I ′ an interpretation and for every m > 0 there exists a (O,m,Σ)-homomorphism from I to I ′. Assume as well that I |= q[~a] with q a conjunctive Σ-query using only individual names from O and ~a = a1, . . . , ak from O. Then I ′ |= q[~a].\nProof. Assume that ~a is a π-match of I and q(~x) = ∃~y.q′(~x, ~y) such that ~a consists of elements of O. By (F2) and (F3) in the definition of O-forests and (H1) and (H4) in the definition of partial homomorphisms, there exists m > 0 such that all π(v), v from ~x ∪ ~y, are in the domain of any (O,m,Σ)-homomorphism f . Take a (O,m,Σ)-homomorphism f . Then ~a is a π′-match of q(~x) and I ′, where π′(v) = f(π(v)), for all v ∈ ~x ∪ ~y.\nThe Logical Difference for the Lightweight Description Logic EL\nFinally, we also need a technique for constructing (O,m,Σ)-homomorphisms. Let I be an interpretation. For each d ∈ ∆I and m > 0, let\ntm,Σ,uI (d) = {C ∈ C u Σ | depth(C) ≤ m, d ∈ CI},\nwhere, as above, depth(C) is the role-depth of C; i.e., the number of nestings of existential restrictions in C.\nLemma 71. Let Σ be a finite signature and let m > 0 Suppose I is an O-forest and I ′ an interpretation such that\n(in0) (aI , bI) ∈ rI implies (aI′ , bI′) ∈ rI′, for all a, b ∈ O and r ∈ Σ;\n(in1) tm,Σ,uI (a I) ⊆ tm,Σ,uI′ (a I′), for all a ∈ O;\n(in2) for all d ∈ ∆I there exists d′ ∈ ∆I′ such that tm,Σ,uI (d) ⊆ t m,Σ,u I′ (d ′);\nThen there exists a (O,m,Σ)-homomorphism g from I to I ′.\nProof. We construct g by constructing a sequence of functions f0, . . . , fm, where fi : I → I ′, as follows: the domain dom(f0) of f0 consists of all a\nI with a ∈ O and all d ∈ ∆I such that there does not exist a d′ with (d′, d) ∈ ⋃ r∈Σ r I . For aI with a ∈ O we set f0(aI) = aI ′ . For every remaining d ∈ dom(f0) choose a d′ according to (in2) and set f0(d) = d′. Observe that tm,Σ,uI (d) ⊆ t m,Σ,u I′ (f0(d)) for all d ∈ dom(f0).\nNow suppose that fn has been constructed and\n(in3) tm−n,Σ,uI (d) ⊆ t m−n,Σ,u I′ (fn(d)) for all d ∈ dom(fn);\n(in4) for n > 0: d ∈ dom(fn) if, and only if, d is not O-named and there exists a sequence d0r I 1 d1r I 2 · · · rIndn = d of which at most d0 is O-named such that ri ∈ Σ and d0 ∈\ndom(f0). To construct fn+1 consider a d ∈ dom(fn) and a not O-named d′ such that (d, d′) ∈ ⋃ r∈Σ r\nI . The domain of fn+1 consists of all such d\n′. Let Rd,d′ = {r ∈ Σ | (d, d′) ∈ rI} and Rud,d′ = ( d r∈Rd,d′ r). Then\n∃Rud,d′ . l\nD∈tm−n−1,Σ,uI (d′)\nD ∈ tm−n,Σ,uI (d)\nBy (in3),\n∃Rud,d′ . l\nD∈tm−n−1,Σ,uI (d′)\nD ∈ tm−n,Σ,uI′ (fn(d))\nThus, we can choose an e with (fn(d), e) ∈ rI ′ for all r ∈ Rd,d′ and tm−n−1,Σ,uI (d′) ⊆ tm−n−1,Σ,uI′ (e) and set fn+1(d\n′) = e. This defines fn+1. Observe further that fn+1 is welldefined by (F1). Observe that fn+1 has the properties (in3) and (in4), by (F3).\nNow we set g = ⋃\n0≤n≤m fm. It is readily checked that g is as required.\nKonev, Ludwig, Walther, & Wolter\nWe are now in the position to prove Lemma 63.\nLemma 63 If ϕ ∈ qDiffΣ(T1, T2), then there exists ϕ′ ∈ cDiff ran,u,u Σ (T1, T2) with sig(ϕ′) ⊆ sig(ϕ).\nProof. Assume T1 and T2 are given and let (A, q(~a)) ∈ qDiffΣ(T1, T2). Let Σ′ = sig(A) ∪ sig(q). Assume that, in contrast to what is to be shown,\n(∗) T1 |= α ⇒ T2 |= α\nfor all ELran,u,u-inclusions α with sig(α) ⊆ Σ′. Consider a model I ′ of (T2,A) with I ′ 6|= q[~a]. By Lemma 70, we obtain a contradiction if there exists an obj(A)-forest I which is a model of (T1,A) and such that for every n > 0 there exists an (obj(A), n,Σ′)-homomorphism fn from I to I ′.\nTake, for every a ∈ obj(A) a model I ′a of T1 with da ∈ ∆I ′ a such that for all Cran ∪ Cu,u-\nconcepts C: da ∈ CI ′ a ⇔ T1 ∪ tI′(a) |= C\nwhere tI′(a) = {C ∈ CranΣ′ | aI ′ ∈ CI′}.\nSuch interpretations I ′a exist by Lemma 67. We now define the unfolding Ia of I ′a. A path in I ′a is a finite sequence d0R1d1 . . . Rndn, n ≥ 0, such that Ri+1 = d Ri+1 for a set Ri+1 of role names with r ∈ Ri+1 iff (di, di+1) ∈ rI ′ a , for all i < n. For a path p, tail(p) denotes the last element of p. Now let ∆Ia consist of all paths in I ′a and set\n• AIa = {p ∈ ∆Ia | tail(p) ∈ AI′a};\n• rIa = {(d, dRd′) ∈ ∆Ia ×∆Ia | r ∈ R}.\nThen Ia is an O-forest for O = ∅. Moreover, for all Cu,u-concepts C and all p ∈ Ia:\n(∗∗) p ∈ CIa ⇔ tail(p) ∈ CI′a .\nIn particular, Ia is still a model of T1. Take the following (disjoint) union I of the interpretations Ia:\n• ∆I = ⋃ a∈obj(A) ∆ Ia ;\n• AI = ⋃ a∈obj(A)A Ia , for A ∈ NC;\n• rI = ⋃ a∈obj(A) r Ia ∪ {(da, db) | r′(a, b) ∈ A, r′ vT1 r}, for r ∈ NR;\n• aI = da, for a ∈ obj(A).\nWe show that I is an obj(A)-forest, a model of (T1,A) and that there exist (obj(A), n,Σ)homomorphisms from I to I ′ for all n > 0. First observe the following:\nClaim 1. For all EL concepts C and d ∈ ∆Ia :\nd ∈ CI ⇔ d ∈ CIa\nThe Logical Difference for the Lightweight Description Logic EL\nThe proof is by induction on the construction of C. The interesting case is C = ∃r.D and the direction from left to right. Assume that d ∈ CI ∩ ∆Ia . Take d′ with (d, d′) ∈ rI and d′ ∈ DI . For (d, d′) ∈ ⋃ a′∈obj(A) r\nIa′ , d ∈ CIa follows immediately from the induction hypothesis. Otherwise, d = da, d ′ = db for some b with r ′(a, b) ∈ A and r′ vT1 r. By the induction hypothesis, d′ ∈ DIb . Hence, by (∗∗), T1 ∪ tI′(b) |= D. By compactness, there exists a concept E ∈ tI′(b) such that T1 |= E v D. We obtain ∃r′.E ∈ tI′(a). But then T1 |= ∃r′.E v ∃r′.D and we obtain da ∈ CIa using r′ vT1 r and (∗∗).\nClaim 2. I is an obj(A)-forest and a model of (T1,A).\nThat I is an obj(A)-forest and a model of A follows from the construction. It remains to show that I is a model of T1. For role inclusions r v s ∈ T1 it follows from the construction that rI ⊆ sI . Suppose C1 v C2 ∈ T1. If C1 is an EL-concept, then I |= C1 v C2 follows from Claim 1 and the condition that the Ia are models of T1. Now assume that C1 = ran(r) and let d ∈ ran(r)I . If d 6= da for any a, then d ∈ CI2 since the Ia are models of T1. If d = da, there exists r′(b, a) ∈ A with r′ vT1 r. We have ran(r′) ∈ tI′(a), and so T1 ∪ tI′(a) |= C2. Hence, by (∗∗), da ∈ CIa2 , i.e. da ∈ CI2 by Claim 1.\nClaim 3. For every n > 0 there exists an (obj(A), n,Σ′)-homomorphism from I to I ′.\nBy Lemma 71, it is sufficient to show conditions (in0), (in1), and (in2). Condition (in0) follows directly from (∗). Condition (in1) is proved by induction on the construction of C. The interesting step is for C = ∃S.D with S = r1 u · · · u rm. Let a ∈ obj(A) and C ∈ tn,Σ\n′,u I (a I). Take d′ with (aI , d′) ∈ SI and d′ ∈ DI . If d′ ∈ ∆Ia , then, by (∗∗), T1∪ tI′(a) |= ∃S.D. By (∗) and compactness, T2 ∪ tI′(a) |= ∃S.D. Hence C ∈ tn,Σ ′,u I′ (a\nI′). Now assume d′ 6∈ ∆Ia . Then there are r′1, . . . , r′k and b with d′ = bI such that r′i(a, b) ∈ A for 1 ≤ i ≤ k and for every 1 ≤ i ≤ m there exists an 1 ≤ j ≤ m with r′j vT1 ri. We have D ∈ t n,Σ′,u I (b I). By the induction hypothesis D ∈ tn,Σ ′,u\nI′ (b I′). By (∗), for every 1 ≤ j ≤ m there exists an\n1 ≤ j ≤ k with r′j vT2 ri. But then C ∈ t n,Σ′,u I′ (a I′), as required.\nFor (in2), let d ∈ ∆I and C = d D∈tn,Σ\n′,u I (d) D. If d 6= aI for any a ∈ obj(A), then by (∗∗) there exists b ∈ obj(A) such that T1 ∪ tI′(b) |= ∃u.C. By compactness and (∗), T2 ∪ tI′(b) |= ∃u.C. Hence, there exists d′ ∈ ∆I ′ with tn,Σ ′,u I (d) ⊆ t n,Σ′,u I′ (d ′), as required. If d = aI for some a ∈ obj(A), then, by (in1) shown above, d′ = aI′ is as required. This finishes the proof of Lemma 63."
    } ],
    "references" : [ {
      "title" : "Pushing the EL envelope further",
      "author" : [ "F. Baader", "S. Brandt", "C. Lutz" ],
      "venue" : "In Proceedings of the 6th International Workshop on OWL: Experiences and Directions (OWLED 2009),",
      "citeRegEx" : "Baader et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2008
    }, {
      "title" : "Pinpointing in the description logic EL+",
      "author" : [ "F. Baader", "R. Peñaloza", "B. Suntisrivaraporn" ],
      "venue" : "In Proceedings of the 30th Annual German Conference on Artificial Intelligence (KI 2007),",
      "citeRegEx" : "Baader et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2007
    }, {
      "title" : "Terminological cycles in a description logic with existential restrictions",
      "author" : [ "F. Baader" ],
      "venue" : "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI 2003), pp. 325–330, San Francisco, CA, USA. Morgan Kaufmann. Bienvenu, M., Lutz, C., & Wolter, F. (2012a). Deciding FO-rewritability in EL. In Proceedings of the 25th International Workshop on Description Logics (DL 2012).",
      "citeRegEx" : "Baader,? 2003",
      "shortCiteRegEx" : "Baader",
      "year" : 2003
    }, {
      "title" : "Query containment in description logics revisited",
      "author" : [ "M. Bienvenu", "C. Lutz", "F. Wolter" ],
      "venue" : "In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Bienvenu et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Bienvenu et al\\.",
      "year" : 2012
    }, {
      "title" : "Approximation and difference in description logics",
      "author" : [ "S. Brandt", "R. Küsters", "Turhan", "A.-Y" ],
      "venue" : "In Proceedings of the 8th International Conference on Principles and Knowledge Representation and Reasoning",
      "citeRegEx" : "Brandt et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Brandt et al\\.",
      "year" : 2002
    }, {
      "title" : "Data complexity of query answering in description logics",
      "author" : [ "D. Calvanese", "G.D. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2006
    }, {
      "title" : "Optimal implementation of conjunctive queries in relational data bases",
      "author" : [ "A.K. Chandra", "P.M. Merlin" ],
      "venue" : "In Proceedings of the 9th Annual ACM Symposium on Theory of Computing (STOC",
      "citeRegEx" : "Chandra and Merlin,? \\Q1977\\E",
      "shortCiteRegEx" : "Chandra and Merlin",
      "year" : 1977
    }, {
      "title" : "Model Theory, Vol. 73 of Studies in Logic and the Foundations of Mathematics",
      "author" : [ "C.C. Chang", "H.J. Keisler" ],
      "venue" : null,
      "citeRegEx" : "Chang and Keisler,? \\Q1990\\E",
      "shortCiteRegEx" : "Chang and Keisler",
      "year" : 1990
    }, {
      "title" : "Version models for software configuration management",
      "author" : [ "R. Conradi", "B. Westfechtel" ],
      "venue" : "ACM Computing Surveys (CSUR),",
      "citeRegEx" : "Conradi and Westfechtel,? \\Q1998\\E",
      "shortCiteRegEx" : "Conradi and Westfechtel",
      "year" : 1998
    }, {
      "title" : "Saving space in a time efficient simulation algorithm",
      "author" : [ "S. Crafa", "F. Ranzato", "F. Tapparo" ],
      "venue" : "Fundamenta Informaticae,",
      "citeRegEx" : "Crafa et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Crafa et al\\.",
      "year" : 2011
    }, {
      "title" : "Modular reuse of ontologies: theory and practice",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "Semantical characterizations and complexity of equivalences in answer set programming",
      "author" : [ "T. Eiter", "M. Fink", "S. Woltran" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "Eiter et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2007
    }, {
      "title" : "Did I damage my ontology? A case for conservative extensions in description logic",
      "author" : [ "S. Ghilardi", "C. Lutz", "F. Wolter" ],
      "venue" : "In Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Ghilardi et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ghilardi et al\\.",
      "year" : 2006
    }, {
      "title" : "The National Cancer Institute’s thesaurus and ontology",
      "author" : [ "J. Golbeck", "G. Fragaso", "F. Hartel", "J. Hendler", "J. Oberhaler", "B. Parsia" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "Golbeck et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Golbeck et al\\.",
      "year" : 2003
    }, {
      "title" : "Analysing multiple versions of an ontology: A study of the NCI thesaurus",
      "author" : [ "R.S. Gonçalves", "B. Parsia", "U. Sattler" ],
      "venue" : "In Proceedings of the 24th International Workshop on Description Logics (DL 2011),",
      "citeRegEx" : "Gonçalves et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gonçalves et al\\.",
      "year" : 2011
    }, {
      "title" : "Concept-based semantic difference in expressive description logics",
      "author" : [ "R.S. Gonçalves", "B. Parsia", "U. Sattler" ],
      "venue" : "In Proceedings of the 25th International Workshop on Description Logics (DL",
      "citeRegEx" : "Gonçalves et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Gonçalves et al\\.",
      "year" : 2012
    }, {
      "title" : "Proof-theoretic approach to description-logic",
      "author" : [ "M. Hofmann" ],
      "venue" : "Proceedings of the 20th Annual IEEE Symposium on Logic in Computer Science (LICS 2005), pp. 229– 237, Washington, DC, USA. IEEE Computer Society.",
      "citeRegEx" : "Hofmann,? 2005",
      "shortCiteRegEx" : "Hofmann",
      "year" : 2005
    }, {
      "title" : "Justification oriented proofs in OWL",
      "author" : [ "M. Horridge", "B. Parsia", "U. Sattler" ],
      "venue" : "In Proceedings of the 9th International Semantic Web Conference (ISWC 2010),",
      "citeRegEx" : "Horridge et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Horridge et al\\.",
      "year" : 2010
    }, {
      "title" : "SNOMED Clinical Terms User Guide",
      "author" : [ "IHTSDO" ],
      "venue" : "The International Health Terminology Standards Development Organisation (IHTSDO). Available from http://www.ihtsdo.org/publications/introducing-snomed-ct/.",
      "citeRegEx" : "IHTSDO,? 2008",
      "shortCiteRegEx" : "IHTSDO",
      "year" : 2008
    }, {
      "title" : "Supporting concurrent ontology development: Framework, algorithms and tool",
      "author" : [ "E. Jiménez-Ruiz", "B. Cuenca Grau", "I. Horrocks", "R.B. Llavori" ],
      "venue" : "Data & Knowledge Engineering,",
      "citeRegEx" : "Jiménez.Ruiz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Jiménez.Ruiz et al\\.",
      "year" : 2011
    }, {
      "title" : "Finding all justifications of OWL DL entailments",
      "author" : [ "A. Kalyanpur", "B. Parsia", "M. Horridge", "E. Sirin" ],
      "venue" : "In Proceedings of the 6th International and 2nd Asian Semantic Web Conference (ISWC’07+ASWC’07),",
      "citeRegEx" : "Kalyanpur et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Kalyanpur et al\\.",
      "year" : 2007
    }, {
      "title" : "Consequence-driven reasoning for Horn SHIQ ontologies",
      "author" : [ "Y. Kazakov" ],
      "venue" : "Proceedings of the 21st International Conference on Artificial Intelligence (IJCAI 2009), pp. 2040– 2045. Kazakov, Y., Krötzsch, M., & Simancik, F. (2011). Unchain my EL reasoner. In Proceedings of the 24th International Workshop on Description Logics (DL 2011), CEUR",
      "citeRegEx" : "Kazakov,? 2009",
      "shortCiteRegEx" : "Kazakov",
      "year" : 2009
    }, {
      "title" : "Ontology versioning and change detection on the web",
      "author" : [ "M.C.A. Klein", "D. Fensel", "A. Kiryakov", "D. Ognyanov" ],
      "venue" : "In Knowledge Engineering and Knowledge Management: Ontologies and the Semantic Web,",
      "citeRegEx" : "Klein et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Klein et al\\.",
      "year" : 2002
    }, {
      "title" : "Semantic modularity and module extraction in description logic",
      "author" : [ "B. Konev", "C. Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "In Proceedings of the 18th European Conference on Artificial Intelligence (ECAI 2008),",
      "citeRegEx" : "Konev et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2008
    }, {
      "title" : "The logical difference problem for description logic terminologies",
      "author" : [ "B. Konev", "D. Walther", "F. Wolter" ],
      "venue" : "In Proceedings of the 4th International Joint Conference on Automated Reasoning (IJCAR 2008),",
      "citeRegEx" : "Konev et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2008
    }, {
      "title" : "Conjunctive query inseparability of OWL 2 QL TBoxes",
      "author" : [ "B. Konev", "R. Kontchakov", "M. Ludwig", "T. Schneider", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In Proceedings of the 25th Conference on Artificial Intelligence (AAAI 2011),",
      "citeRegEx" : "Konev et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2011
    }, {
      "title" : "Logical difference computation with CEX2.5",
      "author" : [ "B. Konev", "M. Ludwig", "F. Wolter" ],
      "venue" : "In Proceedings of the 6th International Joint Conference on Automated Reasoning (IJCAR 2012),",
      "citeRegEx" : "Konev et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2012
    }, {
      "title" : "Formal properties of modularisation",
      "author" : [ "B. Konev", "C. Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "In Modular Ontologies,",
      "citeRegEx" : "Konev et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2009
    }, {
      "title" : "Logic-based ontology comparison and module extraction, with an application to DL-Lite",
      "author" : [ "R. Kontchakov", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2010
    }, {
      "title" : "Minimal module extraction from DL-Lite ontologies using QBF solvers",
      "author" : [ "R. Kontchakov", "L. Pulina", "U. Sattler", "T. Schneider", "P. Selmer", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2009
    }, {
      "title" : "Conservativity in structured ontologies",
      "author" : [ "O. Kutz", "T. Mossakowski" ],
      "venue" : "In Proceedings of the 18th European Conference on Artificial Intelligence (ECAI 2008),",
      "citeRegEx" : "Kutz and Mossakowski,? \\Q2008\\E",
      "shortCiteRegEx" : "Kutz and Mossakowski",
      "year" : 2008
    }, {
      "title" : "A modular consistency proof for DOLCE",
      "author" : [ "O. Kutz", "T. Mossakowski" ],
      "venue" : "In Proceedings of the 25th Conference on Artificial Intelligence (AAAI 2011),",
      "citeRegEx" : "Kutz and Mossakowski,? \\Q2011\\E",
      "shortCiteRegEx" : "Kutz and Mossakowski",
      "year" : 2011
    }, {
      "title" : "OWLDiff: A practical tool for comparison and merge of OWL ontologies",
      "author" : [ "P. Křemen", "M. Šmı́d", "Z. Kouba" ],
      "venue" : "In Proceedings of the 10th International Workshop on Web Semantics,",
      "citeRegEx" : "Křemen et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Křemen et al\\.",
      "year" : 2011
    }, {
      "title" : "Conjunctive query answering in the description logic EL using a relational database system",
      "author" : [ "C. Lutz", "D. Toman", "F. Wolter" ],
      "venue" : "In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Lutz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2009
    }, {
      "title" : "Conservative extensions in expressive description logics",
      "author" : [ "C. Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "In Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Lutz et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2007
    }, {
      "title" : "Deciding inseparability and conservative extensions in the description logic EL",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "Journal of Symbolic Computing,",
      "citeRegEx" : "Lutz and Wolter,? \\Q2010\\E",
      "shortCiteRegEx" : "Lutz and Wolter",
      "year" : 2010
    }, {
      "title" : "Foundations for uniform interpolation and forgetting in expressive description logics",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "In Proceedings of the 22nd International Joint Conference",
      "citeRegEx" : "Lutz and Wolter,? \\Q2011\\E",
      "shortCiteRegEx" : "Lutz and Wolter",
      "year" : 2011
    }, {
      "title" : "Reintroducing CEL as an OWL 2 EL reasoner",
      "author" : [ "J. Mendez", "B. Suntisrivaraporn" ],
      "venue" : "In Proceedings of the 22nd International Workshop on Description Logics (DL 2009),",
      "citeRegEx" : "Mendez and Suntisrivaraporn,? \\Q2009\\E",
      "shortCiteRegEx" : "Mendez and Suntisrivaraporn",
      "year" : 2009
    }, {
      "title" : "PromptDiff: A fixed-point algorithm for comparing ontology versions",
      "author" : [ "N.F. Noy", "M.A. Musen" ],
      "venue" : "In Proceedings of the 18th national conference on Artificial intelligence,",
      "citeRegEx" : "Noy and Musen,? \\Q2002\\E",
      "shortCiteRegEx" : "Noy and Musen",
      "year" : 2002
    }, {
      "title" : "Differences between versions of UML diagrams",
      "author" : [ "D. Ohst", "M. Welle", "U. Kelter" ],
      "venue" : "In Proceedings of the 9th European software engineering conference held jointly with 11th ACM SIGSOFT international symposium on Foundations of software engineering (ESEC’03/SIGSOFT",
      "citeRegEx" : "Ohst et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Ohst et al\\.",
      "year" : 2003
    }, {
      "title" : "Representation of change in controlled medical terminologies",
      "author" : [ "D.E. Oliver", "Y. Shahar", "E.H. Shortliffe", "M.A. Musen" ],
      "venue" : "Artificial Intelligence in Medicine,",
      "citeRegEx" : "Oliver et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Oliver et al\\.",
      "year" : 1999
    }, {
      "title" : "Change representation for OWL 2 ontologies",
      "author" : [ "R. Palma", "P. Haase", "O. Corcho", "A. Gómez-Pérez" ],
      "venue" : "In Proceedings of the 6th International Workshop on OWL: Experiences and Directions (OWLED 2009),",
      "citeRegEx" : "Palma et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Palma et al\\.",
      "year" : 2009
    }, {
      "title" : "Uniform equivalence for equilibrium logic and logic programs",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "In Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2004),",
      "citeRegEx" : "Pearce and Valverde,? \\Q2004\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2004
    }, {
      "title" : "Synonymous theories and knowledge representations in answer set programming",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Pearce and Valverde,? \\Q2012\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2012
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "A. Poggi", "D. Lembo", "D. Calvanese", "G.D. Giacomo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Data Semantics,",
      "citeRegEx" : "Poggi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Poggi et al\\.",
      "year" : 2008
    }, {
      "title" : "Managing change: An ontology version control system",
      "author" : [ "T. Redmond", "M. Smith", "N. Drummond", "T. Tudorache" ],
      "venue" : "In Proceedings of the 5th International Workshop on OWL: Experiences and Directions (OWLED 2008),",
      "citeRegEx" : "Redmond et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Redmond et al\\.",
      "year" : 2008
    }, {
      "title" : "Non-standard reasoning services for the debugging of description logic terminologies",
      "author" : [ "S. Schlobach", "R. Cornet" ],
      "venue" : "In Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Schlobach and Cornet,? \\Q2003\\E",
      "shortCiteRegEx" : "Schlobach and Cornet",
      "year" : 2003
    }, {
      "title" : "Making the difference: A subtraction operation for description logics",
      "author" : [ "G. Teege" ],
      "venue" : "Proceedings of the 4th International Conference on Principles of Knowledge Representation and Reasoning (KR’94), pp. 540–550, San Francisco, CA, USA. Morgan Kaufmann.",
      "citeRegEx" : "Teege,? 1994",
      "shortCiteRegEx" : "Teege",
      "year" : 1994
    }, {
      "title" : "Correcting a space-efficient simulation algorithm",
      "author" : [ "R.J. van Glabbeek", "B. Ploeger" ],
      "venue" : "In Proceedings of the 20th International Conference on Computer Aided Verification (CAV 2008),",
      "citeRegEx" : "Glabbeek and Ploeger,? \\Q2008\\E",
      "shortCiteRegEx" : "Glabbeek and Ploeger",
      "year" : 2008
    }, {
      "title" : "The modular structure of an ontology: Atomic decomposition",
      "author" : [ "C.D. Vescovo", "B. Parsia", "U. Sattler", "T. Schneider" ],
      "venue" : "In Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Vescovo et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Vescovo et al\\.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "For example, the widely used medical terminology Snomed CT (Systematized Nomenclature of Medicine Clinical Terms) contains more than 300 000 term definitions (IHTSDO, 2008).",
      "startOffset" : 158,
      "endOffset" : 172
    }, {
      "referenceID" : 19,
      "context" : ", the equivalence of different structural forms of concepts, are also taken into account (Palma, Haase, Corcho, & Gómez-Pérez, 2009; Jiménez-Ruiz et al., 2011).",
      "startOffset" : 89,
      "endOffset" : 159
    }, {
      "referenceID" : 22,
      "context" : "Ontology versioning based on structural diff of some form is available in most current ontology editors and ontology management systems either natively or through plugins (Noy & Musen, 2002; Klein et al., 2002; Jiménez-Ruiz et al., 2011).",
      "startOffset" : 171,
      "endOffset" : 237
    }, {
      "referenceID" : 19,
      "context" : "Ontology versioning based on structural diff of some form is available in most current ontology editors and ontology management systems either natively or through plugins (Noy & Musen, 2002; Klein et al., 2002; Jiménez-Ruiz et al., 2011).",
      "startOffset" : 171,
      "endOffset" : 237
    }, {
      "referenceID" : 36,
      "context" : "As observed already in the work of Noy and Musen (2002), ontology versioning cannot rely on a purely syntactic diff operation since many syntactic differences (e.",
      "startOffset" : 35,
      "endOffset" : 56
    }, {
      "referenceID" : 19,
      "context" : "It has been argued that syntax-dependence should be regarded as an advantage rather than a deficiency in the context of versioning (Gonçalves, Parsia, & Sattler, 2011; Jiménez-Ruiz et al., 2011).",
      "startOffset" : 131,
      "endOffset" : 194
    }, {
      "referenceID" : 0,
      "context" : "The complexity of subsumption and instance checking is in PTime (Baader et al., 2008).",
      "startOffset" : 64,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "The complexity of subsumption and instance checking is in PTime (Baader et al., 2008). The combined complexity of answering Boolean conjunctive queries (i.e., deciding whether (T ,A) |= q for a conjunctive query q without free variables) is coNP-complete (Rosati, 2007) and its data complexity is in PTime (Rosati, 2007). Information on reasoners for subsumption checking for ELH can be found in the work of Delaitre and Kazakov (2009), Kazakov, Krötzsch, and Simancik (2011), and Mendez and Suntisrivaraporn (2009).",
      "startOffset" : 65,
      "endOffset" : 436
    }, {
      "referenceID" : 0,
      "context" : "The complexity of subsumption and instance checking is in PTime (Baader et al., 2008). The combined complexity of answering Boolean conjunctive queries (i.e., deciding whether (T ,A) |= q for a conjunctive query q without free variables) is coNP-complete (Rosati, 2007) and its data complexity is in PTime (Rosati, 2007). Information on reasoners for subsumption checking for ELH can be found in the work of Delaitre and Kazakov (2009), Kazakov, Krötzsch, and Simancik (2011), and Mendez and Suntisrivaraporn (2009).",
      "startOffset" : 65,
      "endOffset" : 476
    }, {
      "referenceID" : 0,
      "context" : "The complexity of subsumption and instance checking is in PTime (Baader et al., 2008). The combined complexity of answering Boolean conjunctive queries (i.e., deciding whether (T ,A) |= q for a conjunctive query q without free variables) is coNP-complete (Rosati, 2007) and its data complexity is in PTime (Rosati, 2007). Information on reasoners for subsumption checking for ELH can be found in the work of Delaitre and Kazakov (2009), Kazakov, Krötzsch, and Simancik (2011), and Mendez and Suntisrivaraporn (2009). Lutz et al.",
      "startOffset" : 65,
      "endOffset" : 516
    }, {
      "referenceID" : 0,
      "context" : "The complexity of subsumption and instance checking is in PTime (Baader et al., 2008). The combined complexity of answering Boolean conjunctive queries (i.e., deciding whether (T ,A) |= q for a conjunctive query q without free variables) is coNP-complete (Rosati, 2007) and its data complexity is in PTime (Rosati, 2007). Information on reasoners for subsumption checking for ELH can be found in the work of Delaitre and Kazakov (2009), Kazakov, Krötzsch, and Simancik (2011), and Mendez and Suntisrivaraporn (2009). Lutz et al. (2009) present an approach to efficient conjunctive query answering for ELH.",
      "startOffset" : 65,
      "endOffset" : 536
    }, {
      "referenceID" : 2,
      "context" : "Normalised terminologies in the sense defined above are a minor modification of normalised terminologies as defined by Baader (2003). The straightforward extension of the proof given by Baader is provided in the appendix.",
      "startOffset" : 119,
      "endOffset" : 133
    }, {
      "referenceID" : 33,
      "context" : "The construction is similar to the canonical model introduced by Lutz et al. (2009). Let sub(T ) denote the set of all subconcepts of concepts used in T , rol(T ) the set of all role names occurring in T .",
      "startOffset" : 65,
      "endOffset" : 84
    }, {
      "referenceID" : 35,
      "context" : "In contrast to ELH, it has been shown by Lutz and Wolter (2010) that for EL-TBoxes there is no difference between Σ-concept inseparability and Σ-instance inseparability.",
      "startOffset" : 41,
      "endOffset" : 64
    }, {
      "referenceID" : 35,
      "context" : "As observed by Lutz and Wolter (2010) already, even for EL Σ-instance inseparability does not imply Σ-query inseparability.",
      "startOffset" : 15,
      "endOffset" : 38
    }, {
      "referenceID" : 35,
      "context" : "It is shown by Lutz and Wolter (2010) that Example 8 is essentially the only situation in which there is a difference between Σ-instance inseparability and Σ-query inseparability in EL: the two notions become equivalent for EL if the universal role is admitted in instance queries (e.",
      "startOffset" : 15,
      "endOffset" : 38
    }, {
      "referenceID" : 16,
      "context" : "1 Proof System for EL We derive basic properties of EL from the Gentzen-style sequent calculus presented by Hofmann (2005); see Figure 1.",
      "startOffset" : 108,
      "endOffset" : 123
    }, {
      "referenceID" : 16,
      "context" : "Notice that the basic calculus of Hofmann (2005) considers EL without the constant > and for terminologies without concept inclusions.",
      "startOffset" : 34,
      "endOffset" : 49
    }, {
      "referenceID" : 35,
      "context" : "A polytime algorithm computing cWtn Σ (T1, T2) has already been given by Lutz and Wolter (2010) (for EL-TBoxes).",
      "startOffset" : 73,
      "endOffset" : 96
    }, {
      "referenceID" : 35,
      "context" : "The tractability of computing cWtn Σ (T1, T2) for EL has been proved by Lutz and Wolter (2010) for arbitrary EL-TBoxes by reduction to simulation checking.",
      "startOffset" : 72,
      "endOffset" : 95
    }, {
      "referenceID" : 16,
      "context" : "Cut elimination, correctness, and completeness of the proof system can be shown similarly to the corresponding proofs given by Hofmann (2005).",
      "startOffset" : 127,
      "endOffset" : 142
    }, {
      "referenceID" : 21,
      "context" : "CEX2 is written in OCaml and the reasoner CB (Kazakov, 2009) is internally used as classification engine.",
      "startOffset" : 45,
      "endOffset" : 60
    }, {
      "referenceID" : 14,
      "context" : "Similarly to the work of Gonçalves et al. (2011), we have compared 71 consecutive ELH-versions of the NCI Thesaurus ranging between the versions 03.",
      "startOffset" : 25,
      "endOffset" : 49
    }, {
      "referenceID" : 14,
      "context" : "As mentioned above already, Gonçalves et al. (2011) provide an indepth analysis of NCI versions.",
      "startOffset" : 28,
      "endOffset" : 52
    }, {
      "referenceID" : 34,
      "context" : ") For ALC and its standard extensions without nominals deciding concept inseparability and conservative extensions is 2ExpTime-complete (Ghilardi, Lutz, & Wolter, 2006; Lutz et al., 2007; Lutz & Wolter, 2011) and for ALCQIO deciding concept inseparability and conservative extensions becomes undecidable (Lutz et al.",
      "startOffset" : 136,
      "endOffset" : 208
    }, {
      "referenceID" : 34,
      "context" : ", 2007; Lutz & Wolter, 2011) and for ALCQIO deciding concept inseparability and conservative extensions becomes undecidable (Lutz et al., 2007; Cuenca Grau et al., 2008).",
      "startOffset" : 124,
      "endOffset" : 169
    }, {
      "referenceID" : 28,
      "context" : "For DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, & Rosati, 2006), the complexity of concept, instance, and query inseparability ranges from PSpace-hard (and in ExpTime) for the description logic underlying the OWL 2 QL standard, NP-complete for DL-Litehorn, and Π p 2-complete for DL-Litebool (Konev, Kontchakov, Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010).",
      "startOffset" : 304,
      "endOffset" : 398
    }, {
      "referenceID" : 28,
      "context" : "For DLLitebool model-theoretic inseparability is decidable (Kontchakov et al., 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al.",
      "startOffset" : 59,
      "endOffset" : 84
    }, {
      "referenceID" : 25,
      "context" : ", 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al., 2011).",
      "startOffset" : 84,
      "endOffset" : 104
    }, {
      "referenceID" : 10,
      "context" : ", 2007; Cuenca Grau et al., 2008). Nothing is known for ALC about the complexity of inseparability for instance and conjunctive queries. For DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, & Rosati, 2006), the complexity of concept, instance, and query inseparability ranges from PSpace-hard (and in ExpTime) for the description logic underlying the OWL 2 QL standard, NP-complete for DL-Litehorn, and Π p 2-complete for DL-Litebool (Konev, Kontchakov, Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010). For DLLitebool model-theoretic inseparability is decidable (Kontchakov et al., 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al., 2011). In contrast to the work presented in this paper, however, no attempt is made to present the logical difference to the user if two ontology are not inseparable. As mentioned above, in the work of Konev et al. (2012), CEX2 is extended to the conjunctive query difference case between acyclic ELH-terminologies and various experiments based on the NCI thesaurus are discussed.",
      "startOffset" : 15,
      "endOffset" : 935
    }, {
      "referenceID" : 10,
      "context" : ", 2007; Cuenca Grau et al., 2008). Nothing is known for ALC about the complexity of inseparability for instance and conjunctive queries. For DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, & Rosati, 2006), the complexity of concept, instance, and query inseparability ranges from PSpace-hard (and in ExpTime) for the description logic underlying the OWL 2 QL standard, NP-complete for DL-Litehorn, and Π p 2-complete for DL-Litebool (Konev, Kontchakov, Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010). For DLLitebool model-theoretic inseparability is decidable (Kontchakov et al., 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al., 2011). In contrast to the work presented in this paper, however, no attempt is made to present the logical difference to the user if two ontology are not inseparable. As mentioned above, in the work of Konev et al. (2012), CEX2 is extended to the conjunctive query difference case between acyclic ELH-terminologies and various experiments based on the NCI thesaurus are discussed. The work discussed so far is concerned with the logical difference and inseparability between description logic TBoxes. The difference between description logic concepts has been investigated, for example, in the work of Teege (1994), and of Brandt, Küsters, and Turhan (2002) but besides of the interest in some kind of difference the problems considered as well as the techniques employed are rather different.",
      "startOffset" : 15,
      "endOffset" : 1328
    }, {
      "referenceID" : 10,
      "context" : ", 2007; Cuenca Grau et al., 2008). Nothing is known for ALC about the complexity of inseparability for instance and conjunctive queries. For DL-Lite dialects (Calvanese, Giacomo, Lembo, Lenzerini, & Rosati, 2006), the complexity of concept, instance, and query inseparability ranges from PSpace-hard (and in ExpTime) for the description logic underlying the OWL 2 QL standard, NP-complete for DL-Litehorn, and Π p 2-complete for DL-Litebool (Konev, Kontchakov, Ludwig, Schneider, Wolter, & Zakharyaschev, 2011; Kontchakov et al., 2010). For DLLitebool model-theoretic inseparability is decidable (Kontchakov et al., 2010) and for DLLitecore concept, instance, and query inseparability are in PTime (Konev et al., 2011). In contrast to the work presented in this paper, however, no attempt is made to present the logical difference to the user if two ontology are not inseparable. As mentioned above, in the work of Konev et al. (2012), CEX2 is extended to the conjunctive query difference case between acyclic ELH-terminologies and various experiments based on the NCI thesaurus are discussed. The work discussed so far is concerned with the logical difference and inseparability between description logic TBoxes. The difference between description logic concepts has been investigated, for example, in the work of Teege (1994), and of Brandt, Küsters, and Turhan (2002) but besides of the interest in some kind of difference the problems considered as well as the techniques employed are rather different.",
      "startOffset" : 15,
      "endOffset" : 1371
    }, {
      "referenceID" : 12,
      "context" : "In other words, T ∪T ′ should be a conservative extension of T in the sense that the consequences of T ∪ T ′ in the signature of T should coincide with the consequences of T itself (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo, Parsia, Sattler, & Schneider, 2011).",
      "startOffset" : 181,
      "endOffset" : 275
    }, {
      "referenceID" : 25,
      "context" : "Algorithms checking conservative extensions can also be used to extract modules from ontologies (Cuenca Grau et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009; Konev et al., 2011).",
      "startOffset" : 96,
      "endOffset" : 221
    }, {
      "referenceID" : 10,
      "context" : "In other words, T ∪T ′ should be a conservative extension of T in the sense that the consequences of T ∪ T ′ in the signature of T should coincide with the consequences of T itself (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo, Parsia, Sattler, & Schneider, 2011). As observed above already, Σ-inseparability generalises conservative extensions and, therefore, our algorithms can be used to check whether one terminology is a conservative extension of another terminology. Algorithms checking conservative extensions can also be used to extract modules from ontologies (Cuenca Grau et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009; Konev et al., 2011). It would be of interest to explore applications of our inseparability testing algorithms to extract modules of terminologies and check conservativity. (2) Inseparability as defined in this paper does not mean that one terminology can be replaced by another terminology in every context. In various applications of inseparability for modularity it is important to ensure that if T1 and T2 are Σ-inseparable, then T1 ∪ T and T2 ∪ T are Σ-inseparable as well, for any ontology T . This is called the replacement property by Konev, Lutz, Walther, and Wolter (2009) and has been exploited and discussed, for example, in the work of Cuenca Grau et al.",
      "startOffset" : 189,
      "endOffset" : 1269
    }, {
      "referenceID" : 10,
      "context" : "In other words, T ∪T ′ should be a conservative extension of T in the sense that the consequences of T ∪ T ′ in the signature of T should coincide with the consequences of T itself (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo, Parsia, Sattler, & Schneider, 2011). As observed above already, Σ-inseparability generalises conservative extensions and, therefore, our algorithms can be used to check whether one terminology is a conservative extension of another terminology. Algorithms checking conservative extensions can also be used to extract modules from ontologies (Cuenca Grau et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009; Konev et al., 2011). It would be of interest to explore applications of our inseparability testing algorithms to extract modules of terminologies and check conservativity. (2) Inseparability as defined in this paper does not mean that one terminology can be replaced by another terminology in every context. In various applications of inseparability for modularity it is important to ensure that if T1 and T2 are Σ-inseparable, then T1 ∪ T and T2 ∪ T are Σ-inseparable as well, for any ontology T . This is called the replacement property by Konev, Lutz, Walther, and Wolter (2009) and has been exploited and discussed, for example, in the work of Cuenca Grau et al. (2008) and of Kontchakov et al.",
      "startOffset" : 189,
      "endOffset" : 1361
    }, {
      "referenceID" : 10,
      "context" : "In other words, T ∪T ′ should be a conservative extension of T in the sense that the consequences of T ∪ T ′ in the signature of T should coincide with the consequences of T itself (Cuenca Grau et al., 2008; Ghilardi et al., 2006; Vescovo, Parsia, Sattler, & Schneider, 2011). As observed above already, Σ-inseparability generalises conservative extensions and, therefore, our algorithms can be used to check whether one terminology is a conservative extension of another terminology. Algorithms checking conservative extensions can also be used to extract modules from ontologies (Cuenca Grau et al., 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009; Konev et al., 2011). It would be of interest to explore applications of our inseparability testing algorithms to extract modules of terminologies and check conservativity. (2) Inseparability as defined in this paper does not mean that one terminology can be replaced by another terminology in every context. In various applications of inseparability for modularity it is important to ensure that if T1 and T2 are Σ-inseparable, then T1 ∪ T and T2 ∪ T are Σ-inseparable as well, for any ontology T . This is called the replacement property by Konev, Lutz, Walther, and Wolter (2009) and has been exploited and discussed, for example, in the work of Cuenca Grau et al. (2008) and of Kontchakov et al. (2010). The notions of inseparability introduced in this paper do not have the replacement property.",
      "startOffset" : 189,
      "endOffset" : 1393
    }, {
      "referenceID" : 16,
      "context" : "The case when L2 = 0 or L1 = 0, as well as the cases when L2 ends with one of AndL1, AndL2, AndR, Ex, DefL, DefR or PDefL are virtually the same as in the proof of Hofmann (2005). Assume D2 ends with Dom, and so its last sequent is of the form ∃r.",
      "startOffset" : 164,
      "endOffset" : 179
    } ],
    "year" : 2012,
    "abstractText" : "We study a logic-based approach to versioning of ontologies. Under this view, ontologies provide answers to queries about some vocabulary of interest. The difference between two versions of an ontology is given by the set of queries that receive different answers. We investigate this approach for terminologies given in the description logic EL extended with role inclusions and domain and range restrictions for three distinct types of queries: subsumption, instance, and conjunctive queries. In all three cases, we present polynomialtime algorithms that decide whether two terminologies give the same answers to queries over a given vocabulary and compute a succinct representation of the difference if it is nonempty. We present an implementation, CEX2, of the developed algorithms for subsumption and instance queries and apply it to distinct versions of Snomed CT and the NCI ontology.",
    "creator" : "TeX"
  }
}