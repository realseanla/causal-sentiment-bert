{
  "name" : "1312.6130.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Functional View of Strong Negation in Answer Set Programming",
    "authors" : [ "Michael Bartholomew", "Joohyung Lee" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The distinction between default negation and strong negation has been useful in answer set programming. In particular, it yields an elegant solution to the frame problem. The fact that block b stays at the same location l by inertia can be described by the rule\nıOn(b, l, t+1) ← ıOn(b, l, t), ınot ∼ıOn(b, l, t+1) (1)\nalong with the rule that describes the uniqueness of location values [Lifschitz, 2002],\n∼ıOn(b, l1, t) ← ıOn(b, l, t), l 6= l1 . (2)\nHere ‘∼’ is the symbol for strong negation that represents explicit falsity while ‘ınot’ is the symbol for default negation (negation as failure). Rule (1) asserts that without explicit evidence to the contrary, block b remains at location l. If we are given explicit conflicting information about the location of b at time t+1 then this conclusion will be defeated by rule (2), which asserts the uniqueness of location values.\nAn alternative representation of inertia, which uses choice rules instead of strong negation, was recently presented by Bartholomew and Lee [2012]. Instead of rule (1), they use the choice rule\n{ıOn(b, l, t+1)} ← ıOn(b, l, t) , (3)\nwhich states that “if b is at l at time t, then decide arbitrarily whether to assert that b is at l at time t+1.” Instead of rule (2), they write weaker rules for describing the functional\nar X\niv :1\n31 2.\n61 30\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nproperty of ıOn:\n← {ıOn(b, l, t) : Location(l)}0 (existence of location) (4) ← 2{ıOn(b, l, t) : Location(l)} (uniqueness of location), (5)\nwhich can be also combined into one rule: ← ınot 1{ıOn(b, l, t) : Location(l)}1 . In the absence of additional information about the location of block b at time t+1, asserting ıOn(b, l, t+1) is the only option, in view of the existence of location constraint (4). But if we are given conflicting information about the location of b at time t+1 then not asserting ıOn(b, l, t+1) is the only option, in view of the uniqueness of location constraint (5).\nRules (3), (4), and (5) together can be more succinctly represented in the language of [Bartholomew and Lee, 2012] by means of intensional functions. That is, the three rules can be replaced by one rule\n{ıLoc(b, t+1) = l} ← ıLoc(b, t) = l , (6)\nwhere ıLoc is an intensional function constant (the rule reads, “if block b is at location l at time t, by default, the block is at l at time t+1”). In fact, Corollary 2 of [Bartholomew and Lee, 2012] tells us how to eliminate intensional functions in favor of intensional predicates, justifying the equivalence between (6) and the set of rules (3), (4), and (5). The translation allows us to compute the language of [Bartholomew and Lee, 2012] using existing ASP solvers, such as SMODELS and GRINGO. However, DLV cannot be used because it does not accept choice rules. On the other hand, all these solvers accept rules (1) and (2), which contain strong negation.\nThe two representations of inertia involving intensional predicate ıOn do not result in the same answer sets. In the first representation, which uses strong negation, each answer set contains only one atom of the form ıOn(b, l, t) for each block b and each time t; for all other locations l′, negative literals ∼ıOn(b, l′, t) belong to the answer set. On the other hand, such negative literals do not occur in the answer sets of a program that follows the second representation, which yields fewer ground atoms. This difference can be well explained by the difference between the symmetric and the asymmetric views of predicates that Lifschitz described in his message to Texas Action Group, titled “Choice Rules and the Belief-Based View of ASP”: 1\nThe way I see it, in ASP programs we use predicates of two kinds, let’s call them “symmetric” and “asymmetric.” The fact that an object a does not have a property p is reflected by the presence of ∼p(a) in the answer set if p is “symmetric,” and by the absence of p(a) if p is “asymmetric.” In the second case, the strong negation of p is not used in the program at all.\nAccording to these terminologies, predicate ıOn is symmetric in the first representation, and asymmetric in the second representation.\nThis paper presents several technical results that help us understand the relationship between these two views. In this regard, it helps us to understand strong negation as a way of expressing intensional Boolean functions.\n1 http://www.cs.utexas.edu/users/vl/tag/choice discussion\n– Our first result provides an alternative account of strong negation in terms of Boolean intensional functions. For instance, (1) can be identified with\nıOn(b, l, t+1)= TRUE ← ıOn(b, l, t)= TRUE ∧ ¬(ıOn(b, l, t+1)= FALSE) ,\nand (2) can be identified with\nıOn(b, l1, t)= FALSE ← ıOn(b, l, t)= TRUE ∧ l 6= l1 .\nUnder complete interpretations, we show that minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of Boolean function values under the functional stable model semantics. In this sense, strong negation can be viewed as a mere disguise of Boolean functions.2 – We show how non-Boolean intensional functions can be eliminated in favor of Boolean functions. Combined with the result in the first bullet, this tells us a new way of turning the language of [Bartholomew and Lee, 2012] into traditional answer set programs with strong negation, so that system DLV, as well as SMODELS and GRINGO, can be used for computing the language of [Bartholomew and Lee, 2012]. As an example, it tells us how to turn (6) into the set of rules (1) and (2). – Lifschitz [2012] recently proposed “two-valued logic programs,” which modifies the traditional stable model semantics to represent complete information without distinguishing between strong negation and default negation. Using our result that views strong negation in terms of Boolean functions, we show that two-valued logic programs are in fact a special case of the functional stable model semantics in which every function is Boolean.\nWhile the main results are stated for the language of [Bartholomew and Lee, 2012], similar results hold with the language of [Cabalar, 2011] based on the relationship between the two languages studied in [Bartholomew and Lee, 2013]. Furthermore, we note that the complete interpretation assumption in the first bullet can be dropped if we instead refer to the language of [Cabalar, 2011], at the price of introducing partial interpretations.\nThe paper is organized as follows. In Section 2 we review the two versions of the stable model semantics, one that allows strong negation, but is limited to express intensional predicates only, and the other that allows both intensional predicates and intensional functions. As a special case of the latter we also present multi-valued propositional formulas under the stable model semantics. Section 3 shows how strong negation can be viewed in terms of Boolean functions. Section 4 shows how non-Boolean functions can be eliminated in favor of Boolean functions. Section 5 shows how Lifschitz’s two-valued logic programs can be viewed as a special case of the functional stable model semantics. Section 6 shows how strong negation can be represented in the language of [Cabalar, 2011]."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 Review: First-Order Stable Model Semantics and Strong Negation",
      "text" : "This review follows [Ferraris et al., 2011]. A signature is defined as in first-order logic, consisting of function constants and predicate constants. Function constants of arity 0\n2 It is also well-known that strong negation can be also viewed in terms of auxiliary predicate constants [Gelfond and Lifschitz, 1991].\nare also called object constants. We assume the following set of primitive propositional connectives and quantifiers:⊥ (falsity), ∧, ∨, →, ∀, ∃. The syntax of a formula is defined as in first-order logic. We understand ¬F as an abbreviation of F → ⊥.\nThe stable models of a sentence F relative to a list of predicates p = (p1, . . . , pn) are defined via the stable model operator with the intensional predicates p, denoted by SM[F ;p]. Let u be a list of distinct predicate variables u1, . . . , un of the same length as p. By u = p we denote the conjunction of the formulas ∀x(ui(x) ↔ pi(x)), where x is a list of distinct object variables of the same length as the arity of pi, for all i = 1, . . . , n. By u ≤ p we denote the conjunction of the formulas ∀x(ui(x)→ pi(x)) for all i = 1, . . . , n, and u < p stands for (u ≤ p) ∧ ¬(u = p). For any first-order sentence F , expression SM[F ;p] stands for the second-order sentence\nF ∧ ¬∃u((u < p) ∧ F ∗(u)),\nwhere F ∗(u) is defined recursively:\n– pi(t)∗ = ui(t) for any list t of terms; – F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain\nmembers of p; – (F ∧G)∗ = F ∗ ∧G∗; (F ∨G)∗ = F ∗ ∨G∗; – (F → G)∗ = (F ∗ → G∗) ∧ (F → G); – (∀xF )∗ = ∀xF ∗; (∃xF )∗ = ∃xF ∗.\nA model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies SM[F ;p].\nThe traditional stable models of a logic programΠ are identical to the Herbrand stable models of the FOL-representation of Π (i.e., the conjunction of the universal closures of implications corresponding to the rules).\nFerraris et al. [2011] incorporate strong negation into the stable model semantics by distinguishing between intensional predicates of two kinds, positive and negative. Each negative intensional predicate has the form ∼p, where p is a positive intensional predicate and ‘∼’ is a symbol for strong negation. In this sense, syntactically ∼ is not a logical connective, as it can appear only as a part of a predicate constant. An interpretation of the underlying signature is coherent if it satisfies the formula ¬∃x(p(x)∧ ∼p(x)), where x is a list of distinct object variables, for each negative predicate ∼p. We consider coherent interpretations only.\nExample 1 The following is a representation of the Blocks World in the syntax of logic programs:\n⊥ ← ıOn(b1, b, t), ıOn(b2, b, t) (b1 6= b2) ıOn(b, l, t + 1) ← ıMove(b, l, t)\n⊥ ← ıMove(b, l, t), ıOn(b1, b, t) ⊥ ← ıMove(b, b1, t), ıMove(b1, l, t)\nıOn(b, l, 0) ← ınot ∼ıOn(b, l, 0) ∼ıOn(b, l, 0) ← ınot ıOn(b, l, 0)\nıMove(b, l, t) ← ınot ∼ıMove(b, l, t) ∼ıMove(b, l, t) ← ınot ıMove(b, l, t) ıOn(b, l, t + 1) ← ıOn(b, l, t), ınot ∼ıOn(b, l, t + 1) ∼ıOn(b, l, t) ← ıOn(b, l1, t) (l 6= l1) .\n(7)\nHere ıOn and ıMove are intensional predicate constants, b, b1, b2 are variables ranging over the blocks, l, l1 are variables ranging over the locations (blocks and the table), and t is a variable ranging over the timepoints. The first rule asserts that at most one block can be on another block. The next three rules describe the effect and preconditions of action ıMove. The next four rules describe that fluent ıOn is initially exogenous, and action ıMove is exogenous at each time. The next rule describes inertia, and the last rule asserts that a block can be at most at one location."
    }, {
      "heading" : "2.2 Review: The Functional Stable Model Semantics",
      "text" : "The functional stable model semantics is defined by modifying the semantics in the previous section to allow “intensional” functions [Bartholomew and Lee, 2012]. For predicate symbols (constants or variables) u and c, we define u ≤ c as ∀x(u(x)→ c(x)). We define u = c as ∀x(u(x)↔ c(x)) if u and c are predicate symbols, and ∀x(u(x) = c(x)) if they are function symbols.\nLet c be a list of distinct predicate and function constants and let ĉ be a list of distinct predicate and function variables corresponding to c. We call members of c intensional constants. By cpred we mean the list of the predicate constants in c, and by ĉpred the list of the corresponding predicate variables in ĉ. We define ĉ < c as (ĉpred ≤ cpred)∧¬(ĉ = c) and SM[F ; c] as\nF ∧ ¬∃ĉ(ĉ < c ∧ F ∗(ĉ)),\nwhere F ∗(ĉ) is defined the same as the one in Section 2.1 except for the base case:\n– When F is an atomic formula, F ∗ is F ′∧F , where F ′ is obtained from F by replacing all intensional (function and predicate) constants in it with the corresponding (function and predicate) variables.\nIf c contains predicate constants only, this definition of a stable model reduces to the one in [Ferraris et al., 2011], also reviewed in Section 2.1.\nAccording to [Bartholomew and Lee, 2012], a choice formula {F} is an abbreviation of the formula F ∨ ¬F , which is also strongly equivalent to ¬¬F → F . A formula {t = t′}, where t contains an intensional function constant and t′ does not, represents that t takes the value t′ by default, as the following example demonstrates.\nExample 2 Let F1 be {f = 1}, which stands for (f = 1) ∨ ¬(f = 1), and I1 be an interpretation such that I1(f) = 1. Let’s assume that we consider only interpretations that map numbers to themselves. I1 is an f -stable model of F1: F ∗1 (f̂) is equivalent to ((f̂=1)∧(f=1))∨¬(f=1),3 which is further equivalent to (f̂=1) under the assumption I1. It is not possible to satisfy this formula by assigning f̂ a different value from I1(f). On the other hand, I2 such that I2(f) = 2 is not f -stable since F ∗1 (f̂) is equivalent to > under I2, so that it is possible to satisfy this formula by assigning f̂ a different value from I2(f). If we let F2 be {f = 1} ∧ (f = 2), then I2 is a f -stable of F2, but I1 is not: F ∗2 (f̂) is equivalent to f̂=2 under I2, so that f̂ has to map to 2 as well. This example illustrates the nonmonotonicity of the semantics.\n3 It holds that (¬F )∗ is equivalent to ¬F .\nExample 3 The Blocks World can be described in this language as follows. For readability, we write in a logic program like syntax:\n⊥ ← ıLoc(b1, t)=b ∧ ıLoc(b2, t)=b ∧ (b1 6= b2) ıLoc(b, t+1)= l ← ıMove(b, l, t)\n⊥ ← ıMove(b, l, t) ∧ ıLoc(b1, t)=b ⊥ ← ıMove(b, b1, t) ∧ ıMove(b1, l, t)\n{ıLoc(b, 0)= l} {ıMove(b, l, t)}\n{ıLoc(b, t+1)= l} ← ıLoc(b, t)= l .\nHere ıLoc is a function constant. The last rule is a default formula that describes the commonsense law of inertia. The stable models of this program are the models of SM[F ; ıLoc, ıMove], where F is the FOL-representation of the program."
    }, {
      "heading" : "2.3 Review: Stable Models of Multi-Valued Propositional Formulas",
      "text" : "The following is a review of the stable model semantics of multi-valued propositional formulas from [Bartholomew and Lee, 2012], which can be viewed as a special case of the functional stable model semantics in the previous section.\nThe syntax of multi-valued propositional formulas is given in [Ferraris et al., 2011]. A multi-valued propositional signature is a set σ of symbols called constants, along with a nonempty finite set ıDom(c) of symbols, disjoint from σ, assigned to each constant c. We call ıDom(c) the domain of c. A Boolean constant is one whose domain is the set {TRUE, FALSE}. An atom of a signature σ is an expression of the form c=v (“the value of c is v”) where c ∈ σ and v ∈ ıDom(c). A (multi-valued propositional) formula of σ is a propositional combination of atoms.\nA (multi-valued propositional) interpretation of σ is a function that maps every element of σ to an element of its domain. An interpretation I satisfies an atom c=v (symbolically, I |= c=v) if I(c) = v. The satisfaction relation is extended from atoms to arbitrary formulas according to the usual truth tables for the propositional connectives. I is a model of a formula if it satisfies the formula.\nThe reduct F I of a multi-valued propositional formula F relative to a multi-valued propositional interpretation I is the formula obtained from F by replacing each maximal subformula that is not satisfied by I with ⊥. Interpretation I is a stable model of F if I is the only interpretation satisfying F I .\nExample 4 Similar to Example 2, consider the signature σ = {f} such that ıDom(c) = {1, 2, 3}. Let I1 be an interpretation such that I1(c) = 1, and I2 be such that I2(c) = 2. Recall that {f=1} is shorthand for (f=1)∨¬(f=1). The reduct of this formula relative to I1 is (f =1) ∨ ⊥, and I1 is the only model of the reduct. On the other hand, the reduct of {f = 1} relative to I2 is (⊥ ∨ ¬⊥) and I2 is not its unique model. Also, the reduct of {f = 1} ∧ (f = 2) relative to I1 is (⊥ ∨ ¬⊥) ∧ ⊥ and I1 is not a model. The reduct of {f = 1} ∧ (f = 2) relative to I2 is (⊥ ∨ ¬⊥) ∧ (f = 2), and I2 is the only model of the reduct."
    }, {
      "heading" : "3 Relating Strong Negation to Boolean Functions",
      "text" : ""
    }, {
      "heading" : "3.1 Representing Strong Negation in Multi-Valued Propositional Formulas",
      "text" : "Given a traditional propositional logic programΠ of a signature σ [Gelfond and Lifschitz, 1991], we identify σ with the multi-valued propositional signature whose constants are the\nsame symbols from σ and every constant is Boolean. By Πmv we mean the multi-valued propositional formula that is obtained from Π by replacing negative literals of the form ∼p with p = FALSE and positive literals of the form p with p = TRUE.\nWe say that a set X of literals from σ is complete if, for each atom a ∈ σ, either a or ∼a is in X . We identify a complete set of literals from σ with the corresponding multi-valued propositional interpretation.\nTheorem 1 A complete set of literals is an answer set of Π in the sense of [Gelfond and Lifschitz, 1991] iff it is a stable model of Πmv in the sense of [Bartholomew and Lee, 2012].\nThe theorem tells us that checking the minimality of positive and negative literals under the traditional stable model semantics is essentially the same as checking the uniqueness of corresponding function values under the stable model semantics from [Bartholomew and Lee, 2012].\nExample 5 Consider the program that describes a simple transition system consisting of two states depending on whether fluent p is true or false, and an action that makes p true (subscripts 0 and 1 represent time stamps).\np0 ← ınot ∼p0 p1 ← a ∼p0 ← ınot p0\np1 ← p0, ınot ∼p1 a ← ınot ∼a ∼p1 ← ∼p0, ınot p1 . ∼a ← ınot a\n(8)\nThe program has four answer sets, each of which corresponds to one of the four edges of the transition system. For instance, {∼p0, a, p1} is an answer set. This program can be encoded in the input languages of GRINGO and DLV. In the input language of DLV, which allows disjunctions in the head of a rule, the four rules in the first column can be succinctly replaced by\np0∨ ∼p0 a∨ ∼a . According to Theorem 1, the stable models of this program are the same as the stable models of the following multi-valued propositional formula (written in a logic program style syntax; ‘¬’ represents default negation):\np0 = TRUE ← ¬(p0 = FALSE) p0 = FALSE ← ¬(p0 = TRUE)\na= TRUE ← ¬(a= FALSE) a= FALSE ← ¬(a= TRUE)\np1 = TRUE ← a= TRUE\np1 = TRUE ← p0 = TRUE ∧ ¬(p1 = FALSE) p1 = FALSE ← p0 = FALSE ∧ ¬(p1 = TRUE) ."
    }, {
      "heading" : "3.2 Relation among Strong Negation, Default Negation, Choice Rules and Boolean Functions",
      "text" : "In certain cases, strong negation can be replaced by default negation, and furthermore the expression can be rewritten in terms of choice rules, which often yields a succinct representation.\nThe following theorem, which extends the Theorem on Double Negation from [Ferraris et al., 2009] to allow intensional functions, presents a condition under which equivalent transformations in classical logic preserve stable models.\nTheorem 2 Let F be a sentence, let c be a list of predicate and function constants, and let I be a (coherent) interpretation. Let F ′ be the sentence obtained from F by replacing a subformula ¬H with ¬H ′ such that I |= ∀̃(H ↔ H ′). Then\nI |= SM[F ; c] iff I |= SM[F ′; c] .\nWe say that an interpretation is complete on a predicate p if it satisfies ∀x(p(x)∨ ∼p(x)). It is clear that, for any complete interpretation I , we have I |= ∼p(t) iff I |= ¬p(t). This fact allows us to use Theorem 2 to replace strong negation occurring in H with default negation.\nExample 5 continued Each answer set of the first program in Example 5 is complete. In view of Theorem 2, the first two rules can be rewritten as p0 ← ınot ınot p0 and ∼ p0 ← ınot ınot ∼ p0, which can be further abbreviated as choice rules {p0} and {∼p0}. Consequently, the whole program can be rewritten using choice rules as\n{p0} {∼p0}\n{a} {∼a}\np1 ← a\n{p1} ← p0 {∼p1} ← ∼p0 .\nSimilarly, since I |= (p0 = FALSE) iff I |= ¬(p0 = TRUE), in view of Theorem 2, the first rule of the second program in Example 5 can be rewritten as p0 = TRUE ← ¬¬(p0 = TRUE) and further as {p0 = TRUE}. This transformation allows us to rewrite the whole program as\n{p0 =B} {a=B}\np1 = TRUE ← a= TRUE {p1 =B} ← p0 =B ,\nwhere B ranges over {TRUE, FALSE}. This program represents the transition system more succinctly than program (8)."
    }, {
      "heading" : "3.3 Representing Strong Negation by Boolean Functions in the First-Order Case",
      "text" : "Theorem 1 can be extended to the first-order case as follows. Let f be a function constant. A first-order formula is called f -plain if each atomic formula\n– does not contain f , or – is of the form f(t) = u where t is a tuple of terms not containing f , and u is a term\nnot containing f .\nFor example, f=1 is f -plain, but each of p(f), g(f) = 1, and 1=f is not f -plain. For a list c of predicate and function constants, we say that a first-order formula F is c-plain if F is f -plain for each function constant f in c. Roughly speaking, c-plain formulas do not allow the functions in c to be nested in another predicate or function, and at most one function in c is allowed in each atomic formula. For example, f = g is not (f, g)-plain, and neither is f(g) = 1→ g = 1.\nLet F be a formula whose signature contains both positive and negative predicate constants p and ∼p. Formula F (p,∼p)b is obtained from F as follows:\n– in the signature of F , replace p and ∼p with a new intensional function constant b of arity n, where n is the arity of p (or∼p), and add two non-intensional object constants TRUE and FALSE; – replace every occurrence of ∼p(t), where t is a list of terms, with b(t) = FALSE, and then replace every occurrence of p(t) with b(t) = TRUE.\nBy ıBCb (“Boolean Constraint on b”) we denote the conjunction of the following formulas, which asserts that b is a Boolean function:\nTRUE 6= FALSE , (9)\n¬¬∀x(b(x) = TRUE ∨ b(x) = FALSE) ,\nwhere x is a list of distinct object variables.\nTheorem 3 Let c be a set of predicate and function constants, and let F be a c-plain formula. Formulas\n∀x((p(x)↔ b(x)= TRUE) ∧ (∼p(x)↔ b(x)= FALSE)), (10)\nand ıBCb entail SM[F ; p,∼p, c]↔ SM[F (p,∼p)b ; b, c] .\nIf we drop the requirement that F be c-plain, the statement does not hold as in the following example demonstrates.\nExample 6 Take c as (f, g) and let F be p(f)∧ ∼ p(g). F (p,∼p)b is b(f) = TRUE ∧ b(g) = FALSE. Consider the interpretation I whose universe is {1, 2} such that I contains p(1),∼p(2) and with the mappings bI(1) = TRUE, bI(2) = FALSE, f I = 1, gI = 2. I certainly satisfies ıBCb and (10). I also satisfies SM[F ; p,∼p, f, g] but does not satisfy SM[F (p,∼p)b ; b, f, g]: we can let I be b̂\nI(1) = FALSE, b̂I(2) = TRUE, f̂ I = 2, ĝI = 1 to satisfy both (̂b, f̂ , ĝ) < (b, f, g) and (F (p,∼p)b ) ∗(̂b, f̂ , ĝ), which is\nb(f) = TRUE ∧ b̂(f̂) = TRUE ∧ b(g) = FALSE ∧ b̂(ĝ) = FALSE.\nNote that any interpretation that satisfies both (10) and ıBCb is complete on p. Theorem 3 tells us that, for any interpretation I that is complete on p, minimizing the extents of both p and ∼p has the same effect as ensuring that the corresponding Boolean function b have a unique value.\nThe following corollary shows that there is a 1–1 correspondence between the stable models of F and the stable models of F (p,∼p)b . For any interpretation I of the signature of F that is complete on p, by I(p,∼p)b we denote the interpretation of the signature of F (p,∼p) b obtained from I by replacing the relation pI with function bI such that\nbI(ξ1, . . . , ξn) = TRUE I if pI(ξ1, . . . , ξn) = TRUE; bI(ξ1, . . . , ξn) = FALSE I if (∼p)I(ξ1, . . . , ξn) = TRUE .\n(Notice that we overloaded the symbols TRUE and FALSE: object constants on one hand, and truth values on the other hand.) Since I is complete on p and coherent, bI is welldefined. We also require that I(p,∼p)b satisfy (9). Consequently, I (p,∼p) b satisfies ıBCb.\nCorollary 1 Let c be a set of predicate and function constants, and let F be a c-plain sentence. (I) An interpretation I of the signature of F that is complete on p is a model of SM[F ; p,∼p, c] iff I(p,∼p)b is a model of SM[F (p,∼p) b ; b, c]. (II) An interpretation J of the signature of F (p,∼p)b is a model of SM[F (p,∼p) b ∧ ıBCb; b, c] iff J = I (p,∼p) b for some model I of SM[F ; p,∼p, c].\nThe other direction, eliminating Boolean intensional functions in favor of symmetric predicates, is similar as we show in the following.\nLet F be a (b, c)-plain formula such that every atomic formula containing b has the form b(t) = TRUE or b(t) = FALSE, where t is any list of terms (not containing members from (b, c)). Formula F b(p,∼p) is obtained from F as follows:\n– in the signature of F , replace b with predicate constants p and ∼p, whose arities are the same as that of b; – replace every occurrence of b(t) = TRUE, where t is any list of terms, with p(t), and b(t) = FALSE with ∼p(t).\nTheorem 4 Let c be a set of predicate and function constants, let b be a function constant, and let F be a (b, c)-plain formula such that every atomic formula containing b has the form b(t) = TRUE or b(t) = FALSE. Formulas (10) and ıBCb entail\nSM[F ; b, c]↔ SM[F b(p,∼p); p,∼p, c] .\nThe following corollary shows that there is a 1–1 correspondence between the stable models of F and the stable models of F b(p,∼p). For any interpretation I of the signature of F that satisfies ıBCb, by I b(p,∼p) we denote the interpretation of the signature of F b (p,∼p) obtained from I by replacing the function bI with predicate pI such that\npI(ξ1, . . . , ξn) = TRUE iff bI(ξ1, . . . , ξn) = TRUEI ; (∼p)I(ξ1, . . . , ξn) = TRUE iff bI(ξ1, . . . , ξn) = FALSEI .\nCorollary 2 Let c be a set of predicate and function constants, let b be a function constant, and let F be a (b, c)-plain sentence such that every atomic formula containing b has the form b(t) = TRUE or b(t) = FALSE. (I) An interpretation I of the signature of F is a model of SM[F ∧ ıBCb; b, c] iff I b(p,∼p) is a model of SM[F b (p,∼p); p,∼p, c]. (II) An interpretation J of the signature of F b(p,∼p) is a model of SM[F b\n(p,∼p); p,∼p, c] iff J = I b(p,∼p) for some model I of SM[F ∧ ıBCb; b, c].\nAn example of this corollary is shown in the next section."
    }, {
      "heading" : "4 Representing Non-Boolean Functions Using Strong Negation",
      "text" : "In this section, we show how to eliminate non-Boolean intensional functions in favor of Boolean intensional functions. Combined with the method in the previous section, it gives us a systematic method of representing non-Boolean intensional functions using strong negation."
    }, {
      "heading" : "4.1 Eliminating non-Boolean Functions in Favor of Boolean Functions",
      "text" : "Let F be an f -plain formula. Formula F fb is obtained from F as follows:\n– in the signature of F , replace f with a new boolean intensional function b of arity n+ 1 where n is the arity of f ; – replace each subformula f(t) = c with b(t, c) = TRUE.\nBy ıUEb, we denote the following formulas that preserve the functional property:\n∀xyz(y 6= z ∧ b(x, y) = TRUE → b(x, z) = FALSE),\n¬¬∀x∃y(b(x, y) = TRUE),\nwhere x is a n-tuple of variables and all variables in x, y, and z are pairwise distinct.\nTheorem 5 For any f -plain formula F ,\n∀xy ( (f(x) = y ↔ b(x, y)= TRUE) ∧ (f(x) 6= y ↔ b(x, y)= FALSE) ) and ∃xy(x 6= y) entail\nSM[F ; f, c] ↔ SM[F fb ∧ ıUEb; b, c] .\nBy Ifb , we denote the interpretation of the signature of F f b obtained from I by replacing\nthe mapping f I with the mapping bI such that\nbI(ξ1, . . . , ξn, ξn+1) = TRUE I if f I(ξ1, . . . , ξn) = ξn+1 bI(ξ1, . . . , ξn, ξn+1) = FALSE I otherwise.\nCorollary 3 Let F be an f -plain sentence. (I) An interpretation I of the signature of F that satisfies ∃xy(x 6= y) is a model of SM[F ; f, c] iff Ifb is a model of SM[F f b ∧ ıUEb; b, c]. (II) An interpretation J of the signature of F f b that satisfies ∃xy(x 6= y) is a model of SM[F fb ∧ ıUEb; b, c] iff J = I f b for some model I of SM[F ; f, c].\nExample 3 continued In the program in Example 3, we eliminate non-Boolean function ıLoc in favor of Boolean function ıOn as follows. The last two rules are ıUEOn.\n⊥ ← ıOn(b1, b, t)= TRUE ∧ ıOn(b2, b, t)= TRUE ∧ b1 6= b2 ıOn(b, l, t + 1)= TRUE ← ıMove(b, l, t)\n⊥ ← ıMove(b, l, t) ∧ ıOn(b1, b, t)= TRUE ⊥ ← ıMove(b, b1, t) ∧ ıMove(b1, l, t)\n{ıOn(b, l, 0)= TRUE} {ıMove(b, l, t)}\n{ıOn(b, l, t + 1)= TRUE} ← ıOn(b, l, t)= TRUE ıOn(b, l, t)= FALSE ← ıOn(b, l1, t)= TRUE ∧ l 6= l1\n⊥ ← ınot ∃l(ıOn(b, l, t)= TRUE) .\nFor this program, it is not difficult to check that the last rule is redundant. Indeed, since the second to the last rule is the only rule that has ıOn(b, l, t) = FALSE in the head, one can check that any model that does not satisfy ∃l(ıOn(b, l, t)= TRUE) is not stable even if we drop the last rule.\nCorollary 2 tells us that this program can be represented by an answer set program containing strong negation (with the redundant rule dropped).\n⊥ ← ıOn(b1, b, t), ıOn(b2, b, t) (b1 6= b2) ıOn(b, l, t + 1) ← ıMove(b, l, t)\n⊥ ← ıMove(b, l, t), ıOn(b1, b, t) ⊥ ← ıMove(b, b1, t), ıMove(b1, l, t)\n{ıOn(b, l, 0)} {ıMove(b, l, t)} {ıOn(b, l, t + 1)} ← ıOn(b, l, t) ∼ıOn(b, l, t) ← ıOn(b, l1, t) (l 6= l1) .\n(11)\nLet us compare this program with program (7). Similar to the explanation in Example 5 (continued), the 5th and the 7th rules of (7) can be represented using choice rules, which are the same as the 5th and the 6th rules of (11). The 6th and the 8th rules of (7) represent the closed world assumption. We can check that adding these rules to (11) extends the answer sets of (7) in a conservative way with the definition of the negative literals. This tells us that the answer sets of the two programs are in a 1-1 correspondence.\nAs the example explains, non-Boolean functions can be represented using strong negation by composing the two translations, first eliminating non-Boolean functions in favor of Boolean functions as in Corollary 3 and then eliminating Boolean functions in favor of predicates as in Corollary 2. In the following we state this composition.\nLet F be an f -plain formula where f is an intensional function constant. Formula F fp is obtained from F as follows:\n– in the signature of F , replace f with two new intensional predicates p and ∼p of arity n+ 1 where n is the arity of f ; – replace each subformula f(t) = c with p(t, c).\nBy ıUEp, we denote the following formulas that preserve the functional property:\n∀xyz(y 6= z ∧ p(x, y)→∼p(x, z)) , ¬¬∀x∃y p(x, y) ,\nwhere x is an n-tuple of variables and all variables in x, y, z are pairwise distinct.\nTheorem 6 For any (f, c)-plain formula F , formulas\n∀xy(f(x) = y ↔ p(x, y)), ∀xy(f(x) 6= y ↔∼p(x, y)), ∃xy(x 6= y)\nentail SM[F ; f, c]↔ SM[F fp ∧ ıUEp; p,∼p, c] .\nBy I f(p,∼p), we denote the interpretation of the signature of F f (p,∼p) obtained from I by replacing the function f I with the relation pI that consists of the tuples 〈ξ1, . . . , ξn, f I(ξ1, . . . , ξn)〉 for all ξ1, . . . , ξn from the universe of I . We then also add the set (∼p)I that consists of the tuples 〈ξ1, . . . , ξn, ξn+1〉 for all ξ1, . . . , ξn, ξn+1 from the universe of I that do not occur in the set pI .\nCorollary 4 Let F be an (f, c)-plain sentence. (I) An interpretation I of the signature of F that satisfies ∃xy(x 6= y) is a model of SM[F ; f, c] iff I f(p,∼p) is a model of SM[F fp ∧ ıUEp; p,∼p, c]. (II) An interpretation J of the signature of F fp that satisfies ∃xy(x 6= y) is a model of SM[F fp ∧ ıUEp; p,∼p, c] iff J = I f (p,∼p) for some model I of SM[F ; f, c].\nTheorem 6 and Corollary 4 are similar to Theorem 8 and Corollary 2 from [Bartholomew and Lee, 2012]. The main difference is that the latter statements refer to the constraint called ıUECp that is weaker than ıUEp. For instance, the elimination method from [Bartholomew and Lee, 2012] turns the Blocks World in Example 3 into almost the same program as (11) except that the last rule is turned into the constraint ıUECOn:\n← ıOn(b, l, t) ∧ ıOn(b, l1, t) ∧ l 6= l1 . (12)\nIt is clear that the stable models of F fp ∧ıUEp are under the symmetric view, and the stable models of F fp ∧ ıUECp are under the asymmetric view. To see how replacing ıUEOn by ıUECOn turns the symmetric view to the asymmetric view, first observe that adding (12) to program (11) does not affect the stable models of the program. Let’s call this program Π . It is easy to see that Π is a conservative extension of the program that is obtained from Π by deleting the rule with ∼ıOn(b, l, t) in the head."
    }, {
      "heading" : "5 Relating to Lifschitz’s Two-Valued Logic Programs",
      "text" : "Lifschitz [2012] presented a high level definition of a logic program that does not contain explicit default negation, but can handle nonmonotonic reasoning in a similar style as in Reiter’s default logic. In this section we show how his formalism can be viewed as a special case of multi-valued propositional formulas under the stable model semantics in which every function is Boolean."
    }, {
      "heading" : "5.1 Review: Two-Valued Logic Programs",
      "text" : "Let σ be a signature in propositional logic. A two-valued rule is an expression of the form\nL0 ← L1, . . . , Ln : F (13)\nwhere L0, . . . , Ln are propositional literals formed from σ and F is a propositional formula of signature σ.\nA two-valued program Π is a set of two-valued rules. An interpretation I is a function from σ to {TRUE, FALSE}. The reduct of a program Π relative to an interpretation I , denoted ΠI , is the set of rules L0 ← L1, . . . , Ln corresponding to the rules (13) of Π for which I |= F . Interpretation I is a stable model of Π if it is a minimal model of ΠI .\nExample 7 a ← : a, ¬a ← : ¬a, b ← a : > (14)\nThe reduct of this program relative to {a, b} consists of rules a and b ← a. Interpretation {a, b} is the minimal model of the reduct, so that it is a stable model of the program.\nAs described in [Lifschitz, 2012], if F in every rule (13) has the form of conjunctions of literals, then the two-valued logic program can be turned into a traditional answer set\nprogram containing strong negation when we consider complete answer sets only. For instance, program (14) can be turned into\na ← ınot ∼a, ∼a ← ınot a, b ← a .\nThis program has two answer sets, {a, b} and∼a, and only the complete answer set {a, b} corresponds to the stable model found in Example 7."
    }, {
      "heading" : "5.2 Translation into SM with Boolean Functions",
      "text" : "Given a two-valued logic program Π of a signature σ, we identify σ with the multi-valued propositional signature whose constants are from σ and the domain of every constant is Boolean values {TRUE, FALSE}. For any propositional formula G, ıTr(G) is obtained fromG by replacing every negative literal∼A withA= FALSE and every positive literalA with A= TRUE. By ıtv2sm(Π) we denote the multi-valued propositional formula which is defined as the conjunction of\n¬¬ıTr(F ) ∧ ıTr(L1) ∧ · · · ∧ ıTr(Ln)→ ıTr(L0)\nfor each rule (13) in Π . For any interpretation I of σ, we obtain the multi-valued interpretation I ′ from I as follows. For each atom A in σ,\nI ′(A) = { TRUE if I |= A FALSE if I |= ¬A\nTheorem 7 For any two-valued logic program Π , an interpretation I is a stable model of Π in the sense of [Lifschitz, 2012] iff I ′ is a stable model of ıtv2sm(Π) in the sense of [Bartholomew and Lee, 2012].\nExample 7 continued For the program Π in Example 7, ıtv2sm(Π) is the following multi-valued propositional formula:( ¬¬(a= TRUE)→ a= TRUE ) ∧ ( ¬¬(a= FALSE)→ a= FALSE ) ∧ ( a= TRUE → b= TRUE ) .\nAccording to [Bartholomew and Lee, 2012], this too has only one stable model in which a and b are both mapped to TRUE, corresponding to the only stable model of Π according to Lifschitz.\nConsider extending the rules (13) to contain variables. It is not difficult to see that the translation ıtv2sm(Π) can be straightforwardly extended to non-ground programs. This accounts for providing the semantics of the first-order extension of two-valued logic programs."
    }, {
      "heading" : "6 Strong Negation and the Cabalar Semantics",
      "text" : "There are other stable model semantics of intensional functions. Theorem 5 from [Bartholomew and Lee, 2013] states that the semantics by Bartholomew and Lee [2013] coincides with the semantics by Cabalar [2011] on c-plain formulas. Thus several theorems in this note stated for the Bartholomew-Lee semantics hold also under the Cabalar semantics.\nA further result holds with the Cabalar semantics since it allows functions to be partial. This provides extensions of Theorem 3 and Corollary 1, which do not require the interpretations to be complete. Below we state this result. Due to lack of space, we refer the reader\nto [Bartholomew and Lee, 2013] for the definition of CBL, which is the second-order expression used to define the Cabalar semantics.\nSimilar to ıBCb in Section 3.3, by ıBC ′b we denote the conjunction of the following formulas:\nTRUE 6= FALSE, (15)\n¬¬∀x(b(x) = TRUE ∨ b(x) = FALSE ∨ b(x) 6= b(x)),\nwhere x is a list of distinct object variables.4\nTheorem 8 Let c be a set of predicate constants, and let F be a formula. Formulas\n∀x((p(x)↔ b(x)= TRUE)∧(∼p(x)↔ b(x)= FALSE)∧(¬p(x)∧¬∼p(x)↔ b(x) 6= b(x)),\nand ıBC ′b entail 5\nSM[F ; p,∼p, c]↔ CBL[F (p,∼p)b ; b, c] .\nThe following corollary shows that there is a 1–1 correspondence between the stable models of F and the stable models of F (p,∼p)b .\n6 For any interpretation I of the signature of F , by I(p,∼p)b we denote the interpretation of the signature of F (p,∼p) b obtained from I by replacing the relation pI with function bI such that\nbI(ξ) = TRUEI if pI(ξ) = TRUE ; bI(ξ) = FALSEI if (∼p)I(ξ) = TRUE ; bI(ξ) = u if pI(ξ) = (∼p)I(ξ) = FALSE .\nSince I is coherent, bI is well-defined. We also require that I(p,∼p)b satisfy (15). Consequently, I(p,∼p)b satisfies ıBC ′ b.\nCorollary 5 Let F be a sentence, and let c be a set of predicate constants. (I) An interpretation I of the signature of F is a model of SM[F ; p,∼p, c] iff I(p,∼p)b is a model of CBL[F (p,∼p)b ; b, c]. (II) An interpretation J of the signature of F (p,∼p) b is a model of CBL[F (p,∼p)b ∧ ıBC ′ b; b, c] iff J = I (p,∼p) b for some model I of SM[F ; p,∼p, c]."
    }, {
      "heading" : "7 Conclusion",
      "text" : "In this note, we showed that, under complete interpretations, symmetric predicates using strong negation can be alternatively expressed in terms of Boolean intensional functions in the language of [Bartholomew and Lee, 2012]. They can also be expressed in terms of Boolean intensional functions in the language of [Cabalar, 2011], but without requiring the complete interpretation assumption, at the price of relying on the notion of partial interpretations.\nSystem CPLUS2ASP [Casolary and Lee, 2011; Babb and Lee, 2013] turns action language C+ into answer set programs containing asymmetric predicates. The translation in\n4 Under partial interpretations, b(t) 6= b(t) is true if b(t) is undefined. See [Cabalar, 2011; Bartholomew and Lee, 2013] for more details. 5 The entailment is under partial interpretations and satisfaction. 6 Recall the notation defined in Section 3.3.\nthis paper that eliminates intensional functions in favor of symmetric predicates provides an alternative method of computing C+ using ASP solvers.\nAcknowledgements: We are grateful to Vladimir Lifschitz for bringing attention to this subject, to Gregory Gelfond for useful discussions related to this paper, and to anonymous referees for useful comments. This work was partially supported by the National Science Foundation under Grant IIS-0916116 and by the South Korea IT R&D program MKE/KIAT 2010-TD-300404-001."
    } ],
    "references" : [ {
      "title" : "CPLUS2ASP: Computing action language C+ in answer set programming",
      "author" : [ "Babb", "Lee", "2013. Joseph Babb", "Joohyung Lee" ],
      "venue" : "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),",
      "citeRegEx" : "Babb et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Babb et al\\.",
      "year" : 2013
    }, {
      "title" : "Stable models of formulas with intensional functions",
      "author" : [ "Bartholomew", "Lee", "2012. Michael Bartholomew", "Joohyung Lee" ],
      "venue" : "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Bartholomew et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Bartholomew et al\\.",
      "year" : 2012
    }, {
      "title" : "On the stable model semantics for intensional functions",
      "author" : [ "Bartholomew", "Lee", "2013. Michael Bartholomew", "Joohyung Lee" ],
      "venue" : "TPLP,",
      "citeRegEx" : "Bartholomew et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bartholomew et al\\.",
      "year" : 2013
    }, {
      "title" : "Functional answer set programming",
      "author" : [ "Cabalar", "2011. Pedro Cabalar" ],
      "venue" : "TPLP, 11(2-3):203–233,",
      "citeRegEx" : "Cabalar and Cabalar.,? \\Q2011\\E",
      "shortCiteRegEx" : "Cabalar and Cabalar.",
      "year" : 2011
    }, {
      "title" : "Representing the language of the causal calculator in answer set programming",
      "author" : [ "Casolary", "Lee", "2011. Michael Casolary", "Joohyung Lee" ],
      "venue" : "In ICLP (Technical Communications),",
      "citeRegEx" : "Casolary et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Casolary et al\\.",
      "year" : 2011
    }, {
      "title" : "Symmetric splitting in the general theory of stable models",
      "author" : [ "Ferraris et al", "2009. Paolo Ferraris", "Joohyung Lee", "Vladimir Lifschitz", "Ravi Palla" ],
      "venue" : "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "al. et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2009
    }, {
      "title" : "Stable models and circumscription",
      "author" : [ "Ferraris et al", "2011. Paolo Ferraris", "Joohyung Lee", "Vladimir Lifschitz" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "al. et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2011
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "Gelfond", "Lifschitz", "1991. Michael Gelfond", "Vladimir Lifschitz" ],
      "venue" : "New Generation Computing,",
      "citeRegEx" : "Gelfond et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelfond et al\\.",
      "year" : 1991
    }, {
      "title" : "Answer set programming and plan generation",
      "author" : [ "Lifschitz", "2002. Vladimir Lifschitz" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Lifschitz and Lifschitz.,? \\Q2002\\E",
      "shortCiteRegEx" : "Lifschitz and Lifschitz.",
      "year" : 2002
    }, {
      "title" : "Two-valued logic programs",
      "author" : [ "Lifschitz", "2012. Vladimir Lifschitz" ],
      "venue" : "In ICLP (Technical Communications),",
      "citeRegEx" : "Lifschitz and Lifschitz.,? \\Q2012\\E",
      "shortCiteRegEx" : "Lifschitz and Lifschitz.",
      "year" : 2012
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "The distinction between strong negation and default negation has been useful in answer set programming. We present an alternative account of strong negation, which lets us view strong negation in terms of the functional stable model semantics by Bartholomew and Lee. More specifically, we show that, under complete interpretations, minimizing both positive and negative literals in the traditional answer set semantics is essentially the same as ensuring the uniqueness of Boolean function values under the functional stable model semantics. The same account lets us view Lifschitz’s two-valued logic programs as a special case of the functional stable model semantics. In addition, we show how non-Boolean intensional functions can be eliminated in favor of Boolean intensional functions, and furthermore can be represented using strong negation, which provides a way to compute the functional stable model semantics using existing ASP solvers. We also note that similar results hold with the functional stable model semantics by Cabalar.",
    "creator" : "LaTeX with hyperref package"
  }
}