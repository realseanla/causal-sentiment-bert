{
  "name" : "1602.05828.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A General Modifier-based Framework for Inconsistency-Tolerant Query Answering",
    "authors" : [ "Jean François Baget", "Salem Benferhat", "Zied Bouraoui", "Madalina Croitoru", "Marie-Laure Mugnier", "Odile Papini", "Swan Rocher", "Karim Tabia" ],
    "emails" : [ "baget@lirmm.fr", "benferhat@cril.fr", "zied.bouraoui@lsis.fr", "croitoru@lirmm.fr", "mugnier@lirmm.fr", "odile.papini@amu-univ.fr", "rocher@lirmm.fr", "tabia@cril.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 2.\n05 82\n8v 1\n[ cs\n.A I]\n1 8\nFe b\n20 16\nIntroduction In this paper we place ourselves in the context of OntologyBased Data Access (Poggi et al. 2008) and we address the problem of query answering when the assertional base (which stores data) is inconsistent with the ontology (which represents generic knowledge about a domain). Existing work in this area studied different inconsistencytolerant inference relations, called semantics, which consist of getting rid of inconsistency by first computing a set of consistent subsets of the assertional base, called repairs, that restore consistency w.r.t the ontology, then using them to perform query answering. Most of these proposals, inspired by database approaches e.g. (Arenas, Bertossi, and Chomicki 1999) or propositional logic approaches e.g. (Benferhat, Dubois, and Prade 1997), were introduced for the lightweight description logic DL-Lite e.g. (Lembo et al. 2015). Other description logics e.g. (Rosati 2011) or existential rule e.g. (Lukasiewicz et al. 2015) have also been considered. In this paper, we use existential rules e.g.(Baget et al. 2011) as ontology language that generalizes lightweight description logics.\nThe main contribution of this paper consists in setting up a general framework that unifies previous proposals and extends the state of the art with new semantics. The idea behind our framework is to distinguish between the way data assertions are virtually distributed (notion of modifiers) and inference strategies. An inconsistency-tolerant semantics is then naturally defined by a modifier and an inference strategy. We also propose a classification of the productivity of\nCopyright © 2016, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nhereby obtained semantics by sound and complete conditions relying on modifier inclusion and inference strategy order. The objective of framework is to establish a methodology for inconsistency handling which, by distinguishing between modifiers and strategies, allows not only to cover existing semantics, but also to easily define new ones, and to study different kinds of their properties.\nPreliminaries We consider first-order logical languages without functional symbols, hence a term is a variable or a constant. An atom is of the form p(t1, . . . , tk) where p is a predicate of arity k, and the ti are terms. Given an atom or a set of atoms E, terms(E) denotes the set of terms occurring in E. A (factual) assertion is an atom without variables.\nA conjunctive query is an existentially quantified conjunction of atoms. For readability, we restrict our focus to Boolean conjunctive queries, which are closed formulas. However the framework and the obtained results can be directly extended to general conjunctive queries. In the following, by query, we mean a Boolean conjunctive query. Given a set of assertions A and a query q, the answer to q over A is yes iff A |= q, where |= denotes the standard logical consequence.\nA knowledge base can be seen as a database enhanced with an ontological component. Since inconsistency-tolerant query answering has been mostly studied in the context of description logics (DLs), and especially DL-Lite, we will use some DL vocabulary, like ABox for the data and TBox for the ontology. However, our framework is not restricted to DLs, hence we define TBoxes and ABoxes in terms of firstorder logic. We assume the reader familiar with the basics of DLs and their logical translation.\nAn ABox is a set of factual assertions. As a special case we have DL assertions restricted to unary and binary predicates. A positive axiom is of the form ∀x∀y(B[x,y] → ∃z H [y, z]) where B and H are conjunctions of atoms (in other words, it is a positive existential rule). As a special case, we have for instance concept and role inclusions in DL-LiteR, which are respectively of the form B1 ⊑ B2 and S1 ⊑ S2, where Bi := A | ∃S and Si := P | P− (with A an atomic concept, P an atomic role and P− the inverse of an atomic role). A negative axiom is of the form ∀x(B[x] → ⊥) where B is a conjunction of atoms (in other\nwords, it is a negative constraint). As a special case, we have for instance disjointness axioms in DL-LiteR, which are inclusions of the form B1 ⊑ ¬B2 and S1 ⊑ ¬S2, or equivalently B1 ⊓B2 ⊑ ⊥ and S1 ⊓ S2 ⊑ ⊥.\nA TBox T = Tp∪Tn is partitioned into a set Tp of positive axioms and a set Tn of negative axioms. Finally, a knowledge base (KB) is of the form K = 〈T ,A〉 where A is an ABox and T is a TBox. K is said to be consistent if T ∪ A is satisfiable, otherwise it is said to be inconsistent. We also say that A is (in)consistent (with T ), which reflects the assumption that the TBox is reliable. The answer to a query q over a consistent KB K is yes iff 〈T ,A〉 |= q. When K is inconsistent, standard consequence is not appropriate since all queries would be positively answered.\nA key notion in inconsistency-tolerant query answering is the one of a repair of the ABox w.r.t. the TBox. A repair is a subset of the ABox consistent with the TBox and inclusionmaximal for this property: R ⊆A is a repair of A w.r.t. T if i) 〈T ,R〉 is consistent, and ii) ∀R′ ⊆ A, if R R′ (R is strictly included in R′) then 〈T ,R′〉 is inconsistent. We denote by R(A) the set of A’s repairs (for easier reading, we often leave T implicit in our notations). Note that R(A) = {A} iff A is consistent. The most commonly considered semantics for inconsistency-tolerant query answering, inspired from previous work in databases, is the following: q is said to be a consistent consequence of K if it is a standard consequence of each repair of A. Several variants of this semantics have been proposed, which differ with respect to their behaviour (in particular they can be more or less cautious) and their computational complexity. Before recalling the main semantics studied in the literature, we need to introduce the notion of the positive closure of an ABox. The positive closure of A (w.r.t. T ), denoted by Cl(A), is obtained by adding to A all assertions (built on the individuals occurring in A) that can be inferred using the positive axioms of the TBox, namely: Cl(A)={A atom| 〈Tp,A〉 |= A and terms(A) ⊆ terms(A)} Note that the set of atomic consequences of a KB K=〈T ,A〉 may be infinite whereas the positive closure of A is always finite since it does not contain new terms. Note also that A is consistent (with T ) iff Cl(A) is consistent (with T ).\nWe now recall the most well-known inconsistency-tolerant semantics introduced in (Arenas, Bertossi, and Chomicki 1999; Lembo et al. 2010; Bienvenu 2012). Given a possibly inconsistent KB K=〈T ,A〉, a query q is said to be:\n• a consistent (or AR) consequence of K if ∀R ∈ R(A), 〈T ,R〉 |= q;\n• a CAR consequence of K if ∀R ∈R(Cl(A)),〈T ,R〉|=q;\n• an IAR consequence of K if 〈 T , ⋂ R∈R(A)R 〉 |= q;\n• an ICAR consequence of K if 〈 T , ⋂ R∈Cl(A) R 〉 |= q;\n• an ICR consequence of K if 〈 T , ⋂ R∈R(A) Cl(R) 〉 |= q.\nA Unified Framework for Inconsistency-Tolerant Query Answering\nIn this section, we define a unified framework for inconsistency-tolerant query answering based on two main concepts: modifiers and inference strategies.\nLet us first introduce the notion of MBox KBs. While a standard KB has a single ABox, it is convenient for subsequent definitions to define KBs with multiple ABoxes (“MBoxes”). Formally, an MBox KB is of the form KM=〈T ,M〉 where T is a TBox and M={A1,. . .,An} is a set of ABoxes called an MBox. We say that KM is consistent, or M is consistent (with T ) if each Ai in M is consistent (with T ).\nIn the following, we start with an MBox KB which is a possibly inconsistent standard KB (namely with a single ABox in M) and produce a consistent MBox KB, in which each element reflects a virtual reparation of the initial ABox. We see an inconsistency-tolerant query answering method as made out of a modifier, which produces a consistent MBox from the original ABox (and the Tbox), and an inference strategy, which evaluates queries against the obtained MBox"
    }, {
      "heading" : "KB.",
      "text" : ""
    }, {
      "heading" : "Elementary and Composite Modifiers",
      "text" : "We first introduce three classes of elementary modifiers, namely expansion, splitting and selection. For each class, we consider a ”natural” instantiation, namely positive closure, splitting into repairs and selecting the largest elements (i.e., maximal w.r.t. cardinality). Elementary modifiers can be combined to define composite modifiers. Given the three natural instantiations of these modifiers, we show that their combination yields exactly eight different composite modifiers.\nExpansion modifiers. The expansion of an MBox consists in explicitly adding some inferred knowledge to its ABoxes. A natural expansion modifier consists in computing the positive closure of an MBox, which is defined as follows:\n◦cl(M) = {Cl(Ai)|Ai ∈ M}.\nSplitting modifiers. A splitting modifier replaces each Ai of an MBox by one or several of its consistent subsets. A natural splitting modifier consists of splitting each ABox into the set of its repairs, which is defined as follows:\n◦rep(M) = ⋃\nAi∈M\n{R(Ai)}.\nThis modifier always produces a consistent MBox.\nSelection modifiers. A selection modifier selects some subsets of an MBox. As a natural selection modifier, we consider the cardinality-based selection modifier, which selects the largest elements of an MBox:\n◦card(M) = {Ai ∈ M|∄Aj ∈ M s.t |Aj | > |Ai|}.\nWe call a composite modifier any combination of these three elementary modifiers. We now study the question of how many different composite modifiers yielding consistent MBoxes exist and how they compare to each other. We begin with some properties that considerably reduce the number of combinations to be considered. First, the three modifiers are idempotent. Second, the modifiers ◦cl and ◦rep need to be applied only once.\nLemma 1. For any MBox M, the following holds:\n1. ◦cl(◦cl(M))=◦cl(M), ◦rep(◦rep(M))=◦rep(M) and ◦card(◦card(M)) =◦card(M).\n2. Let ◦d be any composite modifier. Then: (a) ◦cl(◦d(◦cl(M))) = ◦d(◦cl(M)), and (b) ◦rep(◦d(◦rep(M))) = ◦d(◦rep(M)).\nFigure 1 presents the eight different composite modifiers (thanks to Lemma 1) that can be applied to an MBox initially composed of a single (possibly inconsistent) ABox. At the beginning, one can perform either an expansion or a splitting operation (the selection has no effect). Expansion can only be followed by a splitting or a selection operation. From the MBox ◦rep(◦cl(M)) only a selection can be performed, thanks to Lemma 1. Similarly, if one starts with a splitting operation followed by a selection operation, then only an expansion can be done (thanks to Lemma 1 again). From ◦cl(◦card(◦rep(M))) only a selection can be performed (Lemma 1 again).\nTo ease reading, we also denote the modifiers by short names reflecting the order in which the elementary modifiers are applied, and using the following letters: R for ◦rep, C for ◦cl and M for ◦card as shown in Table 1. For instance, MCR denotes the modifier that first splits the initial ABox into its set of repairs, then closes these repairs and finally selects the maximal-cardinality elements.\nTheorem 1. Let KM=〈T ,M = {A}〉 be a possibly inconsistent KB. Then for any composite modifier ◦c that can be obtained by a finite combination of the elementary modifiers ◦rep, ◦card, ◦cl, there exists a composite modifier ◦i in {◦1 . . . ◦8} (see Table 1) such that ◦c(M)=◦i(M).\nExample 1. Let KM=〈T ,M〉 be an MBox DLLite KB where T ={A ⊑¬B, A ⊑¬C, B ⊑¬C, A ⊑ D, B ⊑ D, C ⊑ D, B ⊑ E, C ⊑ E} and M={{A(a), B(a), C(a), A(b)}}. We have ◦1(M)={{A(a), A(b)},{B(a), A(b)},{C(a), A(b)}},\nModifier Combination MBox R ◦1 = ◦rep(.) M1 = ◦1(M) MR ◦2 = ◦card(◦rep(.)) M2 = ◦2(M) CMR ◦3 = ◦cl(◦card(◦rep(.))) M3 = ◦3(M) MCMR ◦4 = ◦card(◦cl(◦card(◦rep(.)))) M4 = ◦4(M) CR ◦5 = ◦cl(◦rep(.)) M5 = ◦5(M) MCR ◦6 = ◦card(◦cl(◦rep(.))) M6 = ◦6(M) RC ◦7 = ◦rep(◦cl(.)) M7 = ◦7(M) MRC ◦8 = ◦card(◦rep(◦cl(.))) M8 = ◦8(M)"
    }, {
      "heading" : "Inference Strategies for Querying an MBox",
      "text" : "The universal inference strategy states that a conclusion is valid iff it is entailed from T and every ABox in M. It is a standard way to derive conclusions from conflicting sources, used for instance in default reasoning (Reiter 1980), where one only accepts conclusions derived from each extension of a default theory. The safe inference strategy considers as valid conclusions those entailed from T and the intersection of all ABoxes. The safe inference is a very sound and conservative inference relation since it only considers assertions shared by different ABoxes. The existential inference strategy (called also brave inference relation) considers as valid all conclusions entailed from T and at least one ABox. The existential inference is a very adventurous inference relation and may derive conclusions that are together inconsistent with T . It is often considered as undesirable when the KB represents available knowledge base on some problem. It only makes sense in some decision problems when one is only looking for a possible solution of a set of constraints or preferences. Finally, the majority-based inference relation considers as valid all conclusions entailed from T and the majority of ABoxes. The majority-based inference can be seen as a good compromise between universal / safe inference and existential inference.\nWe formally define these inference strategies as follows:\n• Query q is a universal consequence of KM, denoted by KM |=∀ q iff ∀Ai ∈ M,〈T ,Ai〉 |= q.\n• Query q is a safe consequence of KM, denoted by KM |=∩ q, iff 〈 T , ⋂\nAi∈M Ai\n〉\n|= q.\n• Query q is a majority-based consequence of KM, denoted KM |=maj q, iff |Ai:Ai∈M,〈T ,Ai〉|=q| |M| > 1/2.\n• Query q is an existential consequence of KM, denoted by KM |=∃ q iff ∃Ai ∈ M, 〈T ,Ai〉 |= q.\nGiven two inference strategies si and sj , we say that si is more cautious than sj , denoted si ≤ sj , when for any consistent MBox KM and any query q, if KM|=siq then KM|=sj q. The considered inference strategies are totally ordered by ≤ as follows:\n∩ ≤ ∀ ≤ maj ≤ ∃ (1)\nExample 2. Let us consider the MBox M1=◦1(M) given in Example 1. We have ⋂\nAi∈M Ai={A(b)}, hence\nKM1 |=∩D(b). By universal inference, we also have KM1 |=∀D(a). The majority-based inference adds E(a) as a valid conclusion. Indeed, 〈T , {B(a), A(b)}〉|=E(a) and 〈T , {C(a), A(b)}〉|=E(a) and |M1|=3, hence\nKM1 |=majE(a). Finally, the existential inference adds A(a) as a valid conclusion."
    }, {
      "heading" : "Inconsistency-Tolerant Semantics = Composite Modifier + Inference Strategy",
      "text" : "We can now define an inconsistency-tolerant query answering semantics by a composite modifier and an inference strategy.\nDefinition 1. Let K=〈T ,A〉 be a standard KB, ◦i be a composite modifier and sj be an inference strategy. A query q is said to be an 〈◦i, sj〉-consequence of K, which is denoted by K |=〈◦i,sj〉 q, if it is entailed from the MBox KB 〈T , ◦i({A})〉 with the inference strategy sj .\nThis definition covers the main semantics recalled in Section : AR, IAR, CAR, ICAR and ICR semantics respectively correspond to 〈◦1, ∀〉, 〈◦1,∩〉, 〈◦7, ∀〉 〈◦7,∩〉 and 〈◦5,∩〉.\nComparison of Inconsistency-Tolerant Semantics w.r.t. Productivity\nWe now compare the obtained semantics with respect to productivity, which we formalize as follows.\nDefinition 2. Given two semantics 〈◦i, sk〉 and 〈◦j, sl〉, we say that 〈◦j , sl〉 is more productive than 〈◦i, sk〉, and note 〈◦i, sk〉 ⊑ 〈◦j, sl〉 if, for any KB K=〈T ,A〉 and any query q, if K |=〈◦i,sk〉 q then K |=〈◦j ,sl〉 q.\nWe first pairwise compare semantics defined with the same inference strategy. For each inference strategy, we give necessary and sufficient conditions for the comparability of the associated semantics w.r.t. productivity. These conditions rely on the inclusion relations between modifiers (see Figure 2).\nProposition 1. [Productivity of ∩-semantics] See Figure 4."
    }, {
      "heading" : "It holds that 〈◦i,∩〉 ⊑ 〈◦j ,∩〉 iff ◦j ⊆ ◦i or ◦i ⊆R ◦j in a",
      "text" : "bijective way (see Fact 2).\nProposition 2. [Productivity of ∀-semantics] See Figure 5. It holds that 〈◦i, ∀〉 ⊑ 〈◦j , ∀〉 iff ◦j ⊆ ◦i, or ◦i ⊆R ◦j in a bijective way (see Fact 2) or ◦j ⊆cl ◦i.\nProposition 3. [Productivity of maj-semantics] See Figure 6. It holds that 〈◦i,maj〉 ⊑ 〈◦j,maj〉 iff ◦i ⊆R ◦j in a bijective way (see Fact 2) or ◦j ⊆cl ◦i .\nProposition 4. [Productivity of ∃-semantics] See Figure 7. It holds that 〈◦i, ∃〉 ⊑ 〈◦j , ∃〉 iff ◦i ⊆R ◦j (in particular ◦i ⊆ ◦j or ◦i ⊆cl ◦j) or ◦j ⊆cl ◦i .\nWe now extend previous results to any pair of semantics, possibly based on different inference strategies.\nTheorem 2. [Productivity of semantics] The inclusion relation ⊑ is the smallest relation that contains the inclusions 〈◦i, sk〉 ⊑ 〈◦j, sk〉 defined by Propositions 1-4 and satisfying the two following conditions:\n1. for all sj , sp and oi, if sj ≤ sp then 〈◦i, sj〉 ⊑ 〈◦i, sp〉. 2. it is transitive.\nTheorem 2 is an important result. It states that the productivity relation can only be obtained from Figures 4-7 (resp. Propositions 1-4) and some composition of the relations. No more inclusion relations hold. In particular when si > sj , it holds that ∀k, ∀l, 〈◦k, si〉 6⊑ 〈◦l, sj〉, which means that there exist a query q and a KB K such that q is an 〈◦k, si〉consequence of K but not an 〈◦l, sj〉-consequence of K. Note that this holds already for DL-LiteR KBs. Proof:[Sketch] Condition 1 holds by definition of ≤. Transitivity holds by definition of ⊑. To show that there are no other inclusions, we prove two lemmas: for all 〈◦i, sj〉 and 〈◦k, sp〉, (1) if sp < sj then 〈◦i, sj〉 6⊑ 〈◦k, sp〉; and (2) if 〈◦i, sj〉 ⊑ 〈◦k, sp〉 and sj < sp, then 〈◦i, sp〉 ⊑ 〈◦k, sp〉.\nLastly, it is important to note that when the initial KB is consistent, all semantics collapse with standard entailment, namely:\nProposition 5. Let K be a consistent standard KB. Then: ∀s∈{∩,∀,maj, ∃}, ∀i : 1, ..., 8, K|=〈◦i,s〉q iff K |= q.\nConclusion This paper provides a general and unifying framework for inconsistency-tolerant query answering. On the one hand, our logical setting based on existential rules includes previously considered languages. On the other hand, viewing\nan inconsistency-tolerant semantics as a pair composed of a modifier and an inference strategy allows us to include the main known semantics and to consider new ones. We believe that the choice of semantics depends on the applicative context, namely the features of the semantics, i.e rationality properties, complexity (which we have studied, but not presented in this paper) and productivity with respect to the applicative context. In particular, cardinality-based selection allows us to counter troublesome assertions that conflict with many others. In some contexts, requiring to find an answer in all selected repairs can be too restrictive, hence the interest of majority-based semantics, which are more productive than universal semantics, without being as productive as the adventurous existential semantics. As for future work, we plan consider other inference strategies such as the argued inference, parametrized inferences, etc. We also want to adapt the framework to belief change problems, like merging or revision.\nAcknowledgment This work has been supported by the French National Research Agency. ASPIQ project ANR-12-BS02-0003.\nReferences [Arenas, Bertossi, and Chomicki 1999] Arenas, M.; Bertossi, L. E.;\nand Chomicki, J. 1999. Consistent query answers in inconsistent databases. In Proc. of SIGACT-SIGMOD-SIGART, 68–79.\n[Baget et al. 2011] Baget, J.; Leclère, M.; Mugnier, M.; and Salvat, E. 2011. On rules with existential variables: Walking the decidability line. Artif. Intell. 175(9-10):1620–1654.\n[Benferhat, Dubois, and Prade 1997] Benferhat, S.; Dubois, D.; and Prade, H. 1997. Some syntactic approaches to the handling of inconsistent knowledge bases: A comparative study part 1: The flat case. Studia Logica 58(1):17–45.\n[Bienvenu 2012] Bienvenu, M. 2012. On the complexity of consistent query answering in the presence of simple ontologies. In Proc. of AAAI’12.\n[Lembo et al. 2010] Lembo, D.; Lenzerini, M.; Rosati, R.; Ruzzi, M.; and Savo, D. F. 2010. Inconsistency-tolerant semantics for description logics. In Proc. of RR’10, 103–117.\n[Lembo et al. 2015] Lembo, D.; Lenzerini, M.; Rosati, R.; Ruzzi, M.; and Savo, D. F. 2015. Inconsistency-tolerant query answering in ontology-based data access. J. Web Sem. 33:3–29.\n[Lukasiewicz et al. 2015] Lukasiewicz, T.; Martinez, M. V.; Pieris, A.; and Simari, G. I. 2015. From classical to consistent query answering under existential rules. In Proc. of AAAI’15, 1546–1552.\n[Poggi et al. 2008] Poggi, A.; Lembo, D.; Calvanese, D.; Giacomo, G. D.; Lenzerini, M.; and Rosati, R. 2008. Linking data to ontologies. J. Data Semantics 10:133–173.\n[Reiter 1980] Reiter, R. 1980. A logic for default reasoning. Artificial intelligence 13(1):81–132.\n[Rosati 2011] Rosati, R. 2011. On the complexity of dealing with inconsistency in description logic ontologies. In Proc. of IJCAI’11, 1057–1062.\nAppendix\nIn this appendix, we provide details on the proofs.\nSection 3: A Unified Framework for Inconsistency-Tolerant Query Answering\nTheorem 1. Let KM=〈T ,M = {A}〉 be a possibly inconsistent KB. Then for any composite modifier ◦c that can be obtained by a finite combination of the elementary modifiers ◦rep, ◦card, ◦cl, there exists a composite modifier ◦i in {◦1 . . . ◦8} (see Table 1) such that ◦c(M)=◦i(M).\nLemma 1 For any MBox M, the following holds:"
    }, {
      "heading" : "1. ◦cl(◦cl(M))=◦cl(M), ◦rep(◦rep(M))=◦rep(M) and ◦card(◦card(M)) =◦card(M).",
      "text" : "2. Let ◦d be any composite modifier. Then: (a) ◦cl(◦d(◦cl(M))) = ◦d(◦cl(M)), and (b) ◦rep(◦d(◦rep(M))) = ◦d(◦rep(M)).\nProof. The proof of the idempotence of ◦rep follows from the facts that: i) ∀Ai ∈ ◦rep(M), 〈T ,Ai〉 is consistent and ii) if 〈T ,Ai〉 is consistent, then ◦rep(Ai) = {Ai}. The proof of the the idempotence of ◦card follows from the facts that: i) ∀Ai ∈ ◦card(M),∀Aj ∈ ◦card(M), we have |Ai| = |Aj | ii) if ∀Ai ∈ ◦card(M),∀Aj ∈ ◦card(M), |Ai| = |Aj | then ◦card(M) = M. For the idempotence of ◦cl, it is enough to show that for a given A ∈ M, ◦cl(◦cl(A)) = ◦cl(A). From the definition of ◦cl, clearly we have ◦cl(A) ⊆ ◦cl(◦cl(A)). Now assume that f ∈ ◦cl(◦cl(A)) but f /∈ ◦cl(A). Let Bf ⊆ ◦cl(A) be the subset that allows to derive f , namely 〈Tp, Bf 〉 |= f . Now for each element x of Bf , we have 〈Tp,A〉 |= x. Then clearly, 〈Tp,A〉 |= f .\nRegarding item (2.a), if ◦d is an elementary modifier then it can be either ◦cl, ◦card, or ◦rep. If ◦d = ◦cl then the result holds since ◦cl is idempotent. If ◦d = ◦card then the selected elements from ◦card(◦cl(M)) are closed sets of assertions since ◦card only discards some elements of ◦cl(M) but does not change the content of remaining elements. Lastly, let us consider the case where ◦d = ◦rep. Again ∀A′ ∈ ◦rep(◦cl(M)),A ′ = ◦cl(A ′). Let us recall that A′ is a maximally consistent subset of A ∈ ◦cl(M), with A = ◦cl(A). If A′ 6= ◦cl(A) this means that ∃f ∈ ◦cl(A′) (hence f ∈ A) such that f /∈ A′ despite the fact that 〈T ,A′〉 |= f . This is impossible since A′ should be a maximal consistent subbase of A. Since each ◦d ∈ {◦cl, ◦card, ◦rep} applied on closed a ABox preserves the closeness property, then clearly a composite modifier also preserves this closeness property.\nThe proof of item (2.b) follows immediately from the fact that i) ∀Ai ∈ ◦rep(M), 〈T ,Ai〉 is consistent, ii) if M is consistent, then ∀◦d ∈ {◦cl, ◦card, ◦rep} yields a consistent subbase, and iii) ◦rep(M) = M if M is consistent.\nProof of Theorem 1. The proof relies on Lemma 1 (see also the explanations following Lemma 1 in the paper).\nJustification of Figure 2 (Inclusion relations between composite modifiers): see following Proposition 6, Example 3, Proposition 7 and Example 4.\nProposition 6 (Part of the proof of Figure 2). Let KM=〈T ,M = {A}〉 be an inconsistent KB. Let {M1,...,M8} be the MBoxes obtained by the eight composite modifiers {◦1, ..., ◦8} summarized in Table 1. Then:\n1. M2 ⊆ M1. 2. M4 ⊆ M3. 3. M6 ⊆ M5. 4. M8 ⊆ M7. 5. M3 = ◦cl(M2). 6. M5 = ◦cl(M1). 7. M3 ⊆ M5. 8. M5 ⊆R M7.\nProof.\n• Items 1-4 follow from the definition of the elementary modifier ◦card. Since ◦card selects subsets of M having maximal cardinality. Namely, given M an MBox, we have ◦card(M) ⊆ M. Hence relations M4 ⊆ M3, M2 ⊆ M1, M6 ⊆ M5, and M8 ⊆ M7 holds.\n• Items 5-6 follow immediately from the definition of the elementary modifier ◦cl, hence we trivially have M5 = ◦cl(M1) and M3 = ◦cl(M2).\n• Let us show that M2 ⊆cl M5, namely ∀A∈M2,∃B ∈ M5 such that B = Cl(A). The proof is immediate. Recall that M2 ⊆ M1, hence ∀A ∈ M2 we also have A ∈ M1. Recall also that M5 = ◦cl(M1). This means that ∀A ∈ M2,∃B ∈ M5 such that B = Cl(A).\n• Regarding the proof of Item 8, we have M2 ⊆cl M5. This means that ∀A ∈ M2, there exists B ∈ M5 such that B = Cl(A). Said differently, ∀A ∈ M2, we have Cl(A) ∈ M5. Since M3=◦cl(M2), we conclude that M3 ⊆ M5.\n• We now show that M5⊆RM7. Let B∈◦rep({A}) and let us show that there exists a set of assertions X such that ◦cl({B})⊆X and X∈M7. Since B∈◦rep({A}), this means by definition that B ⊆ A and hence B ⊆ ◦cl(A). Now, B is consistent, this means that there exists R ∈ ◦rep(◦cl(A)) = M7 such that B ⊆ R. From Lemma 1, R is a closed set of assertions, then this means that Cl(B) ⊆ R.\nExample 3 (Counter-examples showing that there are no reciprocal edges in Figure 2).\n1. The converse of M2 ⊆ M1 does not hold. Let T ={B⊑C,C⊑¬D} and M={{B(a), C(a), D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1=◦rep(M)={{C(a), B(a)}, {D(a)}}, and M2 = ◦card(M1) = {{C(a), B(a)}}. One can check that M1 *R M2.\n2. The converse of M4 ⊆ M3 does not hold. Let T ={A ⊑ B, B ⊑¬C} and M={{A(a), C(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1=◦rep(M)={{A(a)}, {C(a)}}, M2 = ◦card(M1) = {{A(a)}, {C(a)}}, M3 = ◦cl(M2) = {{A(a), B(a)}, {C(a)}}, and M4 = ◦card(M3) = {{A(a), B(a)}}. One can check that M3 *R M4.\n3. The converse of M6 ⊆ M5 does not hold. Let T ={B ⊑ C, C ⊑¬D} and M={{B(a), D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1=◦rep(M)={{B(a)}, {D(a)}}, M5 = ◦cl(M1)={{C(a), B(a)}, {D(a)}}, and M6 = ◦card(M5)={{C(a), B(a)}} One can check that M5 *R M6.\n4. The converse of M8 ⊆ M7 does not hold. Let T ={A ⊑ B, B ⊑¬D} and M={{A(a), D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: ◦cl(M)={{A(a), B(a), D(a)}}, M7 = ◦rep(◦cl(M))={{A(a),B(a)}, {D(a)}}, and M8 = ◦card(M7)={{A(a), B(a)}} One can check that M7 *R M8.\n5. The converse of M3 ⊆ M5 does not hold. Let T ={A ⊑ B, B ⊑ C, C ⊑¬D} and M={{A(a), B(a),D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1=◦rep(M)={{A(a), B(a)}, {D(a)}}, M5 = ◦cl(M1) = {{A(a), B(a), C(a)}, {D(a)}}, M2 = ◦card(M1)={{A(a), B(a)}}, and M3 = ◦cl(M2)={{A(a), B(a), C(a)}}. One can check that M5 *R M3.\n6. The converse of M5 ⊆R M7 does not hold. Let T ={A ⊑¬B, B ⊑ D} and M={{A(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: ◦cl(M)={{A(a), B(a), D(a)}}, M7 = ◦rep(◦cl(M))={{A(a),D(a)}, {B(a),D(a)}}, M1=◦rep(M)={{A(a)}, {B(a)}}, and M5 = ◦cl(M1)={{A(a)}, {B(a), D(a)}}, One can check that M7 *R M5.\nCorollary 1. Let KM=〈T ,M = {A}〉 be an inconsistent KB. Let {M1,...,M8} be the MBoxes obtained by the eight composite modifiers {◦1,...,◦8} summarized in Table 1. Then:\n1. ∀Ai ∈ M3, ∃Aj ∈ M1 such that Ai = Cl(Aj). 2. ∀Ai ∈ M4, ∃Aj ∈ M1 such that Ai = Cl(Aj). 3. ∀Ai ∈ M6, ∃Aj ∈ M1 such that Ai = Cl(Aj). 4. ∀Ai ∈ M1, ∃Aj ∈ M7 such that Ai ⊆ Aj . 5. ∀Ai ∈ M1, ∃Aj ∈ M8 such that Ai ⊆ Aj . 6. ∀Ai ∈ M4, ∃Aj ∈ M2 such that Ai = Cl(Aj). 7. ∀Ai ∈ M2, ∃Aj ∈ M7 such that Ai ⊆ Aj .\n8. ∀Ai ∈ M3, ∃Aj ∈ M7 such that Ai ⊆ Aj . 9. ∀Ai ∈ M4, ∃Aj ∈ M7 such that Ai ⊆ Aj .\n10. ∀Ai ∈ M5, ∃Aj ∈ M8 such that Ai ⊆ Aj .\nProposition 7 (Part of the proof of Figure 2). Let {◦1,...,◦8} be the eight composite modifiers summarized in Table 1.Then:\n1. There exists M such that ◦6(M) and ◦8(M) are incomparable. 2. There exists M such that ◦2(M) and ◦6(M) are incomparable. 3. There exists M such that ◦3(M) and ◦6(M) are incomparable. 4. There exists M such that ◦4(M) and ◦6(M) are incomparable. 5. There exists M such that ◦2(M) and ◦8(M) are incomparable. 6. There exists M such that ◦3(M) and ◦8(M) are incomparable. 7. There exists M such that ◦4(M) and ◦8(M) are incomparable.\nExample 4 (Examples that prove Proposition 7). The following examples prove the statements in Proposition 7.\n1. There exists M such that ◦6(M) and ◦8(M) are incomparable. Let T ={B ⊑¬C, B ⊑ A, C ⊑ A,A ⊑¬D,D ⊑ E,E ⊑ F} and M={{A(a), B(a), C(a),D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M) = {{A(a), C(a)}, {A(a), B(a)}, {D(a)}}, and M5 = ◦cl(M1)={{A(a), C(a)}, {A(a), B(a)}, {D(a), E(a), F (a)}}, and M6 = ◦card(M5)={{D(a), E(a), F (a)}}, ◦cl(M)={{A(a), B(a), C(a),D(a), E(a), F (a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), E(a), F (a)}, {A(a), B(a), E(a), F (a)}, {D(a), E(a), F (a)}}, and M8 = ◦rep(M7) = {{A(a), C(a), E(a), F (a)}, {A(a),B(a), E(a), F (a)}} One can check that M6 and M8 are incomparable.\n2. There exists M such that ◦2(M), ◦3(M) and ◦4(M) are incomparable with ◦6(M). Let T ={A ⊑¬B, C ⊑ A, B ⊑ D, D ⊑ F} and M={{A(a), C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {B(a)}}, M2 = ◦card(M2)={{A(a), C(a)}}, M5 = ◦cl(M1)={{A(a), C(a)}, {B(a), D(a), F (a)}}, M6 = ◦card(M5)={{B(a), D(a), F (a)}}, One can check that M2 is incomparable with M6. We have also M2=M3=M4={{A(a), C(a)}}, So, we conclude that M3 and M4 are incomparable with M6.\n3. There exists M such that ◦2(M), ◦3(M) and ◦4(M) are incomparable with ◦8(M). Let T ={B ⊑ A, C ⊑ A,A ⊑¬D,E ⊑ D,D ⊑ F} and M={{A(a), D(a), E(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M) = {{A(a)}, {D(a), E(a)}}, and M2 = ◦card(M1)={D(a), E(a)}}, and M3 = M4={{D(a), E(a), F (a)}}, ◦cl(M)={{A(a), B(a), C(a),D(a), E(a), F (a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), B(a), F (a)}, {D(a), E(a), F (a)}}, and M8 = ◦rep(M7) = {{A(a), C(a),B(a), F (a)}, One can check that M2, M3 and M4 are incomparable with M8.\nProposition 8 (Proof of Equation 1 and Figure 3). Let M be a consistent MBox w.r.t. a TBox T . Let q be a query. Then:"
    }, {
      "heading" : "1. if 〈T ,M〉 |=∩ q then 〈T ,M〉 |=∀ q.",
      "text" : "2. if 〈T ,M〉 |=∀ q then 〈T ,M〉 |=maj q. 3. if 〈T ,M〉 |=maj q then 〈T ,M〉 |=∃ q. Proof of Proposition 8. Item 1 holds from the fact that ∀Ai ∈ M, we have ( ⋂\nAi∈M Ai) ⊆ Ai. Item 2 holds due to the fact that universal\nconsequence requires that q follows from all ABoxes in M. Hence, q holds in more than the half of Ai’s in M. Item 3 follows from the fact that a query is considered as valid using majority-based consequence relation if it is confirmed by more than the half of Ai ∈ M. Hence q follows from at least one ABox.\nFinally, the following two lemmas about the cautiousness relation will be used later. Lemma 2 considers two MBoxes, with one included in the other. Lemma 3 considers two MBoxes, where one is the positive closure of the other.\nLemma 2. Let M1 and M2 be two consistent MBoxes w.r.t. a TBox T such that M1⊆M2. Let q be a query. Then:"
    }, {
      "heading" : "1. If 〈T ,M2〉 |=∀ q then 〈T ,M1〉 |=∀ q.",
      "text" : ""
    }, {
      "heading" : "2. If 〈T ,M2〉 |=∩ q then 〈T ,M1〉 |=∩ q.",
      "text" : "3. There are M1 and M2 such that the majority-based inference yields incomparable results."
    }, {
      "heading" : "4. If 〈T ,M1〉 |=∃ q then 〈T ,M2〉 |=∃ q.",
      "text" : "Proof. The proof is immediate. For item 1, if q holds in all Ai of M2 then trivially it holds in all Aj of M1 (since M1 ⊆ M2). Item 2 holds due to the fact that M1 ⊆ M2 implies that\n⋂ Ai∈M2 Ai ⊆ ⋂ Aj∈M1 Aj . Lastly, from item 4, if there exists an Ai in M1 where q\nholds, then such Ai also exists in M2.\nExample 5 (Counter-examples associated with Lemma 2). The converse of Items 1 and 2 and 4 does not hold, as shown by the following counter-example. Let T = ∅, M1={B(a)} and M2={{B(a)},{B(c)}, {B(c)}}. First, note that M1 ⊆ M2. Clearly 〈T ,M1〉 |=∀ B(a) (resp. 〈T ,M1〉 |=∩ B(a)) holds, while 〈T ,M2〉 |=∀ B(a) (resp. 〈T ,M2〉 |=∩ B(a)) does not hold. Similarly 〈T ,M2〉 |=∃ B(c) holds, while 〈T ,M1〉 |=∃ B(c) does not hold.\nRegarding majority-based inference, one can check that 〈T ,M1〉 |=maj B(a) holds while 〈T ,M2〉 |=maj B(a) does not hold. And 〈T ,M2〉 |=maj B(c) holds while 〈T ,M1〉 |=maj B(c) does not hold.\nLemma 3. Let M1 and M2 be two consistent MBoxex w.r.t. T . Let M2 be the positive closure of M1. Let q be a Boolean query. Then:"
    }, {
      "heading" : "1. 〈T ,M1〉 |=∀ q iff 〈T ,M2〉 |=∀ q.",
      "text" : "2. 〈T ,M1〉 |=maj q iff 〈T ,M2〉 |=maj q."
    }, {
      "heading" : "3. if 〈T ,M1〉 |=∩ q then 〈T ,M2〉 |=∩ q.",
      "text" : ""
    }, {
      "heading" : "4. 〈T ,M1〉 |=∃ q iff 〈T ,M2〉 |=∃ q.",
      "text" : "Proof of Lemma 3. The proof is again immediate. Items 1, 2 and 4 follow from the fact that, if A is a consistent ABox with T , then 〈T ,A〉 |= q iff 〈T ,Cl(A)〉 |= q. Item 3 follows from the fact that Ai ⊆ Cl(Ai) for each Ai ∈ M1. Hence\n⋂ Ai∈M1 Ai ⊆ ⋂ Ai∈M1 Cl(Ai) =⋂\nAj∈M2 Aj .\nSection 4: Comparison of Inconsistency-Tolerant Semantics w.r.t. Productivity\nProof of Figure 4 (intersection-based semantics) The relation pictured in the figure is proved by the following propositions and examples.\nProposition 9 (Proof of Figure 4, Part 1). Let KM=〈T ,M = {A}〉 be an inconsistent KB. Let M1,...,M8 be the MBoxes obtained by applying the eight modifiers {◦1, ..., ◦8}, given in Table 1, on M. Let q be a Boolean query. Then:\n1. If q is a safe conclusion of 〈T ,M1〉 then q is a safe conclusion of 〈T ,M2〉.\n2. If q is a safe conclusion of 〈T ,M1〉 then q is a safe conclusion of 〈T ,M5〉.\n3. If q is a safe conclusion of 〈T ,M2〉 then q is a safe conclusion of 〈T ,M3〉.\n4. If q is a safe conclusion of 〈T ,M3〉 then q is a safe conclusion of 〈T ,M4〉.\n5. If q is a safe conclusion of 〈T ,M5〉 then q is a safe conclusion of 〈T ,M3〉.\n6. if q is a safe conclusion of 〈T ,M5〉 then q is a safe conclusion of 〈T ,M6〉.\n7. If q is a safe conclusion of 〈T ,M5〉 then q is a safe conclusion of 〈T ,M7〉.\n8. If q is a safe conclusion of 〈T ,M7〉 then q is a safe conclusion of 〈T ,M8〉.\nProof. The proof is as follows:\n1. For items 1, we have M2 ⊆ M1, then following Item 2 of Lemma 2, if 〈M1,∩〉 implies a query q then 〈M2,∩〉 implies it also. The proof follow similarly for Items 4,5, 6 and 8 since M4 ⊆ M3, M3 ⊆ M5, M6 ⊆ M5, and M8 ⊆ M7.\n2. For items 2 and 3, we have M5 = ◦cl(M1) and M3 = ◦cl(M2). Then following Item 3 of Lemma 3, if a query holds in 〈M,∩〉 then it also holds in 〈◦cl(M),∩〉. 3. For item 7, we have ∀A ∈ M5,∃B ∈ M7 such that A ⊆ B. Let A(a) ∈ ⋂\nAi∈M5 Ai. Then one can check that there is no conflict\nC in 〈T ,Cl(M)〉 such that A(a) ∈ C. Indeed, assume that such conflict exists. Then this means that there exists B(a) ∈ Cl(M) where 〈T , {(A(a), B(a)}〉 is conflicting. Two options: i) B(a) ∈ M. This means that there exists a maximally consistent subset X of M with B(a) ∈ X . Since B(a) is conflicting with A(a), with respect to T . Then A(a) neither belongs to X nor to Cl(X). This contradict the fact that A(a) ∈\n⋂ Ai∈M5\nAi. ii) B(a) /∈ M. Let Y ⊆ M such that 〈T , Y 〉 |= B(a). Then clearly 〈T , Y ∪ {A(a)}〉 is inconsistent. Hence, there exists D(a) ∈ M such that 〈T , {(D(a), A(a)}〉 is conflicting and D(a) ∈ Y . This comes down to item (i). Now, since there is no conflict in Cl(M) containing A(a), then A(a) belong to all maximally consistent subsets of Cl(M), hence A(a) belongs to\n⋂ Aj∈M7 Aj . Therefore if a q\nholds in 〈M5,∩〉, then it holds that 〈M5,∩〉.\nExample 6 (Proof of Figure 4, Part 2). The following counter-examples show that no reciprocal edges hold in Figure 4.\n1. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M2〉, but q is not a safe conclusion of 〈T ,M1〉: Let us consider T ={A ⊑ B,B ⊑¬C} and M = {{C(a), A(a),B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = {{C(a)}}, {A(a), B(a)}}, and M2 = {{A(a), B(a)}}. Let q ← A(a) be a query. One can check that: M2 |=∩ q, since\n⋂ Ai∈M2\nAi={A(a), B(a)} but M1 6|=∩ q.\n2. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M5〉, but q is not a safe conclusion of 〈T ,M1〉: Let us consider T ={B ⊑ D,B ⊑¬C,C ⊑ D} and M = {{C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = {{C(a)}, {B(a)}}, and M5 = {{B(a), D(a)}, {C(a), D(a)}}. Let q ← D(a) be a query. One can check that : M5 |=∩ q since\n⋂ Ai∈M5\nAi={D(a)}, but M1 6|=∩ q.\n3. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M3〉, but q is not a safe conclusion of 〈T ,M2〉: Let us consider T ={B ⊑¬C,C ⊑ A,B ⊑ A} and M = {{C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = M2 = {{C(a)}, {B(a)}},and M3 = {{C(a), A(a)}}, {B(a), A(a)}}. Let q ← A(a) be a query. One can check that: M3 |=∩ q, but M2 6|=∩ q.\n4. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M4〉, but q is not a safe conclusion of 〈T ,M3〉: Let us consider T ={A ⊑ B,B ⊑¬D} and M = {{A(a), D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = M2 = {{A(a)}, {D(a)}}, M3 = {{A(a), B(a)}, {D(a)}}, and M4 = {{A(a), B(a)}}. Let q ← A(a) be a query. One can check that M4 |=∩ q but M3 6|=∩ q.\n5. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M3〉, but q is not a safe conclusion of 〈T ,M5〉: Let us consider T ={A ⊑ B, B ⊑¬D} and M = {{A(a), D(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = {{A(a), B(a)}, {D(a)}}, M2 = M3 = {{A(a), B(a)}}, and M5 = {{A(a), B(a)}, {D(a)}}. Let q ← A(a) be a query. One can check that M3 |=∩ q but M5 6|=∩ q.\n6. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M6〉, but q is not a safe conclusion of M5: Let us consider T ={B ⊑ C, C ⊑¬D} and M={{B(a), D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = {{B(a)}, {D(a)}}, M5 = {{B(a), C(a)}, {D(a)}}, and M6 = {{B(a), C(a)}}. Let q ← B(a) be a query. One can check that M6 |=∩ q but M5 6|=∩ q.\n7. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M7〉, but q is not a safe conclusion of M5: Let T ={A ⊑¬B, B ⊑ D} and M={{A(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1={{A(a)}, {B(a)}}, M5={{A(a)}, {B(a), D(a))}}, ◦cl(M)={{A(a), B(a), D(a)}}, and M7={{A(a), D(a)}, {B(a), D(a)}}.\nLet q ← D(a) be a query. One can deduce that: M7 |=∩ q but M5 6|=∩ q.\n8. There exists a KB, and a Boolean query q such that q is a safe conclusion of 〈T ,M8〉, but q is not a safe conclusion of 〈T ,M7〉: Let us consider T ={A ⊑ B, B ⊑¬C, C ⊑ D} and M = {{A(a), C(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: ◦cl(M) = {A(a), C(a), B(a),D(a)}, M7 = {{A(a), B(a),D(a)}, {C(a), D(a)}}, and M8 = {{A(a), B(a),D(a)}}. Let q ← A(a) be a Boolean query. One can deduce that: M8 |=∩ q, but M7 6|=∩ q.\nProposition 10 (Proof of Figure 4, Part 3). Let {◦1,...,◦8} be the eight modifier given in Table 1. Let q be a Boolean query. Then:\n1. There exists an MBox M such that the safe inference from ◦2(M) is incomparable with the one obtained from ◦6(M).\n2. There exists an MBox M such that the safe inference from ◦3(M) is incomparable with the one obtained from ◦6(M).\n3. There exists an MBox M such that the safe inference from ◦6(M) is incomparable with the one obtained from ◦7(M).\n4. There exists an MBox M such that the safe inference from ◦6(M) is incomparable with the one obtained from ◦8(M).\n5. There exists an MBox M such that the safe inference from ◦2(M) is incomparable with the one obtained from ◦5(M).\nExample 7. The following examples show the incomparabilities stated in the previous proposition.\n1. The safe inference from M6 is incomparable with the one obtained from M7. Let T ={C ⊑ F ,F ⊑ A,A ⊑¬B,B ⊑ D} and M={{C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{C(a)}, {B(a)}}, and M5 = ◦cl(M1)={{A(a), C(a), F (a)}, {B(a), D(a)}}, and M6 = ◦card(M5)={{A(a), C(a), F (a)}}, ◦cl(M)={{A(a), C(a), F (a),B(a), D(a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), F (a),D(a)}, {D(a), B(a)}}, Let q1 ← F (a) and q2 ← D(a) be two queries. One can check that: 〈M7,∩〉 |= q2 but 〈M6,∩〉 6|= q2 while 〈M6,∩〉 |= q1 but 〈M7,∩〉 6|= q1.\n2. The safe inference from M6 is incomparable with the one obtained from M8. Let T ={B ⊑¬C,B ⊑ A,C ⊑ A,A ⊑¬D,D ⊑ E,E ⊑ F} and M={{A(a),B(a),C(a),D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {A(a), B(a)}, {D(a)}}, M5 = ◦cl(M1)={{A(a), C(a)}, {A(a),B(a)}, {D(a), E(a), F (a)}}, M6 = ◦card(M5)={{D(a), E(a), F (a)}}, ◦cl(M)={{A(a), B(a), C(a),D(a), E(a), F (a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), E(a), F (a)}, {A(a), B(a), E(a), F (a)}, {D(a), E(a), F (a)}}, and M8 = ◦rep(M7)={{A(a), C(a), E(a), F (a)}, {A(a),B(a), E(a), F (a)}} Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M8,∩〉 |= q2 but 〈M6,∩〉 6|= q2 while 〈M6,∩〉 |= q1 but 〈M8,∩〉 6|= q1.\n3. The safe inference from M2 is incomparable with the one obtained from M6. Let T ={A ⊑¬B, C ⊑ A, B ⊑ D, D ⊑ F} and M={{A(a), C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {B(a)}}, M2 = ◦card(M2)={{A(a), C(a)}}, M5 = ◦cl(M1)={{A(a), C(a)}, {B(a), D(a), F (a)}}, M6 = ◦card(M5)={{B(a), D(a), F (a)}}, Let q1 ← A(a) and q2 ← B(a) be two queries. One can check that: 〈M2,∩〉 |= q1 but 〈M6,∩〉 6|= q1 while 〈M6,∩〉 |= q2 but 〈M2,∩〉 6|= q2.\n4. The safe inference from M2 is incomparable with the one obtained from M5. Let T ={A ⊑ B, C ⊑ B, A ⊑¬C, D ⊑ C} and M={{A(a), C(a),D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a)}, {C(a), D(a)}}, M2 = ◦card(M1)={{C(a), D(a)}}, and M5 = ◦cl(M1)={{A(a), B(a)}, {B(a),D(a), C(a)}}, Let q1 ← D(a) and q2 ← B(a) be two queries. One can check that:\n〈M2,∩〉 |= q1 but 〈M5,∩〉 6|= q1 while 〈M5,∩〉 |= q2 but 〈M2,∩〉 6|= q2.\nProof of Figure 5 (universal semantics) The relation pictured in the figure is proved by the following propositions and examples.\nProposition 11 (Proof of Figure 5, Part 1). Let KM=〈T ,M = {A}〉 be an inconsistent KB. Let M1,...,M8 be the MBoxes obtained by applying the eight modifiers, given in Table 1, on M. Let q be a Boolean query. Then:\n1. q is a universal conclusion of 〈T ,M1〉 iff q is a universal conclusion of 〈T ,M5〉.\n2. q is a universal conclusion of 〈T ,M2〉 iff q is a universal conclusion of 〈T ,M3〉.\nProof. Item 1 and 2 follow from item 1 of Lemma 3 and the facts that M5 = ◦cl(M1) and M3 = ◦cl(M2).\nProposition 12 (Proof of Figure 5, Part 2). Let KM=〈T ,M = {A}〉 be an inconsistent KB. Let M1,...,M8 be the MBoxes obtained by applying the eight modifiers, given in Table 1, on M. Let q be a Boolean query. Then:\n1. If q is a universal conclusion of 〈T ,M1〉 (or 〈T ,M5〉) then q is a universal conclusion of 〈T ,M2〉.\n2. If q is universal conclusion of 〈T ,M3〉 (or 〈T ,M2〉) then q is a universal conclusion of 〈T ,M4〉.\n3. If q is universal conclusion of 〈T ,M1〉 (or 〈T ,M5〉) then q is a universal conclusion of 〈T ,M6〉.\n4. If q is universal conclusion of 〈T ,M7〉 then q is a universal conclusion of 〈T ,M8〉.\n5. If q is universal conclusion of 〈T ,M1〉 (or 〈T ,M5〉) then q is a universal conclusion of 〈T ,M7〉.\nProof. For Items 1, 2, 3 and 4, we have M2 ⊆ M1, M4 ⊆ M3, M6 ⊆ M5 and M8 ⊆ M7. Then following Item 2 of Lemma 2, we have if 〈T ,M1〉 |=∀ q then 〈T ,M2〉 |=∀ q. Similarly for M4 ⊆ M3, M6 ⊆ M5 and M8 ⊆ M7.\nFinally, for item 5 recall first that 〈M5,∀〉 ≡ 〈M1,∀〉 and ∀A ∈ M5,∃B ∈ M7 such that A ⊆ B. Now let us show that ∀B ∈ M7, ∃A ∈ M5 such that A ⊆ B. Let B ∈ M7 = ◦rep(◦cl(M)). This means that B ⊆ ◦cl(M) and B is a maximally consistent subset. Let C ∈ ◦rep(M). This means that C ⊆ M ⊆ ◦cl(M). Since C is also a maximally consistent subset then C ⊆ B. Now, recall that B is a closed set of assertion, then A = Cl(C) ⊆ B. Therefore we conclude that if a conclusion holds from M5, then it holds from M7.\nExample 8 (Proof of Figure 5, Part 3). The following counter-examples show that no reciprocal edges hold in Figure 5.\n1. There exists a KB, and a Boolean query q such that q is a universal conclusion of 〈T ,M2〉, but q is not a universal conclusion of 〈T ,M1〉: Let us consider T = {A ⊑ B,B ⊑¬C} and M = {{A(a),B(a), C(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M) = {{A(a), B(a)}, {C(a)}}, and M2 = ◦card(M1) = {{A(a), B(a)}}. Let q ← A(a) be a query. One can check that: 〈M2,∀〉 |= q but 〈M1,∀〉 6|= q, since 〈T , {C(a)}〉 6|= q.\n2. There exists a KB, and a Boolean query q such that q is a universal conclusion of 〈T ,M4〉, but q is not a universal conclusion of 〈T ,M3〉: Let us consider T = {A ⊑¬B,A ⊑ F} and M={{A(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = M2 = {{A(a)}, {B(a)}}, M3 = {{A(a), F (a)},{B(a)}}, and M4 = {{A(a), F (a)}}. Let q ← F (a) be a query. One can check that: 〈M4,∀〉 |= q but 〈M3,∀〉 6|= q, since 〈T , {B(a)}〉 6|= q.\n3. There exists a KB, and a Boolean query q such that q is a universal conclusion of 〈T ,M6〉, but q is not a universal conclusion of 〈T ,M5〉: Let us consider T ={B ⊑ C, C ⊑¬D} and M = {{B(a), D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = {{B(a)}, {D(a)}}, M5 = {{B(a), C(a)}, {D(a)}}, and M6 = {{B(a), C(a)}}. Let q ← C(a) be a query. One can check that: 〈M6,∀〉 |= q but 〈M5,∀〉 6|= q, since 〈T , {D(a)}〉 6|= q\n4. There exists a KB, and a Boolean query q such that q is a universal conclusion of 〈T ,M8〉, but q is not a universal conclusion of 〈T ,M7〉: Let us consider T ={A ⊑ B, B ⊑¬C, C ⊑ D, D ⊑ F} and M = {{A(a), C(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: ◦cl(M) = {A(a), C(a), B(a),D(a), F (a)}, M7 = {{A(a), B(a),D(a), F (a)}, {C(a), D(a), F (a)}}, and M8 = {{A(a), B(a),D(a), F (a)}}. Let q ← A(a) be a query. One can check that: 〈M8,∀〉 |= q, but 〈M7,∀〉 6|= q, since 〈T , {C(a), D(a), F (a}〉 6|= q.\n5. There exists a KB, and a Boolean query q such that q is a universal conclusion of 〈T ,M7〉, but q is not a universal conclusion of 〈T ,M5〉: Let T ={A ⊑¬B, B ⊑ D} and M={{A(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1={{A(a)}, {B(a)}}, ◦cl(M)={{A(a), B(a), D(a)}}, and M7={{A(a), D(a)}, {B(a), D(a)}}. Let q ← D(a) be a query. One can check that: 〈M7,∀〉 |= q but 〈M1,∀〉 6|= q, since 〈T , {A(a)}〉.\nProposition 13 (Proof of Figure 5, Part 4). Let {◦1,...,◦8} be the eight modifiers given in Table 1. Then:\n1. There exists an MBox M such that the universal inference from ◦6(M) is incomparable with the one obtained from ◦7(M). 2. There exists an MBox M such that the universal inference from ◦6(M) is incomparable with the one obtained from ◦8(M). 3. There exists an MBox M such that the universal inference from ◦2(M) (resp.◦3(M), ◦4(M)) is incomparable with the one obtained\nfrom ◦6(M). 4. There exists an MBox M such that the universal inference from ◦2(M) (resp.◦3(M), ◦4(M)) is incomparable with the one obtained\nfrom ◦7(M). 5. There exists an MBox M such that the universal inference from ◦2(M) (resp.◦3(M), ◦4(M)) is incomparable with the one obtained\nfrom ◦8(M).\nExample 9. The following examples prove the incomparabilities stated in the previous proposition.\n1. The universal inference from M6 is incomparable with the one obtained from M7. Let T ={C ⊑ F , F ⊑ A, A ⊑¬B,B ⊑ D} and M={{C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{C(a)}, {B(a)}}, and M5 = ◦cl(M1)={{A(a), C(a), F (a)}, {B(a), D(a)}}, and M6 = ◦card(M5)={{A(a), C(a), F (a)}}, ◦cl(M)={{A(a), C(a), F (a),B(a), D(a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), F (a),D(a)}, {D(a), B(a)}}, Let q1 ← F (a) and q2 ← D(a) be two queries. One can check that: 〈M7,∀〉 |= q2 but 〈M6,∀〉 6|= q2 while 〈M6,∀〉 |= q1 but 〈M7,∀〉 6|= q1.\n2. The universal inference from M6 is incomparable with the one obtained from M8. Let T ={B ⊑¬C, B ⊑ A, C ⊑ A,A ⊑¬D,D ⊑ E,E ⊑ F} and M={{A(a), B(a), C(a),D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {A(a), B(a)}, {D(a)}}, and M5 = ◦cl(M1)={{A(a), C(a)}, {A(a), B(a)}, {D(a), E(a), F (a)}}, and M6 = ◦card(M5)={{D(a), E(a), F (a)}}, ◦cl(M)={{A(a), B(a), C(a),D(a), E(a), F (a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), E(a), F (a)}, {A(a), B(a), E(a), F (a)}, {D(a), E(a), F (a)}}, and M8 = ◦card(M7)={{A(a), C(a), E(a), F (a)}, {A(a),B(a), E(a), F (a)}} Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M8,∀〉 |= q2 but 〈M6,∀〉 6|= q2 while 〈M6,∀〉 |= q1 but 〈M8,∀〉 6|= q1.\n3. The universal inference from M2 (resp. M3 and M4 is incomparable with the one obtained from M6. Let T ={A ⊑¬B, C ⊑ A, B ⊑ D, D ⊑ F} and M={{A(a), C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {B(a)}}, M2 = ◦card(M2)={{A(a), C(a)}}, M4 = {{A(a), C(a)}}, M5 = ◦cl(M1)={{A(a), C(a)}, {B(a), D(a), F (a)}},\nM6 = ◦card(M5)={{B(a), D(a), F (a)}}, Let q1 ← A(a) and q2 ← B(a) be two queries. One can check that: 〈M2,∀〉 |= q1 but 〈M6,∀〉 6|= q1 while 〈M6,∀〉 |= q2 but 〈M2,∀〉 6|= q2. Similarly for M4\n4. The universal inference from M2 (resp. M3 and M4 is incomparable with the one obtained from M7. Let T ={A ⊑¬B, C ⊑ A, B ⊑ D, D ⊑ F} and M={{A(a), C(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {B(a)}}, M2 = ◦card(M2)={{A(a), C(a)}}, M4 = {{A(a), C(a)}}, ◦cl(M)={{A(a), C(a), B(a),D(a), F (a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), D(a), F (a)}, {B(a), D(a), F (a)}}, Let q1 ← A(a) and q2 ← D(a) be two queries. One can check that: 〈M2,∀〉 |= q1 but 〈M7,∀〉 6|= q1 while 〈M7,∀〉 |= q2 but 〈M2,∀〉 6|= q2. Similarly for M4.\n5. The universal inference from M2 (resp. M3 and M4 is incomparable with the one obtained from M8. Let T ={B ⊑ A, C ⊑ A,A ⊑¬D,E ⊑ D,D ⊑ F} and M={{A(a), D(a), E(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M) = {{A(a)},{D(a), E(a)}}, and M2 = ◦card(M1)={D(a), E(a)}}, and M4={{D(a), E(a), F (a)}}, ◦cl(M)={{A(a), B(a), C(a),D(a), E(a), F (a)}}, M7 = ◦rep(◦cl(M))={{A(a), C(a), B(a), F (a)}, {D(a), E(a), F (a)}}, and M8 = ◦rep(M7) = {{A(a), C(a),B(a), F (a)}, Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M2,∀〉 |= q1 but 〈M8,∀〉 6|= q1 while 〈M8,∀〉 |= q2 but 〈M2,∀〉 6|= q2. Similarly for M4\nProof of Figure 6 (majority-based semantics) The relation pictured in the figure is proved by the following propositions and examples.\nProposition 14 (Proof of Figure 6, Part 1). Let KM=〈T ,M = {A}〉 be an inconsistent KB. Let M1,...,M8 be the MBoxes obtained by applying the eight modifiers, given in Table 1, on M. Let q be a Boolean query. Then:\n• 〈T ,M1〉 |=maj q iff 〈T ,M5〉 |=maj q. • 〈T ,M2〉 |=maj q iff 〈T ,M3〉 |=maj q. • If 〈T ,M5〉 |=maj q then 〈T ,M7〉 |=maj q.\nProof. The proof of items 1 and 2 follow immediately from the proof of item 2 of Lemma 3, since M5 = ◦cl(M1) and M2 = ◦cl(M3). For Item 3, we have ∀Ai ∈ M5,∃Aj ∈ M7 such that Ai ⊆ Aj . From proof of item 5 of proposition 12, we have ∀Aj ∈ M7,∃Ai ∈ M5 such that Ai ⊆ Aj . We conclude that if a majority-based conclusion holds from M5, it holds also from M7. The converse does not hold.\nExample 10 (Proof of Figure 6, Part 2). The following counter-examples show that no reciprocal edges hold in Figure 6.\n1. There exists a KB, and a query q such that q is a majority-based conclusion of 〈T ,M7〉, but q is not a majority-based conclusion of 〈T ,M5〉: Let T ={A ⊑¬B, B ⊑ D} and M={{A(a), B(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: ◦cl(M)={{A(a), B(a), D(a)}}, M7 = ◦rep(◦cl(M))={{A(a),D(a)}, {B(a),D(a)}}, M1=◦rep(M)={{A(a)}, {B(a)}}, and M5 = ◦cl(M1)={{A(a)}, {B(a), D(a)}}, Let q ← D(a) be a query. One can check that: 〈M7,maj〉 |= q but 〈M5,maj〉 6|= q\nProposition 15 (Proof of Figure 6, Part 3). Let {◦1,...,◦8} be the eight modifiers given in Table 1. Let q be a Boolean query. Then:\n• There exists an MBox M consistent w.r.t. T such that the majority-based inference from 〈T , ◦1(M)〉 is incomparable with the one obtained from 〈T , ◦2(M)〉.\n• There exists an MBox M consistent w.r.t. T such that the majority-based inference from 〈T , ◦3(M)〉 is incomparable with the one obtained from 〈T , ◦4(M)〉.\n• There exists an MBox M consistent w.r.t. T such that the majority-based inference from 〈T , ◦5(M)〉 is incomparable with the one obtained from 〈T , ◦6(M)〉.\n• There exists an MBox M consistent w.r.t. T such that the majority-based inference from 〈T , ◦7(M)〉 is incomparable with the one obtained from 〈T , ◦8(M)〉.\nExample 11. The following examples show the incomparabilities stated in the previous proposition.\n1. The majority-based inference from 〈T ,M1〉 is incomparable with the one obtained from 〈T ,M2〉. Let T ={B ⊑¬C, B ⊑ A, C ⊑ A, A ⊑¬D, D ⊑ E, E ⊑ F} and M={{A(a), B(a), C(a), D(a), E(a), F (a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = ◦rep(M)={{A(a), C(a)}, {A(a), B(a)}, {D(a), E(a), F (a)}}, and M2 = ◦card(M1)={{D(a), E(a), F (a)}} Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M1,maj〉 |= q2 but 〈M2,maj〉 6|= q2 while 〈M2,maj〉 |= q1 but 〈M1,maj〉 6|= q1.\n2. The majority-based inference from 〈T ,M3〉 is incomparable with the one obtained from 〈T ,M4〉. Let T ={B ⊑¬C, B ⊑ A, C ⊑ A, A ⊑¬D, F ⊑ D, D ⊑ E} and M={{A(a), B(a), C(a), F (a),D(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = M2={{A(a), C(a)}, {A(a),B(a)}, {D(a), F (a)}}, M3={{A(a), C(a)}, {A(a),B(a)}, {D(a), F (a), E(a)}}, M4={{D(a), E(a), F (a)}} Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M3,maj〉 |= q2 but 〈M4,maj〉 6|= q2 while 〈M4,maj〉 |= q1 but 〈M3,maj〉 6|= q1.\n3. The majority-based inference from 〈T ,M5〉 is incomparable with the one obtained from 〈T ,M6〉. Let T ={B ⊑¬C, B ⊑ A, C ⊑ A,A ⊑¬D, F ⊑ D,D ⊑ E} and M={{A(a), B(a), C(a), F (a),D(a), E(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: M1 = M5={{A(a), C(a)}, {A(a),B(a)}, {D(a), F (a), E(a)}}, M6={{D(a), E(a), F (a)}} Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M5,maj〉 |= q2 but 〈M6,maj〉 6|= q2 while 〈M6,maj〉 |= q1 but 〈M5,maj〉 6|= q1.\n4. The majority-based inference from 〈T ,M7〉 is incomparable with the one obtained from 〈T ,M8〉. Let T ={B ⊑¬C, B ⊑ A, C ⊑ A,A ⊑¬D, F ⊑ D,E ⊑ D} and M={{A(a), F (a), E(a), B(a), C(a)}}. It is easy to check that 〈T ,M〉 is inconsistent. We have: ◦cl(M)={{A(a), C(a), B(a),D(a), F (a), E(a)}}, M7={{D(a), E(a), F (a)}, {A(a),B(a)}, {A(a), C(a)}},and M8={{D(a), E(a), F (a)}},and Let q1 ← D(a) and q2 ← A(a) be two queries. One can check that: 〈M7,maj〉 |= q2 but 〈M8,maj〉 6|= q2 while 〈M8,maj〉 |= q1 but 〈M7,maj〉 6|= q1.\nProof of Figure 7 (existential semantics) The relation pictured in the figure is proved by the following propositions and examples.\nProposition 16 (Proof of Figure 7, Part 1). Let KM=〈T ,M = {A}〉 be an inconsistent DL-Lite KB. Let M1,...,M8 be the eight MBoxes given in Figure 1 and in Table 1. Let q be a Boolean query. Then:\n1. if q is an existential conclusion of 〈T ,M4〉 then q is an existential conclusion of 〈T ,M3〉.\n2. q is an existential conclusion of 〈T ,M3〉 iff q is an existential conclusion of 〈T ,M2〉.\n3. if q is an existential conclusion of 〈T ,M2〉 then q is an existential conclusion of 〈T ,M1〉.\n4. q is an existential conclusion of 〈T ,M1〉 iff q is an existential conclusion of 〈T ,M5〉.\n5. if q is an existential conclusion of 〈T ,M2〉 then q is an existential conclusion of 〈T ,M5〉.\n6. if q is an existential conclusion of 〈T ,M6〉 the q is an existential conclusion of 〈T ,M5〉.\n7. if q is an existential conclusion of 〈T ,M8〉 the q is an existential conclusion of 〈T ,M7〉.\n8. if q is an existential conclusion of 〈T ,M5〉 the q is an existential conclusion of 〈T ,M7〉.\nProof. Items 1,3, 6, and 7 follow from item 4 of Lemma 2. Items 2 and 4 follow from Item 4 of Lemma 3. Items 5 and 8 hold due the fact that ◦2 ⊆cl ◦5 and ◦5 ⊆cl ◦7.\nExample 12 (Proof of Figure 7, Part 2). The following examples show that the reciprocal edges do not hold in Figure 7. We do not include the examples that prove that all incomparabilities hold, since they are similar.\n1. There exists an existential conclusion of 〈T ,M4〉 which is not an existential conclusion of 〈T ,M3〉: Let us consider T ={A ⊑ B,B ⊑ C, C ⊑¬D, D ⊑ F} and M = {A(a), D(a)}. We have: M1 = M2 = {{A(a)}, {D(a)}}, M3 = {{A(a), B(a), C(a)}, {D(a), F (a)}}, and M4 = {{A(a), B(a),D(a)}}. Let q ← D(a) ∧ F (a) be a Boolean query. We have: ¡M3,∃¿|= q, since 〈T , {D(a), F (a)}〉 |= q. However ¡M4,∃¿6|= q.\n2. There exists an existential conclusion of 〈T ,M1〉 which is not an existential conclusion of 〈T ,M2〉: Let us consider T ={A ⊑ B,B ⊑¬C, C ⊑ D} and M={A(a), B(a), C(a), D(a)}. We have: M1 = {{A(a), B(a),D(a)}, {C(a), D(a)}}, and M2 = {{A(a), B(a),D(a)}}. Let q ← C(a) ∧D(a) be a Boolean query. One can easily check that ¡M1,∃¿|= q but ¡M2,∃¿6|= q.\n3. There exists an existential conclusion of 〈T ,M5〉 which is not an existential conclusion of 〈T ,M2〉: Let us consider T ={A ⊑ B, B ⊑ C, C ⊑¬D, D ⊑ F} and M = {A(a), B(a),D(a)}. We have: M1 = {{A(a), B(a)}, {D(a)}}, M5 = {{A(a), B(a), C(a)}, {D(a), F (a)}}, and M2 = {{A(a), B(a)}}. Let q ← D(a) ∧ F (a) be a Boolean query. One can deduce that : ¡M5,∃¿ |= q, but ¡M2,∃¿ 6|= q.\n4. There exists an existential conclusion of 〈T ,M5〉 which is not an existential conclusion of 〈T ,M6〉: Let us consider T ={A ⊑ B, B ⊑ C, C ⊑¬D, D ⊑ F} and M = {A(a), D(a)}. We have: M1 = {{A(a)}, {D(a)}}, M5 = {{A(a), B(a), C(a)}, {D(a), F (a)}}, and M6 = {{A(a), B(a), C(a)}}. Let q ← D(a) ∧ F (a) be a Boolean query. One can check that: ¡M5,∃¿ |= q, but ¡M6,∃¿ 6|= q.\n5. There exists an existential conclusion of 〈T ,M7〉 which is not an existential conclusion of 〈T ,M8〉: Let us consider T ={A ⊑ B, B ⊑¬C, C ⊑ D, D ⊑ F} and M = {A(a), C(a)}. We have: ◦cl(M) = {A(a), C(a), B(a),D(a), F (a)}, M7 = {{A(a), B(a),D(a), F (a)}, {C(a), D(a), F (a)}}, and M8 = {{A(a), B(a),D(a), F (a)}}. Let q ← C(a) ∧D(a) be a Boolean query. One can check that: ¡M7,∃¿ |= q, but ¡M8,∃¿ 6|= q.\nTheorem 2 [Productivity of semantics] The inclusion relation ⊑ is the smallest relation that contains the inclusions 〈◦i, sk〉 ⊑ 〈◦j , sk〉 defined by Propositions 1-4 and satisfying the two following conditions:\n1. for all sj , sp and oi, if sj ≤ sp then 〈◦i, sj〉 ⊑ 〈◦i, sp〉.\n2. it is transitive.\nProof. The first point follows from the definition of ≤. Let K = 〈T ,A〉 and K |=〈◦i,sj〉 q. This means that 〈T , ◦i(A)〉 |=sj q. Since sj ≤ sp, we have 〈T , ◦i(A)〉 |=sp q, hence K |=〈◦i,sp〉 q. The transitivity of ⊑ follows from its definition. Indeed, consider three semantics S1, S2, S3 such that S1 ⊑ S2 ⊑ S3, then ∀k,∀q, if K |=S1 q then K |=S2 q and K |=S3 q. Hence S1 ⊑ S3. The following Lemmas 4 and 5 show that there are no other inclusions: the first lemma states that a semantics cannot be included into another semantics with a strictly more cautious inference strategy; the second lemma states that any inclusion from a semantics to another with a strictly less cautious inference strategy can only be obtained by transitivity using an edge “internal” to the latter inference strategy.\nLemma 4. For all 〈◦i, sj〉 and 〈◦k, sp〉, if sp < sj then 〈◦i, sj〉 6⊑ 〈◦k, sp〉;\nProof. The prove this lemma, we consider the following example. Let K=〈T ,A〉 with A={pa(f, a),pb(f, b), pc(f, c), pd(f, d), pe(f, e)} and T ={pa(Z,X),pb(Z, Y )→⊥; pb(Z,X), pc(Z, Y )→⊥; pb(Z,X), pd(Z, Y )→⊥; pc(Z,X), pd(Z, Y )→⊥, pa(Z,X), pe(Z, Y )→⊥}. We have ◦1(A) contains {pa(f, a), pc(f, c)}, {pa(f, a), pd(f, d)}, {pb(f, b), pe(f, e)}, {pe(f, e), pd(f, d)} and {pe(f, e), pc(f, c)}. Since T contains only negative constraints and all ABoxes in ◦1(A) have the same size, then we have ◦1(A) = ◦2(A) = ◦3(A) = . . . = ◦8(A).\nOne can check that ◦1(A) |=∃ pa(f, a), but ◦1(A) 6|=X pa(f, a), for X ∈ {maj,∀,∩}, thus there is no 〈◦i,∃〉 ⊑ 〈◦k, sp〉 for sp ∈ {maj,∀,∩}. Similarly, we have ◦A |=maj pe(f, e), but ◦1(A) 6|=X pe(f, e), for X ∈ {∀,∩}, thus there is no 〈◦i,maj〉 ⊑ 〈◦k, sp〉 for sp ∈ {∀,∩}.\nFinally, by adding to the previous examples the five following rules: pa(X,Y ) → p(X,Z), . . . , pe(X,Y ) → p(X,Z) (which produce non-ground atoms), we do not change the repairs, hence we still have the property ◦1(A) = ◦2(A) = ◦3(A) = . . . = ◦8(A). Furthermore, we have ◦1(A) |=∀ ∃X∃Y p(X,Y ), but ◦1(A) 6|=∩ ∃X∃Y p(X,Y ), thus there is no 〈◦i,∀〉 ⊑ 〈◦k,∩〉.\nLemma 5. For all 〈◦i, sj〉 and 〈◦k, sp〉, if 〈◦i, sj〉 ⊑ 〈◦k, sp〉 and sj < sp, then 〈◦i, sp〉 ⊑ 〈◦k, sp〉.\nTo prove this lemma, we did not find a “generic” example as in the previous proof, hence we checked all cases one by one. Examples showing the incomparability can easily be found (similarly to what has been done for the proofs in the preceding section).\nNote that when we restrict queries to ground atoms additional inclusions hold. We did not consider this specific, nevertheless important, case in the paper for space restriction reasons.\nFinally, the following schema pictures all inclusions between semantics."
    } ],
    "references" : [ {
      "title" : "Consistent query answers in inconsistent databases",
      "author" : [ "Bertossi Arenas", "M. Chomicki 1999] Arenas", "L.E. Bertossi", "J. Chomicki" ],
      "venue" : "In Proc. of SIGACT-SIGMOD-SIGART,",
      "citeRegEx" : "Arenas et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Arenas et al\\.",
      "year" : 1999
    }, {
      "title" : "On rules with existential variables: Walking the decidability line",
      "author" : [ "Baget" ],
      "venue" : null,
      "citeRegEx" : "Baget,? \\Q2011\\E",
      "shortCiteRegEx" : "Baget",
      "year" : 2011
    }, {
      "title" : "Some syntactic approaches to the handling of inconsistent knowledge bases: A comparative study part 1: The flat case",
      "author" : [ "Dubois Benferhat", "S. Prade 1997] Benferhat", "D. Dubois", "H. Prade" ],
      "venue" : "Studia Logica 58(1):17–45",
      "citeRegEx" : "Benferhat et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Benferhat et al\\.",
      "year" : 1997
    }, {
      "title" : "Inconsistency-tolerant semantics for description logics",
      "author" : [ "Lembo" ],
      "venue" : "In Proc. of RR’10,",
      "citeRegEx" : "Lembo,? \\Q2010\\E",
      "shortCiteRegEx" : "Lembo",
      "year" : 2010
    }, {
      "title" : "Inconsistency-tolerant query answering in ontology-based data access",
      "author" : [ "Lembo" ],
      "venue" : "J. Web Sem",
      "citeRegEx" : "Lembo,? \\Q2015\\E",
      "shortCiteRegEx" : "Lembo",
      "year" : 2015
    }, {
      "title" : "From classical to consistent query answering under existential rules",
      "author" : [ "Lukasiewicz" ],
      "venue" : "In Proc. of AAAI’15,",
      "citeRegEx" : "Lukasiewicz,? \\Q2015\\E",
      "shortCiteRegEx" : "Lukasiewicz",
      "year" : 2015
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "Poggi" ],
      "venue" : "J. Data Semantics",
      "citeRegEx" : "Poggi,? \\Q2008\\E",
      "shortCiteRegEx" : "Poggi",
      "year" : 2008
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We propose a general framework for inconsistency-tolerant query answering within existential rule setting. This framework unifies the main semantics proposed by the state of art and introduces new ones based on cardinality and majority principles. It relies on two key notions: modifiers and inference strategies. An inconsistency-tolerant semantics is seen as a composite modifier plus an inference strategy. We compare the obtained semantics from a productivity point of view.",
    "creator" : "LaTeX with hyperref package"
  }
}