{
  "name" : "1401.3849.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Nominals, Inverses, Counting, and Conjunctive Queries or: Why Infinity is your Friend!",
    "authors" : [ "Sebastian Rudolph", "Birte Glimm" ],
    "emails" : [ "rudolph@kit.edu", "birte.glimm@comlab.ox.ac.uk" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "We present a decidability result for entailment of unions of conjunctive queries in the very expressive Description Logic ALCHOIQb. The article is an extended version of the conference paper Status QIO: Conjunctive Query Entailment is Decidable, Proceedings of the 12th International Conference on the Principles of Knowledge Representation and Reasoning (KR 2010), May 09–13, 2010 (Glimm & Rudolph, 2010).\nDescription Logics (DLs) are a family of logic based knowledge representation formalisms (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003). Most DLs correspond to the function-free two variable fragment of First-Order Logic (FOL) often extended with counting quantifiers (e.g., ∀x∃≤ny(R(x, y))) and DLs are also closely related to the (2- variable) guarded fragment since DL formulae naturally result in guarded formulae when translated into FOL. In line with the restriction to 2 variables, DL formulae contain only unary and binary predicates, which are called concepts and roles in DLs. The constructors for building complex expressions are usually chosen such that the key inference problems, such as concept satisfiability, are decidable. A DL knowledge base (KB) consists of a TBox, which contains intensional knowledge such as concept definitions and general background knowledge (essentially a FOL theory), and an ABox, which contains extensional knowledge and is used to describe individuals (a set of ground facts). Using a database metaphor, the TBox corresponds to the schema, and the ABox corresponds to the data. In contrast to\nc©2010 AI Access Foundation. All rights reserved.\ndatabases, however, DL knowledge bases, as FOL in general, adopt an open world semantics, i.e., they represent information about the domain in an incomplete way.\nStandard DL reasoning services include testing concepts for satisfiability and retrieving certain instances of a given concept. The latter retrieves, for a knowledge base consisting of an ABox A and a TBox T , all (ABox) individuals that are instances of the given (possibly complex) concept expression C, i.e., all those individuals a such that T and A entail that a is an instance of C. The underlying reasoning problems are well-understood, and the computational complexity of the standard reasoning tasks given a knowledge base as input range from PTime-complete for DLs with limited expresivity such as DL-Lite (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2005), EL (Baader, 2003), and ELP (Krötzsch, Rudolph, & Hitzler, 2008) to 2-NExpTime-complete for very expressive DLs such as SROIQ (Kazakov, 2008).\nDespite the high worst case complexity of the standard reasoning problems for very expressive DLs such as SROIQ, there are highly optimized implementations available, e.g., FaCT++ (Tsarkov & Horrocks, 2006), Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007), and HermiT (Motik, Shearer, & Horrocks, 2009). These systems are used in a wide range of applications, e.g., biology (Sidhu, Dillon, Chang, & Sidhu, 2005), bio informatics (Wolstencroft, Brass, Horrocks, Lord, Sattler, Turi, & Stevens, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), information integration (Calvanese, De Giacomo, Lenzerini, Nardi, & Rosati, 1998b), geography (Goodwin, 2005), geology (Jet Propulsion Laboratory, 2006), defense (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005), and configuration (McGuinness & Wright, 1998). Most prominently, DLs are known for their use as a logical underpinning of ontology languages, e.g., OIL, DAML+OIL, the W3C standard OWL 1 (Bechhofer, van Harmelen, Hendler, Horrocks, McGuinness, PatelSchneider, & Stein, 2004), and its successor OWL 2 (W3C OWL Working Group, 2009). There are three species of OWL 1: OWL Lite, OWL DL, and OWL Full. OWL 2 extends OWL 1 and adds three further sublanguages (called OWL 2 profiles): OWL EL, OWL QL, and OWL RL. OWL Lite corresponds to the DL SHIF in which the standard reasoning tasks are ExpTime-complete, OWL 1 DL corresponds to the DL SHOIN , in which the standard reasoning tasks are NExpTime-complete, and OWL 2 DL extends this to the DL SROIQ. For OWL Full the standard reasoning tasks are no longer decidable. The new QL, EL, and RL profiles are more restrictive than OWL DL and each of the profiles trades off different aspects of OWL’s expressive power in return for different computational and/or implementational benefits. OWL EL corresponds to the DL EL ++ (Baader, Brandt, & Lutz, 2005) and the basic reasoning problems can be performed in time that is polynomial with respect to the size of the input knowledge base. OWL 2 QL is based on the DL-Lite family of Description Logics, where the data complexity of conjunctive query entailment is in AC0. Thus, conjunctive query answering can be implemented using standard relational database technology. OWL 2 RL enables the implementation of polynomial time reasoning algorithms using rule-extended database technologies.\nIn data-intensive applications, querying KBs plays a central role. Instance retrieval is, in some aspects, a rather weak form of querying: although possibly complex concept expressions are used as queries, we can only query for tree-like relational structures, as a DL concept cannot express arbitrary cyclic structures. This property is known as the tree model property and is considered an important reason for the decidability of most\nModal and Description Logics (Grädel, 2001; Vardi, 1997) and we also heavily exploit a variant of this property to establish our decidability result. Conjunctive queries (CQs) and unions of conjunctive queries (UCQs) are well known in the database community and constitute an expressive query language with capabilities that go well beyond standard instance retrieval. In FOL terms, CQs and UCQs are formulae from the positive existential fragment. Free variables in a query (not bound by an existential quantifier) are also called answer variables or distinguished variables, whereas existentially quantified variables are called non-distinguished.\nIf the query contains no distinguished variables, the query answer is just true or false and the query is called a Boolean query. Given a knowledge base K and a Boolean UCQ q, the query entailment problem is deciding whether q is true or false w.r.t. K, i.e., we have to decide whether each model of K provides for a suitable assignment for the variables in q. For a query with distinguished variables, the answers to the query are those tuples of individual names (constants) for which the knowledge base entails the query that is obtained by replacing the free variables with the individual names in the answer tuple. These answers are also called certain answers. The problem of finding all answer tuples is known as query answering. We present a decidability result for query entailment, which is a decision problem, but this is no restriction since query answering can easily be reduced to query entailment as we illustrate in more detail in Section 3."
    }, {
      "heading" : "1.1 Related Work",
      "text" : "Conjunctive queries have been first mentioned in the context of Description Logics (DLs) by Levy and Rousset (1996). The first account of conjunctive queries as main topic is given by Calvanese, De Giacomo, and Lenzerini (1998a). In particular in recent years, the problem of decidability of conjunctive query entailment and the complexity of the problem in different logics has gained significant attention. For the DLs SHIQ and SHOQ decidability and 2-ExpTime-completeness of the problem is known (Glimm, Horrocks, Lutz, & Sattler, 2008a; Glimm, Horrocks, & Sattler, 2008b; Lutz, 2008; Eiter, Lutz, Ortiz, & Simkus, 2009). Conjunctive query entailment is already 2-ExpTime-hard in the relatively weak DL ALCI (Lutz, 2008), which was initially attributed to inverse roles. Recently, it was shown, however, that also transitive roles together with role hierarchies as in the DL SH make conjunctive query entailment 2-ExpTime-hard (Eiter et al., 2009). The techniques by Glimm et al. for SHIQ and SHOQ (Glimm et al., 2008a, 2008b) reduce query entailment to the standard reasoning task of knowledge base satisfiability checking in the DL extended with role conjunctions. An alternative technique is the so-called knots technique (Ortiz, Simkus, & Eiter, 2008b), which is an instance of the mosaic technique originating in Modal Logic. This technique also gives worst-case optimal algorithms for SHIQ and several of its sub-logics. Further, there are automata-based decision procedures for positive existential path queries (Calvanese, Eiter, & Ortiz, 2007, 2009). Positive existential path queries generalize unions of conjunctive queries and, therefore, decision procedures for this kind of query also provides decision procedures for unions of conjunctive queries. In particular the most recent extension (Calvanese et al., 2009) is very close to a conjunctive query entailment decision procedure for OWL 2, which corresponds to the DL SROIQ, because it covers\nSRIQ, SROQ, and SROI. The use of the three problematic constructors for nominals, inverses, and number restrictions is, however, not covered.\nRegarding data complexity, i.e., the complexity with respect to the ABox (the data) only, CQ entailment is usually coNP-complete for expressive logics. For example, for DLs from ALE up to SHIQ this is the case (Glimm et al., 2008a) and this holds also for CQ entailment in the two variable guarded fragment with counting (Pratt-Hartmann, 2009). The latter work is quite closely related since many Description Logics can be translated into the two variable guarded fragment with counting, i.e., the results of Pratt-Hartmann also hold for SHIQ with only simple roles (roles that are not transitive and have no transitive subrole) in the query. Given the same restriction on the query, also SHOQ and SHOI were shown to have coNP-complete data complexity w.r.t. conjunctive query entailment (Ortiz, Calvanese, & Eiter, 2008a).\nQuery entailment and answering have also been studied in the context of databases with incomplete information (Rosati, 2006b; van der Meyden, 1998; Grahne, 1991). In this setting, DLs can be used as schema languages, but the expressivity of the considered DLs is usually much lower than the expressivity of the DL ALCHOIQb that we consider here and reasoning in them is usually tractable. For example, the constructors provided by logics of the DL-Lite family (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007) are chosen such that the standard reasoning tasks are in PTime regarding combined complexity and query entailment is in AC0 with respect to data complexity. Thus, TBox reasoning can be done independently of the ABox and the ABox can be stored and accessed using a standard database SQL engine. Another tractable DL is EL (Baader, 2003). Conjunctive query entailment in EL is, however, not tractable as the complexity increases to coNP-complete (Rosati, 2007b). Moreover for EL++ (Baader et al., 2005), a still tractable extension of EL, query entailment is even undecidable (Krötzsch, Rudolph, & Hitzler, 2007). This is mainly because in EL++, one can use unrestricted role compositions. This allows for encoding context-free languages, and conjunctive queries can then be used to check the intersection of such languages, which is known to be an undecidable problem. Since the logics used in databases with incomplete information are considerable less expressive than ALCHOIQb, the techniques developed in that area do not transfer to our setting.\nGiven that query entailment is a (computationally) harder task than, for example, knowledge base satisfiability, it is not very surprising that decidability of the latter task does not necessarily transfer to the problem of CQ entailment. Most of the undecidability results can be transferred from FOL since many DLs can directly be translated into an equivalent FOL theory. For example, it is known that conjunctive query entailment is undecidable in the two variable fragment of First-Order Logic L2 (Rosati, 2007a), and Rosati identifies a relatively small set of constructors that cause the undecidability (most notably role negation axioms, i.e., axioms of the form ∀x, y (¬R(x, y)→ P (x, y)) for R,P binary predicates). Pratt-Hartmann (2009) recently established decidability for CQ entailment in the two variable guarded fragment with counting (GC2). It is worth noting that Pratt-Hartmann assumes that the background theory (that is the knowledge base in our case) is constant free and formulae of the form ∃=1x(P (x)), which can be used to simulate constants/nominals, are not considered guarded. His result covers, therefore, only the DL ALCHIQb and is not applicable to the case, when the input knowledge base (the background theory) contains nominals (individual constants).\nMost of the implemented DL reasoners, e.g., KAON2,1 Pellet, and RacerPro,2 provide an interface for conjunctive query answering, although KAON2 and RacerPro consider only named individuals in the ABox for the assignments of variables. Under that restriction queries do no longer have the standard FOL semantics and decidability is obviously not an issue since conjunctive query answering with this restriction can be reduced to standard instance retrieval by replacing the variables with individual names from the ABox and then testing entailment of each conjunct separately. Pellet goes beyond that and also provides an interface for conjunctive queries with FOL semantics under the restriction that the queries have a kind of tree shape. Under this restriction decidability is known since CQs can then be expressed as normal concepts (possibly by adding role conjunctions)."
    }, {
      "heading" : "1.2 Contributions and Overview",
      "text" : "Given all these results, which show a great interest in the problem of conjunctive query entailment over expressive DLs, it is very interesting that for the DLs SHIF , SHOIN , and SROIQ that underpin the widely adopted standards OWL Lite, OWL 1 DL, and OWL 2 DL, respectively, decidability of conjunctive query entailment has only been established for OWL Lite. The main obstacle in devising a decision procedure is the combination of inverse roles (I), nominals (O), and number restrictions/counting quantifiers (F stands for functionality, N for unqualified number restrictions, and Q for qualified number restrictions). The complications arising from the combination of these constructors caused also a major hurdle in the development of implementable algorithms for knowledge base satisfiability in SHOIN and extensions thereof, but Horrocks and Sattler (2005) devised a tableau-based decision procedure that has since been extended to SROIQ. Meanwhile also alternative approaches such as resolution (Kazakov & Motik, 2008), and hypertableau-based procedures (Motik et al., 2009) are available and implemented.\nThe key obstacle in establishing a decision procedure is the existence of potentially infinitely many new nominals, i.e., elements that are uniquely identifiable in any model of a KB. For an example, consider the KB K given in Fig. 1. A concept of the form {o} has to be interpreted as a singleton set, containing only the interpretation of the constant o. For simplicity, we assume for now that a constant is always interpreted as itself, e.g., the interpretation of o is o. An axiom of the form {o1} v ∃f.∃s.∃f−.{o2} can then be understood as follows: For the constant o1, there must be two elements, say d1 and d2, such that f(o1, d1), s(d1, d2), and f(o2, d2) holds. Note that o2 occurs as the first element in f(o2, d2) since an inverse role (f−) is used. Thus, an interpretation for the KB must contain the three elements o1, o2, and o3, which must be interconnected in the following way: paths of the shape\nf→ · s→ · f← have to lead from o1 to o2 as well as from o2 to o3 and from o3 to o1. Moreover, the role f is defined to be functional, meaning that every element can have at most one f -successor. This also applies to all individuals oi, which forces the existence of an s-cycle. Observe that a cyclic Boolean query such as {s(x, y), s(y, z), s(z, x)} that checks for the existence of such a cycle cannot be answered by applying standard techniques such as replacing variables with individual names (oi) or rewriting the query into an equivalent\n1. http://kaon2.semanticweb.org 2. http://www.racer-systems.com\ntree-shaped query. The elements in the cycle behave as if they were nominals, but we do not have names for them.\nWe tackle the problem of conjunctive query entailment in a very expressive DL that contains all the three problematic constructors simultaneously and prove decidability of (unions of) conjunctive queries. The most challenging part is to establish finite representability of countermodels in case the query given as input is not entailed by the knowledge base. Our results also hold for SHOIQ knowledge bases, i.e., with some roles declared as transitive, provided that the queries contain only simple roles (roles that are neither transitive nor have a transitive subrole). This is essentially the same restriction that is placed on roles that can occur in number restrictions since otherwise the standard reasoning tasks become undecidable. Under this restriction, we can use standard techniques for eliminating transitivity (Kazakov & Motik, 2008). Hence, we also show decidability of conjunctive query entailment in OWL DL, for queries with only simple roles.\nWe believe that our work is also valuable for understanding, in general, the structure of models in DLs that contain nominals, inverse roles, and number restrictions. Furthermore, we devise non-trivial extensions of standard techniques such as unraveling, which we believe will prove useful when working with such expressive DLs.\nThe paper is organized as follows: in Section 2, we give a bird’s-eye view of the techniques and ideas used to establish decidability. In Section 3, we give the necessary definitions and introduce standard notations. In Sections 4, 5, and 6 we present the main results that we then use in Section 7 to show how models that do not satisfy the query can be finitely represented before we conclude in Section 8."
    }, {
      "heading" : "2. The Big Picture",
      "text" : "Before going into the technical details, we will describe our overall line of argumentation establishing decidability of conjunctive query entailment in ALCHOIQb."
    }, {
      "heading" : "2.1 Decidability via Finitely Representable Countermodels",
      "text" : "Let K be an ALCHOIQb knowledge base and let q be the conjunctive query in question, i.e., we aim to determine whether\nK |= q.\nClearly, as ALCHOIQb is a fragment of first-order predicate logic with equality, K can be translated into a FOL sentence FOL(K). Likewise we find a FOL sentence FOL(q) for\nq being just an existentially quantified formula. Hence, checking the above entailment is equivalent to determining whether the first-order theory FOL(K) entails FOL(q). As a result of the completeness theorem for FOL (Gödel, 1929), the consequences of a finite FOL theory are recursively enumerable, which provides us with a procedure that terminates if K |= q. Hence, we can establish decidability by providing another algorithm that terminates iff the entailment above does not hold – i.e., if there is a so-called countermodel being a model I of K for which I 6|= q.\nWe will provide such an algorithm by showing that, whenever such a countermodel I exists at all, there is also a countermodel I that is finitely representable. More precisely, I can be encoded into a word Rep(I) of finite length over a finite alphabet, whereby the encoding Rep has the property that for every such finite word it can be effectively checked whether it represents a countermodel for a given knowledge base and query.\nAs a consequence thereof, we can create the desired algorithm that enumerates all words, checks each for being a countermodel, and terminates as soon as it has found one."
    }, {
      "heading" : "2.2 Finite Representability by Bounding Nominals and Blocking",
      "text" : "We now outline how we are going to show that there is always a finitely representable countermodel, if there is one at all. We do this by taking an arbitrary countermodel and cautiously transforming it into a countermodel that is finitely representable. Cautiously means that we have to make sure that the transformation does preserve the two properties of 1) being a model of the underlying knowledge base K and 2) not entailing the considered query q.\nThe result of the overall transformation is going to be a regular model, i.e., a structure where substructures are being in a certain sense periodically repeated. It is common practice in DL theory to construct this kind of models from arbitrary ones by blocking techniques, whereby certain element configurations occurring twice in the original model are detected and the new model is generated by infinitely stringing together the same finite substructure that is delimited by those two configurations.\nIn the case we consider, this technique cannot be applied directly to the original countermodel. This is due to an intricate interplay of nominals, inverse roles and cardinality constraints by which an arbitrary – even an infinite – number of domain elements can be forced to “behave” like nominals; this is why those elements are usually referred to as new nominals in a DL setting. In FOL, nominals are often called kings and the new nominals are called the court. In our case, the presence of infinitely many new nominals in the model may prevent the existence of repeated configurations needed for blocking.\nWe overcome this difficulty by first applying a transformation by means of which the original countermodel is converted into a countermodel with only finitely many new nominals. This guarantees that the subsequent blocking-based transformation is applicable and will yield the desired regular (and thus finitely representable) model."
    }, {
      "heading" : "2.3 Bounding Nominals by Transformations of Forest Quasi-Models",
      "text" : "For our argumentation, we introduce the notion of forest quasi-models. These are structures not satisfying the originally considered knowledge base but a weakened form of it. In\nreturn to this concession, they exhibit a proper forest structure that is easier to handle and manipulate.\nWe employ two techniques to turn “proper” models into forest quasi-models and vice versa: a model can be unraveled yielding a forest quasi-model. A forest quasi-model can be collapsed to obtain a “proper” model. Both techniques preserve certain structural properties.\nOur strategy to construct a countermodel with finitely many nominals consists of the following three steps:\n• Take an arbitrary countermodel and unravel it.\n• Transform the obtained forest quasi-model by substituting critical parts by wellbehaved ones,\n• Collapse the obtained structure into a (proper) model.\nThe mentioned “critical parts” are those giving rise to new nominals. They have to be – at least largely – avoided (we do not care about a finite set of those critical parts remaining).\nThe central question is: where do these mysterious well-behaved substitutes come from? Fortunately, the plethora of critical parts brings about its own remedy. We can use infinite sets of critical parts to construct well-behaved ones in an infinite approximation process (this is why infinity is your friend). We thereby obtain parts which have not been present in our structure before, but are well compatible with it and can hence be used for its reorganization.\nAfter having informally introduced our main line of argumentation, we now move on to the technical details."
    }, {
      "heading" : "3. Preliminaries",
      "text" : "We first define the syntax and semantics of roles, and then go on to SHOIQb-concepts, individuals, and knowledge bases. We do not actually use the full expressivity of SHOIQb, but it is a convenient umbrella for all DLs we are working with and we can define less expressive DLs of interest as restrictions of SHOIQb.\nDefinition 1 (Syntax of SHOIQb). Let NC , NR, and NI be countable, infinite, and pairwise disjoint sets of concept names, role names, and individual names, respectively. We call S = (NC ,NR,NI ) a signature. The set rol(S) of SHOIQb-roles over S (or roles for short) is NR ∪ {r− | r ∈ NR}, where roles of the form r− are called inverse roles. A role inclusion axiom is of the form r v s with r, s roles. A transitivity axiom is of the form trans(r) for r a role. A role hierarchy H is a finite set of role inclusion and transitivity axioms.\nFor a role hierarchy H, we define the function inv over roles as inv(r) := r− if r ∈ NR and inv(r) := s if r = s− for a role name s ∈ NR. Further, we define vH as the smallest transitive reflexive relation on roles such that r v s ∈ H implies r vH s and inv(r) vH inv(s). We write r ≡H s if r vH s and s vH r. A role r is transitive w.r.t. H (notation r+ vH r) if a\nrole s exists such that r vH s, s vH r, and trans(s) ∈ H or trans(inv(s)) ∈ H. A role s is called simple w.r.t. H if there is no role r such that r is transitive w.r.t. H and r vH s.\nFor r ∈ rol(S) a simple role, a Boolean role expressions U is defined as follows:"
    }, {
      "heading" : "U ::= r | ¬U | U u U | U t U.",
      "text" : "We use ` to denote standard Boolean entailment between a set of roles R ⊆ rol(S) and role expressions. Let r ∈ rol(S), and U a Boolean role expression over R. We inductively define:\n• R ` r if r ∈ R, and R 6` r otherwise,\n• R ` ¬U if R 6` U , and R 6` ¬U otherwise,\n• R ` U u V if R ` U and R ` V , and R 6` U u V otherwise,\n• R ` U t V if R ` U or R ` V , and R 6` U t V otherwise.\nA Boolean role expression U is safe if ∅ 6` U . Given a signature S = (NC , NR, NI ), the set of SHOIQb-concepts (or concepts for short) over S is the smallest set built inductively over symbols from S using the following grammar, where o ∈ NI , A ∈ NC , n ∈ IN0, s is a simple role, and U is a role or a safe Boolean role expression:\nC ::= > | ⊥ | {o} | A | ¬C | C1 u C2 | C1 t C2 | ∀U.C | ∃U.C | 6n s.C | >n s.C. 4\nAlternatively, safeness can be characterized as follows: a Boolean role expression U is safe if, after transforming it into disjunctive normal form, each disjunct contains at least one non-negated role. Intuitively, this implies that a safe role expression can never relate individuals that are not in a direct role relation with each other.\nDefinition 2 (Semantics of SHOIQb-concepts). An interpretation I = (∆I , ·I) consists of a non-empty set ∆I , the domain of I, and a function ·I , which maps every concept name A ∈ NC to a subset AI ⊆ ∆I , every role name r ∈ NR to a binary relation rI ⊆ ∆I ×∆I , and every individual name a ∈ NI to an element aI ∈ ∆I . For each role name r ∈ NR, the interpretation of its inverse role (r−)I consists of all pairs 〈δ, δ′〉 ∈ ∆I ×∆I for which 〈δ′, δ〉 ∈ rI .\nThe semantics of SHOIQb-concepts over a signature S is defined as follows:\n(¬r)I = ∆I ×∆I \\ rI (r1 u r2)I = rI1 ∩ rI2 (r1 t r2)I = rI1 ∪ rI2 >I = ∆I ⊥I = ∅ ({o})I = {oI}\n(¬C)I = ∆I \\ CI (C uD)I = CI ∩DI (C tD)I = CI ∪DI (∀U.C)I = {δ ∈ ∆I | if 〈δ, δ′〉 ∈ UI , then δ′ ∈ CI} (∃U.C)I = {δ ∈ ∆I | there is a 〈δ, δ′〉 ∈ UI with δ′ ∈ CI}\n(6n s.C)I = {δ ∈ ∆I | ](sI(δ, C)) ≤ n} (>n s.C)I = {δ ∈ ∆I | ](sI(δ, C)) ≥ n}\nwhere ](M) denotes the cardinality of the set M and sI(δ, C) is defined as\n{δ′ ∈ ∆I | 〈δ, δ′〉 ∈ sI and δ′ ∈ CI}.\nA concept C is in negation normal form (NNF) if negation occurs only in front of concept names and we use nnf(C) to denote the negation normal form of a concept C. 4\nAny concept can be transformed in linear time into an equivalent one in NNF by pushing negation inwards, making use of de Morgan’s laws and the duality between existential and universal restrictions, and between at-most and at-least number restrictions of the form 6n r.C and > n r.C respectively (Horrocks, Sattler, & Tobies, 2000).\nDefinition 3 (Syntax and Semantics of Axioms and Knowledge Bases). A functionality restriction is an expression func(f) for f a role. For C,D concepts, a general concept inclusion (GCI) is an expression C v D. We introduce C ≡ D as an abbreviation for C v D and D v C. A finite set of GCIs and functionality restrictions is called a TBox. An (ABox) assertion is an expression of the form C(a), r(a, b), ¬r(a, b), a .= b, or a 6 .= b, where C is a concept, r is a role, and a, b ∈ NI are individual names. An ABox is a finite set of assertions. A knowledge base K is a triple (T , H, A) with T a TBox, H a role hierarchy, and A an ABox.\nWe use con(K), rol(K), and nom(K) to denote, respectively, the set of concept names, roles (including inverses), and individual names occurring in K. The closure cl(K) of K is the smallest set containing nnf(¬C t D) if C v D ∈ T ; D if D is a sub-concept of C and C ∈ cl(K); and nnf(¬C) if C ∈ cl(K). A role f is functional in K if K contains the functionality axiom func(f) and it is inverse functional in K if K contains the functionality axiom func(inv(f)).\nLet I = (∆I , ·I) be an interpretation. Then I satisfies a role inclusion axiom r v s if rI ⊆ sI , I satisfies a transitivity axiom trans(r) if rI is a transitive binary relation, and a role hierarchy H if it satisfies all role inclusion and transitivity axioms in H. The interpretation I satisfies a functionality restriction func(f) if, for each δ ∈ ∆I , ]({δ′ | 〈δ, δ′〉 ∈ fI}) ≤ 1; I satisfies a GCI C v D if CI ⊆ DI ; and I satisfies a TBox T if it satisfies each functionality restriction and each GCI in T . The interpretation I satisfies an assertion C(a) if aI ∈ CI , r(a, b) if 〈aI , bI〉 ∈ rI , ¬r(a, b) if 〈aI , bI〉 /∈ rI , a .= b if aI = bI , and a 6 .= b if aI 6= bI ; I satisfies an ABox if it satisfies each assertion in A. We say that I satisfies K if I satisfies T , H, and A. In this case, we say that I is a model of K and write I |= K. We say that K is consistent if K has a model. 4\nIf the knowledge base K is clear from the context, we simply say that a role f is (inverse) functional instead of saying f is (inverse) functional in K.\nThe names of DLs indicate which constructors are supported. The basic DL ALC supports Boolean concept constructors and GCIs, but no role hierarchies, functionality restrictions et cetera. If transitivity axioms are added, we use S instead of ALC. Inverse roles are indicated by the letter I, role inclusion axioms by H, nominals, i.e., concepts of the form {o} for o ∈ NI , by O, functionality restrictions by F , qualified number restrictions, i.e., concepts of the form 6n s.C and > n s.C, by Q, and safe Boolean role expressions by b. If number restrictions are limited to concepts of the form 6n s.> and >n s.>, we use the letter N .\nWe mostly refer to a few particular DLs in this paper: the DL SHOIQ is obtained from SHOIQb by disallowing Boolean role expressions. The DLs SHIQ, SHOQ, and SHOI are obtained from SHOIQ by disallowing nominals, inverse roles, and number restrictions (incl. functionality restrictions), respectively. Finally, the DL ALCOIFb is obtained from SHOIQb by disallowing transitivity axioms (we use ALC instead of S in the name of the DL to indicate this), role inclusion axioms, and concepts of the form 6n s.C and >n s.C."
    }, {
      "heading" : "3.1 Conjunctive Queries and Unions of Conjunctive Queries",
      "text" : "We now introduce Boolean conjunctive queries since they are the basic form of queries we are concerned with. We later also define non-Boolean queries and show how they can be reduced to Boolean queries. Finally, unions of conjunctive queries are just a disjunction of conjunctive queries.\nDefinition 4 (Syntax and Semantics of Conjunctive Queries). Let S = (NC ,NR,NI ) be a signature and NV a countably infinite set of variables disjoint from NC , NR, and NI . A term t is an element from NV ∪ NI . Let A ∈ NC be a concept name, r ∈ NR a role name, and t, t′ terms. An atom is an expression A(t) or r(t, t′) and we refer to these two types of atoms as concept atoms and role atoms respectively. A Boolean conjunctive query q is a non-empty set of atoms. We use var(q) to denote the set of (existentially quantified) variables occurring in q and term(q) to denote the set of variables and individual names occurring in q. As usual, we use ](q) to denote the cardinality of q, which is simply the number of atoms in q, and we use |q| for the size of q, i.e., the number of symbols necessary to write q.\nLet I = (∆I , ·I) be an interpretation. A total function π : term(q)→ ∆I is an evaluation if π(a) = aI for each individual name a occurring in q. For A(t), r(t, t′) atoms, we write\n• I |=π A(t) if π(t) ∈ AI ;\n• I |=π r(t, t′) if (π(t), π(t′)) ∈ rI .\nIf, for an evaluation π, I |=π At for all atoms At ∈ q, we write I |=π q. We say that I satisfies q and write I |= q if there exists an evaluation π such that I |=π q. We call such a π a match for q in I.\nLet K be a knowledge base and q a conjunctive query. If I |= K implies I |= q, we say that K entails q and write K |= q. 4\nThe query entailment problem is defined as follows: given a knowledge base K and a query q, decide whether K |= q.\nDefinition 5 (Unions of Conjunctive Queries). A union of Boolean conjunctive queries is a formula q1 ∨ . . . ∨ qn, where each disjunct qi is a Boolean conjunctive query.\nA knowledge base K entails a union of Boolean conjunctive queries q1∨ . . .∨ qn, written as K |= q1 ∨ . . .∨ qn, if, for each interpretation I such that I |= K, there is some i such that I |= qi and 1 ≤ i ≤ n. 4\nWe now clarify the connection between query entailment and query answering. For query answering, let the variables of a conjunctive query be typed: each variable can either be existentially quantified (also called non-distinguished) or free (also called distinguished or answer variables). Let q be a query in n variables (i.e., ](var(q)) = n), of which v1, . . . , vm (m ≤ n) are answer variables. The answers of K to q are those m-tuples (a1, . . . , am) of individual names such that, for all models I of K, I |=π q for some π that satisfies π(vi) = aIi for all i with 1 ≤ i ≤ m. Recall that we use nom(K) to denote the set of individual names occurring in K (in the form of nominals or ABox individuals). It is not hard to see (cf. Chandra & Merlin, 1977) that the answers of K to q can be computed by testing, for each\n(a1, . . . , am) ∈ nom(K)m, whether the query q[v1,...,vm/a1,...,am] obtained from q by replacing each occurrence of vi with ai for 1 ≤ i ≤ m is entailed by K. The set of certain answers to q is then the set of all m-tuples (a1, . . . , am) for which K |= q[v1,...,vm/a1,...,am]. Let k = ](nom(K)) be the number of individual names occurring in K. Since K is finite, clearly k is finite. Hence, deciding which tuples belong to the set of answers can be checked with at most km entailment tests.\nThe algorithm that we present in this paper decides query entailment. The reasons for devising a decision procedure for query entailment instead of query answering are twofold: first, query answering can be reduced to query entailment as shown above; second, in contrast to query answering, query entailment is a decision problem and can be studied in terms of complexity theory."
    }, {
      "heading" : "3.2 Simplifying Assumptions",
      "text" : "In the following, we make several assumptions that are without loss of generality, but simplify the presentation of the decision procedure.\n3.2.1 From SHOIQ and ALCHOIQb to simplified ALCOIFb Knowledge Bases\nIn the following, we only work with ALCOIFb knowledge bases. Nevertheless, our results also hold for SHOIQ knowledge bases and queries with only simple roles in the query and for ALCHOIQb knowledge bases, i.e., when the knowledge base contains safe Boolean role expressions, but no transitivity. The restriction to ALCOIFb is without loss of generality, as we show now.\nProvided the query contains only simple roles, we can use the elimination techniques for transitivity (Kazakov & Motik, 2008) to reduce a SHOIQ knowledge base to anALCHOIQ knowledge base with extended signature. We can further eliminate qualified number restrictions and role inclusion axioms by transforming an ALCHOIQb knowledge base into an ALCOIFb knowledge base that is equivalent to the original one up to an extension of the signature (Rudolph, Krötzsch, & Hitzler, 2008). We do not repeat a formal proof here, but rather give an informal argument as to how this reduction works.\nWe assume that the knowledge base is in negation normal form, i.e., all GCIs are of the form > v C with C a concept in NNF. Now, consider a concept expression of the form > n r.C with r a role and C a concept. This means that there are at least n distinct rneighbors satisfying C. However, this situation can be enforced by introducing n new roles r1, . . . , rn each of which is deemed to have r as a superrole (ri v r) and which are pairwise disjoint (> v ∀(ri u rj).⊥). Under those “side conditions”, the above concept expression can be replaced by ∃r1.C u . . . u ∃rn.C.\nA somewhat dual argumentation is possible for concept expressions of the form 6n r.C restricting the number of r-neighbors satisfying C to at most n. Again we extend the signature by introducing new roles r1, . . . , rn, but this time, we let them “cover” all outgoing r-links in the following sense: whenever an r-link leads to some domain element δ which satisfies C, then one of the roles r1, . . . , rn also leads there. Indeed, safe Boolean role expressions allow for expressing this correspondence via the concept description ∀(ru¬r1u . . . u ¬rn).¬C. It is now easy to see, that this concept expression can replace the above if we additionally demand all roles r1, . . . , rn to be functional.\n{o} v ∃r.A A v ∃r.A A v ∃s.B\nfunc(f−) func(g−) B v C tD\nC v ∃f.E D v ∃g.E E v B t {o}\nFinally consider a role hierarchy statement r v s, stating that whenever two domain elements δ1 and δ2 are connected by role r, they are also interconnected via s. Clearly, this statement can be reformulated as: there are no two domain elements connected by r and by ¬s. This, in turn, can be equivalently rephrased by saying that no domain element has an r u ¬s-neighbor or, expressed as GCI, > v ∀(r u ¬s).⊥.\nThese transformations can be applied to an ALCHOIQb knowledge base, whereby all cardinality constraints and role inclusion axioms are eliminated. This leaves us with an equivalent ALCOIFb knowledge base up to an extension of the signature.\nFigure 2 displays an ALCOIFb knowledge base and an according model, which we will refer to as a running example throughout the paper.\nFurthermore, we assume that the ABox is internalized (e.g., C(a) is replaced by the equivalent GCI {a} v C, r(a, b) by {a} v ∃r.{b}, etc.). Thus, we effectively decide query entailment with respect to a TBox only since knowledge bases in this setting have an empty ABox.\nFor T an ALCOIFb TBox, it is always possible to transform T into an equivalent TBox T ′ up to signature extension such that all GCIs in T ′ have one of the following simplified forms:\nl Ai v ⊔ Bj | A ≡ {o} | A v ∀U.B | A v ∃U.B | func(f), (1)\nwhere A(i) and B(j) are concept names, o is an individual name, U is a safe Boolean role expression, and f is a role. If i = 0, we interpret d Ai as > and if j = 0, we interpret ⊔ Bj as ⊥. An ALCOIFb knowledge base K = (T ,A) is simplified if T is simplified and A is empty. Every ALCOIFb knowledge base, which is not in this form, can be transformed in polynomial time into the desired form by using the standard structural transformation, which iteratively introduces definitions for compound sub-concepts (Kazakov & Motik, 2008). Thus, we assume in the remainder that any knowledge base is rewritten into a simplified ALCOIFb knowledge base."
    }, {
      "heading" : "3.2.2 Connected and Constant-free Queries",
      "text" : "We assume that queries are connected. More precisely, let q be a conjunctive query. We say that q is connected if, for all t, t′ ∈ term(q), there exists a sequence t1, . . . , tn such that t1 = t, tn = t′ and, for all 1 ≤ i < n, there exists a role name r such that r(ti, ti+1) ∈ q or r(ti+1, ti) ∈ q. A collection q1, . . . , qn of queries is a partitioning of q if q = q1 ∪ . . . ∪ qn, term(qi) ∩ term(qj) = ∅ for 1 ≤ i < j ≤ n, and each qi is connected.\nLemma 6. Let K be a knowledge base, q a conjunctive query, and q1, . . . , qn a partitioning of q. Then K |= q iff K |= qi for each i with 1 ≤ i ≤ n.\nA proof is given by Tessaris (2001) and, with this lemma, it is clear that the restriction to connected queries is indeed without loss of generality since entailment of q can be decided by checking entailment of each qi at a time. In what follows, we therefore assume queries to be connected without further notice.\nIn unions of conjunctive queries, we assume that the variable names in each disjunct are different from the variable names in the other disjuncts. This can always be achieved by naming variables apart. We further assume that each disjunct in a UCQ is a connected conjunctive query. This is without loss of generality since a UCQ which contains unconnected disjuncts can always be transformed into conjunctive normal form; we can then decide entailment for each resulting conjunct separately and each conjunct is a union of connected conjunctive queries (Glimm et al., 2008a). Note that, due to the transformation into conjunctive normal form, the resulting number of unions of connected conjunctive queries for which we have to test entailment can be exponential in the size of the original query.\nWe further assume that queries do not contain constants (individual names) to occur in the position of variables. In the presence of nominals this is without loss of generality: for each individual name a occurring in q, we extend the knowledge base K with the axioms {a} ≡ Na for Na ∈ NC a fresh concept name, and replace each occurrence of a in q with a fresh variable xa ∈ NV and add a concept atom Na(xa) to q."
    }, {
      "heading" : "3.2.3 General Notation",
      "text" : "Throughout this paper, concept names and role expressions are written in upper case, while roles and individual names are written in lower case. Unless stated otherwise, we use A and B for concept names; C and D for possibly complex concepts; r and s for roles, f for functional or inverse functional roles; U and V for safe Boolean role expressions; and o for nominals that are used in TBox axioms or that occur in complex concepts. Sub- and superscripts might be appended if necessary. If not stated otherwise, we use q (possibly with subscripts) for a connected Boolean conjunctive query, K for a simplified ALCOIFb knowledge base, I for an interpretation (∆I , ·I), and π, µ for evaluations."
    }, {
      "heading" : "4. Model Construction",
      "text" : "In this section, we introduce interpretations and models that have a kind of forest shape. The main notion of a forest is, however, very weak since we do also allow for arbitrary relations between tree elements and roots. Without such relations, we call the result a strict forest. We exploit the nice properties of trees and forests in the following sections,\nwhen we replace parts in interpretations that give rise to an infinite number of new nominals. Since even models of an ALCOIFb knowledge base that have a kind of forest shape are not really forests, we also introduce “approximations” of models in which nominals are no longer interpreted as singleton sets. We call these structures quasi-interpretations or quasi-models and such interpretations can have the form of real forests. Further, we provide a way of “unraveling” an arbitrary model into a forest that is a quasi-model for the knowledge base and a way of “collapsing” such forest quasi-models back into real models of the knowledge base that still have a kind of forest shape.\nDefinition 7 (Forest (Quasi-)Interpretations and (Quasi-)Models). A tree T is a nonempty, prefix-closed subset of IN∗. For w,w′ ∈ T , we call w′ a successor of w if w′ = w · c for some c ∈ IN, where “·” denotes concatenation. We call w′ a predecessor of w if w = w′ ·c for some c ∈ IN, and w′ is a neighbor of w if w′ is a successor of w or vice versa. The empty word ε is called the root of the tree. We use |w| to denote the length of w.\nA forest F is a subset of R×IN∗, where R is a countable, possibly infinite set of elements such that, for each ρ ∈ R, the set {w | (ρ, w) ∈ F} is a tree. Each pair (ρ, ε) ∈ F is called a root of F . For (ρ, w), (ρ′, w′) ∈ F , we call (ρ′, w′) a successor of (ρ, w) if ρ′ = ρ and w′ is a successor of w; (ρ′, w′) is a predecessor of (ρ, w) if ρ′ = ρ and w′ is a predecessor of w; (ρ′, w′) is a neighbor of (ρ, w) if (ρ′, w′) is a successor of (ρ, w) or vice versa. A node (ρ, w) is an ancestor of a node (ρ′, w′) if ρ = ρ′ and w is a prefix of w′ and it is a descendant if ρ = ρ′ and w′ is a prefix of w.\nA forest interpretation of a knowledge base K is an interpretation I = (∆I , ·I) that satisfies the following conditions:\nFI1 ∆I is a forest with roots R;\nFI2 there is a total and surjective function λ : nom(K)→ R × {ε} such that λ(o) = (ρ, ε) iff oI = (ρ, ε);\nFI3 for each role r ∈ rol(K), if 〈(ρ, w), (ρ′, w′)〉 ∈ rI , then either\n(a) w = ε or w′ = ε, or\n(b) (ρ, w) is a neighbor of (ρ′, w′).\nIf I |= K, we say that I is a forest model for K. If ∆I has a single root, we call I a tree interpretation and a tree model for K, respectively.\nLet K be an ALCOIFb knowledge base. With nomFree(K), we denote the ALCIFb knowledge base obtained from K by replacing each nominal concept {o} with o ∈ nom(K) with a fresh concept name No. A forest quasi-interpretation for K is an interpretation J = (∆J , ·J ) of nomFree(K) that satisfies the following properties:\nFQ1 ∆J is a forest with roots R;\nFQ2 there is a total and surjective function λ : nom(K)→ R × {ε} such that λ(o) = (ρ, ε) iff (ρ, ε) ∈ NJo\nFQ3 for each role r ∈ rol(K), if 〈(ρ, w), (ρ′, w′)〉 ∈ rI , then either\n(a) w = ε or w′ = ε, or\n(b) (ρ, w) is a neighbor of (ρ′, w′).\nNote that condition FQ2 allows for elements (ρ, w) ∈ ∆J with w 6= ε such that (ρ, w) ∈ NJo . We call J strict if in condition FQ3, only FQ3(b) is allowed. If J |= nomFree(K) we say that J is a forest quasi-model for K.\nThe branching degree d(w) of a node w in a tree T is the number of successors of w. Let I = (∆I , ·I) be a forest (quasi) interpretation for K. If there is a k such that d(w) ≤ k for each (ρ, w) ∈ ∆I , then we say that I has branching degree k. 4\nIn the remainder, when we use the concept name No, we mean the fresh concept name that was introduced in nomFree(K) for the nominal concept {o} with o ∈ nom(K). Elements in the extension of a concept No are called nominal placeholders. Please note that, in a forest quasi-interpretations J , we can have several elements (ρ, w) with w 6= ε such that (ρ, w) ∈ NJo .\nIn the following, we define a notion of isomorphism between forest interpretations. Note that we demand not only structural identity w.r.t. concepts and roles but also w.r.t. the successor relation.\nDefinition 8 (Isomorphism between Forest Interpretations). Let I, I ′ be two forest interpretations of K with δ1, δ2 ∈ ∆I , δ′1, δ′2 ∈ ∆I ′ . The pairs 〈δ1, δ2〉, 〈δ′1, δ′2〉 are isomorphic w.r.t. K, written 〈δ1, δ2〉 ∼=K 〈δ′1, δ′2〉 iff\n1. 〈δ1, δ2〉 ∈ rI iff 〈δ′1, δ′2〉 ∈ rI ′ for each r ∈ rol(K),\n2. δi ∈ AI iff δ′i ∈ AI ′ for i ∈ {1, 2} and each A ∈ con(K),\n3. δi = oI iff δ′i = o I′ for i ∈ {1, 2} and each o ∈ nom(K).\nWe say that I and I ′ are isomorphic w.r.t. K, written: I ∼=K I ′, if there is a bijection ϕ : ∆I → ∆I′ such that, for each δ1, δ2 ∈ ∆I , 〈δ1, δ2〉 ∼=K 〈ϕ(δ1), ϕ(δ2)〉 and δ1 is a successor of δ2 iff ϕ(δ1) is a successor of ϕ(δ2). 4\nIf clear from the context, we omit the subscript K of ∼=K. We extend the above definition in the obvious way to forest quasi-interpretations, i.e., by omitting condition 3 and defining the isomorphism with respect to K′ = nomFree(K).\nForest quasi-models have, intuitively, the purpose of an intermediate step between arbitrary models of K and forest models of K. When identifying each δ in the interpretation of a concept No in the knowledge base K′ with a root that is in the interpretation of No, we obtain an interpretation that would be a model for K apart from functionality restrictions for some nominals that might be violated. We show later how we can eliminate those relations from the forest back to the roots that violate functionality restrictions and how we can eventually obtain a forest model from a forest quasi-model.\nAnother useful property of quasi-interpretations is that, for simplified ALCIFb knowledge bases, it can be checked locally whether an interpretation I is actually a model of K.\nDefinition 9 (Local K-consistency). Let I = (∆I , ·I) be an interpretation for a simplified ALCIFb knowledge base K with δ ∈ ∆I . We define local satisfaction for δ and concepts that can occur in simplified ALCIFb axioms as follows:\n1. for A1, . . . , An ∈ con(K):\n(a) I, δ |= d Ai if δ ∈ AIi for each i with 1 ≤ i ≤ n; I, δ 6|= d Ai otherwise;\n(b) I, δ |= ⊔ Ai if δ ∈ AIi for some i with 1 ≤ i ≤ n; I, δ 6|= ⊔ Ai otherwise;\n2. for U a safe Boolean role expression over rol(K), A ∈ con(K):\n(a) I, δ |= ∃U.A if there is some δ′ ∈ ∆I such that 〈δ, δ′〉 ∈ UI and I, δ′ |= A; I, δ 6|= ∃U.A otherwise;\n(b) I, δ |= ∀U.A if, for each δ′ ∈ ∆I such that 〈δ, δ′〉 ∈ UI , I, δ′ |= A; I, δ 6|= ∀U.A otherwise;\n3. for f ∈ rol(K), I, δ |= func(f) if ]({δ′ ∈ ∆I | 〈δ, δ′〉 ∈ fI}) ≤ 1; I, δ 6|= func(f) otherwise.\nAn element δ ∈ ∆I locally satisfies a GCI C v D with C,D ALCIFb-concepts if I, δ |= C implies I, δ |= D. It locally satisfies a functionality restriction func(f) if I, δ |= func(f). An element δ ∈ ∆I is locally K-consistent if it locally satisfies each axiom in K. 4\nLemma 10. Let K be a simplified ALCIFb knowledge base and I = (∆I , ·I) an interpretation for K. Then I is a model for K iff each element δ ∈ ∆I is locally K-consistent.\nProof. For simplified ALCIFb knowledge bases, only axioms of the form A v ∀U.B and A v ∃U.B involve checking neighbors of an element δ and, since B is a concept name in simplified knowledge bases, it is immediate that satisfaction of B can be checked locally for the neighbor of δ in question.\nFor a knowledge base K with nominals, we can also use local K-consistency, but we need an additional global condition that ensures that nominals are interpreted as singleton sets. The following is an immediate consequence of Lemma 10 and the extra condition 2 for nominals:\nProposition 11. Let K be a simplified ALCOIFb knowledge base and I = (∆I , ·I) an interpretation for K. Then I is a model for K iff\n1. each element δ ∈ ∆I is locally K-consistent and,\n2. for each o ∈ nom(K), there is exactly one element δ ∈ ∆I such that oI = δ.\nWe now show how we can obtain a forest quasi-model from a model of K by using an adapted version of unraveling.\nDefinition 12 (Unraveling). Let K be a consistent ALCOIFb knowledge base and I = (∆I , ·I) a model for K. Let choose be a function that returns, for a concept C = ∃U.B ∈ cl(K) and an element δ ∈ (∃U.B)I an element δC,δ ∈ ∆I such that 〈δ, δC,δ〉 ∈ UI and δC,δ ∈ BI .\nWithout loss of generality, we assume that, for all δ ∈ ∆I and concepts C1 = ∃U1.B1, C2 = ∃U2.B2 ∈ cl(K) such that δ ∈ CI1 ∩ CI2 , if choose(C1, δ) = δ1, choose(C2, δ) = δ2, and 〈δ, δ1〉 ∼= 〈δ, δ2〉, then δ1 = δ2.\nAn unraveling for some element δ ∈ ∆I , denoted as ↓(I, δ), is an interpretation that is obtained from I and δ as follows: we define the set S ⊆ (∆I)∗ of sequences to be the smallest set such that\n• δ is a sequence;\n• δ1 · · · δn · δn+1 is a sequence, if\n– δ1 · · · δn is a sequence, – if n > 2 and 〈δn, δn−1〉 ∈ fI for some functional role f , then δn+1 6= δn−1, – δn+1 = choose(C, δn) for some C = ∃U.B ∈ cl(K).\nNow fix a set F ⊆ {δ} × IN∗ and a bijection λ : F → S such that\n(i) F is a forest,\n(ii) λ(δ, ε) = δ,\n(iii) if (δ, w), (δ, w · c) ∈ F with w · c a successor of w, then λ(δ, w · c) = λ(δ, w) · δn+1 for some δn+1 ∈ ∆I .\nSuch a forest F and bijection λ exist because S is a prefix-closed set with root δ. Thus, we just map from the notion of sequences to that of forests.\nFor each o ∈ nom(K), let No ∈ NC be a fresh concept name. For each (δ, w) ∈ F , set Tail(δ, w) = δn if λ(δ, w) = δ1 · · · δn. Now, we define the unraveling for δ as the interpretation J = (∆J , ·J ) with ∆J = F and, for each (δ, w) ∈ ∆J , we define the interpretation of concept and role names as follows:\n(a) for each o ∈ nom(K), NJo = {(δ, w) ∈ ∆J | Tail(δ, w) ∈ oI};\n(b) for each concept name A ∈ con(K), AJ = {(δ, w) ∈ ∆J | Tail(δ, w) ∈ AI};\n(c) for each role name r ∈ rol(K), 〈(δ, w), (δ, w′)〉 ∈ rJ iff w′ is a neighbor of w, and 〈Tail(δ, w),Tail(δ, w′)〉 ∈ rI .\nLet R be the subset of ∆I that contains exactly those δ ∈ ∆I such that oI = δ for some o ∈ nom(K). Let U be a set containing an unraveling of I starting from each δ ∈ R. The union of all interpretations from U is called an unraveling for I, denoted as ↓(I), where unions of interpretations are defined in the natural way. 4\nFigure 3 shows the unraveling for our example knowledge base and model. The dotted lines under the non-root elements labeled No indicate that a copy of the whole tree should be appended since we do not stop unraveling at nominal placeholders.\nIt might be helpful to think of the function Tail as a homomorphism (up to signature extension) from the elements in the unraveling J to elements in the original model I. Indeed, Tail satisfies the following properties: For each (δ, w), (δ′, w′) ∈ ∆J ,\n• Tail(δ, w) = oI iff (δ, w) ∈ NJo , for all o ∈ nom(K),\n• Tail(δ, w) ∈ AI iff (δ, w) ∈ AJ , for all A ∈ con(K), and\n• 〈Tail(δ, w),Tail(δ′, w′)〉 ∈ rI iff 〈(δ, w), (δ′, w′)〉 ∈ rJ , for all r ∈ rol(K).\nUnravelings are the first step in the process of transforming an arbitrary model of K into a forest model since the resulting model is a forest quasi-model of K, as we show in the next lemma.\nLemma 13. Let K be a consistent ALCOIFb knowledge base and I = (∆I , ·I) a model of K. Then J = (∆J , ·J ) = ↓(I) is a strict forest quasi-model for K.\nProof. Let K′ = nomFree(K). By construction, J satisfies conditions FQ1 and FQ3 of forest quasi-models and the strictness condition. Since J is obtained from a model I of K, by definition of unravelings as starting from each δ ∈ ∆I such that oI = δ for some o ∈ nom(K), and by condition (a) of unravelings, there is, for each o ∈ nom(K), one root (δ, ε) ∈ ∆J such that (δ, ε) ∈ NJo . Thus, J satisfies also property FQ2 and J is a forest quasi-interpretation for K. We show that J is a model of K′ by demonstrating that each (δ, w) ∈ ∆J is locally K′-consistent. Since we assume all knowledge bases to be simplified, we only have to consider axioms of form (1).\nLet Ax be an axiom of the form d Ai v ⊔ Bj and assume that (δ, w) ∈ ( d Ai)J . By\ncondition (b) of unravelings, we have δw = Tail(δ, w) ∈ ( d Ai)I and, since I |= K, we have δw ∈ BIj for some j. Again by condition (b) of unravelings, we then have (δ, w) ∈ B J j as required. Axioms of the form A ≡ {o} in K are rewritten into A ≡ No in K′. We consider A v No and No v A separately. Let Ax be of the form A v No for o ∈ nom(K) and assume that (δ, w) ∈ AJ . By condition (b), we have that δw = Tail(δ, w) ∈ AI and, since I |= K, we have δw ∈ {oI}. By condition (a) of unravelings, we then have that (δ, w) ∈ NJo as required. For No v A with o ∈ nom(K), assume that (δ, w) ∈ NJo . By condition (a), we have δw = Tail(δ, w) ∈ {oI} and, since I |= K, we have δw ∈ AI . By condition (b) of unravelings, we then have (δ, w) ∈ AJ as required.\nLet Ax be an axiom of the form A v ∀U.B and assume that (δ, w) ∈ AJ . By condition (b), we have δw = Tail(δ, w) ∈ AI and, since I |= K, we have each δw′ ∈ ∆I such that 〈δw, δw′〉 ∈ UI is such that δw′ ∈ BI . Let (δ′, w′) be such that 〈(δ, w), (δ′, w′)〉 ∈ UJ and (δ′, w′) /∈ BJ . By condition (c) of unravelings, we then have that 〈δw, δw′〉 ∈ UI for δw′ = Tail(δ′, w′) and by condition (b) that δw′ /∈ BI , which is a contradiction.\nLet Ax be an axiom of the form A v ∃U.B and assume that (δ, w) ∈ AJ . By condition (b), we have δw = Tail(δ, w) ∈ AI and, since I |= K, we have there is at least one δw′ ∈ ∆I such that 〈δw, δw′〉 ∈ UI and δw′ ∈ BI . In case there is more than one such element, let δw′ be such that δw′ = choose(C, δw). Then, by definition of sequences, there is some neighbor (δ, w′) of (δ, w) with Tail(δ, w′) = δw′ . Let λ(δ, w) = δ1 · · · δn, i.e., δn = δw. We distinguish two cases:\n1. The element δw′ is such that δw′ = δn−1. By definition of the bijection λ, w = w′ · c, by definition of J from I (condition (c)) and since 〈δw, δw′〉 ∈ UI , we have 〈(δ, w), (δ, w′)〉 ∈ UJ . Then, since B is a concept name and δw′ ∈ BI , we have by condition (b) that (δ, w′) ∈ BJ , which proves the claim.\n2. The element δw′ is such that δw′ 6= δn−1. By definition of sequences and the bijection λ, we have that λ(δ, w′) = δ1 · · · δn · δw′ . Now, by definition of J from I (in particular properties (b) and (c)), we have 〈(δ, w), (δ, w′)〉 ∈ UJ and, again since B is a concept name, (δ, w′) ∈ BJ , which proves the claim.\nLet Ax be an axiom of the form func(r) for r ∈ rol(K). Assume, to the contrary of what is to be shown, that (δ, w) has two distinct neighbors (δ, w1), (δ, w2) such that 〈(δ, w), (δ, w1)〉, 〈(δ, w), (δ, w2)〉 ∈ rJ . Since the function λ introduced in the unraveling is a bijection, there are two distinct sequences s1 and s2 such that λ(δ, w1) = s1 and λ(δ, w2) = s2 and Tail(δ, w1) = δ1,Tail(δ, w2) = δ2 with δ1 6= δ2. Since 〈(δ, w), (δ, w1)〉, 〈(δ, w), (δ, w2)〉 ∈ rJ we get, due to condition (c), that 〈Tail(δ, w), δ1〉, 〈Tail(δ, w), δ2〉 ∈ rI , which is a contradiction since I |= K.\nSince (δ, w) was arbitrarily chosen, we have that each element in the domain of J is locally K′-consistent as required and J |= K′ by Lemma 10.\nLemma 14. Let K be a consistent ALCOIFb knowledge base, I = (∆I , ·I) a model of K, and J = (∆J , ·J ) = ↓(I) an unraveling for I. Then J has a branching degree bounded in |cl(K)|.\nProof. Let m be the number of axioms in K. Each axiom of a simplified knowledge base can contain at most one existential restriction and, due to the definition of the function choose used in the unraveling, there are, for each sequence s ∈ S, at most m elements δ1, . . . , δm ∈ ∆I such that s · δi with 1 ≤ i ≤ m is a sequence in S. Since the mapping λ from the forest ∆J to sequences is a bijection, ∆J is a forest with branching degree m.\nIn the following steps, we traverse a forest quasi-model in an order in which elements with smaller tree depth are always of smaller order than elements with greater tree depth. Elements with the same tree depth are ordered lexicographically. The bounded branching degree of unravelings then guarantees that, after a finite number of steps, we go on to the next level in the forest and process all nodes eventually. Further, we can merge nodes such that, finally, all nominal placeholders (in the extension of some No) can be interpreted as nominals without violating functionality restrictions. In fact, we do not only have to merge nominal placeholders, but also elements that are related to a nominal placeholder by an inverse functional role since, by definition of the semantics, these elements have to correspond to the same element in a model. In order to identify such elements, we define the notion of backwards counting paths as follows:\nDefinition 15 (Paths and BCPs). Let I = (∆I , ·I) be an interpretation. We call δ1 · . . . ·δn a path from δ1 to δn if, for each i with 1 ≤ i < n, 〈δi, δi+1〉 ∈ rIi for some role ri ∈ rol(K). The length |p| of a path p = δ1 · . . . · δn is n − 1. Each element δ ∈ ∆I is a path of length 0. We write δ1 U1→ δ2 . . . Un−1→ δn to denote a path from δ1 to δn such that 〈δi, δi+1〉 ∈ UIi for each 1 ≤ i < n and Ui a safe Boolean role expression. Let K be an ALCOIFb knowledge base and I = (∆I , ·I) a forest model (a forest quasimodel) of K. A path p = δ1 ·. . .·δn in I is a descending path if there is some root (ρ, ε) ∈ ∆I such that, for each i with 1 ≤ i ≤ n, δi = (ρ, wi) and, for 1 ≤ i < n, |wi| < |wi+1|. The path p is a backwards counting path (BCP) in I if δn = oI (δn ∈ NIo ) for some nominal o ∈ nom(K) and, for each i with 1 ≤ i < n, 〈δi, δi+1〉 ∈ fIi for some inverse functional role fi ∈ rol(K). The path p is a descending BCP if it is a BCP and a descending path. Given a BCP p = δ1 f1→ δ2 . . . fn→ δn+1 with δn+1 ∈ oJ (δn+1 ∈ NJo ), we call the sequence f1 · · · fno a path sketch of p. 4\nPlease note that an element δ in the domain of J already counts as a (descending) BCP if δ ∈ oJ (NJo ) for some o ∈ nom(K).\nWe now define the order that guarantees that in an iterative parsing process, we not only process all nodes, but also that we can merge nodes as required so that, finally, all nominal placeholders can be interpreted as nominals without violating functionality restrictions.\nDefinition 16 (Ordering). For convenience and without loss of generality, we assume that the set of individual names NI is ordered. Let K be a consistent ALCOIFb knowledge base and J a forest quasi-interpretation for K. We extend the order to elements in ∆J as follows: let w1 = wp · c11 · · · cn1 , w2 = wp · c12 · · · cm2 ∈ IN∗ where wp ∈ IN∗ is the longest common prefix of w1 and w2, then w1 < w2 if either n < m or both n = m and c11 < c 1 2. For (ρ1, ε), (ρ2, ε) ∈ ∆J , let o1 ∈ nom(K) be the smallest nominal such that (ρ1, ε) ∈ NJo1 and o2 ∈ nom(K) the smallest nominal such that (ρ2, ε) ∈ NJo2 . Now (ρ1, w1) < (ρ2, w2) if either (i) |w1| < |w2| or (ii) |w1| = |w2| and o1 < o2 or (ii) |w1| = |w2|, o1 = o2 and w1 < w2.\nIn the following, we are merging elements in an unraveling and, in this process, create new roots of the form (ρw, ε) from elements of the form (ρ, w) and elements of the form (ρw,w′) from (ρ, ww′). We extend, therefore, the order to elements of this form as follows: (ρ1w1, w′1) < (ρ2w2, w ′ 2) if (ρ1, w1w ′ 1) < (ρ2, w2w ′ 2). 4\nRoughly speaking, we proceed as follows in order to transform a quasi-forest model J into a forest model I: we work our way downwards the trees level by level along the descending BCPs and use the above defined order for this purpose. By definition of the semantics, elements that start the same descending BCP or, more precisely, that start BCPs with identical path sketches, have to correspond to the same element in the forest model I that we produce. During the traversal of the forest quasi-model, we distinguish two situations: (i) we encounter an element (ρ, w) that starts a descending BCP and we have not seen another element before that starts a descending BCP with the same path sketch. In this case, we promote (ρ, w) to become a new root node of the form (ρw, ε) and we shift the subtree rooted in (ρ, w) with it; (ii) we encounter a node (ρ, w) that starts a descending BCP, but we have already seen a node (ρ′, w′) that starts a descending BCP with that path sketch and which is now a root of the form (ρ′w′, ε). In this case, we delete the subtree rooted in (ρ, w) and identify (ρ, w) with (ρ′w′, ε). If (ρ, w) is an f -successor of its predecessor for some inverse functional role f , we delete all f−-successors of (ρ′w′, ε) and their subtrees in order to satisfy the functionality restriction. We use a notion of collapsing admissibility to characterize models in which the predecessor of (ρ, w) satisfies the same atomic concepts as the deleted successor of (ρ′, w′), which ensures that local consistency is preserved. By virtue of this notion, we can characterize forest quasi-models that can be collapsed into proper models irrespective of whether they have been obtained by unraveling of a model or not.\nIn order to keep the domain as a forest when promoting an element (ρ, w) to a new root, we build the new domain with elements of the form (ρw, ε) for (ρ, w) and elements of the form (ρw,w′) for descendants (ρ, ww′) of (ρ, w).\nDefinition 17 (Equivalence Relation ∼ and Collapsings). Let K be an ALCOIFb knowledge base, K′ = nomFree(K), and J = (∆J , ·J ) a forest quasi-interpretation of K. We define ∼ as the smallest equivalence relation on ∆J that satisfies δ1 ∼ δ2 if δ1, δ2 start descending BCPs with identical path sketches.\nLet J be a strict forest quasi-interpretation for K, J0 = (∆J0 , ·J0) = J and (ρ0, w0) ∈ ∆J0 the smallest element with w0 6= ε that starts a descending BCP. We call J0 an initial collapsing for J and (ρ0, w0) the focus of J0.\nLet Ji be a collapsing for J and (ρi, wi) ∈ ∆Ji the focus of Ji. We obtain a collapsing Ji+1 = (∆Ji+1 , ·Ji+1) with focus (ρi+1, wi+1) for J from Ji according to the following two cases:\n1. There is no element (ρ, ε) ∈ ∆Ji such that (ρ, ε) is smaller than the focus (ρi, wi) and (ρ, ε) ∼ (ρi, wi). Then Ji+i is obtained from Ji by renaming each element (ρi, wiw′i) ∈ ∆Ji to (ρiwi, w′i).\n2. There is an element (ρ, ε) ∈ ∆Ji such that (ρ, ε) is smaller than the focus (ρi, wi) and (ρ, ε) ∼ (ρi, wi). Let (ρ, ε) be the smallest such element.\n(a) ∆Ji+1 = ∆Ji \\ ({(ρi, wiw′i) | w′i ∈ IN∗} ∪ {(ρ, w) | w = c · w′, c ∈ IN, w′ ∈ IN∗, (ρi, wi) has a predecessor (ρi, w′i) such that 〈(ρi, w′i), (ρi, wi)〉 ∈ fJi for an inverse functional role f in rol(K) and 〈(ρ, c), (ρ, ε)〉 ∈ fJi});\n(b) for each concept name A ∈ con(K) and (ρ, w) ∈ ∆Ji+1 , (ρ, w) ∈ AJi+1 iff (ρ, w) ∈ AJi ;\n(c) for each role name r ∈ rol(K) and (ρ1, w1), (ρ2, w2) ∈ ∆Ji+1 , 〈(ρ1, w1), (ρ2, w2)〉 ∈ rJi+1 iff\ni. 〈(ρ1, w1), (ρ2, w2)〉 ∈ rJi or ii. (ρ1, w1) is the predecessor of (ρi, wi) in Ji (i.e., ρ1 = ρi and wi = w1 · c for\nsome c ∈ IN), (ρ2, w2) = (ρ, ε), and 〈(ρ1, w1), (ρi, wi)〉 ∈ rJi .\nThe focus (ρi+1, wi+1) in Ji+1 is the smallest descending BCP with (ρi, wi) < (ρi+1, wi+1). For a collapsing Ji, let safe(Ji) be the restriction of Ji to elements (ρ, w) such that (ρ, w) ∈ Jj for all j ≥ i. With Jω we denote the non-disjoint union of all interpretations safe(Ji) obtained from subsequent collapsings Ji for J . The interpretation obtained from Jω by interpreting each o ∈ nom(K) as (ρ, ε) ∈ NJωo is denoted by collapse(J ) and called a purified interpretation with respect to J. If collapse(J ) |= K, we call collapse(J ) a purified model of K. 4\nIn Figures 4 to 7 we illustrate the first collapsing steps for the unraveling depicted in Figure 3. Apart from the nominal placeholder concepts, the concept interpretations are not shown in the figures, but are assumed to be as indicated in Figure 3. The edges for descending BCPs are shown in red color, and the dashed lines in Figure 4 indicate the levels of the tree because, within a tree, the order in which the nodes are processed depends firstly on their level. Within a level, we assume that the order increases from left to right. The numbers next to nodes in Figure 4 indicate, which elements are used as focus element in a collapsing step and their order. For the initial collapsing (Figure 4) the focus is on the first non-root element that starts a BCP, which we indicate with a black border around the node and a black triangle pointing to the focus.\nIn the first collapsing step we just rename elements to promote the focus from Figure 4 to a root. Because the focus element highlighted in Figure 5 starts a BCP with path sketch different from the ones started by smaller elements, we again only rename elements to obtain a new root (Figure 6). Now, the focus is on a nominal placeholder and since nominal placeholder are BCPs, we have a root with the same path sketch and use the second case of Definition 17. The resulting collapsing is depicted in Figure 7.\nFinally, we obtain a collapsing for the unraveling shown in Figure 3 as the one depicted in Figure 8.\nWe can now show that the collapsing of an unraveling results in a forest model for K. Our aim is, however, to show something more general. We want to collapse not only unravelings into forest models, but also forest quasi-models which have been obtained in another way. Unfortunately, it is not the case that the collapsing of any forest quasi-model results in a forest model for K since the elements that we merge in the collapsing process do not necessarily satisfy the same atomic concepts. We define, therefore, the following admissibility criterion that characterizes forest quasi-models that can be collapsed into forest models.\nDefinition 18 (Collapsing-admissibility). Let J be a forest quasi-interpretation for some ALCOIFb knowledge base K. Then J is collapsing-admissible if there exists a function ch : (cl(K)×∆J )→ ∆J such that\n1. for each concept C = ∃U.B ∈ cl(K) and each δ ∈ CJ , we have 〈δ, ch(C, δ)〉 ∈ UJ and ch(C, δ) ∈ BJ . Moreover, if there is no functional role f for which 〈δ, ch(C, δ)〉 ∈ fJ then ch(C, δ) is a successor of δ,\n2. for each concept C = ∃U.B ∈ cl(K) and elements δ, δ′ ∈ CJ that start descending BCPs with identical path sketches, we have 〈δ, ch(C, δ)〉 ∼= 〈δ′, ch(C, δ′)〉.\n4\nLemma 19. Let K be an ALCOIFb knowledge base. Any unraveling J of a model I for K is collapsing-admissible.\nProof. We define a function ch directly from the function choose used in the unraveling as follows: for each C ∈ cl(K) and (ρ, w) ∈ ∆J with λ(ρ, w) = δ1 · . . . · δn and choose(C,Tail(ρ, w)) = {δ′}, we set ch(C, (ρ, w)) = (ρ, w′) for (ρ, w′) = λ−(δ1 · . . . · δn · δ′) if δ1 · . . . · δn · δ′ is a sequence in S and (ρ, w′) = λ−(δ1 · . . . · δn−1) otherwise. This is well-defined since the function λ in unravelings is total and bijective and it is as required for admissibility since elements that start BCPs with identical path sketches are always generated from the same element in I. The first condition of collapsing-admissibility holds since in unravelings, we always add δ1 · . . . · δn · δ′ to the set of sequences unless the pair 〈δn, δn−1〉 is in the interpretation of some functional role. In that case, the function ch uses the predecessor instead of the successor, which is still admissible.\nLemma 20. Let K be a consistent ALCOIFb knowledge base, J = (∆J , ·J ) a strict forest quasi-model for K with branching degree b that is collapsing-admissible. Then collapse(J ) is a forest model for K with branching degree b.\nProof. Let K′ = nomFree(K). Since J is a forest quasi-model of K by assumption, J |= K′. We first show that each collapsing Ji for J is a forest quasi-model for K, i.e., Ji |= K′. We then show that each collapsing Ji+1 produced from an admissible collapsing Ji is again collapsing-admissible. Finally, we show that, for each o ∈ nom(K), there is exactly one node in Jω of the form (ρ, ε) such that (ρ, ε) ∈ NJωo , which implies by Proposition 11 that collapse(J ) is a forest model for K.\nWe start with the first claim: For the initial collapsing this is immediate since J is a forest quasi-model for K. In particular, J0 is locally K′-consistent. Assume that Ji is a locally K′-consistent collapsing and (ρi, wi) is the focus in Ji. We show that Ji+1 is locally\nK′-consistent. Since K′ is simplified by assumption, we only have to consider axioms of form (1).\nIf Ji+1 is obtained according to the first case of Definition 17, we only rename elements of the domain in order to create a new root node and local K′-consistency is immediate. We assume, thus, that Ji+1 is obtained according to the second case of Definition 17.\nAxioms of the form d Ai v ⊔ Bj and A ≡ {o} (rewritten into A ≡ No in K′) hold immediately due to condition 2.b of collapsings. Let Ax be an axiom of the form A v ∀U.B and assume that (ρ, w) ∈ AJ . The only interesting elements are the predecessor (ρi, w′i) of the focus (ρi, wi) and (ρ, ε). However, (ρi, wi) ∼ (ρ, ε) and, since J is collapsing-admissible, (ρi, wi) and (ρ, ε) satisfy the same atomic concepts with respect to con(K). Further, the interpretation of atomic concepts is not changed due to 2.b, which again implies local K′-consistency for this kind of axioms.\nLet Ax be an axiom of the form A v ∃U.B and assume that (ρ, w) ∈ AJi+1 . We concentrate on the three interesting cases where the direct neighborhoods of elements change:\n1. We start with the case where the focus (ρi, wi) is the corresponding U -successor of (ρ, w), i.e., ρi = ρ, wi = w·c for some c ∈ IN, 〈(ρ, w), (ρi, wi)〉 ∈ UJi , and (ρi, wi) ∈ BJi . Since (ρ, ε) and (ρi, wi) are in the same equivalence class for ∼ by assumption, (ρ, ε) starts a BCP with the same path sketch as (ρi, wi) and both (ρ, ε) and (ρi, wi) satisfy the same atomic concepts with respect to con(K). Then condition 2.(c)ii. ensures that (ρ, ε) is the required U -successor for (ρ, w) in Ji+1.\n2. Assume that (ρ, w) = (ρ, ε), 〈(ρ, ε), (ρ, c)〉 ∈ UJi , (ρ, c) ∈ BJi , (ρ, c) /∈ ∆Ji+1 , and (ρ, ε) /∈ (∃U.B)Ji+1 . Due to 2.a, the focus (ρi, wi) has a predecessor (ρi, w′i) such that 〈(ρi, w′i), (ρi, wi)〉 ∈ fJi for an inverse functional role f ∈ rol(K) and 〈(ρ, ε), (ρ, c)〉 ∈ (f−)Ji . Since f is inverse functional and Ji is, by assumption, locally K′-consistent, there is no successor (ρi, wi · ci) of (ρi, wi) such that 〈(ρi, wi), (ρi, wi · ci)〉 ∈ (f−)Ji . Similarly, there is no element (ρ′, w′) such that 〈(ρ, ε), (ρ′, w′)〉 ∈ (f−)Ji . Then, since Ji is collapsing-admissible, we have that (ρi, w′i) ∈ ch(∃U.B, (ρi, wi)), (ρ, c) ∈ ch(∃U.B, (ρ, ε)), and 〈(ρi, wi), (ρi, w′i)〉 ∼= 〈(ρ, ε), (ρ, c)〉 since (ρi, wi) and (ρ, ε) start descending BCPs with identical path sketches. In particular, 〈(ρi, wi), (ρi, w′i)〉 ∈ UJi and (ρi, w′i) ∈ BJi . Then, by condition 2.(c)ii., 〈(ρ, ε), (ρi, w′i)〉 ∈ UJi+1 , by condition 2.b, (ρi, w′i) ∈ BJi+1 , and, thus, (ρ, ε) ∈ (∃U.B)Ji+1 as required.\n3. We assume that (ρi, wi) has a predecessor (ρi, w′i) such that 〈(ρi, w′i), (ρi, wi)〉 ∈ fJi for an inverse functional role f in rol(K) and 〈(ρ, c), (ρ, ε)〉 ∈ fJi , causing the deletion of (ρ, c) and its descendants, one of which, say (ρ, v) is connected to some (ς, ε), such that 〈(ς, ε), (ρ, v)〉 ∈ UJi and (ρ, v) ∈ BJi . Now, if there is no inverse functional role g for which 〈(ς, ε), (ρ, v)〉 ∈ gJi , then the strictness and collapsing-admissibility of Ji ensure the existence of a c′ ∈ IN for which 〈(ς, ε), (ς, c)〉 ∈ UJi and (ς, c) ∈ BJi and, consequently, also 〈(ς, ε), (ς, c)〉 ∈ UJi+1 and (ς, c) ∈ BJi+1 . If 〈(ς, ε), (ρ, v)〉 ∈ gJi for some inverse functional role g, then strictness of the initial collapsing implies that (ρ, v) itself started a descending BCP and, due to the defined order, it must have been a focus before and now be a root itself. This contradicts, however, the initial assumption that (ρ, v) is a descendant of (ρ, ε) and we are done.\nIn all cases, the elements in ∆Ji+1 have the required successors.\nLet Ax be an axiom of the form func(f) for f ∈ rol(K). We concentrate on relations between the predecessor (ρi, w′i) of the focus and (ρ, ε) since otherwise local K′-consistency is immediate. A predecessor exists for the focus since we process elements in ascending order starting with non-root nodes. Assume 〈(ρi, w′i), (ρi, wi)〉 ∈ fJi , in which case 〈(ρi, w′i), (ρ, ε)〉 ∈ fJi+1 due to 2.(c)ii. and assume (ρ, ε) has a successor (ρ, c) in Ji such that 〈(ρ, c), (ρ, ε)〉 ∈ fJi . In this case, (ρ, c) /∈ ∆Ji+1 according to 2.a and together with local K′-consistency of Ji, this implies that (ρi, w′i) is the only element in ∆Ji+1 such that 〈(ρi, w′i), (ρ, ε)〉 ∈ fJi+1 .\nWe now show that each Ji+1 produced from an admissible collapsing Ji is again admissible for collapsing. By assumption, the initial collapsing is admissible, so let Ji be an admissible collapsing and chi the required function. We distinguish two cases:\n1. Let Ji+1 be produced according to the first case of collapsings. We define a function chi+1 for Ji+1 as follows: For each C ∈ cl(K) and δ ∈ ∆Ji+1 , we set chi+1(C, δ) = δ′ for δ′ = (ρiwi, w′1) if chi(C, δ) = (ρi, wiw ′ i) for (ρi, wi) the focus in Ji and δ′ = chi(C, δ)\notherwise. Since we just change the names of the elements and leave the interpretation of concepts and roles as before, the function is as required for admissibility.\n2. Let Ji+1 be produced according to the second case of collapsings. We define a function chi+1 for Ji+1 as follows: For each C ∈ cl(K),\n(a) for each δ ∈ ∆Ji+1 /∈ {(ρi, w′i), (ρ, ε)} with (ρi, w′i) the predecessor of the focus (ρi, wi), we set chi+1(C, δ) = δ′ for δ′ such that δ′ ∈ ∆Ji+1 and δ′ = chi(C, δ); this is well-defined since only successors of (ρ, ε) and (ρi, w′i) are deleted in Ji+1. (b) for δ = (ρ, ε) and (ρi, w′i) the predecessor of the focus, chi+1(C, δ) = δ ′ for δ′ = (ρi, w′i) if chi(C, δ) = (ρ, c) and (ρ, c) /∈ ∆Ji+1 and δ′ = chi(C, δ) otherwise; (c) for δ = (ρi, w′i) the predecessor of the focus, we set chi+1(C, δ) = δ\n′ for δ′ = (ρ, ε) if chi(C, δ) = (ρi, wi) and δ′ = chi(C, δ) otherwise.\nFor elements apart from the predecessor of the focus (ρi, w′i) and the root (ρ, ε) that replaces (ρi, wi), the interpretation of concepts and roles remains as before by properties 2.b and 2.c and the function is as required. For (ρi, w′i), we change the function so that in cases where (ρi, wi) was returned, (ρ, ε) is returned. Since (ρi, wi) ∼ (ρ, ε), this is admissible. Similarly, if a successor (ρ, c) of (ρ, ε) is not contained in ∆Ji+1 , then (ρi, w′i) is used instead. This is admissible since, in this case, 〈(ρi, wi), (ρi, w′i)〉 ∼= 〈(ρ, ε), (ρ, c)〉 as argued above for axioms of the form A v ∃U.B.\nWe now show that, for each o ∈ nom(K), there is exactly one node in Jω of the form (ρ, ε) such that (ρ, ε) ∈ NJωo . Nominal placeholders are descending BCPs by definition and, when a nominal placeholder becomes the focus, it is merged into a root that is in the same equivalence class of ∼ and which is by definition of lower order. Such a root exists because of property FQ2 of forest quasi-interpretations.\nThe interpretation Jω is obtained by building the non-disjoint union of the “safe” parts for all collapsings, which contain only elements which will neither be renamed nor deleted. Thus, Jω does not contain nominal placeholders as required. Considering any one element (ρ, w) ∈ ∆Jω , we find that there is an i ∈ IN such that all successors and all root neighbors\nof (ρ, w) in Ji are the same as in Jω. As we have shown, Ji is locally K′-consistent and therefore (ρ, w) has a consistent neighborhood. Hence Jω is a forest quasi-model of K.\nNow, when interpreting each o ∈ nom(K) as {(ρ, ε) ∈ ∆Jω | (ρ, ε) ∈ NJωo } in collapse(J ), we obtain a forest model for K, where the set of roots is {(ρ, ε) | (ρ, ε) ∈ ∆Jω}.\nThe bounded branching degree is an immediate consequence of the construction since we never add successors during the construction and the starting forest quasi-interpretation J has a bounded branching degree by assumption.\nSince unravelings of a model I for K are strict forest quasi-models of K with branching degree bounded in |cl(K)| by Lemma 13, and unravelings are collapsing-admissible by Lemma 19, it is an immediate consequence of Lemma 20 that the collapsing of an unraveling yields a forest model branching degree bounded in |cl(K)|.\nCorollary 21. Let K be an ALCOIFb knowledge base and I an interpretation such that I |= K, then the purified interpretation collapse(↓(I)) is a forest model for K with branching degree b bounded in |cl(K)|.\nSince the number of roots might still be infinite in purified models, we could, up to now, have obtained the same result by unraveling an arbitrary model, where we take all elements on BCPs as roots instead of taking just the nominals and creating new roots in the collapsing process. In the next sections, however, we show how we can transform an unraveling of a counter-model for the query such that it remains collapsing-admissible and such that it can in the end be collapsed into a forest model with a finite number of roots that is still a counter model for the query. For this transformation it is much more convenient to work with real (strict) trees and forests, which is why we use (strict) forest quasi-interpretations.\nIn the next sections, we also use the following alternative characterization of the result of a collapsing, which comes in handy for the subsequent proofs.\nWe start by defining the so-called pruning of a forest quasi-interpretation, which is, roughly speaking, the structure obtained by just deleting all the nodes, which will be erased in the course of the collapsing process anyway.\nDefinition 22 (Pruning). Let J be a strict forest quasi-model for an ALCOIFb knowledge base K that is collapsing-admissible and let J0,J1, . . . ,Jω be as defined in Definition 17. The pruning of J (written prune(J )) is obtained by restricting J to a set Γ ⊆ ∆J which is defined as follows: Γ contains all 〈ρw1, w2w3〉 ∈ ∆J for which 〈ρw1w2, w3〉 ∈ ∆Jω or 〈ρw1w2, w3〉 is the focus in some Ji. 4\nWe again use the equivalence relation ∼ for elements that start descending BCPs with identical path sketches from Definition 17 and construct an interpretation from a pruning by identifying equivalent nodes, also known as factorization.\nDefinition 23 (Factorization). Let K be an ALCOIFb knowledge base, J a strict forest quasi-interpretation for K that is collapsing-admissible, and L = prune(J ).\nThe factorization of L by ∼ (denoted by L/∼) is now defined as the forest quasi-interpretation M = (∆M, ·M) with\n• ∆M = {[δ]∼ | δ ∈ ∆L};\n• for each A ∈ con(K), AM = {[δ]∼ | δ ∈ AL},\n• for each r ∈ rol(K), rM = {〈[δ]∼, [δ′]∼〉 | 〈δ, δ′〉 ∈ rL}, and\n• for each o ∈ nom(K), oM = [δ]∼ for δ ∈ NLo . 4\nNote that the interpretation of nominals in M is well defined as, by definition, all No-instances are in the same ∼-equivalence class.\nNow we are ready to establish the wanted correspondence: the collapsing of a forest quasi-interpretation can essentially be obtained by first pruning and then factorizing it.\nLemma 24. Let J be a strict forest quasi-model for an ALCOIFb knowledge base K and let J be collapsing-admissible. Then collapse(J ) ∼= prune(J )/∼. Moreover the new roots in collapse(J ) correspond to those ∼-equivalence classes that contain J -elements which start descending BCPs in J .\nProof. Considering the first claim, note that by definition of the collapsing procedure, for every (ρw,w′) ∈ ∆collapse(J ) there is exactly one pair w1, w2 with w = w1w2 such that (ρw1, w2w′) ∈ ∆prune(J ). Moreover, case 1 of the construction assures that ∆collapse(J ) contains one element from every ∼-equivalence class from ∆prune(J )/∼ . Hence the mapping ϕ : ∆collapse(J ) → ∆prune(J )/∼ with ϕ(ρw,w′) = [(ρw1, w2w′)]∼ is a bijection and, as a consequence of the construction, an isomorphism.\nThe second claim is also a direct consequence of the construction of the collapsing."
    }, {
      "heading" : "5. Quasi-Entailment in Quasi-Models",
      "text" : "In this section, we will provide a characterization for forest quasi-models that mirrors query entailment for the corresponding “proper models”. In our further argumentation, we will talk about the initial part of a tree, i.e., the part that is left if branches are cut down to a fixed length. For a forest interpretation I = (∆I , ·I) and an n ∈ IN, we therefore denote with cutn(I) the interpretation obtained from I by restricting ∆I to those pairs (ρ, w) for which |w| ≤ n.\nThe following lemma ensures that in the case of purified models, we find only finitely many unraveling trees of depth n that “look different”.\nLemma 25. Let K be a consistent ALCOIFb knowledge base. Then there is a purified interpretation I such that I |= K and, for every n ∈ IN, there are only finitely many non-isomorphic trees of depth n.\nProof. Since K has a model by assumption, Corollary 21 guarantees that there is some purified model I of K. In particular, I is a forest model with the branching degree bounded in the size of cl(K).\nWe now compute the maximal number of non-isomorphic trees of depth n over the domain of I. We denote this bound by Tn. The argumentation is close to the one used by Levy and Rousset (1998) for their definition of tree blocking.\nLet c = |cl(K)| and r = |rol(K)|. We first consider trees of depth n = 0. We have 2c choices for the different subsets of concepts in cl(K). For n > 0, each concept at level 0 can trigger the generation of a new successor and we can have any number of successors between 0 and c. Assume, for now, that we have only a single role name r ∈ rol(K) and that each node in a level smaller than n is the root of a tree with depth n− 1 with exactly c successors for each node. In this case, there are O(2cT cn−1) non-isomorphic sub-trees of depth n. Taking into account that a node does not necessarily have c successors, but we can choose any number between 0 and c, we get a bound of O(2ccT cn−1) for the number of nonisomorphic sub-trees of depth n. Finally, since we have not only one but a choice of r roles, we get a bound of O(2c(cT cn−1)\nr). We now abbreviate 2ccr with x and rc with a and rewrite the obtained bound as Tn = O(x(Tn−1)a). Unfolding yields Tn = O((x1+a+...+a n−1 )(T0)a n ) which is bounded by O((xa n )(2c)a n ) = O((x2c)a n ). By expanding the abbreviated symbols, we obtain a bound for Tn of O((2ccr)(rc) n ).\nFor our further considerations, we introduce the notion of “anchored n-components”. These are meant to be certain substructures of forest quasi-interpretations. In the first place, these substructures contain a connected set of nodes W ′ which are situated “closely together” in the original structure, this closeness being witnessed by the fact that all elements of W ′ are descendants of some node δ and have a distance ≤ n to δ. Moreover for each of those nodes δ′ from W ′, the anchored n-component may (but does not need to) contain a finite number of descending BCPs starting from δ′.\nDefinition 26 (Anchored Components). Let J be a forest quasi-interpretation and δ ∈ ∆J . An interpretation C will be called anchored n-component of J with witness δ if C can be created by restricting J to a set W ⊆ ∆J obtained as follows:\n• Let Jδ be the subtree of J that is started by δ and let Jδ,n := cutn(Jδ). Select a subset W ′ ⊆ ∆Jδ,n that is closed under predecessors.\n• For every δ′ ∈W ′, let P be a finite set (possibly empty) of descending BCPs p starting from δ′ and let Wδ′ contain all nodes from all p ∈ P .\n• Set W = W ′ ∪ ⋃ δ′∈W ′Wδ′ .\n4\nNow think of a forest quasi-model J and some query q. The following definition and lemma employ the notion of anchored n-components to come up with the notion of quentailment (short for quasi-entailment), a criterion that reflects query-entailment in the world of forest quasi-models.\nDefinition 27 (Quentailment). Let q be a conjunctive query with ](q) = n and J some forest quasi-model of an ALCOIFb knowledge base K. We say that J quentails q (written J |≈ q) if, for V = var(q), J contains connected anchored n-components C1, . . . , C` and there are according functions µi : V → 2∆ Ci such that the following hold:\nQ1 For every x ∈ V , there is at least one Ci, such that µi(x) 6= ∅\nQ2 For all A(x) ∈ q, we have µi(x) ⊆ AJ for all i.\nQ3 For every r(x, y) ∈ q there is a Ci such that there are δ1 ∈ µi(x) and δ2 ∈ µi(y) such that 〈δ1, δ2〉 ∈ rJ .\nQ4 If, for some x ∈ V , there are connected anchored n-components Ci and Cj with δ ∈ µi(x) and δ′ ∈ µj(x), then there is\n• a sequence Cn1 , . . . , Cnk with n1 = i and nk = j and • a sequence δ1, . . . , δk with δ1 = δ and δk = δ′ as well as δm ∈ µnm(x) for all\n1 ≤ m < k,\nsuch that, for every m with 1 ≤ m < k, we have that\n• Cnm contains a descending BCP p1 started by δm, • Cnm+1 contains a descending BCP p2 started by δm+1, • p1 and p2 have the same path sketch.\nFor a union of conjunctive queries u = q1 ∨ . . . ∨ qh, we say that J quentails u (written J |≈u) if J |≈ q for a q ∈ {q1, . . . , qh}. 4\nNote that an anchored component may contain none, one or several instantiations of a variable x ∈ V . Intuitively, the definition ensures, that we find matches of query parts which when fitted together by identifying BCP-equal elements yield a complete query match.\nLemma 28. Let u = q1 ∨ . . . ∨ qh be a union of conjunctive queries and K an ALCOIFb knowledge base. Then\n1. For any model I of K, ↓(I) |≈u implies I |= u.\n2. For any strict forest quasi-model J of K that is collapsing-admissible, collapse(J ) |= u implies J |≈u.\nProof. 1. Let q be a disjunct of u such that ↓(I) |≈ q, V = var(q), and C1, . . . , C` the connected anchored n-components witnessing the quentailment. We use the function Tail from Definition 12 and exploit its properties as a homomorphism. Note that Tail maps nodes in ↓(I) to the same individual in I, if they start descending BCPs with the same path sketches. Due to condition Q4 from Definition 27, this implies, for every x ∈ V and every δ1 ∈ µi(x) and δ2 ∈ µj(x), that Tail(δ1) = Tail(δ2). Hence, the total function µ : V → ∆I defined by letting µ(x) = γ whenever Tail(δ) = γ for some δ ∈ µi(x) and some i with 1 ≤ i ≤ `, is well-defined. We now show that µ is a query match for q in I by examining the atoms of q:\n• For every unary atom A(x), the definition of quentailment ensures that there exist a Ci and a δ ∈ ∆Ci with δ ∈ µi(x) and δ ∈ AJ . Then, by definition of Tail, it follows that µ(x) = Tail(δ) ∈ AI . • Likewise, for every binary atom r(x, y), the definition of quentailment ensures\nthat there exists a Ci and δ1, δ2 ∈ ∆Ci such that δ1 ∈ µi(x) and δ2 ∈ µi(y) as well as 〈δ1, δ2〉 ∈ rJ . Again, by definition of Tail, it follows that 〈µ(x), µ(y)〉 = 〈Tail(δ1),Tail(δ2)〉 ∈ rI .\n2. To prove this, we employ the alternative characterization of collapsings as established in Lemma 24. Let I ′ = (∆I′ , ·I′) = prune(J )/∼ and let µ : V → ∆I ′ be a match for\nq in I ′. We use µ to construct the anchored n-components and functions needed to show that J quentails q. Let V ∗ ⊆ V contain those variables that µ maps to a singleton ∼-equivalence class. We now define V = {V1, . . . , Vm} as the finest partitioning on V ∗ such that, for any x, y ∈ V ∗, x and y are in the same partition whenever r(x, y) ∈ q for some r ∈ rol(K). Next, we assign to every partition V ′ ∈ V the set QV ′ of query atoms containing variables from V ′. We now construct for every V ′ an anchored n-component CV ′ and a function µV ′ (initialized as yielding ∅ for all inputs) as follows:\n• For every x ∈ V ′, let CV ′ contain the J -element δ for which µ(x) = {δ}. Note that ∆I ′ consists of the ∼-equivalence classes over elements from J , i.e., {δ} is\none of the ∼-equivalence classes from ∆I′ . Moreover, set µV ′(x) = µV ′(x)∪ {δ}. • For every r(x, y) ∈ QV ′ with y 6∈ V ′ and µ(x) = {δ}, let CV ′ contain an addi-\ntional element δ′ ∈ µ(y) for which 〈δ, δ′〉 ∈ rJ (existence assured by definition of collapsing via factorization) and all elements from some descending BCP in prune(J ) starting from δ (existence assured since [δ′]∼ is not a singleton class). Moreover set µV ′(y) = µV ′(y) ∪ {δ′}. • Likewise, for every r(x, y) ∈ QV ′ with x 6∈ V ′ and µ(y) = {δ}, let CV ′ contain an\nadditional element δ′ ∈ µ(x) for which 〈δ′, δ〉 ∈ rJ (existence assured by definition of collapsing via factorization) and all elements from the shortest descending BCP in prune(J ) starting from δ′ (existence assured since [δ′]∼ is not a singleton class). Moreover set µV ′(x) = µV ′(x) ∪ {δ′}.\nWe furthermore construct, for each query atom a that contains no variables from V ∗, its own anchored n-component Ca and function µa (again initialized to always return ∅) as follows:\n• If a = r(x, y), let Ca contain two nodes δ1 and δ2 for which δ1 ∈ µ(x) and δ2 ∈ µ(y) and 〈δ1, δ2〉 ∈ rJ (existence assured by definition via factorization) as well as some prune(J )-descending BCP starting from δ1 and the shortest prune(J )-descending BCP starting from δ2. • If a = A(x), let Ca contain a node δ for which δ ∈ µ(x) and δ ∈ AJ (existence\nassured by definition via factorization) as well as the shortest prune(J )-descending BCP starting from δ.\nLet C contain all CV ′ and Ca defined so far. Note that C already satisfies the conditions Q1-Q3 of Definition 27. We now have to add some more anchored n-components in order to satisfy condition Q4 as well. Let C′ be initially empty. For any x ∈ V where µ(x) is a non-singleton equivalence class and any two Cα, Cβ ∈ C with δ ∈ µα(x) and δ′ ∈ µβ(x), we have that, since δ and δ′ are in the same ∼-equivalence class µ(x), there is a sequence δ1, . . . , δk of J -nodes with δ = δ1 and δ′ = δk and every δi and δi+1 start a descending BCP having the same path sketch. We enhance C′ by one anchored component per δi which contains just δi and the corresponding descending\nBCPs. Then, by construction, the elements of C∪C′ constitute the necessary anchored n-components to justify that J quentails q and, thus, J quentails u.\nAs an example for the correspondence between (query) entailment and quentailment, consider the conjunctive query\nq = {r(x1, x2), s(x2, x3), f(x4, x3), s(x5, x4)}.\nA match µ for this query into our example model from Figure 2 is displayed in the upper part of Figure 9, which witnesses I |= q. In the lower part, the anchored components C1 and C2 and according functions µ1 and µ2 establish ↓(I) |≈ q."
    }, {
      "heading" : "6. Limits and Forest Transformations",
      "text" : "Before introducing the following constructions in detail, we will try to provide some highlevel explanation to convey the intuition behind the subsequent steps. As mentioned before, one of the major obstacles for a decision procedure for conjunctive query entailment is that\nfor DLs including inverses, nominals, and cardinality restrictions (or alternatively functionality), there are potentially infinitely many so-called “new nominals”: domain elements which can be identified by being linked to a “proper nominal” via a BCP.\nHowever, we will show that for every model of a knowledge base that does not satisfy a conjunctive query (i.e., for every countermodel), there is a “nice” countermodel with only finitely many new nominals (in the subsequent section, we will then argue that this ensures the existence of a procedure that terminates when the query is not entailed by the knowledge base in question). We provide a construction which transforms an arbitrary countermodel into a “nice” one by first unraveling it into a quasi forest model, then substituting new nominals by uncritical elements and finally collapsing the result back into a proper model. For doing this, we have to find appropriate substitutes for most of the new nominals. Those substitutes have to fit in their environment without themselves introducing new nominals.\nDue to the global cardinality constraints that BCPs impose on their elements, the existence of infinitely many new nominals implies that their “witnessing” BCPs must get longer and longer, such that by just looking at some finite-distance neighborhood, most of those new nominals just look like non-nominal domain elements. This state of affairs can be exploited by essentially constructing new domain elements as “environment-limits”. In a way, those new domain elements are characterized by the property that they can be approximated with arbitrary precision by already present domain elements – possibly without themselves being present in the domain.3 We will see in the following that those new domain elements can serve as the substitutes we are looking for.\nDefinition 29 (Limits of a Model). Let I = (∆I , ·I) with δ ∈ ∆I be some model of an ALCOIFb knowledge base K. A tree interpretation J is said to be generated by δ (written: J C δ), if it is isomorphic to the restriction of ↓(I, δ) to elements of {(δ, cw) | (δ, cw) ∈ ∆↓(I,δ), c 6∈ H} for some H ⊆ IN.\nThe set of limits of I (written lim I) is the set of all tree interpretations J such that for every k ∈ IN, there are infinitely many δ ∈ ∆I such that cutk(L) ∼= cutk(J ) for some LC δ. 4\nFigure 10 displays one limit element of our example model. The following lemma gives some useful properties of limits. Besides some rather obvious compatibility considerations with respect to knowledge base satisfaction, claim 3 of Lemma 30 provides us with the as pleasant as useful insight that the root node of a limit can never be part of a BCP at all.\nLemma 30. Let K be an ALCOIFb knowledge base, K′ = nomFree(K), I a purified model of K, and n some fixed natural number. Then the following hold:\n1. Let L′ be a tree interpretation such that there are infinitely many δ ∈ ∆I with L′ ∼= cutn(L) for some LCδ. Then, there is at least one limit J ∈ lim I such that cutn(J ) ∼= L′.\n2. Every J ∈ lim I is locally K′-consistent apart from its root (ρ, ε).\n3. As an analogy, consider the fact that any real number can be approximated by a sequence of rational numbers, even if it is itself irrational.\n3. For every J ∈ lim I it holds that its root (ρ, ε) has no BCP to any (ρ, w) ∈ ∆J .\n4. If J ∈ lim I contains a node δ starting two backwards counting paths with path sketches s1 and s2, then for any element δ∗ in any unraveling holds: if the direct neighborhood of δ∗ is isomorphic to that of δ and δ∗ starts a descending BCP with path sketch s1 then it also starts a descending BCP with path sketch s2.\n5. Every J ∈ lim I is collapsing-admissible.\nProof. 1. Let b be the branching degree of I, let Dn be the (by assumption infinite) set of all δ ∈ ∆I such that L′ ∼= cutn(L) for some L C δ, and let Jn contain all those L. Starting with k = n, we now iteratively increase k and construct sets Jk and Dk and tree interpretations Lk. On our way, we inductively prove some properties. By induction hypothesis we know that Dk is infinite and there is some Lk with Lk ∼= cutk(M) for all M∈ Jk. By Lemma 25, there are only finitely many non-isomorphic tree interpretations of depth k + 1 with branching degree b, and we can partition Jk into finitely many sets Jk,1, . . . , Jk,m such that every two M,M′ from any Jk,i satisfy cutk+1(M) ∼= cutk+1(M′). Likewise, we can define classes Dk,1, . . . , Dk,m with Dk = Dk,1 ∪ . . . ∪ Dk,m such that δ ∈ Dk,i if there is an L C δ with L ∈ Jk,i. Now, as Dk is infinite, one of the Dk,i must be infinite as well and we can set Dk+1 = Dk,i and Jk+1 = Jk,i. Hence, we know that Dk+1 is infinite and there is some Lk+1 with Lk+1 ∼= cutk+1(M) for all M∈ Jk+1. Thus, we have established an infinite sequence Ln,Ln+1, . . . with Li ∼= cuti(Lj) for all j > i. Without loss of generality, we can assume that isomorphic nodes are named identically, i.e., we even have Li = cuti(Lj) for all j > i. Now we can define J as the (non-disjoint) union of all Li. This way we have established the structure J for which cutk(J ) = Lk and we know that for every k there are infinitely many δ (namely all elements from Dk) such that cutk(L) ∼= Lk for some LC δ. Hence this J is the limit element with the desired properties.\n2. Let (ρ, w) with w 6= ε be a node in J . Now choose a δ ∈ ∆I such that cut|w|+1(L) ∼= cut|w|+1(J ) for some L C δ (by definition, there are even infinitely many such δs to\nchoose from). Then L contains a node δ∗ whose direct neighborhood is isomorphic to that of (ρ, w). However, as L is contained in ↓(I, δ) and I |= K by assumption, it is locally K′-consistent and hence δ∗ is. Therefore (ρ, w) is locally K′-consistent in J .\n3. Assume the contrary, i.e., that some J ∈ lim I has a BCP from the root (ρ, ε) to some (ρ, w) ∈ ∆J with (ρ, w) ∈ NJo for some o ∈ nom(K). Since we have only functionality and by definition of BCPs, a BCP uniquely identifies one domain individual. By definition of lim I, however, there are infinitely many δ ∈ ∆I satisfying cut|w|(L) ∼= cut|w|(J ) for some J C δ and we have an infinite number of individuals with the same counting path to oI . This is a contradiction.\n4. Choose k to be the maximum length of the two BCPs. By definition of the limit, I contains an element γ such that cut|w|+k(L) ∼= cut|w|+k(J ) for some L C γ. Now, let δ′ ∈ ∆L be the element that (with respect to this isomorphism) corresponds to δ ∈ ∆J . Then, δ′ is the origin of two descending BCPs with path sketches s1 and s2. Let Tail(δ′) = γ′. Since path sketches of descending BCPs uniquely identify one domain individual, every node δ∗ in any unraveling that starts a descending BCP with path sketch s1 must have been caused by γ′ as well. Furthermore (as their direct neighborhoods are isomorphic and by the specific design of the choose function from Definition 12 which renders all successors non-isomorphic), all successors of δ∗\nuniquely correspond to neighbors of γ′ and in turn to successors of δ′.\nThis in turn implies that, for every successor of δ∗, one finds a successor of δ′ with isomorphic direct neighbourhood. Yet, this synchronicity argument can be inductively applied and thereby iterated down the BCP. Thus, we obtain that δ∗ also starts a descending BCP with path sketch s2.\n5. We define the function ch : (cl(K) × ∆J ) → ∆J essentially like in the proof of Lemma 19, namely by referring to the function choose. For a given element δ ∈ ∆J that starts a BCP of length ` in J , choose a δ′ ∈ ∆I such that cut|δ|+`(L) ∼= cut|δ|+`(J ) for some LC δ′. As L is contained in ↓(I, δ′), we can now proceed and define ch(C, δ) as demonstrated in the proof of Lemma 19.\nHaving defined limit elements as convenient building blocks for restructuring forest quasi-interpretations, the following definition provides the first hints on where inside such a structure one existing node (and all its successors) can safely be exchanged by a limit element.\nDefinition 31 (n-Secure Replacement). Let K be an ALCOIFb knowledge base, I a model for K, J some forest quasi-model for K with δ ∈ ∆J . A strict tree quasi-interpretation J ′ ∈ lim I is called an n-secure replacement for δ if\n• cutn(↓(J , δ)) is isomorphic to cutn(J ′),\n• for every anchored n-component of J ′ with witness δ′, there is an isomorphic anchored n-component of J with witness δ.\nIf a δ ∈ ∆J has an n-secure replacement in lim I, we call δ n-replaceable w.r.t. I, otherwise we call δ n-irreplaceable w.r.t. I. 4\nFigure 11 displays a 3-secure replacement in the considered unraveling of our example model.\nAfter having defined which elements of a forest quasi-model are eligible for being replaced by a limit element, we have to make sure that not too many elements (actually defined in terms of the original model) are exempt from being replaced.\nLemma 32. Every purified model I of an ALCOIFb knowledge base K contains only finitely many distinct elements that start a BCP and are the cause for n-irreplaceable nodes in the unraveling of I.\nProof. Assume the converse: let a purified model I of K contain an infinite set D of elements giving rise to n-irreplaceable nodes in ↓(I). Then there must be an L′ such that there is an infinite set D′ ⊆ D such that every d′ ∈ D′ generates an L for which cutn(L) ∼= L (since by Lemma 25, there are only finitely many non-isomorphic choices for L′). This set D′ can be used to guide the construction of a specific limit element J ∈ lim I according to Lemma 30.1. Now, for an element (ρ, w) from J starting a BCP, let l(ρ,w) ∈ IN be the length of the shortest such BCP starting from (ρ, w). Then, let k be the maximum over all l(ρ,w) of individuals (ρ, w) from J that start a BCP and for which |w| ≤ n. By construction, D′ contains one element d′′ generating an L with cutk(L) ∼= cutk(J ) (actually infinitely many). By the choice of k and Lemma 30.4, we can conclude that J is an n-secure replacement for the irreplaceable ↓(I)-node caused by d′′ which contradicts the fact that d′′ ∈ D.\nNow we know, which elements of a forest quasi-model can be replaced by a suitable limit element. The following definition exactly tells us, how such a replacement is carried out: the respective element and all its successors are deleted and the limit element (together with its successors) is inserted at the same position.\nDefinition 33 (Replacement Step). Let K be an ALCOIFb knowledge base, I a model of K, and J a forest quasi-model of K, i.e., J |= K′ = nomFree(K). Let (ρ, w) ∈ ∆J be n-replaceable w.r.t. I and J ′ an according n-replacement for (ρ, w) from lim I with root (ς, ε).\nWe define the result of replacing (ρ, w) by J ′ as the interpretation R where\n• ∆R = ∆Jred ∪ {(ρ, ww ′′) | (ς, w′′) ∈ ∆J ′} with ∆Jred = (∆ J \\ {(ρ, ww′) | |w′| > 1})\n• for each A ∈ con(K′), AR = (AJ ∩∆Jred) ∪ {(ρ, ww ′) | (ς, w′) ∈ AJ ′}\n• for each r ∈ rol(K′), rR = (rJ ∩∆Jred×∆ J red)∪{〈(ρ, ww ′), (ρ, ww′′)〉 | 〈(ς, w′), (ς, w′′)〉 ∈ rJ ′}\n4\nFigure 12 displays the result of carrying out this replacement step on our example. The following lemma assures that during a replacement as described above, no new anchored n-components are introduced, instead all anchored n-components present after an n-secure transformation were present before or completely contained in the inserted limit element.\nLemma 34. Let K be an ALCOIFb knowledge base, I a model for K, J a forest quasimodel for K, i.e., J |= K′ = nomFree(K), and let (ρ, w) ∈ ∆J be n-replaceable w.r.t. I. Let J ′ be an n-replacement for (ρ, w) with root (ς, ε) and R be the result of replacing (ρ, w) by J ′. Then the following hold:\n1. cutn(↓(J , (ρ, w))) is isomorphic to cutn(↓(R, (ρ, w))).\n2. If n ≥ 1, then R is locally K′-consistent.\n3. Whenever R contains an anchored n-component C, then one of J or J ′ contains an anchored n-component isomorphic to C.\nProof. 1. This is a direct consequence from Definitions 31 and 33.\n2. We make a case distinction when element-wise investigating local consistency of R (note that K and K′ are simplified and that local consistency of a node (ρ, v) ∈ ∆R depends only on this node and its direct neighbors):\n• v = ww′ for some w′ 6= ε: then the direct neighborhood of (ρ, v) in R is isomorphic to the direct neighborhood of (ς, w′) in J ′ (recall that (ς, ε) is the root of J ′). By Lemma 30.2, J ′ is locally K′-consistent except possibly for (ς, ε). Hence also (ρ, v) is locally K′-consistent in R. • v 6= ww′ for any w′, i.e., (ρ, v) was not affected by the replacement: then the\ndirect neighborhood of (ρ, v) has not changed by the replacement and, therefore, the neighborhoods of (ρ, v) in J and R coincide. As J is locally K′-consistent by assumption, so is (ρ, v) in R. • v = w: in that case, the direct neighborhood of (ρ, v) has changed but remained\nisomorphic. This follows from the preceding statement (34.1).\n3. Let (ρ′, w′) be the witness of C. We distinguish three cases:\n• ρ′ = ρ and w is a prefix of w′. Then, clearly C is completely contained in J ′. • ρ′ = ρ and w′ is a prefix of w. Let C′ be the structure obtained by restricting C\nto all elements of the form (ρ, ww′′) and then renaming every element (ρ, ww′′) to (ς, w′′), where (ς, ε) is the root of J ′. Then C′ is an anchored n-component in J ′ with witness (ς, ε). Now, by definition of replacing, J must contain an isomorphic copy of C′ with witness (ρ, w). Since the other part of C (consisting of those nodes (ρ′, w′) such that w is not a prefix of w′) has not been altered by the replacement, we can conclude that J must contain an isomorphic copy of C. • Neither of the above. Then, (ρ′, w′) and the subtree rooted in (ρ′, w′) is contained\nin J as this part of J has not been affected by the replacement. Then, clearly also C is contained in J .\nWe are now ready for defining the whole process of restructuring a forest quasi-model essentially by substituting as many nodes as possible by appropriate limit elements.\nDefinition 35 (n-Secure Transformation). Let I be a model of some ALCOIFb knowledge base K and J an unraveling for I. An interpretation J ′ is called an n-secure transformation of J if it is obtained by (possibly infinitely) repeating the following step:\nChoose one unvisited and w.r.t. tree-depth minimal node (ρ, w) that is n-replaceable w.r.t. I. Replace (ρ, w) with one of its n-secure replacements from lim I and mark (ρ, w) as visited. 4\nNote that this is well-defined as every node is visited at most once and no formerly irreplaceable node ever becomes replaceable. Hence for every k ∈ IN, the “initial segment” cutk(J ) of the current intermediate structure J is already isomorphic to the initial segment cutk(J ′) of J ′ after a bounded number of replacement steps, due to the fact that all involved structures have bounded branching degree.\nBy now, the whole effort might still look a bit contrived and pointless, however, the following lemma establishes a bunch of properties that in the end allow us to deduce the existence of a very well-behaved countermodel whenever there is any at all.\nWe show that the process of unraveling, n-secure transformation and collapsing preserves the property of being a model of a knowledge base and (with the right choice of n) also preserves the property of not entailing a conjunctive query. Moreover, this model conversion process ensures that the resulting model contains only finitely many new nominals (witnessed by a bound on the length of BCPs). Figure 13 illustrates these properties for our example model. Note that only two new nominals are left whereas collapsing the original unraveling yields infinitely many.\nLemma 36. Let I be a purified model of some ALCOIFb knowledge base K, J an unraveling of I, and J ′ an n-secure transformation of J . Then the following hold:\n1. J ′ is a strict forest quasi-model for K.\n2. J ′ is collapsing-admissible.\n3. collapse(J ′) is a model of K.\n4. There is a natural number m such that J ′ does not contain any node whose shortest descending BCP has a length greater than m.\n5. If J ′ contains an anchored n-component C, then J contains an anchored n-component isomorphic to C.\n6. If, for some union of conjunctive queries u = q1 ∨ . . . ∨ qh, we have J |6≈u and n > maxq∈{q1,...,qh} ](q), then J ′ |6≈u.\n7. If, for some union of conjunctive queries u = q1 ∨ . . . ∨ qh, we have I 6|= u and n > maxq∈{q1,...,qh} ](q), then collapse(J ′) 6|= u.\nProof. 1. Let K′ = nomFree(K). Due to Lemma 13, J is a strict forest quasi-model for K. By Lemma 34.2, each replacement step preserves local K′-consistency and results, thus, in a forest quasi-model for K. Since each n-replacement is a strict tree quasi-interpretation also strictness is preserved. By induction it follows that every interpretation produced in the n-secure transformation procedure is a strict forest quasimodel for K. For every node in J ′, its direct predecessor and direct successors have not changed any more after finitely many replacement steps and local K′-consistency depends solely on those neighbors. Hence J ′ is also locally K′-consistent.\n2. By Lemma 19, J is collapsing-admissible, by Lemma 30.5 every limit of I is. Moreover, as is obvious from the proofs of both propositions, it is possible to define the respective ch-functions recurring to the original choose-function on I, hence every two elements from (even different) unravelings or limits that start descending BCPs with identical path sketches correspond to the very same element in I whence the separate ch-functions are compatible with each other. Therefore, replacing an element in the unraveling yields a strict forest quasi-model that is collapsing-admissible. Applying the same argument inductively yields that every intermediate strict forest quasi-model during the n-secure transformation is collapsing-admissible. Finally, as the according ch-function stabilizes after finitely many replacement steps (together with the neighborhood of the considered elements), also J ′ is collapsing-admissible.\n3. This follows from the two previous facts (36.1 and 36.2) together with Lemma 20.\n4. Consider the set D of all δ ∈ ∆I causing n-irreplaceable nodes in J . By Lemma 32, D is finite. We obtain D′ by removing all δ from D that do not start any descending BCPs.\nFor δ ∈ D′, let dBCP(δ) denote the set of descending BCPs starting in δ and choose\nm := max δ∈D′\n( min p∈dBCP(δ) |p| )\nNow assume there were a δ′ ∈ ∆I having a shortest descending BCP of length greater than m. Obviously, as δ′ 6∈ D′, there must be a (ρ, w) generated by δ′ that is nreplaceable. However, during the n-secure transformation all n-replaceable elements have been replaced by elements that do not start any descending BCPs at all due to Lemma 30.3.\n5. We prove this by induction on the replacement steps of the n-secure transformation process by showing that this is true for every intermediate replacement result R′.\nThe claim for J ′ then follows from the fact that, for every considered C (which is always finite), only a finite part cut`(J ′) is relevant and that for every `, there is a bounded number of replacement steps after which we have cut`(R′) = cut`(J ′) for every further intermediate R′.\nAs base case (zero replacement steps carried out), we find that for R′ = J , the claim is trivially true.\nNow assume that the claim has been established for R and has to be shown for R′ that is created by replacing (ρ, w) in R with some J ′′. By Lemma 34.3, we then know that one of the following is the case:\n• R contains C. Yet, we can apply the induction hypothesis and conclude that also J contains C as claimed.\n• J ′′ contains C. But, since C is finite, it is already contained in cutk(J ′′) for some k ∈ IN and, as J ′′ is a limit element, we find one δ ∈ ∆I with cutk(↓(I, δ)) = cutk(J ′′). Since I is purified, we find a (ρ, w) ∈ ∆J that corresponds to δ, i.e., J contains an isomorphic copy of ↓(I, δ) which in turn contains an isomorphic copy of C.\n6. This is actually a straightforward consequence from the preceding proposition and the definition of quentailment.\nFor the indirect proof, we suppose J |6≈u and n > maxq∈{q1,...,qh} ](q) and J ′ |≈u, the latter witnessed by J ′ |≈ q for a q ∈ {q1, . . . , qh}. By definition, the latter assures the existence of adequate anchored n-components in J ′. Then, applying the preceding proposition (36.5), we obtain that isomorphic copies of all those anchored n-components are contained in J which, by definition, just means J |≈ q and, therefore, J |≈u. Hence, we have a contradiction, which proves the claim.\n7. We prove this indirectly, so assume I 6|= u, n > maxq∈{q1,...,qh} ](q), and collapse(J ′) |=\nu, witnessed by collapse(J ′) |= q for a q ∈ {q1, . . . , qh}.\nThen, from Lemma 28.2, it follows that J ′ |≈ q. By the previous proposition (36.6), we conclude J |≈ q, which in turn implies I |= q by Lemma 28.1. This implies I |= u, a contradiction.\nNow we are able to establish our first milestone on the way to showing finite representability of countermodels.\nTheorem 37. For every ALCOIFb knowledge base K with K 6|= u, there is a forest model I of K with finitely many roots such that I 6|= u. Moreover, I has bounded branching degree.\nProof. Let u = q1 ∨ . . . ∨ qh. Since an inconsistent knowledge base entails every query, we can assume that K is consistent and, since K 6|= u, there is a model I of K with I 6|= u. Choose an n > maxq∈{q1,...,qh} ](q) and let J\n′ be obtained by carrying out an n-secure transformation on ↓(I) and let I ′ = collapse(J ′). We know that I ′ is a model of K (via Lemma 36.3) and that I ′ 6|= u (by Lemma 36.7).\nBy Lemma 36.4, we know that there is a fixed natural number m such that the shortest descending BCP started by any node in J ′ is shorter than m. Note that there are only finitely many path sketches of length ≤ m. This means that every node in J ′ that starts a descending BCP at all can be assigned to one such path sketch. However, this entails that there are only finitely many elements (i.e., ∼-equivalence classes) in I ′ that contain J ′-elements starting descending BCPs in J ′. This implies, via Lemma 24, that I ′ contains only finitely many roots.\nThe fact that I ′ has bounded branching degree is a direct consequence from the fact that the initial unraveling has bounded branching degree, that replacement do not change the branching degree nor do collapsings as assured by Lemma 20."
    }, {
      "heading" : "7. Finite Representations of Models",
      "text" : "In this section, we show how we can construct a finite representation of a forest model of a knowledge base that has only a finite number of roots. We then show that these finite representations can be used to check query entailment. In order to do this, we use a technique that is very similar to the blocking techniques used in tableau algorithms (see, e.g., Horrocks & Sattler, 2007). A tableau algorithm builds a so-called completion graph that is a finite representation of a model. A completion graph has essentially the same structure as our forest quasi-models. It contains root nodes for the nominals occurring in the input knowledge base plus further root nodes for new nominals that start BCPs. Each (new and old) nominal is the root of a tree, and relations only occur between direct neighbors within a tree, between elements within a tree and a root, or between the roots. An initial completion graph contains only nodes for the nominals occurring in the input knowledge base. Concepts are expanded according to a set of expansion rules, and new nodes are added to the graph when expanding existential restrictions. New nominals are added by the so-called NN-rule whenever an element from within a tree has a relationship with an inverse functional role to a root node that represents a nominal from the input knowledge base, i.e., when a BCP is created. In order to obtain a finite representation, tableau algorithms usually employ some cycle detection mechanism, called blocking. Otherwise the depth of the trees and the number of new nominals might grow infinitely. For logics as expressive as ALCOIFb, blocking usually requires two pairs of elements. In our notation, a (non-root) node n with predecessor n′ blocks a node m with predecessor m′, if 〈n′, n〉 ∼= 〈m′,m〉. In order to obtain a real model from the finite representation, the part between n and m is copied and appended infinitely often. We use a similar technique to obtain a finite representation for a forest model. Since we want to preserve non-entailment, working with just pairs of elements is not sufficient. Instead, we take the length n of the query into account and use isomorphic trees of depth n to define blocking. This technique has first been employed for deciding query entailment in ALCN with role conjunctions (Levy & Rousset, 1998) and has recently been extended to the logics ALCHIQ, ALCHOQ, and ALCHOI (Ortiz, 2008;\nOrtiz et al., 2008a) and extends, as our result, to the DLs SHIQ, SHOQ, and SHOI (i.e., with transitivity) as long as the query contains only simple roles.\nAs for forest quasi-interpretations, we use isomorphisms between forest interpretations or parts of them.\nDefinition 38 (Isomorphism between Forest Interpretations). Let K be an ALCOIFb knowledge base and I = (∆I , ·I), I ′ = (∆I′ , ·I′) two forest interpretations of K. Without loss of generality, we assume from now on that each root δ = (ρ, ε) ∈ ∆I is in the extension of a unique concept Nδ that does not occur in con(K). Then I and I ′ are called isomorphic w.r.t. K, written: I ∼=K I ′, iff there is a bijection ϕ : ∆I → ∆I ′ such that:\n• δ1 is a successor of δ2 iff ϕ(δ1) is a successor of ϕ(δ2) for all δ1, δ2 ∈ ∆I ,\n• 〈δ1, δ2〉 ∈ rI iff 〈ϕ(δ1), ϕ(δ2)〉 ∈ rI ′ for all δ1, δ2 ∈ ∆I and r ∈ rol(K),\n• δ ∈ AI iff ϕ(δ) ∈ AI′ for all δ ∈ ∆I and A ∈ con(K) ∪ {Nδ | δ = (ρ, ε) ∈ ∆I}.\n• δ = oI iff ϕ(δ) = oI′ for all δ ∈ ∆I and o ∈ nom(K). 4\nUsually, we omit the subscript K from ∼=K and assume that it is clear from the context.\nDefinition 39 (n-Blocking). Let n ∈ IN be a fixed natural number and I = (∆I , ·I) with (δ, w) ∈ ∆I , w 6= ε a forest interpretation for some ALCOIFb knowledge base K. An n-blocking-tree w.r.t. (δ, w), denoted blocknI(δ, w), is the interpretation obtained from I by restricting I to elements in {(δ, ww′) | |w′| ≤ n} ∪ {(ρ, ε) | (ρ, ε) ∈ ∆I}. An n-blocking-tree blocknI(δ, w) n-blocks an n-blocking-tree block n I(δ, ww ′) if\n1. blocknI(δ, w) and block n I(δ, ww ′) have disjoint domains except for root elements,\n2. there is a bijection ϕ from elements in blocknI(δ, w) to elements in block n I(δ, ww ′) that witnesses blocknI(δ, w) ∼= blocknI(δ, ww′), and\n3. for each descendant (δ, wv) of (δ, w), there is no inverse functional role f and root (ρ, ε) ∈ ∆I such that 〈(δ, wv), (ρ, ε)〉 ∈ fI .\nA node (δ, v) ∈ ∆I is n-blocked, if (δ, v) is either directly or indirectly n-blocked ; (δ, v) is indirectly n-blocked, if one of its ancestors is n-blocked; (δ, v) is directly n-blocked if none of its ancestors is n-blocked and (δ, v) is a leaf of some n-blocking-tree blocknI(δ, ww\n′) in I that is n-blocked; in this case we say that (δ, v) is (directly) n-blocked by ϕ−(δ, ww′) for ϕ the bijection witnessing ∼=.\nWithout loss of generality, we assume that the n-blocking-trees used above are minimal w.r.t. the order of elements in ∆I (cf. Definition 16).\nA forest interpretation I = (∆I , ·I) for K is an n-representation of K if\n1. ∆I is finite,\n2. ∆I contains no indirectly n-blocked nodes,\n3. for each o ∈ nom(K), there is one element of the form (ρ, ε) ∈ ∆I such that oI = (ρ, ε)I ,\n4. each element that is not directly n-blocked is locally K-consistent. 4\nNote that n = 1 is more restrictive than standard pairwise blocking since two trees of depth one need to be isomorphic before blocking occurs, whereas standard blocking already occurs for two isomorphic pairs of nodes. For DLs as expressive as ALCOIFb, however, n has to be greater than 0 (at least trees of depth 1) if we want to transform n-representations into models of the knowledge base. We now show that each knowledge base has an n-representation for some fixed n ∈ IN and, afterwards, that we can use an n-representation to build a model for the knowledge base.\nLemma 40. Let K be a consistent ALCOIFb knowledge base and u = q1∨ . . .∨ qh a union of conjunctive queries and n a fixed natural number greater than max1≤i≤h|qi|. If K 6|= u, then there is an n-representation of K that does not satisfy u.\nProof. By assumption, K is consistent and K 6|= u. Then, by Theorem 37, there is a forest model I of K with finitely many roots and branching degree bounded in |cl(K)|, and for all q ∈ {q1, . . . , qh} holds I 6|= q. We show that we can find an n-representation R for I.\nWe use a similar argumentation as in Lemma 25 to show that there are only finitely many non-isomorphic n-blocking trees. We again denote this bound by Tn. Let c = |cl(K)|, r = |rol(K)|, and m the (finite) number of roots in I. Each root ρ ∈ ∆I is annotated with a special concept Nρ by assumption. For n = 0, we again have 2c choices. For n > 0, each element can have between 0 and c successors and between 0 and m relations with roots. For roots we have 2c+m choices for the concepts. We use 2cm as bound for the choice of concepts for roots and this clearly bounds the choice for non-roots as well. Each non-root node in a level smaller than n is the root of a tree with depth n − 1 and each node in the sub-tree can again have up to m relations to a root. Assuming that we have only a single role name r ∈ rol(K), we get a bound of O(2ccmT cmn−1) for the number of non-isomorphic sub-trees of depth n with relations to the at most m roots. Since we have not only one but a choice of r roles, we get a bound of O(2c(cmT cmn−1) r). We now abbreviate 2c(cm)r with x and cmr with a and rewrite the obtained bound as Tn = O(x(Tn−1)a). Unfolding yields Tn = O((x1+a+...+a n−1 )(T0)a n ) which is bounded by O((xa n )(2c)a n ) = O((x2c)a n ). By expanding the abbreviated symbols, we obtain a bound for Tn of O((2c(cm)r)(cmr) n ).\nTogether with the fact that I is obtained from a collapsing and relations from elements within a tree to a root in collapsings are never for inverse functional roles, this shows that there is an n-representation of I because for each tree rooted in a node (δ, ε) ∈ ∆I with depth greater than Tn, there are two nodes (δ, w) and (δ, ww′) such that blocknI(δ, w) n-blocks blocknI(δ, ww\n′), and we can simply discard indirectly n-blocked nodes from I to obtain the desired n-representation.\nSince I 6|= q and the n-representation is a restriction of I, non-entailment of q is clearly preserved.\nPlease note that we would not obtain such a bound if we had not fixed a bound on the number of new nominals (roots) beforehand and that we cannot use the standard tableau algorithms to obtain this result. The reason for this is that the number of new nominals (roots) in the tableau algorithms depends on the length of the longest path before blocking\noccurs. For our n-blocking-trees, however, we also have to consider relations back to the roots, which means that blocking occurs the later the more roots we have. On the other hand, delaying blocking may lead to the introduction of more and more new roots. Due to this cyclic argument, termination cannot be guaranteed for the tableau algorithms unless we have fixed a bound on the number of new nominals beforehand. This is also the reason why the tableau algorithm for entailment of conjunctive queries with only simple roles in the query of Calvanese et al. (2009) is sound, complete, and terminating on SHIQ, SHOQ, and SHOI knowledge bases, but is not guaranteed to terminate on SHOIQ knowledge bases (transitivity, i.e., having a DL with S instead of ALC does not have any impact on this).\nWe now show, how we can obtain a model for a knowledge base K from some nrepresentation of K. We use a technique that is directly inspired from tableau algorithms and resembles the process of building a tableau from a complete and clash-free completion graph. In particular the tableau algorithm by Ortiz et al. (Ortiz, 2008; Ortiz et al., 2008a) is very similar as it also uses tree blocking.\nDefinition 41 (Models for n-Representations). Let R = (∆R, ·R) be an n-representation of some ALCOIFb knowledge base K. Let s = δ\n′ 1 δ1 , . . . , δ ′ m δm\nbe a sequence of pairs of elements from ∆R. With |s| we denote the length m of s. For such a sequence s, we set last∗(s) = δ′m and last∗(s) = δm. By s | δ′m+1 δm+1 we denote the sequence δ ′ 1 δ1 , . . . , δ ′ m δm , δ′m+1 δm+1\n. The set of R-induced elements, denoted elem(R), is inductively defined as follows:\n• If δ = (ρ, ε) ∈ ∆R, then δδ ∈ elem(R).\n• If s ∈ elem(R), δ = (ρ, w) ∈ ∆R, δ is not n-blocked, and δ is a successor of last∗(s), then s | δδ ∈ elem(R).\n• If s ∈ elem(R), δ = (ρ, w) ∈ ∆R, δ is directly n-blocked by some δ′ ∈ ∆R, and δ is a successor of last∗(s), then s | δ′δ ∈ elem(R). We define the interpretation I = (∆I , ·I) induced by R as follows:\n• ∆I = elem(R),\n• for each s ∈ ∆I and A ∈ con(K), s ∈ AI iff last∗(s) ∈ AR,\n• for each s ∈ ∆I and o ∈ nom(K), s = oI iff last∗(s) = oR,\n• for each s, s′ ∈ ∆I and r ∈ rol(K), rI =\n{〈s, s′〉 | s′ = s | δ′δ and 〈last ∗(s), last∗(s′)〉 ∈ rR}∪ {〈s, s′〉 | s = s′ | δ′δ and 〈last∗(s), last ∗(s′)〉 ∈ rR}∪ {〈s, s′〉 | s′ = δδ and 〈last ∗(s), δ〉 ∈ rR}∪ {〈s, s′〉 | s = δδ and 〈δ, last ∗(s′)〉 ∈ rR}.\n4\nThe interpretation of nominals is well-defined since n-representations are forest interpretations for K (hence, there is a unique root for each nominal) and pairs δδ with δ = (ρ, ε) are never appended to sequences in elem(R).\nLemma 42. Let K be a consistent ALCOIFb knowledge base, u = q1 ∨ . . .∨ qh a union of conjunctive queries, and n ≥ 1 a fixed natural number greater than max1≤i≤h|qi|. If R is an n-representation of K such that R 6|= u, then there is a model I of K such that I 6|= u.\nThe proof is essentially as the one by Ortiz et al. (2008a), but adapted to our case, where we work completely on interpretations. Our n-representations correspond to completion graphs and our models to tableaux in their case.\nProof. Let I be an interpretation induced by R. Since n-representations do not contain relations from an element within a tree to a root for an inverse functional role by definition, functionality restrictions are not violated in I. Further, since K is simplified andR is a forest interpretation for K such that all elements apart from (directly) n-blocked ones are locally K-consistent, it is quite straightforward that each element in the induced interpretation is locally K-consistent. Together with the restriction on nominals (property 3), this implies that I is a model for K. This is essentially the same principle as the one used to prove that tableaux constructed from completion graphs are proper representations of models of the input knowledge base.\nAssume, to the contrary of what is to be shown, that I |= u. Then there is a disjunct q ∈ {q1, . . . , qh} and a match µ for q such that I |=µ q. We use µ to construct a match π for q in R by “shifting” the mapping for variables into parts that have no direct counterpart in R upwards.\nWe define the match graph G for q in I as an undirected graph containing a node s for each s ∈ ∆I such that µ(x) = s for some x ∈ var(q) and containing an edge 〈s, s′〉 for each s, s′ ∈ ∆I such that there is an atom r(x, y) ∈ q, µ(x) = s, and µ(y) = s′. We call nodes of G that correspond to roots in ∆I root nodes of G (i.e., nodes s such that s = δδ ) and we call all other nodes tree nodes. Note that the restriction of G to tree nodes is a set of trees that we refer to as G1, . . . , Gk and that each such tree has a depth smaller than n.\nFor each x ∈ var(q) such that µ(x) = δδ ( δ δ is a root node in G), we set π(x) = last ∗( δδ ). Note that δ is a root node in R.\nFor each Gi ∈ {G1, . . . , Gk}, we distinguish two situations:\n1. Gi contains a node s such that last∗(s) 6= last∗(s) (i.e., Gi contains a path from within an n-blocking tree to a copy of the path starting from the node that blocks). Due to the use of n-blocking, a single tree Gi can never cover more than one n-blocking tree and it can use at most nodes from two n-blocking trees (leaving one and then entering the next one in less than n steps). For each node s′ in Gi such that |s′| < |s| and x ∈ var(q) such that µ(x) = s′, we set π(x) = ϕ(last∗(s′)). For each s′ in Gi with |s′| ≥ |s| and x ∈ var(q) such that µ(x) = s′, we set π(x) = last∗(s′).\n2. Gi contains no node s such that last∗(s) 6= last∗(s) (i.e., Gi contains a path that lies completely within an n-blocking tree or from a path outside of an n-blocking-tree into an n-blocking-tree). For each node s in Gi and x ∈ var(q) such that µ(x) = s, we set π(x) = last∗(s).\nBy definition of π, I as an induced model of R, and n-blocking, we immediately have that, for each A(x) ∈ q, π(x) ∈ AR. We show that, for each r(x, y) ∈ q, 〈π(x), π(y)〉 ∈ rR, which proves R |= q. We distinguish three cases:\n1. µ(x) = δδ for some δ ∈ ∆ R. Then π(x) = δ = (ρ, ε) ∈ ∆R. We distinguish three cases\nfor µ(y):\n(a) µ(y) = δ ′ δ′ is also a root, then π(y) = δ ′ = (ρ′, ε) ∈ ∆R and, since µ is a match\nfor q in I and by definition of I as an induced interpretation of R, we have that 〈π(x), π(y)〉 = 〈δ, δ′〉 ∈ rR.\n(b) µ(y) is a successor of µ(x) in I, i.e., µ(y) = s = δδ | δ′\nδ′ . Then s is not n-blocked and π(y) = δ′ = (ρ′, c) ∈ ∆R for c ∈ IN. Again, since µ is a match for q in I and by definition of I as an induced interpretation of R, we have that 〈π(x), π(y)〉 = 〈δ, δ′〉 ∈ rR.\n(c) µ(y) is neither a root (µ(y) 6= δ′δ′ for any δ ′ ∈ ∆R) nor a successor of µ(x) in I\n(µ(y) 6= δδ | δ′ δ′ for any δ ′ ∈ ∆R). Then µ(y) belongs to some graph match component Gi and π(y) = last∗(µ(y)) or π(y) = ϕ−(last∗(µ(y))). Since the isomorphism between n-blocking trees also takes the relations to root nodes into account and other parts have direct counterparts in R, we have that 〈π(x), π(y)〉 ∈ rR.\n2. µ(x) = s 6= δδ for any δ ∈ ∆ R. The cases when µ(y) = δ\n′\nδ′ for some δ ′ ∈ ∆R is as\nabove. We assume, therefore, that µ(y) = s′ with |s′| > 1. By definition of I, this means that either s = s′| δδ′ or s ′ = s| δδ′ for some δ, δ ′ ∈ ∆R. We assume s′ = s| δδ′ . The opposite case is analogous. By definition of the match graph G, there is a component Gi of G that contains both s and s′. We distinguish two cases:\n(a) The component Gi contains a node s̄ such that last∗(s̄) 6= last∗(s̄). The most interesting case is when last∗(µ(y)) 6= last∗(µ(y)), i.e., s̄ = s′. Then π(x) = ϕ−(last∗(s)) and π(y) = last∗(s′). Since last∗(s′) 6= last∗(s′), we have that last∗(s′) is the node that directly n-blocks last∗(s′) and, by definition of the bijection ϕ, which witnesses the isomorphism, we have that π(x) = ϕ−(last∗(s)) is the predecessor of π(y) = last∗(s′) and, by definition of I from R, that 〈π(x), π(y)〉 ∈ rR.\n(b) The component Gi contains no node s̄ such that last∗(s̄) 6= last∗(s̄). Then π(x) = last∗(µ(x)) and π(y) = last∗(µ(y)). By definition of I from R, we immediately have that 〈π(x), π(y)〉 ∈ rR.\nIn any case, we have that 〈π(x), π(y)〉 ∈ rR, which implies R |=π q contradicting the initial assumption.\nNow Lemma 40 guarantees that, in case K 6|= q, there is always a finite n-representation R for K such that R 6|= q and Lemma 42 guarantees that R can be transformed into a model I of K such that I 6|= q. This suffices to show that we can enumerate all (finite) n-representations for K and check whether they entail a disjunct of the union of conjunctive queries. Together with the semi-decidability result for FOL, we get the following theorem.\nTheorem 43. Let K be an ALCOIFb knowledge base and u = q1 ∨ . . . ∨ qh a union of conjunctive queries. The question whether K |= u is decidable."
    }, {
      "heading" : "8. Conclusions",
      "text" : "We have solved the long-standing open problem of deciding conjunctive query entailment in the presence of nominals, inverse roles, and qualified number restrictions. We have shown that the problem is decidable by providing a decision procedure and proving its correctness. Since the approach is purely a decision procedure, the computational complexity of the problem remains open.\nOur result also shows decidability of entailment of unions of conjunctive queries in SHOIQ and SROIQ (underlying OWL DL and OWL 2) if we disallow non-simple roles as binary query predicates. We thereby have reached a first important milestone towards tackling the problem of conjunctive queries for OWL 1 DL and OWL 2 DL.\nEntailment of unions of conjunctive queries is also closely related to the problem of adding rules to a DL knowledge base, e.g., in the form of Datalog rules. Augmenting a DL KB with an arbitrary Datalog program easily leads to undecidability (Levy & Rousset, 1998). In order to ensure decidability, the interaction between the Datalog rules and the DL knowledge base is usually restricted by imposing a safeness condition. The DL+log framework (Rosati, 2006a) provides the least restrictive integration proposed so far and Rosati presents an algorithm that decides the consistency of a DL+log knowledge base by reducing the problem to entailment of unions of conjunctive queries. Notably, Rosati’s results (2006a, Thm. 11) imply that the consistency of an ALCHOIQb knowledge base extended with (weakly-safe) Datalog rules is decidable if and only if entailment of unions of conjunctive queries in ALCHOIQb is decidable, which we have established.\nCorollary 44. The consistency of ALCHOIQb+log-knowledge bases (both under FOL semantics and under non-monotonic semantics) is decidable.\nAnother related reasoning problem is query containment. Given a schema (or TBox) S and two queries q and q′, we have that q is contained in q′ w.r.t. S iff every interpretation I that satisfies S and q also satisfies q′. It is well known that query containment w.r.t. a TBox can be reduced to deciding entailment for unions of conjunctive queries w.r.t. a knowledge base (Calvanese et al., 1998a). Decidability of unions of conjunctive query entailment in ALCHOIQb implies, therefore, also decidability of query containment w.r.t. an ALCHOIQb TBox.\nThere are two obvious avenues for future work. We will embark on extending our results in order to allow non-simple roles as query predicates. This is a non-trivial task as our current approach heavily relies on a certain locality of query matches, which has to be relinquished when considering non-simple roles. On the other hand, we are eager to determine the associated computational complexities and provide techniques that can form the basis for implementable algorithms."
    }, {
      "heading" : "Acknowledgments",
      "text" : "During his stay in Oxford where our collaboration started, Sebastian Rudolph was supported by a scholarschip of the German Academic Exchange Service (DAAD). Continuative work on the subject was enabled by funding through the ExpresST project of the German Research Foundation (DFG).\nBirte Glimm was supported by EPSRC in the project HermiT: Reasoning with Large Ontologies.\nWe thank the three anonymous reviewers for their numerous helpful comments. We thank Ian Pratt-Hartmann for (unknowingly) smashing our graphomata, Maria Magdalena Ortiz de la Fuente for establishing the competitive atmosphere, Yevgeny Kazakov for breath-taking discussions on black holes, Boris Motik for his motivating considerations on the value of the academic life, and last not least God for providing us with extraordinary weather and – most notably – infinity."
    } ],
    "references" : [ {
      "title" : "Terminological cycles in a description logic with existential restrictions",
      "author" : [ "F. Baader" ],
      "venue" : "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Baader,? \\Q2003\\E",
      "shortCiteRegEx" : "Baader",
      "year" : 2003
    }, {
      "title" : "The Description Logic Handbook",
      "author" : [ "F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2003
    }, {
      "title" : "DL-Lite: Tractable description logics for ontologies",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Proceedings of the 20th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2005
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "On the decidability of query containment under constraints",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Lenzerini" ],
      "venue" : "In Proceedings of the 17th ACM SIGACT SIGMOD Symposium on Principles of Database Systems (PODS",
      "citeRegEx" : "Calvanese et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 1998
    }, {
      "title" : "Description logic framework for information integration",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "D. Nardi", "R. Rosati" ],
      "venue" : "In Proceedings of the 6th International Conference on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Calvanese et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 1998
    }, {
      "title" : "Answering regular path queries in expressive description logics: An automata-theoretic approach",
      "author" : [ "D. Calvanese", "T. Eiter", "M. Ortiz" ],
      "venue" : "In Proceedings of the 22th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Regular path queries in expressive description logics with nominals",
      "author" : [ "D. Calvanese", "T. Eiter", "M. Ortiz" ],
      "venue" : "In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2009
    }, {
      "title" : "Optimal implementation of conjunctive queries in relational data bases",
      "author" : [ "A.K. Chandra", "P.M. Merlin" ],
      "venue" : "In Proceedings of the 9th ACM Symposium on Theory of Computing (STOC",
      "citeRegEx" : "Chandra and Merlin,? \\Q1977\\E",
      "shortCiteRegEx" : "Chandra and Merlin",
      "year" : 1977
    }, {
      "title" : "Query answering in description logics with transitive roles",
      "author" : [ "T. Eiter", "C. Lutz", "M. Ortiz", "M. Simkus" ],
      "venue" : "In Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Eiter et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2009
    }, {
      "title" : "Conjunctive query answering for the description logic SHIQ",
      "author" : [ "B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Glimm et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Glimm et al\\.",
      "year" : 2008
    }, {
      "title" : "Status QIO: Conjunctive query entailment is decidable",
      "author" : [ "B. Glimm", "S. Rudolph" ],
      "venue" : "In Proceedings of the 12th International Conference on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Glimm and Rudolph,? \\Q2010\\E",
      "shortCiteRegEx" : "Glimm and Rudolph",
      "year" : 2010
    }, {
      "title" : "Über die Vollständigkeit des Logikkalküls",
      "author" : [ "K. Gödel" ],
      "venue" : "Ph.D. thesis,",
      "citeRegEx" : "Gödel,? \\Q1929\\E",
      "shortCiteRegEx" : "Gödel",
      "year" : 1929
    }, {
      "title" : "The foundational model of anatomy in OWL: Experience and perspectives",
      "author" : [ "C. Golbreich", "S. Zhang", "O. Bodenreider" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "Golbreich et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Golbreich et al\\.",
      "year" : 2006
    }, {
      "title" : "Experiences of using OWL at the ordnance survey",
      "author" : [ "J. Goodwin" ],
      "venue" : "In Proceedings of the 1st OWL Experiences and Directions Workshop (OWLED 2005),",
      "citeRegEx" : "Goodwin,? \\Q2005\\E",
      "shortCiteRegEx" : "Goodwin",
      "year" : 2005
    }, {
      "title" : "Why are modal logics so robustly decidable",
      "author" : [ "E. Grädel" ],
      "venue" : "Current Trends in Theoretical Computer Science, Entering the 21th Century,",
      "citeRegEx" : "Grädel,? \\Q2001\\E",
      "shortCiteRegEx" : "Grädel",
      "year" : 2001
    }, {
      "title" : "Problem of Incomplete Information in Relational Databases. Lecture Notes in Computer Science",
      "author" : [ "G. Grahne" ],
      "venue" : "In Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Grahne,? \\Q1991\\E",
      "shortCiteRegEx" : "Grahne",
      "year" : 1991
    }, {
      "title" : "Reasoning with Individuals for the Description Logic SHIQ",
      "author" : [ "I. Horrocks", "U. Sattler", "S. Tobies" ],
      "venue" : "Proceedings of the 17th Conference on Automated Deduction (CADE 2000),",
      "citeRegEx" : "Horrocks et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Horrocks et al\\.",
      "year" : 2000
    }, {
      "title" : "A resolution-based decision procedure for SHOIQ",
      "author" : [ "Y. Kazakov", "B. Motik" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Kazakov and Motik,? \\Q2008\\E",
      "shortCiteRegEx" : "Kazakov and Motik",
      "year" : 2008
    }, {
      "title" : "Conjunctive queries for a tractable fragment of OWL",
      "author" : [ "M. Krötzsch", "S. Rudolph", "P. Hitzler" ],
      "venue" : "Proceedings of the 7th International Semantic Web Conference (ISWC 2007),",
      "citeRegEx" : "Krötzsch et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2007
    }, {
      "title" : "ELP: Tractable rules for OWL",
      "author" : [ "M. Krötzsch", "S. Rudolph", "P. Hitzler" ],
      "venue" : "Proceedings of the 8th International Semantic Web Conference (ISWC 2008),",
      "citeRegEx" : "Krötzsch et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2008
    }, {
      "title" : "Experiences using OWL in military applications",
      "author" : [ "L. Lacy", "G. Aviles", "K. Fraser", "W. Gerber", "A. Mulvehill", "R. Gaskill" ],
      "venue" : "In Proceedings of the 1st OWL Experiences and Directions Workshop (OWLED",
      "citeRegEx" : "Lacy et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Lacy et al\\.",
      "year" : 2005
    }, {
      "title" : "CARIN: A representation language combining horn rules and description logics",
      "author" : [ "A.Y. Levy", "Rousset", "M.-C" ],
      "venue" : "In Proceedings of the 12th European Conference on Artificial Intelligence (ECAI",
      "citeRegEx" : "Levy et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Levy et al\\.",
      "year" : 1996
    }, {
      "title" : "Combining horn rules and description logics in CARIN",
      "author" : [ "A.Y. Levy", "Rousset", "M.-C" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Levy et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Levy et al\\.",
      "year" : 1998
    }, {
      "title" : "The complexity of conjunctive query answering in expressive description logics",
      "author" : [ "C. Lutz" ],
      "venue" : "In Proceedings of the International Joint Conference on Automated Reasoning (IJCAR",
      "citeRegEx" : "Lutz,? \\Q2008\\E",
      "shortCiteRegEx" : "Lutz",
      "year" : 2008
    }, {
      "title" : "An industrial strength description logic-based configuration platform",
      "author" : [ "D.L. McGuinness", "J.R. Wright" ],
      "venue" : "IEEE Intelligent Systems,",
      "citeRegEx" : "McGuinness and Wright,? \\Q1998\\E",
      "shortCiteRegEx" : "McGuinness and Wright",
      "year" : 1998
    }, {
      "title" : "Hypertableau reasoning for description logics. Submitted to a journal. http://www.hermit-reasoner.com/publications/ msh08hypertableau-journal.pdf",
      "author" : [ "B. Motik", "R. Shearer", "I. Horrocks" ],
      "venue" : "In Proceedings of Logics in Artificial Intelligence,",
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "Data complexity of query answering in expressive description logics via tableaux",
      "author" : [ "M. Ortiz", "D. Calvanese", "T. Eiter" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Conjunctive query answering in sh using knots",
      "author" : [ "M. Ortiz", "M. Simkus", "T. Eiter" ],
      "venue" : "In Proceedings of the 2008 Description Logic Workshop (DL",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Data-complexity of the two-variable fragment with counting quantifiers",
      "author" : [ "I. Pratt-Hartmann" ],
      "venue" : "Forthcoming in Information and Computation",
      "citeRegEx" : "Pratt.Hartmann,? \\Q2009\\E",
      "shortCiteRegEx" : "Pratt.Hartmann",
      "year" : 2009
    }, {
      "title" : "DL+log: Tight integration of description logics and disjunctive datalog",
      "author" : [ "R. Rosati" ],
      "venue" : "In Proceedings of the 10th International Conference on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Rosati,? \\Q2006\\E",
      "shortCiteRegEx" : "Rosati",
      "year" : 2006
    }, {
      "title" : "On the decidability and finite controllability of query processing in databases with incomplete information",
      "author" : [ "R. Rosati" ],
      "venue" : "In Proceedings of the 25th ACM SIGACT SIGMOD Symposium on Principles of Database Systems (PODS",
      "citeRegEx" : "Rosati,? \\Q2006\\E",
      "shortCiteRegEx" : "Rosati",
      "year" : 2006
    }, {
      "title" : "The limits of querying ontologies",
      "author" : [ "R. Rosati" ],
      "venue" : "Proceedings of the 11th International Conference on Database Theory (ICDT 2007),",
      "citeRegEx" : "Rosati,? \\Q2007\\E",
      "shortCiteRegEx" : "Rosati",
      "year" : 2007
    }, {
      "title" : "Terminological reasoning in SHIQ with ordered binary decision diagrams",
      "author" : [ "S. Rudolph", "M. Krötzsch", "P. Hitzler" ],
      "venue" : "In Proc. 23rd National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Rudolph et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Rudolph et al\\.",
      "year" : 2008
    }, {
      "title" : "Protein ontology development using OWL",
      "author" : [ "A. Sidhu", "T. Dillon", "E. Chang", "B.S. Sidhu" ],
      "venue" : "In Proceedings of the 1st OWL Experiences and Directions Workshop (OWLED 2005),",
      "citeRegEx" : "Sidhu et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Sidhu et al\\.",
      "year" : 2005
    }, {
      "title" : "Pellet: A practical OWL-DL reasoner",
      "author" : [ "E. Sirin", "B. Parsia", "B. Cuenca Grau", "A. Kalyanpur", "Y. Katz" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "Sirin et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Sirin et al\\.",
      "year" : 2007
    }, {
      "title" : "Questions and answers: Reasoning and querying in Description Logic",
      "author" : [ "S. Tessaris" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "Tessaris,? \\Q2001\\E",
      "shortCiteRegEx" : "Tessaris",
      "year" : 2001
    }, {
      "title" : "FaCT++ description logic reasoner: System description",
      "author" : [ "D. Tsarkov", "I. Horrocks" ],
      "venue" : "In Proceedings of the International Joint Conference on Automated Reasoning (IJCAR 2006),",
      "citeRegEx" : "Tsarkov and Horrocks,? \\Q2006\\E",
      "shortCiteRegEx" : "Tsarkov and Horrocks",
      "year" : 2006
    }, {
      "title" : "Logical approaches to incomplete information: A survey. In Logics for Databases and Information Systems, pp. 307–356",
      "author" : [ "R. van der Meyden" ],
      "venue" : null,
      "citeRegEx" : "Meyden,? \\Q1998\\E",
      "shortCiteRegEx" : "Meyden",
      "year" : 1998
    }, {
      "title" : "Why is modal logic so robustly decidable",
      "author" : [ "M.Y. Vardi" ],
      "venue" : "In Descriptive Complexity and Finite Models: Proceedings of a DIMACS Workshop,",
      "citeRegEx" : "Vardi,? \\Q1997\\E",
      "shortCiteRegEx" : "Vardi",
      "year" : 1997
    }, {
      "title" : "A Little Semantic Web Goes a Long Way in Biology",
      "author" : [ "K. Wolstencroft", "A. Brass", "I. Horrocks", "P. Lord", "U. Sattler", "D. Turi", "R. Stevens" ],
      "venue" : "In Proceedings of the 5th International Semantic Web Conference (ISWC",
      "citeRegEx" : "Wolstencroft et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Wolstencroft et al\\.",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "The underlying reasoning problems are well-understood, and the computational complexity of the standard reasoning tasks given a knowledge base as input range from PTime-complete for DLs with limited expresivity such as DL-Lite (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2005), EL (Baader, 2003), and ELP (Krötzsch, Rudolph, & Hitzler, 2008) to 2-NExpTime-complete for very expressive DLs such as SROIQ (Kazakov, 2008).",
      "startOffset" : 289,
      "endOffset" : 303
    }, {
      "referenceID" : 14,
      "context" : ", biology (Sidhu, Dillon, Chang, & Sidhu, 2005), bio informatics (Wolstencroft, Brass, Horrocks, Lord, Sattler, Turi, & Stevens, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), information integration (Calvanese, De Giacomo, Lenzerini, Nardi, & Rosati, 1998b), geography (Goodwin, 2005), geology (Jet Propulsion Laboratory, 2006), defense (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005), and configuration (McGuinness & Wright, 1998).",
      "startOffset" : 280,
      "endOffset" : 295
    }, {
      "referenceID" : 15,
      "context" : "Modal and Description Logics (Grädel, 2001; Vardi, 1997) and we also heavily exploit a variant of this property to establish our decidability result.",
      "startOffset" : 29,
      "endOffset" : 56
    }, {
      "referenceID" : 39,
      "context" : "Modal and Description Logics (Grädel, 2001; Vardi, 1997) and we also heavily exploit a variant of this property to establish our decidability result.",
      "startOffset" : 29,
      "endOffset" : 56
    }, {
      "referenceID" : 24,
      "context" : "For the DLs SHIQ and SHOQ decidability and 2-ExpTime-completeness of the problem is known (Glimm, Horrocks, Lutz, & Sattler, 2008a; Glimm, Horrocks, & Sattler, 2008b; Lutz, 2008; Eiter, Lutz, Ortiz, & Simkus, 2009).",
      "startOffset" : 90,
      "endOffset" : 214
    }, {
      "referenceID" : 24,
      "context" : "Conjunctive query entailment is already 2-ExpTime-hard in the relatively weak DL ALCI (Lutz, 2008), which was initially attributed to inverse roles.",
      "startOffset" : 86,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "Recently, it was shown, however, that also transitive roles together with role hierarchies as in the DL SH make conjunctive query entailment 2-ExpTime-hard (Eiter et al., 2009).",
      "startOffset" : 156,
      "endOffset" : 176
    }, {
      "referenceID" : 7,
      "context" : "In particular the most recent extension (Calvanese et al., 2009) is very close to a conjunctive query entailment decision procedure for OWL 2, which corresponds to the DL SROIQ, because it covers",
      "startOffset" : 40,
      "endOffset" : 64
    }, {
      "referenceID" : 29,
      "context" : ", 2008a) and this holds also for CQ entailment in the two variable guarded fragment with counting (Pratt-Hartmann, 2009).",
      "startOffset" : 98,
      "endOffset" : 120
    }, {
      "referenceID" : 16,
      "context" : "Query entailment and answering have also been studied in the context of databases with incomplete information (Rosati, 2006b; van der Meyden, 1998; Grahne, 1991).",
      "startOffset" : 110,
      "endOffset" : 161
    }, {
      "referenceID" : 0,
      "context" : "Another tractable DL is EL (Baader, 2003).",
      "startOffset" : 27,
      "endOffset" : 41
    }, {
      "referenceID" : 0,
      "context" : "Another tractable DL is EL (Baader, 2003). Conjunctive query entailment in EL is, however, not tractable as the complexity increases to coNP-complete (Rosati, 2007b). Moreover for EL++ (Baader et al., 2005), a still tractable extension of EL, query entailment is even undecidable (Krötzsch, Rudolph, & Hitzler, 2007). This is mainly because in EL++, one can use unrestricted role compositions. This allows for encoding context-free languages, and conjunctive queries can then be used to check the intersection of such languages, which is known to be an undecidable problem. Since the logics used in databases with incomplete information are considerable less expressive than ALCHOIQb, the techniques developed in that area do not transfer to our setting. Given that query entailment is a (computationally) harder task than, for example, knowledge base satisfiability, it is not very surprising that decidability of the latter task does not necessarily transfer to the problem of CQ entailment. Most of the undecidability results can be transferred from FOL since many DLs can directly be translated into an equivalent FOL theory. For example, it is known that conjunctive query entailment is undecidable in the two variable fragment of First-Order Logic L2 (Rosati, 2007a), and Rosati identifies a relatively small set of constructors that cause the undecidability (most notably role negation axioms, i.e., axioms of the form ∀x, y (¬R(x, y)→ P (x, y)) for R,P binary predicates). Pratt-Hartmann (2009) recently established decidability for CQ entailment in the two variable guarded fragment with counting (GC2).",
      "startOffset" : 28,
      "endOffset" : 1503
    }, {
      "referenceID" : 26,
      "context" : "Meanwhile also alternative approaches such as resolution (Kazakov & Motik, 2008), and hypertableau-based procedures (Motik et al., 2009) are available and implemented.",
      "startOffset" : 116,
      "endOffset" : 136
    }, {
      "referenceID" : 12,
      "context" : "As a result of the completeness theorem for FOL (Gödel, 1929), the consequences of a finite FOL theory are recursively enumerable, which provides us with a procedure that terminates if K |= q.",
      "startOffset" : 48,
      "endOffset" : 61
    }, {
      "referenceID" : 35,
      "context" : "A proof is given by Tessaris (2001) and, with this lemma, it is clear that the restriction to connected queries is indeed without loss of generality since entailment of q can be decided by checking entailment of each qi at a time.",
      "startOffset" : 20,
      "endOffset" : 36
    }, {
      "referenceID" : 2,
      "context" : "This is also the reason why the tableau algorithm for entailment of conjunctive queries with only simple roles in the query of Calvanese et al. (2009) is sound, complete, and terminating on SHIQ, SHOQ, and SHOI knowledge bases, but is not guaranteed to terminate on SHOIQ knowledge bases (transitivity, i.",
      "startOffset" : 127,
      "endOffset" : 151
    }, {
      "referenceID" : 27,
      "context" : "The proof is essentially as the one by Ortiz et al. (2008a), but adapted to our case, where we work completely on interpretations.",
      "startOffset" : 39,
      "endOffset" : 60
    } ],
    "year" : 2010,
    "abstractText" : "Description Logics are knowledge representation formalisms that provide, for example, the logical underpinning of the W3C OWL standards. Conjunctive queries, the standard query language in databases, have recently gained significant attention as an expressive formalism for querying Description Logic knowledge bases. Several different techniques for deciding conjunctive query entailment are available for a wide range of DLs. Nevertheless, the combination of nominals, inverse roles, and number restrictions in OWL 1 and OWL 2 DL causes unsolvable problems for the techniques hitherto available. We tackle this problem and present a decidability result for entailment of unions of conjunctive queries in the DL ALCHOIQb that contains all three problematic constructors simultaneously. Provided that queries contain only simple roles, our result also shows decidability of entailment of (unions of) conjunctive queries in the logic that underpins OWL 1 DL and we believe that the presented results will pave the way for further progress towards conjunctive query entailment decision procedures for the Description Logics underlying the OWL standards.",
    "creator" : "TeX"
  }
}