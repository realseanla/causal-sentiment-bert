{
  "name" : "1411.5220.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Existential Rule Languages with Finite Chase: Complexity and Expressiveness",
    "authors" : [ "Heng Zhang", "Yan Zhang", "Jia-Huai You" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "Introduction",
      "text" : "It has been shown that existential rule languages, also called Datalog±, have prominent applications in ontological reasoning, knowledge representation, and databases, in which query answering is a primary yet challenging problem; see e.g., (Calı̀ et al. 2010; Baget et al. 2011a). Under an existential rule language, queries are answered against a logical theory consisting of an input database and a finite set of existential rules, while a chase procedure is usually used. Specifically, given an input database D, a finite set Σ of existential rules, and a query q, we want to decide whether D ∪Σ |= q. Applying the chase procedure, the problem is equivalent to deciding whether chase(D,Σ) |= q. Through a chase procedure, fresh nulls have to be introduced for each application of the existential rules, and hence, potential cyclic applications of these rules may lead the chase procedure not to terminate, i.e., chase(D,Σ) is infinite. Therefore, the problem of query answering under existential rule languages is in general undecidable (Beeri and Vardi 1981).\nThere have been a considerable number of works on identifying decidable classes with respect to query answering. Basically, two major approaches have provided a landscape on this study: One is to focus on some restricted\nCopyright c© 2015, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nfragments of existential rule languages such that the underlying chase procedure, though non-terminating in general, still enjoys some kind of finite representability property, so that the problem of query answering is decidable under this setting. This paradigm includes, e.g., guarded rules (Calı̀, Gottlob, and Lukasiewicz 2012), greedy bounded treewidth sets (Baget et al. 2011b), sticky sets (Calı̀, Gottlob, and Pieris 2012), and Shy programs (Leone et al. 2012). The other approach is to identify a certain acyclicity condition under which each existential rule can only be finitely applied so that the chase procedure always terminates. There have been many recent studies on this paradigm. Our work presented in this paper is along this line. Below, let us provide a brief summary of recent works under this approach.\nIn their milestone paper, Fagin et al. (2005) formulated a concept called weak acyclicity (WA) as a sufficient condition to ensure the chase termination for existential rules. This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Krötzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al. 2013), and some dependency relations by (Baget et al. 2014). Among these, MFA is known to define the largest rule class. In addition, many ontologies in various domains turn out to be in the MFA class, as evidenced in (Grau et al. 2013).\nIt has been observed that almost all of the existential rule languages defined based on the notion of acyclicity or its variations have PTIME-complete data complexity and 2- EXPTIME-complete combined complexity. The uniformity on data complexity is in fact due to an interesting result proved in (Marnette 2009), which states that every rule language with finite Skolem chase is in PTIME for data complexity. A natural question then arises: Does this uniformity hold for combined complexity? Moreover, what is the expressiveness of existing rule languages with finite chase? Please note that the uniformity on data complexity does not imply the uniformity on expressiveness as data complexity only captures the hardest case of a language. Recently, there have been two interesting related works that studied the expressiveness of existential rules (Arenas, Gottlob, and Pieris 2014; Gottlob, Rudolph, and Simkus 2014). But both of them only focus on guarded language or its variations. ar X\niv :1\n41 1.\n52 20\nv3 [\ncs .A\nI] 8\nJ an\n2 01\n5\nIn this paper, we study the complexity, expressiveness and succinctness for existential rule languages with finite chase. Our contributions are summarized as follows:\n1. A novel approach for classifying the existential rule languages with finite Skolem chase is proposed by restricting the use of existential variables in the Skolem chase. Under this approach, a family of interesting decidable rule languages, called bounded languages, are naturally defined. All of the existing rule languages with finite chase, e.g., the MFA class, are contained in these languages.\n2. For every nonnegative integer k, the combined complexity of Boolean query answering for k-exponentially bounded language is proved to be (k + 2)-EXPTIME-complete, and the membership problem of k-exponentially bounded language is proved to be in (k + 2)-EXPTIME. Furthermore, for other bounded languages, the corresponding upper bounds of the complexity are also obtained.\n3. All the languages with finite Skolem chase that extend the WA class are proved to be of the same expressiveness as WA, while languages with higher combined complexity are in general more succinct than those with lower combined complexity. On ordered databases, WA is shown to capture all existential rule sets whose universal models are computable in PTIME, even if they have no finite chase.\nThe results presented in this paper not only generalize some of the existing works, such as the two acyclicity notions of MFA and MSA proposed in (Grau et al. 2013), more importantly, they provide a global landscape for characterizing the existential rule languages with finite Skolem chase.\nThe rest of this paper is organized as follows. Section 2 provides necessary preliminaries. Section 3 defines a family of existential rule languages with finite Skolem chase called bounded classes, and presents some interesting properties of this family of languages. Section 4 then focuses on the complexity issues for bounded classes of languages, while section 5 explores the expressiveness and succinctness of these bounded classes of languages in details. Finally, section 6 concludes this paper with some remarks. Due to space limitation, proofs of some results are presented in an extended version of this paper, see (Zhang, Zhang, and You 2014)."
    }, {
      "heading" : "Preliminaries",
      "text" : "Databases and Queries. As usual, we assume (i) an infinite set ∆ of constants, (ii) an infinite set ∆n of (labelled) nulls, and (iii) an infinite set ∆v of variables. A relational schema R consists of a finite set of relation symbols, each of which is armed with a natural number, its arity. Terms are either constants or variables. Every atomic formula (or atom) has the form R(t) where R is a relation symbol and t a tuple of terms of a proper length. Ground terms are terms involving no variable, and facts are atoms built from ground terms.\nGiven a relational schemaR, an instance (database) over R, or simply R-instance (R-database), is a (finite) set of facts involving only relation symbols from R. The domain of a database D, denoted dom(D), is the set of all constants appearing inD. General instances (databases) are the extensions of instances (databases) by allowing nulls to be\nused. Given a general instance (database) D and a relational schemaR, the restriction ofD toR, denotedD|R, is the set of facts in D involving only relation symbols fromR.\nA substitution is a function h : ∆∪∆n∪∆v → ∆∪∆n∪ ∆v with (i) h(c) = c for all c ∈ ∆ and (ii) h(n) ∈ ∆ ∪∆n for all n ∈ ∆n. Let D and D0 be general instances of the same schema. Then D is called homomorphic to D0, written D → D0, if there is a substitution h with h(D) ⊆ D0 where h is assumed to be extended to atoms and general instances naturally. In this case, the function is called a homomorphism from D to D0. Moreover, D is homomorphically equivalent toD0 ifD is homomorphic toD0 and vice versa.\nEvery conjunctive query (CQ) q over a relational schema R has the form q(x) := ∃yϕ(x,y), where x,y are tuples of variables, and ϕ(x,y) is a conjunction (sometimes we regard it as a set) of atoms with variables from x and y, and relation symbols fromR. A Boolean CQ (BCQ) is a CQ of the form q(). Actually, BCQs can be regarded as general databases if we omit the quantifiers and regard the variables as nulls. Given any BCQ q and any general instance D over the same schema, the answer to q over D is “Yes”, written D |= q, if there exists a homomorphism from q to D.\nExistential Rules and Skolem Chase. Given a relational schemaR, every (existential) rule overR is a first-order sentence γ of the form ∀x∀y(ϕ(x,y)→ ∃zψ(x, z)), where ϕ and ψ are conjunctions of atoms with relation symbols from R and variables from x ∪ y and x ∪ z, respectively. We call ϕ the body of γ and ψ the head of γ, and write them as body(γ) and head(γ), respectively. When writing a rule, for simplicity, we will omit the universal quantifiers.\nA rule ontology is a triple (Σ,D,Q), where Σ is finite and nonempty set Σ of rules, D, called database schema, is a relational schema consisting of the relation symbols to be used in databases, and Q, called query schema, is a relational schema consisting of the relation symbols to be used in queries. Relation symbols appearing in Σ but neither D norQ are called auxiliary symbols. Note thatD andQ could be the same. Without loss of generality, in any rule ontology, each variable is assumed to be quantified at most once.\nLet γ be a rule ϕ(x,y) → ∃zψ(x, z). We introduce a function symbol fz of arity |x| for each variable z ∈ z. From now on, we will regard terms built from constants and the introduced function symbols as a special class of nulls. The functional transformation of γ, denoted sk(γ), is the formula obtained from γ by substituting fz(x) for each variable z ∈ z. Given a set Σ of rules, the functional transformation of Σ, denoted sk(Σ), is the set of rules sk(γ) for all γ ∈ Σ.\nNow we are in the position to define the (Skolem) chase. Let D be a database and Σ a rule set. We let chase0(D,Σ) = D and, for all n > 0, let chasen(D,Σ) denote the union of chasen−1(D,Σ) and h(head(γ)) for all rules γ ∈ sk(Σ) and all substitutions h such that h(body(γ)) ⊆ chasen−1(D,Σ). Let chase(D,Σ) be the union of chasen(D,Σ) for all n ≥ 0. It is well-known that, for all BCQs q, D ∪Σ |= q (under the semantics of first-order logic) if and only if chase(D,Σ) |= q. Given a rule ontology O = (Σ,D,Q), we say that O has finite chase if for all D-databases D, chase(D,Σ) is finite. For more details, please refer to (Marnette 2009).\nMore Notations. Given a set Σ of rules and a BCQ q, let ||Σ|| and ||q|| denote the numbers of symbols occurring in Σ and q, respectively. We assume that the reader is familiar with complexity theory. Given a unary function T on natural numbers, by DTIME(T (n)) we mean the class of complexity languages decidable in time T (n) by a deterministic Turing machine. For k ≥ 0 we let expk(n) denote the function that maps n to n if k = 0, and 2expk−1(n) otherwise. By k-EXPTIME we mean the class ⋃ c≥0 DTIME(expk(n\nc)). For simplicity, we denote relation symbols (nulls/function symbols, respectively) by capitalized (lower-case, respectively) sans-serif letters, constants by lower-case italic letters a, b, c, variables by lower-case italic letters u, v, w, x, y, z, and terms by lower-case italic letters s, t. All of these symbols may be written with subscripts or superscripts. In addition, bold italic letters u,v,w,x,y, z and s, t are used to range over tuples of variables and terms, respectively."
    }, {
      "heading" : "Bounded Classes",
      "text" : "In this section, we define a family of rule languages with finite chase, and study its general properties.\nWe first define some notations. Given a ground term t, the height of t, denoted ht(t), is defined as follows:\nht(t) := { 0 if t ∈ ∆; max{ht(s) : s ∈ s}+ 1 if t= f(s) for some f.\nGiven any general instance A, the height of A, denoted ht(A), is defined as the maximum height of terms that have at least one occurrence in A if it exists, and∞ otherwise. Definition 1. Every bound function is a function from positive integers to positive integers. Let δ be a bound function. A rule ontology (Σ,D,Q) is called δ-bounded if, for all D-databases D, ht(chase(D,Σ)) ≤ δ(||Σ||). We let δBOUNDED denote the class of δ-bounded rule ontologies.\nAs there exist an infinite number of bound functions, it is interesting to know if there is a “maximum” bound function that captures all δ-bounded rule ontologies for any bound function δ (or all rule ontologies with finite chase). The following result shows that the answer is definitely “yes”. Proposition 1. There is a bound function δ such that, for every rule ontology O, O has finite chase iff it is δ-bounded.\nProof. (Sketch) We first construct a bound function δ, and then it suffices to show that every rule ontology with finite chase is δ-bounded. To define δ, we want to prove that, for every rule ontology O = (Σ,D,Q), there exists a database D∗O such that ht(chase(D,Σ)) ≤ ht(chase(D∗O,Σ)) for all D-databasesD. This can be done by employing the so-called critical database technique, which was developed in (Marnette 2009). Define δ(n) as the maximum ht(chase(D∗O,Σ)) among all rule ontologies O = (Σ,D,Q) with finite chase such that ||Σ|| ≤ n; we then have the desired function δ. Remark 1. Let BOUNDED be the union of δ-BOUNDED for all bound functions δ. A rule ontology is called bounded if it belongs to BOUNDED. As all bounded rule ontologies have finite chase, by Proposition 1 we have that BOUNDED contains exactly the rule ontologies with finite chase.\nNext, let us define a class of interesting bound functions. Definition 2. Let k be a natural number and let expk be the function defined in the previous section. A rule ontology is called k-exponentially bounded if it is expk-bounded. Remark 2. The MFA class (Grau et al. 2013), which was shown to extend many existing languages with an acyclicity restriction, is defined by restricting the recursive uses of existential variables in Skolem chase. It is not difficult to see that MFA ⊆ exp0-BOUNDED. The following example shows that the inclusion is in fact strict. Example 1. Let O = (Σ,D,Q) be a rule ontology, where D = {R} and Σ consists of the following rules:\nR(x, x) → ∃yz S(x, y) ∧ S(y, z) R(x, y) ∧ S(x, z) → ∃v R(z, v)\nThis rule ontology does not belong to the MFA class because the existential variable v might be recursively applied in the Skolem chase (one can check it by letting the database D be {R(a, a)}). As each existential variable can be recursively used at most twice, O is 0-exponentially bounded.\nOne might ask if all bounded ontologies can be captured by exponential bound functions (or computable bound functions). The proposition below shows that this is impossible. Proposition 2. There is no computable bound function δ such that every bounded rule ontology is δ-bounded."
    }, {
      "heading" : "Complexity",
      "text" : "Now we study the complexity of bounded classes. We are interested in the complexity of two kinds of important computations: query answering and language membership.\nBoolean Query Answering. The problem to be investigated here, also known as query entailment, is defined as follows: Given a set Σ of rules, a database D and a Boolean query q, decide if D ∪ Σ |= q. We first consider the upper bound. Proposition 3. Let δ be a bound function. Then for any δbounded rule ontology (Σ,D,Q), any D-database D and any BCQ q over Q, it is in\nDTIME((|dom(D)|+ ||Σ||)||Σ||O(δ(||Σ||))·||q||O(1)) to check whether D ∪ Σ |= q. Proof. (Sketch) First evaluate the size of chase(D,Σ). By this we know how many stages are needed for the chase to terminate. Counting the cost of each chase stage and querying on chase(D,Σ), we then have the desired result.\nA lower bound for the combined complexity is as follows. Proposition 4. It is (k + 2)-EXPTIME-hard (for the combined complexity) to check, given a k-exponentially bounded rule ontology (Σ,D,Q), aD-databaseD and a BCQ q over Q, whether D ∪ Σ |= q. Proof. (Sketch) LetM be any deterministic Turing machine that terminates in expk+2(n) steps on any input of length n. Let D = ∅ and Q = {Accept} where Accept is a nullary relation symbol. To show the desired result, it suffices to\nshow that, for each input (a binary string) x, there is an expkbounded rule ontology (Σ,D,Q) such that M terminates on input x if and only if ∅ ∪ Σ |= Accept. Let x be an input of length n. To construct the rule set Σ, the main difficulty is to define a linear order of length expk+2(n). If the order is defined, by an encoding similar to that in (Dantsin et al. 2001), one can construct a set of datalog rules to encode both M and x. Here we only explain how to define the linear order.\nLet us first consider the case where k is even. The general idea is to construct a sequence of rule sets (Σi)i≥0. For each i, let Succi,Mini and Maxi be relation symbols intended to define the (immediate) successor relation, the minimum element and the maximum element, respectively, of a linear order. For i > 0, the function of Σi is as follows: If Succi−1,Mini−1 and Maxi−1 define a linear order of length n, then Succi,Mini and Maxi define a linear order on integers (represented in binary strings) from 0 to 22 n\n. To implement each Σi, we generalize a technique used in the proof of Theorem 1 in (Calı̀, Gottlob, and Pieris 2010).\nThe first task is to define the binary strings of length one, i.e. “0” and “1”. This can be done by the following rule:\nMini−1(v)→ BSi(v, 0) ∧ BSi(v, 1) where BSi(v, x) states that x is a binary string of length 2v .\nThe following rules are used to generate binary strings of length 2v+1 by combining two binary strings of length 2v:\nBSi(v, x) ∧ BSi(v, y) → ∃z Ci(v, x, y, z) Ci(v, x, y, z) ∧ Succi−1(v, w) → BSi(w, z)\nThen, some rules to define a successor relation (w.r.t. the lexicographic order) on strings of length 2v+1 are as follows: [\nCi(v, x, y, z) ∧ Ci(v, x, y0, z0) ∧Succ∗i (v, y, y0) ∧ Succi−1(v, w)\n] → Succ∗i (w, z, z0)\n  Ci(v, x, y, z) ∧ Ci(v, x0, y0, z0) ∧Max∗i (v, y) ∧Min∗i (v, y0)\n∧Succ∗i (v, x, x0) ∧ Succi−1(v, w)\n  → Succ∗i (w, z, z0)\nwhere Succ∗i (v, x, y) is intended to assert that y is the immediate successor of x, and both x and y are of length 2v .\nThe minimum and the maximum binary strings of length 2v+1 are defined by the following rules:[\nMin∗i (v, x) ∧Min∗i (v, y) ∧Ci(v, x, y, z) ∧ Succi−1(v, w) ] → Min∗i (w, z)\n[ Max∗i (v, x) ∧Max∗i (v, y)\n∧Ci(v, x, y, z) ∧ Succi−1(v, w)\n] → Max∗i (w, z)\nNow the desired relations Numi,Succi,Mini and Maxi can be obtained by applying the following rules:\nSucc∗i (v, x, y) ∧Maxi−1(v) → Succi(x, y) Min∗i (v, x) ∧Maxi−1(v) → Mini(x) Max∗i (v, x) ∧Maxi−1(v) → Maxi(x)\nFor all i > 0, let Σi consist of all of the above rules. It is easy to see that Σi is as desired. Let 0, . . . , n− 1 be distinct constants. Let Σ0 denote the following rule set:\nMin0(0) ∧Max0(n− 1) Succ0(0, 1) ∧ · · · ∧ Succ0(n− 2, n− 1)\nNext, let ` = k/2 + 1 and let Σnum be the union of Σi for all i with 0 ≤ i ≤ `. By the previous analysis, it is not difficult to see that Succ`,Min` and Max` define a linear order on (the binary representions of) integers from 0 to expk+2(n). It is also not difficult to check that the rule ontology (Σnum, ∅, {Accept}) is expk-bounded.\nFor the case where k is odd, we can achieve the goal by some slight modifications to Σnum: (i) substituting the least integer greater than or equal to log n for n in Σ0, and then (ii) setting ` = k/2 + 2. Similarly, we can show that the resulting rule set Σnum satisfies the desired property.\nNow, by combining Propositions 3, 4, and the data complexity of Datalog (see, e.g., (Dantsin et al. 2001)), for any k-exponentially bounded class we then have the exact bound of the complexity w.r.t. Boolean query answering. Theorem 5. For all integers k ≥ 0, the Boolean query answering problem of the k-exponentially bounded language is (k+ 2)-EXPTIME-complete for the combined complexity, and PTIME-complete for the data complexity.\nMembership of Language. Now we consider the membership problem of bounded languages. The problem is as follows: Given a rule ontology, check whether it belongs to the bounded language under consideration. Since the boundedness is defined in a semantical way, it is interesting to know how to check whether a rule ontology is δ-bounded. Proposition 6. Let δ be a bound function that is computable in DTIME(T (n)) for some function T (n). Then for every rule ontology O = (Σ,D,Q), it is in\nDTIME(||Σ||||Σ||O(δ(||Σ||)) + T (log ||Σ||)O(1)) to check whether O is δ-bounded.\nThe above proposition can be proved by using Marnette’s critical database technique (2009) and then by an analysis similar to that in the proof of Proposition 3. Remark 3. Two immediate corollaries of Proposition 6 are: It is in (k + 2)-EXPTIME to check whether a rule ontology is k-exponentially bounded; moreover, the membership for δ-bounded language is decidable whenever δ is computable."
    }, {
      "heading" : "Expressiveness and Succinctness",
      "text" : "Though all rule languages with finite chase are tractable for data complexity (Marnette 2009), in the last section we have shown that their combined complexity could be very high. Hence, a natural question is as follows: Are the languages with high combined complexity really necessary for representing ontological knowledge? In this section, we address this question on two aspects: What is the expressiveness of these languages? How about the succinctness among them?\nUniversal Worldview Mapping. We first propose a semantic (and more general) definition for rule ontologies. Definition 3. LetD andQ be two relational schemas. A universal worldview mapping, or UWM for short, over (D,Q) is a function that maps every D-database D to a general instance Q over Q. Let Φ and Ψ be two UWMs over (D,Q). We say that Φ is equivalent to Ψ, written Φ ≈ Ψ, if for allDdatabases, Φ(D) is homomorphically equivalent to Ψ(D).\nIt is clear that ≈ is an equivalence relation on the UWMs. Next, we show how to define UWMs from rule ontologies. Definition 4. Let O = (Σ,D,Q) be any rule ontology. We define [[O]] as the function that maps every D-database D to the general instance chase(D,Σ)|Q.\nGiven any rule ontology O, it is clear that [[O]] is a UWM. We say that two rule ontologies O1 and O2 are equivalent if the corresponding UWMs are equivalent, i.e., [[O1]] ≈ [[O2]]. The following property explains why this is desired. Proposition 7. Let O1 = (Σ1,D,Q) and O2 = (Σ2,D,Q) be two rule ontologies with finite chase. Then [[O1]] ≈ [[O2]] iff, for all D-databases D and all BCQs q over Q, we have"
    }, {
      "heading" : "D ∪ Σ1 |= q iff D ∪ Σ2 |= q.",
      "text" : "In addition, for a technical reason, given a rule ontology O = (Σ,D,Q), we require that D andQ are disjoint and no relation symbol in D has an occurrence in the head of any rule in Σ.1 We call such rule ontologies normal. These assumptions do not change the expressiveness since, for every relation symbol R ∈ D ∩ Q, we can always replace R in D with a fresh relation symbol R′ of the same arity, and then add a copy rule R′(x)→ R(x) into the rule set Σ. From Bounded Classes to the WA Class. In this subsection, we show that any bounded ontology can be rewritten to a rule ontology that is weakly acyclic (Fagin et al. 2005).\nLet us first review the notion of weak acyclicity. Fix Σ as a set of rules and R its schema. A position of Σ is a pair (R, i) where R ∈ R is of an arity n and 1 ≤ i ≤ n. The dependency graph of Σ is a directed graph with each position of Σ as a node, and with each pair ((R, i), (S, j)) as an edge if there is a rule ϕ(x,y)→ ∃zψ(x, z) from Σ such that • there is a variable x ∈ x such that x occurs both in the\nposition (R, i) in ϕ and in the position (S, j) in ψ, or • there are variables x ∈ x and z ∈ z such that x occurs in\nthe position (R, i) in ϕ and z occurs in the position (S, j) in ψ (in this case, the edge is called a special edge).\nA rule ontology (Σ,D,Q) is weakly acyclic (WA) if no cycle in the dependency graph of Σ goes through a special edge.\nIt is well-known that the class of WA rule ontologies enjoys the finite chase property. In the last few years, a number of classes have been proposed to extend it. However, the next theorem shows that, in view of the expressiveness, the WA class is no weaker than any class with finite chase. Theorem 8. For every normal rule ontologyO = (Σ,D,Q) with finite chase, there exists a weakly acyclic normal rule ontology O∗ = (Σ∗,D,Q) such that [[O]] ≈ [[O∗]].\nWe prove this theorem by developing a translation. The general idea is as follows. Given any normal rule ontology O = (Σ,D,Q) with finite chase, we need to construct a weakly acyclic rule ontology O∗ = (Σ∗,D,Q) such that any computation onO can be simulated by a computation on O∗. The main difficulty is how to simulate the cyclic existential quantifications by weakly acyclic existential quantifications. Fortunately, by Proposition 1,O is always bounded,\n1This is similar to that in data exchange (Fagin et al. 2005).\nwhich means that the size of any (possibly functional) term generated by the chase procedure of O on any database is bounded by some integer `. Therefore, every (possibly functional) term generated by the chase procedure of O can be encoded by an `-tuple of function-free terms. For every relation symbol R occurring in O, we introduce an auxiliary relation symbol R∗ with a larger arity so that every fact of the form R(t) can be encoded by a fact of the form R∗(t∗).\nWith these settings, we can then construct some rules to simulate the chase procedure of O by that of O∗ so that, for every D-database D and every fact R(t) ∈ chase(D,Σ), there exists a fact R∗(t∗) ∈ chase(D,Σ∗) that encodes R(t). These rules can be constructed by an approach similar to that in (Krötzsch and Rudolph 2011). So, the remaining task is to decode R(t) from R∗(t∗). The difficulty of decoding is how to assure that, for each term (that might occur as arguments in different facts) in chase(D,Σ), there is exactly one null to be allocated to it. Fortunately again, it can be overcome by some encoding techniques. We will explain this later.\nNow, let us define the translation formally. Let D,Q and Σ be defined as in the theorem. Let δ be a bound function such that Σ is δ-bounded. Let m be the maximum arity of function symbols appearing in sk(Σ). Let ` = ∑δ(||Σ||) i=0 m i and s = (`− 1)/m. Introduce a fresh ` ·n-ary relation symbol2 R∗ for each n-ary relation symbol R, introduce a fresh variable vi for each variable v and each i with 1 ≤ i ≤ `, and introduce (as a blank symbol to fill the gaps) and all non-nullary function symbols in sk(Σ) as fresh constants.\nTo represent a (functional) term t, we first regard t as an m-complete tree with each symbol (function or constant) as a node and arguments of a function symbol f as the children of f. If some node is empty, we then fill it with . The tuple encodes t is then the symbol sequence obtained by a depthfirst traversal. If the tuple is of length < `, we then fill s in the tail. Lastly, we let [t] denote this tuple. For example, if m = 2, ` = 7 and t = f(g(a), b), then [t] = fga b .\nTo activate the simulation, some rules are needed to copy the data of R to R∗. Formally, for each n-ary relation symbols R ∈ D, we need a rule %R, defined as follows:\nR(x1, . . . , xn)→ R∗(x1, ?, · · ·xn, ?) where ? denotes the tuple consisting of `−1 consecutive s.\nLet γ be a rule from Σ of the form ϕ(x,y)→ ∃z ψ(x, z) where x = x1 · · ·xk is a permutation of all the variables occurring in both ϕ and ψ. We need a rule γ∗, which will be defined shortly, to simulate γ. For any term t in γ, we let\nτ(t) :=    a · · · if t = a ∈ ∆; v1 · · · vs · · · if t = v ∈ x ; fvx 1 1 · · ·xs1x12 · · ·xsk · · · if t = v ∈ z ;\nv1 · · · v` if t = v ∈ y . where, in each of the first three cases, the tail of τ(t) is filled with the symbol such that the length of τ(t) is exactly `. Now we define γ∗ as the rule ϕ∗ → ψ∗, where ϕ∗ and ψ∗ denote the formulas obtained from ϕ and ψ, respectively, by\n2In fact, we can use some relation symbol with a smaller arity, but this will make the presentation more complicated.\n• substituting τ(t) for each term t ∈ ∆ ∪∆v , followed by • substituting R∗ for each relation symbol R.\nIn the chase procedure for the new ontology, by applying above rules on a D-database D, we obtain a fact set S∗ that encodes chase(D,Σ). Thus, as mentioned previously, the remaining task is to construct rules for the decoding. The idea is as follows: (i) let Dom∗ be the set of all `-tuples that encode terms with occurrences in chase(D,Σ); (ii) for each `-tuple s∗ ∈ Dom∗, generate a null n for it (by appying an existential quantifier once), and use Map(s∗, n) to record the correspondence between s∗ and n; (iii) translate each fact R∗(t∗) to a fact R(t) by looking up the relation Map.\nTo collect the `-tuples in stage (i), we need the following rules. Given an n-ary relation symbol R ∈ Q, let λR denote\nR∗(v1, . . . ,vn)→ Dom∗(v1) ∧ · · · ∧ Dom∗(vn) where each vi is a tuple of distinct variables v1i · · · vsi , and Dom∗ a fresh relation symbol of arity `.\nNext, we define some rules to generate nulls, which implement stage (ii). For each function symbol fx in sk(Σ) where x is an existential variable in Σ, let ζx denote\nDom∗(fx,v)→ ∃xMap(fx,v, x) where v is a tuple of distinct variables v1 · · · v`−1, and Map a fresh (`+1)-ary relation symbol. In addition, let ζc denote\nDom∗(x, , . . . , )→ Map(x, , . . . , , x). Informally, this rule asserts that, for any `-tuple that encodes a single-symbol term, we do not need to generate any null.\nNow, we can define rules to carry out the decoding. For each n-ary relation symbol R ∈ Q, let ϑR denote [ R∗(v1, . . . ,vn) ∧Map(v1, x1)\n∧ · · · ∧Map(vn, xn)\n] → R(x1, . . . , xn).\nFinally, we let Σ∗ denote the rule set consisting of (1) %R for every relation symbol R ∈ D, (2) γ∗ for every rule γ ∈ Σ, (3) λR for every relation symbol R ∈ Q, (4) ζx for every existential variable x in Σ such that fx is of a positive arity, (5) ζc, and (6) ϑR for every relation symbol R ∈ Q. Example 2. By adding a copy rule into the rule ontology O defined in Example 1, we then obtain a normal rule ontology O0 = (Σ0,D0,Q0), where Σ0 is the following rule set:\nD(x, y)→ R(x, y) R(x, x)→ ∃yz S(x, y) ∧ S(y, z) R(x, y) ∧ S(x, z)→ ∃v R(z, v)\nand D0 = {D}, Q0 = {R}. Next, we will illustrate the translation by the rule ontology O0.\nAll the function symbols in sk(Σ0) are clearly unary, and as analyzed in Example 1, O0 is δ-bounded for some bound function δ with δ(||Σ0||) = 2. So, we have ` = 10+11+12 = 3, i.e., terms generated by the chase procedure of O0 will be encoded by triples of function-free terms. Now, we use the following rule to initialize the auxiliary relation symbol D∗:\nD(x, y)→ D∗(x y )\nTo simulate the chase procedure of O0, we need the following rules, which correspond to the rules in Σ0:\nD∗(x1x2x3 y1y2y3)→ R∗(x1x2x3 y1y2y3) R∗(x1x2 x1x2 )→S∗(x1x2 fyx1x2)∧S∗(fyx1x2 fzx1x2) R∗(x1x2x3 y1y2y3)∧S∗(y1y2y3 z1z2 )→R∗(z1z2 fvz1z2)\nThe following rules are used to implement the decoding: R∗(x1x2x3 y1y2y3)→ Dom∗(x1x2x3) ∧ Dom∗(y1y2y3) Dom∗(fyx1x2)→ ∃yMap(fyx1x2 y) Dom∗(fzx1x2)→ ∃zMap(fzx1x2 z) Dom∗(fvx1x2)→ ∃vMap(fvx1x2 v)\nDom∗(x )→ Map(x x) [\nR∗(x1x2x3 y1y2y3)∧ Map(x1x2x3 x) ∧Map(y1y2y3 y)\n] → R(x y)\nFinally, let Σ∗0 consist of the set of all rules defined above. It is not difficult to check that [[O0]] ≈ [[(Σ∗0,D0,Q0)]]. Capturing PTIME by the WA Class. We have proved that all the rule languages with finite chase are of the same expressiveness as the WA class in the last subsection. However, this characterization is syntactic. In this subsection, we will give a complexity-theoretic characterization. Before presenting the result, we need some definitions.\nLike in traditional Datalog (Dantsin et al. 2001), we will study the expressiveness on ordered databases. Every ordered database is a database whose domain is an integer set {0, . . . , n} for some integer n ≥ 0; whose schema contains three special relation symbols Succ, Min and Max (we call such a schema ordered); in which Succ is interpreted as the immediate successor relation on natural numbers, and Min and Max are interpreted as {0} and {n}, respectively. By ordered UWMs we mean the restrictions of UWMs to ordered databases. We generalize definitions of [[·]] and ≈ to ordered UWMs by replacing “database” with “ordered database”. Note that the ordered version of Proposition 7 still holds.\nWe fix a natural way for representing (general) databases in binary strings. Given a general databaseD, let 〈D〉 denote its binary represention. Let D and Q be any two disjoint relational schemas where D is ordered. Let Φ be an ordered UWM over (D,Q). We say that Φ is computed by a Turing machine M if M halts on any input 〈D〉 where D is an ordered D-database, and there is a general Q-database Q such that Q is homomorphically equivalent to Φ(D) and the output w.r.t. 〈D〉 is 〈Q〉, the binary representation of Q.\nOn syntax, we also need a slightly richer language defined as follows. LetD be a relational schema (as a database schema). A semipositive rule w.r.t. D is a generalized rule defined by allowing negated atoms with relation symbols from D to appear in the body. Semipositive rule ontologies are then generalized from rule ontologies by allowing semipositive rules w.r.t. its database schema. A semipositive rule ontology is called weakly acyclic if the rule ontology obtained by omitting negative atoms is weakly acyclic. Theorem 9. For every ordered UWM Φ that is computable in deterministic polynomial time, there is a weakly acyclic and semipositive rule ontology O such that [[O]] ≈ Φ.\nRemark 4. By a slight generalization of the critical database technique proposed in (Marnette 2009), one can show that every semipositive rule ontology with finite Skolem chase is computable in deterministic polynomial time. Therefore, the above theorem implies that every semipositive rule language with finite Skolem chase that extends the semipositive WA class captures the class of PTIME-computable UWMs.\nSuccinctness. Our previous results show that all the rule languages with finite chase that extend the weakly acyclic class are of the same expressiveness. Now we further consider the following question: Is it possible to compare the efficiency of rule languages with finite chase for representing ontological knowledge? In general, it is not an easy task to compare the succinctness for fragments of first-order logic. However, the following theorem provides us with such a result for rule languages, which states that the bounded rule languages with higher combined complexity are normally more succinct than those with lower combined complexity. Theorem 10. For all k > 0, there exists a k-exponentially bounded rule ontologyO=(Σ,D,Q) such that, for any (k− 1)-exponentially bounded rule ontology O0 = (Σ0,D,Q) where Σ0 is of polynomial size w.r.t. Σ, we have [[O0]] 6≈ [[O]]. Proof. (Sketch) Let n, ` and Σnum be defined as in the proof of Proposition 4. Let D = ∅ and Q = {Min`,Max`,Succ`}. By using the notion of core (see, e.g., (Deutsch, Nash, and Remmel 2008)), we show a lower bound for the number of nulls in universal models. By estimating the number of nulls to be used in the chase, we then prove that (Σnum,D,Q) is not equivalent to any (k − 1)-exponentially bounded ontology (Σ,D,Q) if Σ is of a polynomial size w.r.t. Σnum. Remark 5. Theorem 10 tells us that, although extending the WA class to larger classes with finite chase does not increase the expressiveness, the succinctness could be a bonus.\nRemark 6. It would be interesting to compare the succinctness of finite-chase rule languages with the same combined complexity under query answering. For instance, is the MFA class more succinct than the WA class? But this is beyond the scope of this work. We will pursue it in the future."
    }, {
      "heading" : "Concluding Remarks",
      "text" : "We have studied the existential rule languages with finite chase in this paper. Instead of considering specific rule languages like most current works on this topic, here we have defined a family of rule languages based on a new concept called δ-boundedness, from which the overall complexity and expressiveness characterizations on these languages have been provided. Our study on this topic may be further undertaken in various directions. One interesting yet challenging future work is to investigate disjunctive existential rule languages. It is important to discover whether our approach can be extended to identify decidable disjunctive existential rule languages and to characterize relevant complexity and expressiveness properties. Results on this aspect may significantly enhance our current understanding on ontological reasoning with disjunctive existential rules (Alviano et al. 2012; Bourhis, Morak, and Pieris 2013)."
    }, {
      "heading" : "Appendix: Detailed Proofs",
      "text" : ""
    }, {
      "heading" : "Proof of Proposition 1",
      "text" : "Proposition 1. There is a bound function δ such that, for every rule ontology O, O has finite chase iff it is δ-bounded.\nTo show this, we use a technique developed by (Marnette 2009). Let O = (Σ,D,Q) be a rule ontology. Let C denote the set of constants appearing in Σ and let ∗ be a special constant without occurrence in Σ. A database over D is called critical forO if each relation in it is a full relation on the domain C ∪ {∗}. Clearly, the critical database for O is unique. For convenience, let D∗O denote the critical database of O.\nProof of Proposition 1. Given an arbitrary bound function δ, it is clear that every δ-bounded rule ontology has finite chase. So, it suffices to show that there is a bound function δ such that every rule ontology with finite chase is δ-bounded. To do this, we first need to prove a claim as follow.\nClaim 1. Let O = (Σ,D,Q) be a rule ontology and D a D-database. Then ht(chase(D,Σ)) ≤ ht(chase(D∗O,Σ)).\nProof. Let f denote the function that maps every constant in ∆ to itself if it appears in Σ, and ∗ otherwise. Furthermore, we generalize f to terms, atoms and general instances in the standard way. By a routine induction, one can easily show that f(chasen(D,Σ)) ⊆ chasen(D∗O,Σ) for all n ≥ 0, which implies f(chase(D,Σ)) ⊆ chase(D∗O,Σ) immediately. Since ht(f(t)) = ht(t) for every term t, we can then conclude that ht(chase(D,Σ)) ≤ ht(chase(D∗O,Σ)).\nNow we are in the position to complete the proof. Let p be a function that maps each rule ontology O = (Σ,D,Q) with finite chase to ht(chase(D∗O,Σ)). It is clear that p(O) is a positive integer for any rule ontology O with finite chase. Now, for all n > 0 let δ(n) be the maximal p(O) for all rule onologies O = (Σ,D,Q) with finite chase and ||Σ|| = n. Since the number of rule sets of size n is finite, δ should be a bound function. By Claim 1, every rule ontology with finite chase is clearly δ-bounded, which is as desired."
    }, {
      "heading" : "Proof of Proposition 2",
      "text" : "Proposition 2. There is no computable bound function δ such that every bounded rule ontology is δ-bounded.\nProof. Towards a contradiction, we assume that such a computable function δ exists. Let Σ be any rule ontology. Then, by Remark 1, to check whether Σ has finite chase, it is equivalent to check whether Σ is δ-bounded. Since δ is computable, by Proposition 6 (whose proof is given shortly in this appendix), there is an algorithm to check whether Σ is δ-bounded. This means that the problem of checking whether a rule ontology has finite Skolem chase is decidable, which contradicts with Theorem 4 in (Marnette 2009), which states that it is RE-complete to decide whether a tg schema-mapping (i.e., rule ontology) has finite Skolem chase. This completes the proof."
    }, {
      "heading" : "Proof of Proposition 3",
      "text" : "Proposition 3. Let δ be a bound function. Then for any δbounded rule ontology (Σ,D,Q), any D-database D and any BCQ q over Q, it is in\nDTIME((|dom(D)|+ ||Σ||)||Σ||O(δ(||Σ||))·||q||O(1)) to check whether D ∪ Σ |= q. Proof. Let (Σ,D,Q) be a δ-bounded rule ontology, D a D-database, and q a BCQ over Q. Let k, n, `, m, and c denote the number of relation symbols appearing in Σ, the maximal arity of relation symbols appearing in Σ, the number of function symbols in sk(Σ), the maximal arity of function symbols appearing in sk(Σ), and the number of constants appearing in D, respectively. Let R(t) be any fact in chase(D,Σ). By the definition of δ-boundedness, it is clear that every component t ∈ t contains at most∑δ(||Σ||) i=0 m\ni = mO(δ(||Σ||)) symbols, and each symbol is either a constant or a function symbol. So, chase(D,Σ) consists of (c + `)m\nO(δ(||Σ||))·n · k facts. Since k, n, `,m ≤ ||Σ|| and c = |dom(D)|, the chase on D and Σ must terminate in (|dom(D)| + ||Σ||)||Σ||O(δ(||Σ||))·||Σ||O(1) steps. It is also clear that each step of the chase can be computed in DTIME((|dom(D)|+||Σ||)||Σ||O(δ(||Σ||))). Thus, chase(D,Σ) can be computed in DTIME((|dom(D)|+ ||Σ||)||Σ||O(δ(||Σ||))), too.\nTo complete the query answering, it is now sufficient to evaluate q on chase(D,Σ) directly. Without loss of generality, we assume that q is in prenex normal form. Let s be the number of existential variables occurring in q. To evaluate the chase, it is equivalent to check whether there is a substitution h, mapping every existential variable to a ground term of height less than δ(||Σ||), such that h(q) ⊆ chase(D,Σ). By the previous analysis, there are at most (|dom(D)| + ||Σ||)||Σ||O(δ(||Σ||))·s substitutions that need to be check. In addition, it is in DTIME((|dom(D)| + ||Σ||)||Σ||O(δ(||Σ||))·||q||O(1)) to check whether h(q) ⊆ chase(D,Σ). Since s ≤ ||q||, the evaluation can then be finished in DTIME((|dom(D)| + ||Σ||)||Σ||O(δ(||Σ||))·||q||O(1)). Combining it with the result in previous paragraph, we then have the desired proposition."
    }, {
      "heading" : "Proof of Theorem 5",
      "text" : "Theorem 5. For all integers k ≥ 0, the Boolean query answering problem of the k-exponentially bounded language is (k + 2)-EXPTIME-complete for the combined complexity, and PTIME-complete for the data complexity.\nProof. The combined complexity is by Propositions 3 and 4. The membership of the data complexity is by Proposition 3 (also in fact implied by Theorem 3 of (Marnette 2009)), and the hardness follows from the PTIME-completeness of data complexity for Datalog, see, e.g., (Dantsin et al. 2001)."
    }, {
      "heading" : "Proof of Proposition 6",
      "text" : "Proposition 6. Let δ be a bound function that is computable in DTIME(T (n)) for some function T (n). Then for every rule ontology O = (Σ,D,Q), it is in\nDTIME(||Σ||||Σ||O(δ(||Σ||)) + T (log ||Σ||)O(1))\nto check whether O is δ-bounded.\nProof. Let O = (Σ,D,Q) be a rule ontology. According to Claim 1, we can infer that O is δ-bounded if and only if ht(chase(D∗O,Σ)) ≤ δ(||Σ||), where D∗O is the critical database defined as previous. So, to check ifO is δ-bounded, it is equivalent to check if ht(chase(D∗O,Σ)) ≤ δ(||Σ||). By the analysis in the proof of Proposition 3, if the inequality holds, chase(D∗Σ,Σ) should be of the size ||Σ||||Σ|| O(δ(||Σ||)) . In particular, an upper bound for this size can be computed in DTIME((||Σ|| + T (log ||Σ||))O(1)). Let n denote the resulting upper bound. Now, we can design an algorithm to simulate the first n + 1 stages of the chase on D∗O and Σ. If ht(chasen+1(D∗O,Σ)) ≤ δ(||Σ||), then Σ should be δ-bounded, otherwise not. It is clear that the full computation can be implemented in DTIME(||Σ||||Σ||O(δ(||Σ||)) + T (log ||Σ||)O(1))."
    }, {
      "heading" : "Proof of Proposition 7",
      "text" : "Proposition 7. Let O1 = (Σ1,D,Q) and O2 = (Σ2,D,Q) be two rule ontologies with finite chase. Then [[O1]] ≈ [[O2]] iff, for all D-databases D and all BCQs q over Q, we have"
    }, {
      "heading" : "D ∪ Σ1 |= q iff D ∪ Σ2 |= q.",
      "text" : "Proof. The direction of “only-if” is trivial. We only show the converse. Assume thatD∪Σ1 |= q if and only ifD∪Σ2 |= q for all D-databases D and all BCQs q over Q. Let D be any D-database. For i = 1 or 2, let qi denote the BCQ obtained from chase(D,Σi) by replacing each null (i.e., a functional term) by a fresh existential variable. Note that both O1 and O2 have finite chase, so such BCQs exist. Then it is clear that D ∪ Σi |= qi. Thus, by the assumption we have that chase(D,Σ2) |= q1 and chase(D,Σ1) |= q2. From these, we can infer that chase(D,Σ1) and chase(D,Σ1) are homomorphically equivalent. This completes the proof."
    }, {
      "heading" : "Proof of Theorem 8",
      "text" : "Theorem 8. For every normal rule ontologyO = (Σ,D,Q) with finite chase, there exists a weakly acyclic normal rule ontology O∗ = (Σ∗,D,Q) such that [[O]] ≈ [[O∗]]. Proof. Let R be the schema of Σ, and let R∗ consist of R∗ for all relation symbols R ∈ R. Given a ground term t, let [t] be defined as previous (after the statement of Theorem 8). Now, we need to generalized the mapping [·] to atoms and general instances. For any atom α of the form R(t1, . . . , tn), we define [α] = R∗([t1], . . . , [tn]). Given any general instance I , let [I] denote the set of [α] for all α ∈ I . To prove the desired theorem, we need two claims.\nClaim 2. [chasen(D,Σ)]⊆chasen+1(D,Σ∗)|R∗ for n ≥ 0. Proof of Claim 2. We show this by an induction on n. It is clear for n = 0 since chase0(D,Σ) = D and any fact from [D] can be obtained from D by applying rules %R in one chase stage. Assume n > 0, and suppose as inductive hypothesis that [chasen−1(D,Σ)] ⊆ chasen(D,Σ∗)|R∗ . Let α ∈ [chasen(D,Σ)] be an atom of form [R(t1, . . . , tk)] for some R ∈ R. Then it is clear that R(t1, . . . , tk) ∈ chasen(D,Σ). By the definition of chase, there exist a rule γ ∈ Σ and a\nsubstitution h such that h(body(γ)) ⊆ chasen−1(D,Σ) and R(t1, . . . , tk) ∈ h(head(γ)). By the inductive hypothesis, we can conclude that [h(body(γ))] ⊆ chasen(D,Σ∗). Let [h] be the substitution that maps each variable x to [h(x)]. We then have that [h](body(γ∗)) ⊆ chasen(D,Σ∗). Consequently, it holds that [h](head(γ∗)) ⊆ chasen+1(D,Σ∗), or equivalently [h(head(γ))] ⊆ chasen+1(D,Σ∗). Thus, we have α ∈ chasen+1(D,Σ∗). This yields the desired claim.\nClaim 3. [chasen(D,Σ)] ⊇ chasen(D,Σ∗)|R∗ for n ≥ 0. Proof of Claim 3. Again, we show this by an induction on n. It is clearly true for n = 0 since chase0(D,Σ∗)|R∗ = ∅. Now we assume n > 0 and suppose as inductive hypothesis that [chasen−1(D,Σ)] ⊇ chasen−1(D,Σ∗)|R∗ . Let α∗ be any atom from chasen(D,Σ∗). By the definition of chase, there must exist a rule γ0 ∈ Σ∗ and an assignment h∗ such that h∗(body(γ0)) ⊆ chasen−1(D,Σ∗) and α∗ ∈ h∗(head(γ0)). So it suffices to show α∗ ∈ [chasen(D,Σ)] for each of the following cases: (1) γ0 = %R for some R ∈ D; (2) γ0 = γ∗ for some γ ∈ Σ. Let us first assume case (1), and suppose that α∗ is of form R∗(c1, ?, · · · , ck, ?) for some k-ary relation symbol R ∈ D, where ? denotes the tuple consisting of ` − 1 consecutive s. Then, it is not difficult to see that R(c1, . . . , ck) ∈ D, which implies α∗ ∈ [chasen(D,Σ)] immediately. Next, let us consider case (2). Let γ be the rule from Σ such that γ0 = γ∗. Let h be an assignment that maps each variable x to [h∗(x)]−1, where [·]−1 denotes the inverse function of [·]. (Clearly, such a function exists.) Then, by the definition of γ∗, it is clear that [α∗]−1 ∈ h(head(γ)). To show α∗ ∈ [chasen(D,Σ)], it is enough to show h(body(γ)) ⊆ chasen−1(D,Σ), which can be obtained from the definition of γ∗ and the inductive hypothesis.\nBy these two claims, we then have that [chase(D,Σ)] = chase(D,Σ∗)|R∗ . On the other hand, let g be a function that maps each variable-free `-tuple t to the first component of t if the second component of t is , and fx(t) (where x is a variable) otherwise. By rules ζx and ζc, we see that Map is the graph of g. Let h be the function that maps each term t to g([t]). It is not difficult to check that h is a homomorphism from chase(D,Σ)|Q to chase(D,Σ∗)|Q and h−1 is a homomorphism from chase(D,Σ∗)|Q to chase(D,Σ)|Q."
    }, {
      "heading" : "Proof of Theorem 9",
      "text" : "Theorem 9. For every ordered UWM Φ that is computable in deterministic polynomial time, there is a weakly acyclic and semipositive rule ontology O such that [[O]] ≈ Φ. Proof. Let Φ be a UWM for ordered database that is computed by a deterministic Turing machine M in polynomial time, where D and Q are disjoint relational schemas. Then there is an integer k ≥ 0 such that M will halt on every orderedD-database D in |dom(D)|k steps. To show the theorem, it is sufficient to construct a weakly acyclic and semipositive rule ontology O = (Σ,D,Q) such that [[O]] ≈ Φ. W.l.o.g., we assume theM has only three tape symbols: “0”, “1” and “ ” (the blank symbol), and a one-way tape in which cells are indexed by natural numbers. Both the input and output are stored on the tape started from the 0-th cell.\nLet D be any ordered D-database. Again, the first task is to define a linear order of length ≥ |dom(D)|k. Clearly, we can use the following rule to assert that the unary relation Const consists of all the constants from the domain of D:\nSucc(x, y)→ Const(x) ∧ Const(y). With it, we can then generate |dom(D)|k new elements by\nConst(x1) ∧ · · ·Const(xk)→ ∃y G(x1, . . . , xk, y) where new elements are stored in the last argument of G. To define a linear order (it can be built from the original order Succ) on these new elements, we need the following rule[\nG(xi, y,zi, u) ∧ G(xi, y0,vi, w) ∧Succ(y, y0) ∧Max(z) ∧Min(v)\n] → Succ∗(u,w)\nfor each i with 1 ≤ i ≤ k, where xi is an (i − 1)-tuple of distinct variables, and zi and vi denote the (k−i−1)-tuples z · · · z and v · · · v, respectively. Clearly, Succ∗ defines a linear order on new elements (the lexicographical order generated from Succ). For technical reasons, we will combine it with the old order. This can be done by the following rules:\nMin(x) → Min∗(x) Succ(x, y) → Succ∗(x, y)\nMax(x) ∧Min(y) ∧ G(y, . . . , y, z) → Succ∗(x, z) Max(x) ∧ G(x, . . . , x, y) → Max∗(y)\nNow, by applying the above rules, we then have a linear order of length |dom(D)|+ |dom(D)|k. To complete the construction, we still need to define some arithmetical relations. This can be done in a routine way, e.g., we can define the relation Add of addition by the following rules:\nSucc∗(x, y)→ Num(x) ∧ Num(y) Num(x) ∧Min∗(y)→ Add(x, y, x)\nAdd(x, y, z) ∧ Succ∗(y, u) ∧ Succ∗(z, v)→ Add(x, u, v) In addition, we let LE∗ define the relation “less than or equal to”. It can be defined by the following rules:\nNum(x)→ LE∗(x, x) Succ∗(x, y)→ LE∗(x, y)\nLE∗(x, y) ∧ LE∗(y, z)→ LE∗(x, z) With the linear order and arithmetical relations, we are then in the position to represent the Turing machine M . Without loss of generality, we assume D = {D0, . . .Dd} andQ = {Q0, . . .Qq} for some d, q > 0. We let DPosi(x, v) be a binary relation asserting that the truth of fact Di(x) has been stored in the v-th tape cell initially; QPosi(x, v) be a binary relation asserting that the truth of fact Qi(x) should be stored in the v-th tape cell finally; DSize(x) and QSize(y) asserting that the sizes of input string and output string are x and y, respectively. It is not difficult to see that, for a natural encoding approach of the (general) database, these relations can be defined by using some arithmetical relations.\nTo set the initial configuration, we need following rules Min∗(x)→ Head(x, x) ∧ State(x, s0)\nDi(v) ∧ DPosi(v, x) ∧Min∗(y)→ Tape(y, x, 1) ¬Di(v) ∧ DPosi(v, x) ∧Min∗(y)→ Tape(y, x, 0) DSize(z) ∧ LE∗(z, x) ∧Min∗(y)→ Tape(y, x, )\nfor each relation symbol Di ∈ D, where Tape(x, y, z) states that, in time x, the tape symbol z is written on the y-th tape cell, State(x, y) states that, in time x, the state of M is y, and Head(x, y) states that, in time x, the head of M is under the y-th tape cell. The last rule says that every tape cell after the input string are initially written as “ ”.\nThe rules that define the state transitions of M are similar to those in the proof of Theorem 7.2 in (Dantsin et al. 2001). Hence, it remains to define rules for output. For each relation symbol Qi ∈ Q, we define the following rule QPosi(v, x) ∧ Tape(y, x, 1) ∧Max∗(y)→ Qi(v)\nInformally, the function of these rules is to reconstruct the query (general) database from the output of M . Here, we assume that M do the operation “nop” repeatedly so that it will terminate at the |dom(D)|+ |dom(D)|k-th stage."
    }, {
      "heading" : "Proof of Theorem 10",
      "text" : "Theorem 10. For all k > 0, there exists a k-exponentially bounded rule ontologyO=(Σ,D,Q) such that, for any (k− 1)-exponentially bounded rule ontology O0 = (Σ0,D,Q) where Σ0 is of polynomial size w.r.t. Σ, we have [[O0]] 6≈ [[O]].\nProof. Let n, ` and Σnum be defined as in the proof of Proposition 4. Let D = ∅ and Q = {Min`,Max`,Succ`}, and let m = expk+2(n) − 1. Let Q be a general database over Q that consists of Min`(n0),Max`(nm) and Succ`(ni, ni+1) for all integers i with 0 ≤ i < m, where (ni)0≤i≤m are distinct nulls. By the analysis in the proof of Proposition 4, it is clear that [[(Σnum,D,Q)]](∅) is homomorphically equivalent to Q. (Note that ∅ is the only database over schema D.) Since the core of Q is Q, Q should be the least universal model of ∅∪Σnum. Towards a contradiction, we assume that there exists a (k − 1)-exponentially bounded rule ontology O = (Σ,D,Q) such that [[O]] = [[(Σnum,D,Q)]] and Σ is of polynomial size w.r.t. Σnum. Then [[O]] is homomorphically equivalent to Q. This implies that [[O]](∅) contains at least expk+2(n) nulls. On the other hand, as Σ is of polynomial size w.r.t. Σnum, by the analysis in the proof of Proposition 3, we infer that the size of chase(∅,Σ) is expk+1(O(n)). This means that chase(∅,Σ), or equivalently [[O]](∅), contains expk+1(O(n)) nulls, a contradiction as desired."
    } ],
    "references" : [ {
      "title" : "Disjunctive datalog with existential quantifiers: Semantics, decidability, and complexity issues",
      "author" : [ "M. Alviano", "W. Faber", "N. Leone", "M. Manna" ],
      "venue" : "Theor. Pract. Log. Prog. 12:701–718.",
      "citeRegEx" : "Alviano et al\\.,? 2012",
      "shortCiteRegEx" : "Alviano et al\\.",
      "year" : 2012
    }, {
      "title" : "Expressive languages for querying the semantic web",
      "author" : [ "M. Arenas", "G. Gottlob", "A. Pieris" ],
      "venue" : "Proc. PODS-2014, 14–26.",
      "citeRegEx" : "Arenas et al\\.,? 2014",
      "shortCiteRegEx" : "Arenas et al\\.",
      "year" : 2014
    }, {
      "title" : "On rules with existential variables: Walking the decidability line",
      "author" : [ "J. Baget", "M. Leclère", "M. Mugnier", "E. Salvat" ],
      "venue" : "Artif. Intell. 175(9-10):1620–1654.",
      "citeRegEx" : "Baget et al\\.,? 2011a",
      "shortCiteRegEx" : "Baget et al\\.",
      "year" : 2011
    }, {
      "title" : "Walking the complexity lines for generalized guarded existential rules",
      "author" : [ "J. Baget", "M. Mugnier", "S. Rudolph", "M. Thomazo" ],
      "venue" : "Proc. IJCAI-2011, 712–717.",
      "citeRegEx" : "Baget et al\\.,? 2011b",
      "shortCiteRegEx" : "Baget et al\\.",
      "year" : 2011
    }, {
      "title" : "Extending acyclicity notions for existential rules",
      "author" : [ "J. Baget", "F. Garreau", "M. Mugnier", "S. Rocher" ],
      "venue" : "Proc. ECAI-2014, 39–44.",
      "citeRegEx" : "Baget et al\\.,? 2014",
      "shortCiteRegEx" : "Baget et al\\.",
      "year" : 2014
    }, {
      "title" : "The implication problem for data dependencies",
      "author" : [ "C. Beeri", "M.Y. Vardi" ],
      "venue" : "Proc. ICALP-1981, 73–85.",
      "citeRegEx" : "Beeri and Vardi,? 1981",
      "shortCiteRegEx" : "Beeri and Vardi",
      "year" : 1981
    }, {
      "title" : "The impact of disjunction on query answering under guarded-based existential rules",
      "author" : [ "P. Bourhis", "M. Morak", "A. Pieris" ],
      "venue" : "Proc. IJCAI-2013, 796–802.",
      "citeRegEx" : "Bourhis et al\\.,? 2013",
      "shortCiteRegEx" : "Bourhis et al\\.",
      "year" : 2013
    }, {
      "title" : "Datalog+/-: A family of logical knowledge representation and query languages for new applications",
      "author" : [ "A. Calı", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris" ],
      "venue" : "In Proc. LICS-2010,",
      "citeRegEx" : "Calı̀ et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Calı̀ et al\\.",
      "year" : 2010
    }, {
      "title" : "A general datalogbased framework for tractable query answering over ontologies",
      "author" : [ "A. Calı", "G. Gottlob", "T. Lukasiewicz" ],
      "venue" : "J. Web Sem",
      "citeRegEx" : "Calı̀ et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Calı̀ et al\\.",
      "year" : 2012
    }, {
      "title" : "Query answering under non-guarded rules in Datalog+/",
      "author" : [ "A. Calı", "G. Gottlob", "A. Pieris" ],
      "venue" : "In Proc. RR-2010,",
      "citeRegEx" : "Calı̀ et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Calı̀ et al\\.",
      "year" : 2010
    }, {
      "title" : "Towards more expressive ontology languages: The query answering problem",
      "author" : [ "A. Calı", "G. Gottlob", "A. Pieris" ],
      "venue" : null,
      "citeRegEx" : "Calı̀ et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Calı̀ et al\\.",
      "year" : 2012
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov" ],
      "venue" : "ACM Comput. Surv. 33(3):374–425.",
      "citeRegEx" : "Dantsin et al\\.,? 2001",
      "shortCiteRegEx" : "Dantsin et al\\.",
      "year" : 2001
    }, {
      "title" : "The chase revisited",
      "author" : [ "A. Deutsch", "A. Nash", "J. Remmel" ],
      "venue" : "Proc. PODS-2008, 149–158.",
      "citeRegEx" : "Deutsch et al\\.,? 2008",
      "shortCiteRegEx" : "Deutsch et al\\.",
      "year" : 2008
    }, {
      "title" : "Data exchange: Semantics and query answering",
      "author" : [ "R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa" ],
      "venue" : "Theor. Comput. Sci. 336(1):89–124.",
      "citeRegEx" : "Fagin et al\\.,? 2005",
      "shortCiteRegEx" : "Fagin et al\\.",
      "year" : 2005
    }, {
      "title" : "Expressiveness of guarded existential rule languages",
      "author" : [ "G. Gottlob", "S. Rudolph", "M. Simkus" ],
      "venue" : "Proc. PODS-2014, 27–38.",
      "citeRegEx" : "Gottlob et al\\.,? 2014",
      "shortCiteRegEx" : "Gottlob et al\\.",
      "year" : 2014
    }, {
      "title" : "Acyclicity notions for existential rules and their application to query answering in ontologies",
      "author" : [ "B.C. Grau", "I. Horrocks", "M. Krötzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang" ],
      "venue" : "J. Artif. Intell. Res. 47:741–808.",
      "citeRegEx" : "Grau et al\\.,? 2013",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2013
    }, {
      "title" : "Stratification criteria and rewriting techniques for checking chase termination",
      "author" : [ "S. Greco", "F. Spezzano", "I. Trubitsyna" ],
      "venue" : "PVLDB 4(11):1158–1168.",
      "citeRegEx" : "Greco et al\\.,? 2011",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2011
    }, {
      "title" : "Extending decidable existential rules by joining acyclicity and guardedness",
      "author" : [ "M. Krötzsch", "S. Rudolph" ],
      "venue" : "Proc. IJCAI2011, 963–968.",
      "citeRegEx" : "Krötzsch and Rudolph,? 2011",
      "shortCiteRegEx" : "Krötzsch and Rudolph",
      "year" : 2011
    }, {
      "title" : "Efficiently computable datalog∃ programs",
      "author" : [ "N. Leone", "M. Manna", "G. Terracina", "P. Veltri" ],
      "venue" : "Proc. KR-2012, 13–23.",
      "citeRegEx" : "Leone et al\\.,? 2012",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2012
    }, {
      "title" : "Generalized schema-mappings: from termination to tractability",
      "author" : [ "B. Marnette" ],
      "venue" : "Proc. PODS-2009, 13–22.",
      "citeRegEx" : "Marnette,? 2009",
      "shortCiteRegEx" : "Marnette",
      "year" : 2009
    }, {
      "title" : "Existential rule languages with finite chase: Complexity and expressiveness",
      "author" : [ "H. Zhang", "Y. Zhang", "J.-H. You" ],
      "venue" : "CoRR abs/1411.5220.",
      "citeRegEx" : "Zhang et al\\.,? 2014",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : ", (Calı̀ et al. 2010; Baget et al. 2011a).",
      "startOffset" : 2,
      "endOffset" : 41
    }, {
      "referenceID" : 2,
      "context" : ", (Calı̀ et al. 2010; Baget et al. 2011a).",
      "startOffset" : 2,
      "endOffset" : 41
    }, {
      "referenceID" : 5,
      "context" : "Therefore, the problem of query answering under existential rule languages is in general undecidable (Beeri and Vardi 1981).",
      "startOffset" : 101,
      "endOffset" : 123
    }, {
      "referenceID" : 3,
      "context" : ", guarded rules (Calı̀, Gottlob, and Lukasiewicz 2012), greedy bounded treewidth sets (Baget et al. 2011b), sticky sets (Calı̀, Gottlob, and Pieris 2012), and Shy programs (Leone et al.",
      "startOffset" : 86,
      "endOffset" : 106
    }, {
      "referenceID" : 18,
      "context" : "2011b), sticky sets (Calı̀, Gottlob, and Pieris 2012), and Shy programs (Leone et al. 2012).",
      "startOffset" : 72,
      "endOffset" : 91
    }, {
      "referenceID" : 19,
      "context" : "This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Krötzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al.",
      "startOffset" : 133,
      "endOffset" : 148
    }, {
      "referenceID" : 17,
      "context" : "This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Krötzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al.",
      "startOffset" : 228,
      "endOffset" : 255
    }, {
      "referenceID" : 15,
      "context" : "This concept was then extended to a number of notions, such as stratification (Deutsch, Nash, and Remmel 2008), superweak acyclicity (Marnette 2009), local stratification (Greco, Spezzano, and Trubitsyna 2011), joint acyclicity (Krötzsch and Rudolph 2011), model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA) (Grau et al. 2013), and some dependency relations by (Baget et al.",
      "startOffset" : 328,
      "endOffset" : 346
    }, {
      "referenceID" : 4,
      "context" : "2013), and some dependency relations by (Baget et al. 2014).",
      "startOffset" : 40,
      "endOffset" : 59
    }, {
      "referenceID" : 15,
      "context" : "In addition, many ontologies in various domains turn out to be in the MFA class, as evidenced in (Grau et al. 2013).",
      "startOffset" : 97,
      "endOffset" : 115
    }, {
      "referenceID" : 10,
      "context" : "In their milestone paper, Fagin et al. (2005) formulated a concept called weak acyclicity (WA) as a sufficient condition to ensure the chase termination for existential rules.",
      "startOffset" : 26,
      "endOffset" : 46
    }, {
      "referenceID" : 19,
      "context" : "The uniformity on data complexity is in fact due to an interesting result proved in (Marnette 2009), which states that every rule language with finite Skolem chase is in PTIME for data complexity.",
      "startOffset" : 84,
      "endOffset" : 99
    }, {
      "referenceID" : 15,
      "context" : "The results presented in this paper not only generalize some of the existing works, such as the two acyclicity notions of MFA and MSA proposed in (Grau et al. 2013), more importantly, they provide a global landscape for characterizing the existential rule languages with finite Skolem chase.",
      "startOffset" : 146,
      "endOffset" : 164
    }, {
      "referenceID" : 19,
      "context" : "For more details, please refer to (Marnette 2009).",
      "startOffset" : 34,
      "endOffset" : 49
    }, {
      "referenceID" : 19,
      "context" : "This can be done by employing the so-called critical database technique, which was developed in (Marnette 2009).",
      "startOffset" : 96,
      "endOffset" : 111
    }, {
      "referenceID" : 15,
      "context" : "The MFA class (Grau et al. 2013), which was shown to extend many existing languages with an acyclicity restriction, is defined by restricting the recursive uses of existential variables in Skolem chase.",
      "startOffset" : 14,
      "endOffset" : 32
    }, {
      "referenceID" : 11,
      "context" : "If the order is defined, by an encoding similar to that in (Dantsin et al. 2001), one can construct a set of datalog rules to encode both M and x.",
      "startOffset" : 59,
      "endOffset" : 80
    }, {
      "referenceID" : 11,
      "context" : ", (Dantsin et al. 2001)), for any k-exponentially bounded class we then have the exact bound of the complexity w.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 19,
      "context" : "The above proposition can be proved by using Marnette’s critical database technique (2009) and then by an analysis similar to that in the proof of Proposition 3.",
      "startOffset" : 45,
      "endOffset" : 91
    }, {
      "referenceID" : 19,
      "context" : "Though all rule languages with finite chase are tractable for data complexity (Marnette 2009), in the last section we have shown that their combined complexity could be very high.",
      "startOffset" : 78,
      "endOffset" : 93
    }, {
      "referenceID" : 13,
      "context" : "In this subsection, we show that any bounded ontology can be rewritten to a rule ontology that is weakly acyclic (Fagin et al. 2005).",
      "startOffset" : 113,
      "endOffset" : 132
    }, {
      "referenceID" : 13,
      "context" : "This is similar to that in data exchange (Fagin et al. 2005).",
      "startOffset" : 41,
      "endOffset" : 60
    }, {
      "referenceID" : 17,
      "context" : "These rules can be constructed by an approach similar to that in (Krötzsch and Rudolph 2011).",
      "startOffset" : 65,
      "endOffset" : 92
    }, {
      "referenceID" : 11,
      "context" : "Like in traditional Datalog (Dantsin et al. 2001), we will study the expressiveness on ordered databases.",
      "startOffset" : 28,
      "endOffset" : 49
    }, {
      "referenceID" : 19,
      "context" : "By a slight generalization of the critical database technique proposed in (Marnette 2009), one can show that every semipositive rule ontology with finite Skolem chase is computable in deterministic polynomial time.",
      "startOffset" : 74,
      "endOffset" : 89
    } ],
    "year" : 2015,
    "abstractText" : "Finite chase, or alternatively chase termination, is an important condition to ensure the decidability of existential rule languages. In the past few years, a number of rule languages with finite chase have been studied. In this work, we propose a novel approach for classifying the rule languages with finite chase. Using this approach, a family of decidable rule languages, which extend the existing languages with the finite chase property, are naturally defined. We then study the complexity of these languages. Although all of them are tractable for data complexity, we show that their combined complexity can be arbitrarily high. Furthermore, we prove that all the rule languages with finite chase that extend the weakly acyclic language are of the same expressiveness as the weakly acyclic one, while rule languages with higher combined complexity are in general more succinct than those with lower combined complexity.",
    "creator" : "LaTeX with hyperref package"
  }
}