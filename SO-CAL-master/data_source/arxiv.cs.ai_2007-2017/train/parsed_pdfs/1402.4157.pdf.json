{
  "name" : "1402.4157.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Conservative collision prediction and avoidance for stochastic trajectories in continuous time and space",
    "authors" : [ "Jan-P. Calliess", "Michael Osborne", "Stephen Roberts" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Due to their practical importance, multi-agent collision avoidance and control have been extensively studied across different communities including AI, robotics and control. Considering continuous stochastic trajectories, reflecting each agent’s uncertainty about its neighbours’ time-indexed locations in an environment space, we exploit a distribution-independent bound on collision probabilities to develop a conservative collision-prediction module. It avoids\n∗The authours gratefully acknowledge funds via EPSRC EP/I011587.\nar X\niv :1\n40 2.\n41 57\nv2 [\ncs .A\nI] 1\ntemporal discretisation by stating collision-prediction as a one-dimensional optimization problem. If mean and standard deviation are computable Lipschitz functions of time, one can derive Lipschitz constants that allow us to guarantee collision prediction success with low computational effort. This is often the case, for instance, when dynamic knowledge of the involved trajectories is available (e.g. maximum velocities or even the stochastic differential equations).\nTo avoid collisions detected by the prediction module, we let an agent re-plan repeatedly until no more collisions occur with a definable probability. Here, replanning refers to modifying a control signal (influencing the basin of attraction and equilibrium point of the agent’s stochastic dynamics) so as to bound the collision probability while seeking low plan execution cost in expectation. To keep the exposition concrete, we focus our descriptions on an example scenario where the plans correspond to sequences of setpoints of a feedback controller regulating an agent’s noisy state trajectory. However, one can apply our method in the context of more general policy search problems.\nIn order to foster low social cost across the entire agent collective, we compare two different coordination mechanisms. Firstly, we consider a simple fixedpriority scheme [11], and secondly, we modify an auction-based coordination protocol [7] to work in our continuous setting. In contrast to pre-existing work in auction-style multi-agent planning (e.g. [7,16]) and multi-agent collision avoidance (e.g. [1, 2, 15]), we avoid a priori discretizations of space and time. Instead, we recast the coordination problem as one of incremental open-loop policy search. That is, as a succession of continuous optimisation or root-finding problems that can be efficiently and reliably solved by modern optimisation and root-finding techniques (e.g. [13, 23]).\nWhile our current experiments were conducted with linear stochastic differential equation (SDE) models with state-independent noise (yielding Gaussian processes), our method is also applicable to any situation where mean and covariances can be evaluated. This encompasses non-linear, non-Gaussian cases that may have state-dependent uncertainties (cf. [12]).\nThis preprint is an extended and improved version of a conference paper that appeared in Proc. of the 13th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2014) [6]."
    }, {
      "heading" : "1.1 Related Work",
      "text" : "Multi-agent trajectory planning and task allocation methods have been related to auction mechanisms by identifying locations in state space with atomic goods to be auctioned in a sequence of repeated coordination rounds (e.g. [7, 16, 26]). Unfortunately, even in finite domains the coordination is known to be intractable – for instance the sequential allocation problem is known to be NP-hard in the number of goods and agents [14, 22]. Furthermore, collision avoidance corresponds to non-convex interactions.\nThis renders the coordination problem inapplicable to standard optimization techniques that rely on convexity of the joint state space. In recent years, several works have investigated the use of mixed-integer programming techniques for\nsingle- and multi-agent model-predictive control with collision avoidance both in deterministic and stochastic settings [7, 19]. To connect the problem to preexisting mixed-integer optimization tools these works had to limit the models to dynamics governed by linear, time-discrete difference equations with stateindependent state noise. The resulting plans were finite sequences of control inputs that could be chosen freely from a convex set. The controls gained from optimization are open-loop – to obtain closed-loop policies the optimization problems have to be successively re-solved on-line in a receding horizon fashion. However, computational effort may prohibit such an approach in multi-agent systems with rapidly evolving states.\nFurthermore, prior time-discretisation comes with a natural trade-off. On the one hand, one would desire a high temporal resolution in order to limit the chance of missing a collision predictably occurring between consecutive time steps. On the other hand, communication restrictions, as well as poor scalability of mixed-integer programming techniques in the dimensionality of the input vectors, impose severe restrictions on this resolution. To address this tradeoff, [10] proposed to interpolate between the optimized time steps in order to detect collisions occurring between the discrete time-steps. Whenever a collision was detected they proposed to augment the temporal resolution by the timestep of the detected collision thereby growing the state-vectors incrementally as needed. A detected conflict, at time t, is then resolved by solving a new mixed-integer linear programme over an augmented state space, now including the state at t. This approach can result in a succession of solution attempts of optimization problems of increasing complexity, but can nonetheless prove relatively computationally efficient. Unfortunately, their method is limited to linear, deterministic state-dynamics.\nAnother thread of works relies on dividing space into polytopes [1,17], while still others [8,9,15,21] adopt a potential field. In not accommodating uncertainty and stochasticity, these approaches are forced to be overly conservative in order to prevent collisions in real systems.\nIn contrast to all these works, we will consider a different scenario. Our exposition focuses on the assumption that each agent is regulated by influencing its continuous stochastic dynamics. For instance, we might have a given feedback controller with which one can interact by providing a sequence of setpoints constituting the agent’s plan. While this restricts the choice of control action, it also simplifies computation as the feedback law is fixed. The controller can generate a continuous, state-dependent control signal based on a discrete number of control decisions, embodied by the setpoints. Moreover, it renders our method applicable in settings where the agents’ plants are controlled by standard offthe-shelf controllers (such as the omnipresent PID-controllers) rather than by more sophisticated customized ones. Instead of imposing discreteness, we make the often more realistic assumption that agents follow continuous time-state trajectories within a given continuous time interval. Unlike most work [1,21,25,27] in this field, we allow for stochastic dynamics, where each agent cannot be certain about the location of its team-members. This is crucial for many real-world multi-agent systems. The uncertainties are modelled as state-noise which can re-\nflect physical disturbances or merely model inaccuracies. While our exposition’s focus is on stochastic differential equations, our approach is generally applicable in all contexts where the first two moments of the predicted trajectories can be evaluated for all time-steps. As noted above, this paper is an extended version of work that has been published in the proceedings of AAMAS’14 [6] and an earlier stage of this work was presented at an ICML [5] workshop."
    }, {
      "heading" : "2 Predictive Probabilistic Collision Detection with",
      "text" : "Criterion Functions\nTask. Our aim is to design a collision-detection module that can decide whether a set of (predictive) stochastic trajectories is collision-free (in the sense defined below). The module we will derive is guaranteed to make this decision correctly, based on knowledge of the first and second order moments of the trajectories alone. In particular, no assumptions are made about the family of stochastic processes the trajectories belong to. As the required collision probabilities will generally have to be expressed as non-analytic integrals, we will content ourselves with a fast, conservative approach. That is, we are willing to tolerate a non-zero false-alarm-rate as long as decisions can be made rapidly and with zero false-negative rate. Of course, for certain distributions and plant shapes, one may derive closed-form solutions for the collision probability that may be less conservative and hence, lead to faster termination and shorter paths. In such cases, our derivations can serve as a template for the construction of criterion functions on the basis of the tighter probabilistic bounds.\nProblem Formalization. Formally, a collision between two objects (or agents) a, r at time t ∈ I := [t0, tf ] ⊂ R can be described by the event\nCa,r(t) = {(xa(t), xr(t))| ‖xa(t)− xr(t)‖2 ≤ Λa+Λr 2 }. Here, Λ a,Λr denote the objects’ diameters, and xa, xr : I → RD are two (possibly uncertain) trajectories in a common, D-dimensional interaction space.\nIn a stochastic setting, we desire to bound the collision probability below a threshold δ ∈ (0, 1) at any given time in I. We loosely say that the trajectories are collision-free if Pr[Ca,r(t)] < δ, ∀t ∈ I.\nApproach. For conservative collision detection between two agents’ stochastic trajectories xa, xr, we construct a criterion function γa,r : I → R (eq. as per Eq. 2 below). A conservative criterion function has the property γa,r(t) > 0 ⇒ Pr[Ca,r(t)] < δa. That is, a collision between the trajectories with probability above δ can be ruled-out if γa,r attains only positive values. If one could evaluate the function t 7→ Pr[Ca,r(t)], an ideal criterion function would be\nγa,rideal(t) := δ − Pr[C a,r(t)]. (1)\nIt is ideal in the sense that γa,rideal(t) > 0 ⇔ Pr[Ca,r(t)] < δ. However, in most cases, evaluating the criterion function in closed form will not be feasible. Therefore, we adopt a conservative approach: That is, we determine a\ncriterion function γa,r(t) such that provably, we have γa,r(t) ≤ γa,rideal(t),∀t, including the possibility of false-alarms. That is, it is possible that for some times t, γa,r(t) ≤ 0, in spite of γa,rideal(t) > 0.\nUtilising the conservative criterion functions for collision-prediction, we assume a collision occurs unless mint∈I γ\na,r(t) > 0,∀r 6= a. If the trajectories’ means and standard deviations are Lipschitz functions of time then one can often show that γa,r is Lipschitz as well. In such cases negative values of γa,r can be found or ruled out rapidly, as will be discussed in Sec. 2.1. In situations where a Lipschitz constant is unavailable or hard to determine, we can base our detection on the output of a global minimization method such as DIRECT [13]."
    }, {
      "heading" : "2.1 Finding negative function values of Lipschitz functions",
      "text" : "Let t0, tf ∈ R, t0 ≤ tf , I := [t0, tf ] ⊂ R. Assume we are given a Lipschitz continuous target function f : I → R with Lipschitz constant L ≥ 0. That is, ∀S ⊂ I ∃LS ≤ L∀x, x′ ∈ S : |f(x)− f(x′)| ≤ LS |x− x′|. Let t0 < t1 < t2 < ... < tN < tf and define GN = (t0, . . . , tN+1) to be the sample grid of size N + 2 ≥ 2 consisting of the inputs at which we choose to evaluate the target f .\nOur goal is to prove or disprove the existence of a negative function value of target f ."
    }, {
      "heading" : "2.1.1 A naive algorithm",
      "text" : "As a first, naive method, Alg. 1 leverages Lipschitz continuity to answer the question of positivity correctly after a finite number of function evaluations.\nThe algorithm evaluates the function values on a finite grid assuming a uniform constant Lipschitz number L. The grid is iteratively refined until either a negative function value is found or, the Lipschitz continuity of function γ allows us to infer that no negative function values can exist. The latter is the case whenever mint∈GN γ(t) > L∆ where GN = (t0, ..., tN+1) is the grid of function input (time) samples, ∆ = |ti+1 − ti| (i = 0, ..., N − 1) and L > 0 a Lipschitz number of the function γ : (t0, tf )→ R which is to be evaluated.\nThe claim is established by the following Lemma:\nLemma 2.1. Let γ : [t0, tf ] ⊂ R → R be a Lipschitz function with Lipschitz number L > 0. Furthermore, let GN = (t0, t1, . . . , tN+1) be an equidistant grid with ∆ = |ti+1 − ti| (i = 0, ..., N − 1).\nWe have, γ(t) > 0,∀t ∈ (t0, tf ) if ∀t ∈ GN : γ(t) > L∆.\nProof. Since L is a Lipschitz constant of γ we have |γ(t)−γ(t′)| ≤ L|t−t′|,∀t, t′ ∈ (t0, tf ). Now, let t\n∗ ∈ (t0, tf ) and ti, ti+1 ∈ GN such that t∗ ∈ [ti, ti+1]. Consistent with the premise of the implication we aim to show, we assume γ(ti), γ(ti+1) > L∆ and, without loss of generality, we assume γ(ti) ≤ γ(ti+1). Let δ := |ti − t∗|. Since ti ≤ t∗ ≤ ti+1 we have 0 ≤ ∆ − δ. Finally, 0 < L∆ < |γ(ti)| implies γ(t∗) ≥ γ(ti) − |γ(ti) − γ(t∗)| ≥ γ(ti) − L|ti − t∗| > L∆− Lδ = L(∆− δ) ≥ 0.\ninput : Domain boundaries t0, tf ∈ R, function γ : (t0, tf )→ R, Lipschitz constant L > 0. output: Flag flag indicating presence of a non-positive function value (flag = 1 indicates existence of a non-positive function value; flag =0 indicates it has been ruled out that a negative function value can exist). Variable criticalTime contains the time of a non-positive function value if such exists (criticalTime = t0 − 1, iff γ((t0, tf )) ⊂ R+).\nflag← −1; criticalTime← t0 − 1; TimeGrid← {t0, tf}; r ← −1; repeat\nr ← r + 1; ∆← tf−t02r ; N ← (tf − t0)/∆; TimeGrid← ∪Ni=0{t0 + i∆}; minVal← mint∈TimeGrid γ(t); if minVal ≤ 0 then\nflag← 1; criticalTime← arg mint∈TimeGrid γ(t); else if minVal > L ∆ then\nflag← 0;\nuntil flag = 1 OR flag = 0;\nAlgorithm 1: Naive algorithm deciding whether a Lipschitz continuous function γ has a non-positive value on a compact domain. Note, if minVal > L ∆ the function is guaranteed to map into the positive reals exclusively.\nAppart from a termination criterion, the lemma establishes that larger Lipschitz numbers will generally cause longer run-times of the algorithm as finer resolutions ∆t will be required to ensure non-negativity of the function under investigation."
    }, {
      "heading" : "2.1.2 An improved adaptive algorithm",
      "text" : "Next, we will present an improved version of the algorithm provided above. We can define two functions, ceiling uN and floor lN , such that (i) they bound the target ∀t ∈ I : lN (t) ≤ γ(t) ≤ uN (t), and (ii) the bounds get tighter for denser grids. In particular, one can show that lN , uN\nN→∞−→ f uniformly if GN converges to a dense subset of [a, b]. Define ξlN := arg minx∈I lN (x). It has been shown that ξlN = min N−1 i=1 ti+1+ti 2 − γ(ti+1)−γ(ti) 2L and lN (ξ l N ) = mini γ(ti+1)+γ(ti) 2 − L ti+1−ti 2 (see [13,23]). It is trivial to refine this to take localised Lipschitz constants into account: ξlN = mini γ(ti+1)+γ(ti) 2 − LJi ti+1−ti\n2 where LJi is a Lipschitz number valid on interval Ji = (ti, ti+1).\nThis suggests the following algorithm: We refine the grid GN to grid GN+1, by including ξlN , f(ξ l N ) as a new sample. This process is repeated until either of the following stopping conditions are met: (i) a negative function value of γ is discovered (f(ξlN ) < 0), or (ii) lN (ξ l N ) ≥ 0 (in which case we are guaranteed that no negative function values can exist). For pseudo-code refer to Alg. 2. An example run is depicted in Fig. 1. Note, without our stopping criteria, our algorithm degenerates to Shubert’s minimization method [23]. The stopping criteria are important to save computation, especially in the absence of negative function values."
    }, {
      "heading" : "2.2 Deriving collision criterion functions",
      "text" : "This subsection is dedicated to the derivation of a (Lipschitz) criterion function. In lieu to the approach of [7, 20], the idea is to define hyper-cuboids Ha, Hr sufficently large to contain a large enough proportion of each agent’s probability mass to ensure that no collision occurs (with sufficient confidence) as long as the\ninput : Domain boundaries t0, tf ∈ R, function γ : (t0, tf )→ R, Lipschitz constant L > 0. output: Flag flag indicating presence of a non-positive function value (flag = 1 indicates existence of a non-positive function value; flag =0 indicates it has been ruled out that a negative function value can exist). Variable criticalTime contains the time of a non-positive function value if such exists (criticalTime = t0 − 1, iff γ((t0, tf )) ⊂ R+).\nflag← −1; criticalTime← t0 − 1; GN ← {t0, tf}; N = 0; repeat\nξl ← minNi=1 ti+1+ti 2 − γ(ti+1)−γ(ti) 2L ; lN (ξ l N )← min N i=1 γ(ti+1)+γ(ti) 2 − L ti+1−ti 2 ; minVal← γ(ξl); if minVal ≤ 0 then\nflag← 1; criticalTime← ξl; else if lN (ξ l N ) > 0 then\nflag← 0; else\nN ← N + 1; GN ← GN ∪ {ξl}; end\nuntil flag = 1 OR flag = 0;\nAlgorithm 2: Adaptive algorithm based on Shubert’s method to prove whether a Lipschitz continuous function γ has a non-positive value on a compact domain. Note, if lN (ξ l N ) > 0 the function is guaranteed to map into the positive reals exclusively.\ncuboids do not overlap. We then define the criterion function so as to negative values whenever the hyper-cuboids do overlap.\nFor ease of notation, we omit the time index t. For instance, in this subsection, xa now denotes random variable xa(t) rather than the stochastic trajectory.\nThe next thing we will do is to derive sufficient conditions for absence of collisions, i.e. for Pr[Ca,r] < δ.\nTo this end, we make an intermediate step: For each agent q ∈ {a, r} we define an open hyper-cuboid Hq centred around mean µq = 〈xq(t)〉. As a Ddimensional hyper-cuboid, Hq is completely determined by its centre point µq and its edge lengths lq1, ..., l q D. Let O\nq denote the event that xq /∈ Hq and P q := Pr[Oq]. We derive a simple disjunctive constraint on the component distances of the means under which we can guarantee that the collision probability is not greater than the probability of at least one object being outside its hyper-cuboid. This is the case if the hypercuboids do not overlap. That is, their max-norm distance is at least Λa,r := Λ a+Λr\n2 . Before engaging in a formal discussion we need to establish a preparatory\nfact:\nLemma 2.2. Let µqj denote the jth component of object q’s mean and r q j = 1 2 l q j . Furthermore, let Fa,r := Ca,r be the event that no collision occurs and Ba,r := Ha × Hr the event that xa ∈ Ha and xr ∈ Hr. Assume the component-wise distance between the hyper-cuboids Ha, Hr is at least Λa,r, which is expressed by the following disjunctive constraint:\n∃j ∈ {1, ..., D} : ∣∣µaj − µrj∣∣ > Λa,r + raj + rrj .\nThen, we have : Ba,r ⊂ Fa,r.\nProof. Since ‖x‖∞ ≤ ‖x‖2 ,∀x we have F∞ := {(xa, xr)| ‖xa − xr‖∞ > Λa,r} ⊂ {(xa, xr)| ‖xa − xr‖2 > Λa,r} = Fa,r. It remains to be shown that Ba,r ⊂ F∞: Let (xa, xr) ∈ Ba,r = Ha × Ha. Thus, ∀j ∈ {1, ..., D}, q ∈ {a, r} :\n∣∣xqj − µqj ∣∣ ≤ rqj . For contradiction, assume (xa, xr) /∈ F∞. Then, |xai − xri | ≤ Λa,r for all i ∈ {1, ..., D}.\nHence, |µai − µri | = |µai − xai + xai − xri + xri − µri | ≤ |µai − xai | + |xai − xri | + |xri − µri | ≤ rai + Λa,r + rri ,∀i ∈ {1, ..., D} which contradicts our disjunctive constraint in the premise of the lemma. q.e.d.\nTheorem 2.3. Let µqj denote the jth component of object q’s mean and r q j = 1 2 l q j . Assume, x\na, xr are random variables with means µa = 〈xa〉, µr = 〈xr〉, respectively. The max-norm distance between hypercuboids Ha, Hr is at least Λa,r > 0 (i.e. the hypercuboids do not overlap), which is expressed by the following disjunctive constraint:\n∃j ∈ {1, ..., D} : ∣∣µaj − µrj∣∣ > Λa,r + raj + rrj .\nThen, we have :\nPr[Ca,r] ≤ P a + P r − P r P a ≤ P a + P r\nwhere P q = Pr[xq /∈ Hq], (q ∈ {a, r}).\nProof. As in Lem. 2.2, let Fa,r := Ca,r be the event that no collision occurs and let Ba,r := Ha ×Hr. We have Pr[Ca,r] ≤ 1− Pr[Ca,r] = 1− Pr[Fa,r]. By Lem. 2.2 we have Ba,r ⊂ Fa,r and thus, 1− Pr[Fa,r] ≤ 1− Pr[Ba,r] = Pr[Ba,r]. Now, Pr[Ba,r] = Pr[xa /∈ Ha ∨ xr /∈ Hr] = P a + P r − P a P r ≤ P a + P r. q.e.d.\nOne way to define a criterion function is as follows:\nγa,r(t; %(t)) := max i=1,...,D {|µai (t)− µri(t)| − Λa,r − rai (t)− rri (t)} (2)\nwhere % = (ra1 , . . . , r a D, r r 1, . . . , r r D) is the parameter vector of radii. (For notational convenience, we will often omit explicit mention of parameter % in the function argument.)\nFor more than two agents, agent a′s overall criterion function is Γa(t) := minr∈A\\{a} γ\na,r(t). Thm. 2.3 tells us that the collision probability is bounded from above by the desired threshold δ if γa,r(t) > 0, provided we chose the radii raj , r r j (j = 1, ..., D) such that P a, P r ≤ δ2 . Let q ∈ {a, r}. Probability theory provides several distribution-independent bounds relating the radii of a (possibly partly unbounded) hypercuboid to the probability of not falling into it. That is, these are bounds of the form\nP q ≤ β(rq1 , ..., r q D; Θ)\nwhere β is a continuous function that decreases monotonically with increasing radii and Θ represents additional information. In the case of Chebyshev-type bounds information about the first two moments are folded in, i.e. Θ = (µq, Cq) where Cq(t) ∈ RD×D is the variance (-covariance) matrix. We then solve for radii that fulfil the inequality δ2 ≥ β(r q 1 , ..., r q D; Θ) while simultaneously ensuring collision avoidance with the desired probability. Inspecting Eq. 2, it becomes clear that, in order to maximally diminish conservatism of the criterion function, it would be ideal to choose the radii in % such that % = argmax%γ a,r(t; %) = argmaxra1 ,...,raDrr1,...,rrD maxi=1,...,D{|µ a i − µri |− Λa,r−rai−rri} subject to the constraints δ2 ≥ β(r q 1 , ..., r q D; Θ), (q ∈ {a, r}). Solving this constrained optimisation problem can often be done in closed form. In the context where β is derived from a Chebyshev-type bound, we propose to set as many radii as large as possible (in order to decrease (β to satisfy the constraints) while setting the radii rai , r r i as small as possible without violating the constraint (where i is some dimension). That is, we define the radii as follows: Set rqj := ∞,∀j 6= i. The remaining unknown variable, r q i , then is defined as the solution to the equation δ2 = β(r q 1 , ..., r q D; Θ). The resulting criterion function, denoted by γa,ri , we obtain with this procedure of course depends on the arbitrary choice of dimension i. Therefore, we obtain a less conservative criterion function by repeating this process for each dimension i and then constructing a new criterion function as the point-wise maximum: γa,r(t) := maxi γ a,r i (t).\nA concrete example of this procedure is provided below."
    }, {
      "heading" : "2.2.1 Example constructions of distribution-independent criterion functions",
      "text" : "We can use the above derivation as a template for generating criterion functions. Consider the following concrete example. Combining union bound and the\nstandard (one-dim.) Chebyshev bound yields P q = Pr[xq /∈ Hq] ≤ ∑D j=1 Cqjj rqj r q j =: β(rq1 , . . . , r q D;C q). Setting every radius, except rqi , to infinitely large values and β equal to δ2 yields δ 2 = Cqii rqi r q i , i.e. rqi = √ 2Cqii δ . (Note, this a correction of the radius provided in the conference version of this paper.) Finally, inserting these radii ( for q = a, r) into Eq. 2 yields our first collision criterion function:\nγa,r(t) := |µai (t)− µri(t)| − Λa,r − √ 2Caii(t) δ − √ 2Crii(t)\nδ . Of course, this argument can be made for any choice of dimension i. Hence,\na less conservative, yet valid, choice is\nγa,r(t) := max i=1,...,D\n|µai (t)− µri(t)| − Λa,r − √ 2Caii(t) δ − √ 2Crii(t) δ . (3)\nNotice, this function has the desirable property of being Lipschitz continuous, provided the mean µqi : I → R and standard deviation functions σqii = √ Cqii : I → R+ are. In particular, it is easy to show L(γa,r) ≤ maxi=1,...,D L(µ a i ) + L(µ r i) + √ 2 δ ( L(σaii) + L(σ r ii) ) where, as before, L(f) denotes a Lipschitz constant of function f . For the special case of two dimensions, we can derive a less conservative alternative criterion function based on a tighter two-dimensional Chebyshevtype bound [28]:\nTheorem 2.4 (Alternative collision criterion function). Let spatial dimensionality be D = 2. Choosing\nrqi (t) := √ 1 2δa √ Cqii(t) + √ Cqii(t)C q jj(t)(C q ii(t)C q jj(t)−(C q ij(t)) 2)\nCqjj(t)\n(q ∈ {a, r}, i ∈ {1, 2}, j ∈ {1, 2} − {i}) in Eq. 2 yields a valid distributionindependend criterion function. That is, γa,r(t) > 0⇒ Pr[Ca,r(t)] < δa.\nA proof sketch and a Lipschitz constant (for non-zero uncertainty) are provided in the appendix. Note, the Lipschitz constant we have derived therein becomes infinite in the limit of vanishing variance. In that case, the presence of negative criterion values can be tested based on the sign of the minimum of the criterion function. This can be found employing a global optimiser. Future work will investigate, in how far Hoelder continuity instead of Lipschitz continuity can be leveraged to yield a similar algorithm as the one provided in Sec. 2.1.2."
    }, {
      "heading" : "2.2.2 Multi-agent case.",
      "text" : "Let a ∈ A, A′ ⊂ A such that a /∈ A′ a subset of agents. We define the event that a collides with at least one of the agents in A’ at time t as Ca,A ′ (t) :=\n{(xa(t), xr(t))|∃r ∈ A′ : ‖xa(t)− xr(t)‖2 ≤ Λ} = ⋃ r∈A′ C a,r. By union bound, Pr[Ca,A ′ (t)] ≤ ∑ r∈A′ Pr[C a,r(t)].\nTheorem 2.5 (Multi-Agent Criterion). Let γa,r be valid criterion functions defined w.r.t. collision bound δa. We define multi-agent collision criterion function Γa,A ′ (t) := minr∈A′ γ a,r(t). If Γa,A ′ (t) > 0 then the collision probability with A’ is bounded below δa|A′|. That is, Pr[Ca,A′(t)] < δa|A′|.\nProof. Let a ∈ A, A′ ⊂ A such that a /∈ A′ a subset of agents. We define the event that a collides with at least one of the agents in A’ at time t as Ca,A\n′ (t) := {(xa(t), xr(t))|∃r ∈ A′ : ‖xa(t)− xr(t)‖2 ≤ ∆} = ⋃ r∈A′ C\na,r. We have established that if ∀r ∈ A′ : γa,r(t) > 0 then Pr[Ca,r(t)] < δa,∀r ∈ A′. Now, let Γa,A ′ < δa. Hence,∀r ∈ A′ : γa,r(t) > 0. Thus, ∀r ∈ A′ :\nPr[Ca,r(t)] < δa) Therefore, ∑\nr∈A′ Pr[C a,r(t)] ≤ |A′| δa. By union bound,\nPr[Ca,A ′ (t)] ≤ ∑ r∈A′ Pr[C a,r(t)]. Consequently, we have Pr[Ca,A ′ (t)] ≤ |A′| δa. q.e.d.\nMoreover, Γa,A ′\nis Lipschitz if the constituent functions γa,r are (see Appendix B).\nOur distribution-independent collision criterion functions have the virtue that they work for all distributions – not only the omnipresent Gaussian. Unfortunately, distribution-independence is gained at the price of conservativeness ( ref. to Fig. 2). In our experiments in Sec. 4, the collision criterion function as per Thm. B.3 is utilized as an integral component of our collision avoidance mechanisms. The results suggest that the conservativeness of our detection module does not entail prohibitively high-false-alarm rates for the distributionindependent approach to be considered impractical. That said, whenever distributional knowledge can be converted into a criterion function. One could then\nuse our derivations as a template to generate refined criterion functions using Eq. 2 with adjusted radii ri,rj , reflecting the distribution at hand."
    }, {
      "heading" : "3 Collision Avoidance",
      "text" : "In this section we outline the core ideas of our proposed approach to multi-agent collision avoidance. After specifying the agent’s dynamics and formalizing the notion of a single-agent plan, we define the multi-agent planning task. Then we describe how conflicts, picked-up by our collision prediction method, can be resolved. In Sec. 3.1 we describe the two coordination approaches we consider utilizing to generate conflict-free plans.\nI) Model (example). We assume the system contains a set A of agents indexed by a ∈ {1, ..., |A |}. Each agent a’s associated plant has a probabilistic state trajectory following stochastic controlled D-dimensional state dynamics (we consider the case D = 2) in the continuous interval of (future) time I = (t0, tf ]. We desire to ask agents to adjust their policies to avoid collisions. Each policy gives rise to a stochastic belief over the trajectory resulting from executing the policy. For our method to work, all we require is that the trajectory’s mean function m : I → RD and covariance matrix function Σ : I → RD×D are evaluable for all times t ∈ I.\nA prominent class for which closed-form moments can be easily derived are linear stochastic differential equations (SDE s). For instance, we consider the SDE\ndxa(t) = K ( ξa(t)− xa(t) ) dt+B dW (4)\nwhere K,B ∈ RD×D are matrices xa : I → RD is the state trajectory and W is a vector-valued Wiener process. Here, u(xa; ξa) := K(ξa − xa) could be interpreted as the control policy of a linear feedback-controller parametrised by ξa. It regulates the state to track a desired trajectory ξa(t) = ζa0χ{0}(t) +∑Ha i=1 ζ a i χτai (t) where χτi : R→ {0, 1} denotes the indicator function of the halfopen interval τai = (t a i−1, t a i ] ⊂ [0, T a] and each ζai ∈ RD is a setpoint. If K is positive definite the agent’s state trajectory is determined by setpoint sequence pa = (tai , ζ a i ) Ha\ni=0 (aside from the random disturbances) which we will refer to as the agent’s plan. For example, plan pa := ( (t0, x a 0), (tf , x a f ) )\ncould be used to regulate agent a’s start state xa0 to a given goal state x a f between times t0 and tf . For simplicity, we assume the agents are always initialized with plans of this form before coordination commences.\nOne may interpret a setpoint as some way to alter the stochastic trajectory. Below, we will determine setpoints that modify a stochastic trajectory to reduce collision probability while maintaining low expected cost. From the vantage point of policy search, ξa is agent a’s policy parameter that has to be adjusted to avoid collisions.\nII) Task. Each agent a desires to find a sequence of setpoints (pa) such that (i) it moves from its start state xa0 to its goal state x a f along a low-cost trajectory and (ii) such that along the trajectory its plant (with diameter ∆)\ndoes not collide with any other agents’ plant in state space with at least a given probability 1− δ ∈ (0, 1).\nIII) Collision resolution. An agent seeks to avoid collisions by adding new setpoints to its plan until the collision probability of the resulting state trajectory drops below threshold δ. For choosing these new setpoints we consider two methods WAIT and FREE. In the first method the agents insert a timesetpoint pair (t, xa0) into the previous plan p\na. Since this aims to cause the agent to wait at its start location xa0 we will call the method WAIT. It is possible that multiple such insertions are necessary until collisions are avoided. Of course, if a higher-priority agent decides to traverse through xa0, this method is too rigid to resolve a conflict. In the second method the agent optimizes for the time and location of the new setpoint. Let pa↑(t,s) be the plan updated by insertion of time-setpoint pair (t, s) ∈ I × RD. We propose to choose the candidate setpoint (t, s) that minimizes a function being a weighted sum of the expected cost entailed by executing updated plan pa↑(t,s) and a hinge-loss collision penalty cacoll(p a ↑(t,s)) := λ max{0,−mint Γ\na(t)}. Here, Γa is computed based on the assumption we were to execute pa↑(t,s) and λ >> 0 determines the extent to which collisions are penalized. Since the new setpoint can be chosen freely in time and state-space we refer to the method as FREE."
    }, {
      "heading" : "3.1 Coordination",
      "text" : "We will now consider how to integrate our collision detection and avoidance methods into a coordination framework that determines who needs to avoid whom and at what stage of the coordination process. Such decisions are known to significantly impact the social cost (i.e. the sum of all agents’ individual costs) of the agent collective.\nFixed-priorities (FP). As a baseline method for coordination we consider a basic fixed-priority method (e.g. [3,11]). Here, each agent has a unique ranking (or priority) according to its index a (i.e. agent 1 has highest priority, agent |A| lowest). When all higher-ranking agents are done planning, agent a is informed of their planned trajectories which it has to avoid with a probability greater than 1 − δ. This can be done by repeatedly invoking for collision detection and resolution methods described above until no further collision with higherranking agents are found.\nLazy Auction Protocol (AUC). While the FP method is simple and fast the rigidity of the fixed ranking can lead to sub-optimal social cost and coordination success. Furthermore, its sequential nature does not take advantage of possible parallelization a distributed method could. To alleviate this we propose to revert the ranking flexibly on a case-by-case basis. In particular, the agents are allowed to compete for the right to gain passage (e.g. across a region where a collision was detected) by submitting bids in the course of an auction. The structure of the approach is outlined in Alg. 3.\nAssume an agent a detects a collision at a particular time step tcoll and\ninput : Agents a ∈ A, cost functions ca, dynamics, initial start and goal states, initial plans p1, ..., p|A| . output: collision-free plans p1, ..., p|A|.\nrepeat for a ∈ A do\n[ flag a, Ca, tcoll]← CollDetect a(a,A− {a}) if flaga = 1 then\nwinner← Auction(Ca ∪ {a}, tcoll) foreach r ∈ (Ca ∪ {a})− {winner} do\npr ← Avoidr((Ca ∪ {a})− {r}, tcoll) Broadcastr (pr)\nend\nend\nend\nuntil ∀a ∈ A : flaga = 0; Algorithm 3: Lazy auction coordination method (AUC) (written in a sequentialized form). Collisions are resolved by choosing new setpoints to enforce collision avoidance. Ca: set of agents detected to be in conflict with agent a. flaga: collision detection flag (=0, iff no collision detected). tcoll: earliest time where a collision was detected. Avoid: collision resolution method updating the plan by a single new setpoint according to WAIT or FREE.\ninvites the set of agents Ca = {r|γa,r(tcoll) ≤ 0} to join an auction to decide who needs to avoid whom. In particular, the auction determines a winner who is not required to alter his plan. The losing agents need to insert a new setpoint into their respective plans designed to avoid all other agents in Ca while keeping the plan cost function low.\nThe idea is to design the auction rules as a heuristic method to minimize the social cost of the ensuing solution. To this end, we define the bids such that their magnitude is proportional to a heuristic magnitude of the expected regret for losing and not gaining passage. That is agent a submits a bid ba = la − sa. Magnitude la is defined as a’s anticipated cost caplan(p a ↑(t,s)) for the event that the agent will not secure “the right of passage” and has to create a new setpoint (t, s) (according to (III)) tailored to avoid all other agents engaged in the current auction. On the other hand, sa := caplan(p\na) is the cost of the unchanged plan pa. If there is a tie among multiple agents the agent with the lowest index among the highest bidders wins.\nAcknowledging that swinner+ ∑\na6=winner l a is an estimated social cost (based\non current beliefs of trajectories) after the auction, we see that the winner determination rule greedily attempts to minimize social cost: bwinner ≥ br ⇔ ∀r : sr + ∑ a6=r l a ≥ swinner + ∑ a6=winner l a."
    }, {
      "heading" : "4 Simulations",
      "text" : "As a first test, we simulated three simple multi-agent scenarios, EXP1, EXP2 and EXP3. Each agent’s dynamics were an instantiation of an SDE of the form of Eq. 4. We set δ to achieve collision avoidance with certainty greater than 95%. Collision prediction was based on the improved criterion function as per Thm. B.3. During collision resolution with the FREE method each agent a assessed a candidate plan pa according to cost function caplan(p\na) = w1 c a traj(p a) + w2 c a miss(p a) + w3 c a coll(p\na). Here catraj is a heuristic to penalize expected control energy or path length; in the second summand, camiss(p\na) =∥∥∥xa(tf )− xaf∥∥∥2 penalizes expected deviation from the goal state; the third term cacoll(p\na) penalizes collisions (cf. III ). The weights are design parameters which we set to w1 = 10, w2 = 10 3 and w3 = 10 6, emphasizing avoidance of mission failure and collisions. Note, if our method was to be deployed in a receding horizon fashion, the parameters could also be adapted online using standard learning techniques such as no-regret algorithms [18,24].\nEXP1. Collision resolution was done with the WAIT method to update\nplans. Draws from the SDEs with the initial plans of the agents are depicted in Fig. 3 (left). The curves represent 20 noisy trajectories of agents 1 (red) and 2 (blue). Each curve is a draw from the stochastic differential dynamics obtained by simulating the execution of the given initial plan. The trajectories were simulated with the Euler-Maruyama method for a time interval of I = [0s, 2s]. The spread of the families of curves is due to the random disturbances each agent’s controller had to compensate for during runtime.\nAgent 1 desired to control the state from start state x10 = (5, 10) to goal x1f = (5, 5). Agent 2 desired to move from start state x 2 0 = (5, 0) via intermediate goal x2f1 = (5, 7) (at 1s) to final goal state x 2 f2\n= (0, 7). While the agents meet their goals under the initial plans, their execution would imply a high probability of colliding around state (5, 6) (cf. Fig. 3 (left), Tab. 1). Coordination with fixed priorities (1 (red) > 2 (blue)) yields conflict-free plans (Fig. 3 (centre)). However, agent 2 is forced to wait too long at its start location to be able to reach intermediate waypoint x2f,1 in time and therefore, decides to move directly to its second goal. This could spawn high social cost due to missing one of the designated goals (Tab. 1 ). By contrast, the auction method is flexible enough to reverse the ranking at the detected collision point causing agent 1 to wait instead of 2 (Fig. 3 (right)). Thereby, agent 2 is able to reach both of its goal states in time. This success is reflected by low social cost (see Tab. 1).\nEXP2. The setup was analogous to EXP1 but with three agents and different start and goal states as depicted in Fig. 4. Furthermore, collisions were avoided with the FREE method with 10 random initializations of the local optimizer. Coordination of plans with fixed priorities (1 (red) > 2 (blue) > 3 (green) ) caused 2 to avoid agent 1 by moving to the left. Consequently, 3 now had to temporarily leave its start and goal state to get out of the way (see Fig. 4 (centre) ). With two agents moving to avoid collisions social cost was relatively\nhigh (see Tab. 1). During coordination with the auction-based method agent 2 first chose to avoid agent 1 (as in the FP method). However, losing the auction to agent 3 at a later stage of coordination, agent 2 decided to finally circumvent 1 by arcing to the right instead of to the left. This allowed 3 to stay in place (see Tab. 1).\nEXP3. Next, we conducted a sequence of experiments for varying numbers of agents ranging from |A| = 1, .., 7. In each experiment all agents’ start locations were placed on a circle. Their respective goals were placed on the opposite ends of the circle. The eigenvalues of the feedback gain matrices of each agent were drawn at random from a uniform distribution on the range [2,7]. An example situation for an experiment with 5 agents is depicted in Fig. 5. Collision avoidance was achieved.\nNote, that despite this setting being close to worst case (i.e. almost all agents try to traverse a common, narrow corridor) the coordination overhead is moderate (see Fig. 6, right). Also, all collisions were successfully avoided (see Fig. 6, left)."
    }, {
      "heading" : "5 Conclusions",
      "text" : "This work considered multi-agent planning under stochastic uncertainty and non-convex chance-constraints for collision avoidance. In contrast to pre-existing work, we did not need to rely on prior space or time-discretisation. This was achieved by deriving criterion functions with the property that the collision probability is guaranteed to be below a freely definable threshold δ ∈ (0, 1) if the criterion function attains no negative values. Thereby, stochastic collision detection is reduced to deciding whether such negative values exist. For Lipschitz criterion functions, we provided an algorithm for making this decision rapidly. We described a general procedure for deriving criterion functions and presented two such functions based on Chebyshev-type bounds. The advantage of using Chebyshev inequalities is their independence of the underlying distribution. Therefore, our approach is applicable to any stochastic state noise model for which the first two moments can be computed at arbitrary time steps. In particular, this would apply to models with state-dependent uncertainty and non-convex chance constraints which, to the best to our knowledge, have not been successfully approached in the multi-agent control literature. Nonetheless, future work could build on our results and derive less conservative criterion functions by using more problem-specific probabilistic inequalities. For instance, in simple cases such as additive Gaussian noise, tighter bounds can be given [4] and used in Eq. 2.\nTo enforce collision avoidance, our method modified the agent’s plans until no collisions could be detected. To coordinate the detection and avoidance efforts of the agents, we employed an auction-based as well as a fixed-priority method.\nOur experiments are a first indication that our approach can succeed in\nfinding collision-free plans with high-certainty with the number of required coordination rounds scaling mildly in the number of agents. While in its present form, the coordination mechanism does not come with a termination guarantee, in none of our simulations have we encountered an infinite loop. For graph routing, [7] provides a termination guarantee of the lazy auction approach under mild assumptions. Current work considers if their analysis can be extended to our continuous setting. Moreover, if required, our approach can be combined with a simple stopping criterion that terminates the coordination attempt when a computational budget is expended or an infinite loop is detected.\nThe computation time within each coordination round depends heavily on the time required for finding a new setpoint and for collision detection. This involves minimizing (t, s) 7→ caplan(pa↑(t,s)) and c a coll, respectively. The worstcase complexity depends on the choice of cost functions, their domains and the chosen optimizer. Fortunately, we can draw on a plethora of highly advanced global optimisation methods (eg [13, 23]) guaranteeing rapid optimization success. In terms of execution time, we can expect considerable alleviations from implementation in a compiled language. Furthermore, the collision detection and avoidance methods are based on global optimization and thus, would be highly amenable to parallel processing – this could especially benefit the auction approach.\nWhile our exposition was focussed on the task of defining setpoints of feedbackcontrolled agents, the developed methods can be readily applied to other policy search settings, where the first two moments of the probabilistic beliefs over the trajectories (that would result from applying the found policies) can be computed."
    }, {
      "heading" : "A Derivations of the covariance and mean of the",
      "text" : "feedback-controlled agents as deployed in the trajectory planning experiments\nWe will now solve the mean and covariance for the dynamics given by the ItoSDE describing the dynamics of the feedback controlled agents considered in the experiments of this paper. Our aim is to obtain closed-form solutions avoiding the need to approximate any integrals. This ameliorates the computational burden of our method since mean and covariance matrix functions need to be evaluated frequently in the course of collision detection and resolution.\nTheorem A.1. For all t ∈ [t0, T ] let ξ(t), x(t) ∈ RD, A = diag(a1, ..., aD),K = diag(k1, ..., kD), B = diag( √ ν1, ..., √ νD) and let x(t0) be a normally distributed random vector. The solution to the SDE dx = (Ax−K(x− ξ))dt + B dW is a Gaussian process with vector-valued mean function µ : [t0, T ]→ RD and matrixvalued covariance function C : [t0, T ]\n2 → RD×D. Here the mean components are\nµj(t) = e (kj−aj)(t0−t) 〈xj(t0)〉+ ∫ t t0 kj e (kj−aj)(t̃−t)ξj(t̃)dt̃\nand the covariance matrix function is C(s, t) = diag(cov11(s, t), ..., covDD(s, t)) where\ncovjj(s, t) = e (aj−kj)(t+s−2t0)(〈x2j (t0)〉 − 〈xj(t0)〉2)\n+ νj\n2(kj − aj) [e(aj−kj)|t−s| − e(kj−aj)(2t0−(s+t))].\nProof. Let qj := kj − aj . Owing to the diagonal form of A,K and B and the independence of the output dimensions of the vector-valued Wiener process, the given SDE decomposes into a system of D indpendent 1-dimensional SDEs dxj = (−qjxj+kjξj)dt+ √ νjdWj (j = 1, ..., D) which can be treated separately.\nFor ease of notation we omit the subscripts yielding an SDE of the form: dx = (−qx + kξ)dt + √ ν dW . To solve each of these SDEs we introduce the substitution y := xeqt. With Ito’s product rule we find\ndy = x deqt + eqt dx+ dx deqt\n= ξkeqt dt+ √ νeqtdW\nwhere the last equality follows from substitution of the SDE for dx and utilization the formal rules dt dW = 0, (dt)2 = 0.\nThis SDE is solved by y(t) = y(t0) + ∫ t t0 kξ(t̃)eqt̃dt̃+ ∫ t t0 eqt̃ √ νdW (t̃) where\nthe last integral is to be interpreted as an Ito integral. Re-substitution yields\nx(t) = x(t0)e q(t0−t) + ∫ t t0 k eq(t̃−t)ξ(t̃)dt̃+ ∫ t t0 eq(t̃−t) √ νdW (t̃).\nRandom variables x(t) (t ∈ [t0, T ]) are given as affine transformations of a Wiener process. Since the Wiener process is Gaussian, the solution is clearly a Gaussian process as long as x(t0) is a normally distributed random variable.\nFor notational convenience we define\nJt := ∫ t t0 k eq(t̃−t)ξ(t̃) dt̃,\nΩt := ∫ t t0 eq(t̃−t) √ ν dW (t̃)\nand ct := x(t0)e q(t0−t).\nTherefore, we can write\nx(t) = ct + Jt + Ωt.\nIt remains to find the first and second moments. Owing to the linearity of the expectation and, since the expectation of the Ito integral of a non-anticipating integrand is zero, the mean function is:\nµ(t) = 〈x(t)〉 = 〈ct〉+ 〈Jt〉+ 〈Ωt〉 = 〈x(t0)〉ek(t0−t) + Jt.\nNow, we calculate the second moment:\ncov(s, t) = 〈x(s)x(t)〉 − µ(s)µ(t)\nwhere\n〈x(s)x(t)〉 = 〈(cs + Js + Ωs)(ct + Jt + Ωt)〉 = 〈csct〉+ 〈csJt〉+ 〈csΩt〉+ ...+ 〈ΩsΩt〉.\nOnce again leveraging that the expectation of an Ito integral with non-anticipating integrand is zero, the cross-terms 〈cqΩr〉, 〈JqΩr〉 (q, r ∈ {s, t}) vanish. Hence, we obtain\n〈x(s)x(t)〉 = 〈csct〉+ 〈csJt〉+ 〈ctJs〉+ JtJs + 〈ΩsΩt〉 = 〈csct〉+ Jt〈cs〉+ Js〈ct〉+ JtJs + 〈ΩsΩt〉 = µ(s)µ(t) + 〈csct〉 − 〈cs〉〈ct〉+ 〈ΩsΩt〉.\nHence,\ncov(s, t) = 〈csct〉 − 〈cs〉〈ct〉+ 〈ΩsΩt〉 = e−q(t+s−2t0)(〈x2(t0)〉 − 〈x(t0)〉2) + 〈ΩsΩt〉\nIt is well-known that for non-anticipating f, g interval I we have 〈 ∫ I f(t)dW (t) ∫ I g(t)dW (t)〉 = ∫ I f(t)g(t)dt.\nApplying this fact as well as leveraging the independent increments property of the Wiener process yields:\n〈ΩsΩt〉 = ν\neq(s+t) ∫ min{t,s} t0 e2qt̃dt̃\n= ν\n2qeq(s+t) [e2kmin{t,s} − e2qt0 ]\n= ν\n2q [eq(2 min{t,s}−(s+t) − eq(2t0−(s+t))]\n= ν\n2q [e−q|t−s| − eq(2t0−(s+t))]\nNotice, that when altering the plan and hence, ξ, the integral\nJt,j := ∫ t t0 kj e (kj−aj)(t̃−t)ξj(t̃)dt̃\nhas to be computed. For general forms of allowable ξ we would have to rely on numerical approximation methods. Since repeated calculations of solutions need to be done in the course of coordination we will want to alleviate the computational burden thereof as much as possible. This motivated our restriction to plans that give rise to step functions for which we can show that Jt is closed-form.\nLemma A.2. Let t ≥ t0, t, t0 ∈ [0, T a]. Given plan pa = ( (tai , ζ a i ) )Ha i=0 where each ζai = (ζ a i,j) D j=1. Let i = arg maxi{ti ≤ t0}, i = arg mini{ti ≥ t} and I := {i ∈ {1, ...,Ha}|i < i ≤ i}. Furthermore, let ξaj denote the jth component of step-function setpoint signal ξa. We have∫ t\nt0\nkj e qj(t̃−t)ξaj (t̃)dt̃\n= ∑ i∈I kj qj ζai,j(e qj(min{ti,t}−t) − eqj(max{ti−1,t0}−t)).\nProof. Remember, τai = (t a i−1, t a i ] ⊂ [0, T a]. We have∫ t\nt0\nkj exp(qj(t̃− t))ξaj (t̃)dt̃\n= ∫ t t0 kj exp(qj(t̃− t)) Ha∑ i=1 ζai,jχτai (t̃)dt̃\n= ∑ i∈I ∫ min{t,ti} max{t0,ti−1} kj exp(qj(t̃− t))ζai,jdt̃\nCalculation of the anti-derivate and substitution of the integration bounds yields the desired result.\nWe immediately get the following corollary\nCorollary A.3. Let a ∈ A be an agent with controlled plant dynamics\ndxa = (Axa −K(xa − ξa))dt+B dW\nwhere for all t ∈ [t0, T ]: ξa(t), xa(t) ∈ RD, A = diag(a1, ..., aD), K = diag(k1, ..., kD), B = diag( √ ν1, ..., √ νD). Let x a(t0) be a normally\ndistributed random vector. Assume a’s plan is pa = ( (tai , ζ a i ) )Ha 0=1 where each ζai = (ζ a i,j) D j=1. Let t ≥ t0, i = arg maxi{ti ≤ t0}, i = arg mini{ti ≥ t} and I := {i ∈ {1, ...,Ha}|i < i ≤ i}. Furthermore, let ξaj denote the jth component of step-function reference signal ξa.\nThe solution to agent a’s SDE is a Gaussian process with vector-valued mean function µ : [t0, T ] → RD and matrix-valued covariance function C : [t0, T ]2 → RD×D. Here the mean components are\nµj(t) = e kj(t0−t) 〈xj(t0)〉 + ∑ i∈I kj kj − aj ζai,j(e (kj−aj)(min{ti,t}−t) − e(kj−aj)(max{ti−1,t0}−t))\nand the covariance matrix function is C(s, t) = diag(cov11(s, t), ..., covDD(s, t)) where\ncovjj(s, t) = e (aj−kj)(t+s−2t0)(〈x2j (t0)〉 − 〈xj(t0)〉2)\n+ νj\n2(kj − aj) [e(aj−kj)|t−s| − e(kj−aj)(2t0−(s+t))]."
    }, {
      "heading" : "B Deriving Lipschitz numbers",
      "text" : "So far, we have established how knowledge of the Lipschitz number of a Lipschitz function can be utilized to exclude the presence of any negative function values on a compact domain based on a finite number of function evaluations. To employ this insight in the context of collision detection we will have to know a Lipschitz number L of the criterion functions γa,r.\nWe may consider two cases:\n• We have a belief quantified as a distribution over the smallest Lipschitz constant L′. Let the cumulative distribution function of this belief be denoted by F : R → [0, 1]. That is, F (x) = Pr[L′ < x]. If we desire a guaranteed success of collision detection of at least δ ∈ (0, 1) we invoke Alg.1 with a Lipschitz number L ≥ min{x ∈ R|F (x) ≥ δ} to detect nonpositive values of γa,r.\n• If we do not have such a belief function or desire complete certainty in collision detection success it may be possible to derive a Lipschitz number for the γa,r based on the mean and covariance functions of the agent’s stochastic trajectories. In turn, these may be derived from the agents’ SDEs. How this can be accomplished is the subject of the remainder of this section.\nB.1 Lipschitz arithmetic\nIn preparation of the derivations of Lipschitz numbers, we need to establish a few basic properties of Lipschitz continuous functions. As a convention, Lφ will always denote the Lipschitz constant of a Lipschitz continuous function φ.\nLemma B.1 (Lipschitz arithmetic). Let, I, J ⊂ R+. Let f : R→ R be Lipschitz on I with Lipschitz number LI(f) and g : R→ R be Lipschitz on J with Lipschitz number LJ(g). We have:\n1. Mapping t 7→ |f(t)| is Lipschitz on I with constant LI(f).\n2. If g is Lipschitz on all of J = f(I) the concatenation g ◦ f : t 7→ g(f(t)) is Lipschitz on I with Lipschitz constant LI(g ◦ f) ≤ LJ(g)LI(f).\n3. Let r ∈ R. r f : x 7→ r f(x) is Lipschitz on I having a Lipschitz constant LI(r f) = |r|LI(f).\n4. f + g : t 7→ f(t) + g(t) has Lipschitz number at most LI(f) + LJ(g).\n5. Let mf = supt∈I f(t) and mg = supt∈I g(t). Product function f · g : x 7→ f(x) g(x) has a Lipschitz number on I which is at most (mf LJ(g) + mg LI(f)).\n6. Let h(t) = max{f(t), g(t)},∀t ∈ I∩J . We have LI∩J(h) = max{LI(f), LJ(g)}.\n7. Let b := inft∈I |f(t)| > 0 and let φ(t) = 1f(t) ,∀t ∈ I. Then LI(φ) ≤ b−2 LI(f) on I.\n8. f cont. differentiable on I ⇒ LI(f) = supt∈I |ḟ(t)|.\n9. Let c ∈ R, f(t) = c,∀t ∈ I. Then LI(f) = 0.\n10. LI(f 2) ≤ 2 s(f)LI(f).\n11. f cont. differentiable ⇒ ∀q ∈ Q : LI(fq) = |q| supτ∈I |fq−1(τ) ḟ(τ)|.\nProof. 1) We show |f | has the same Lipschitz number as f . Let t, t′ ∈ I arbitrary. We enter a case differentiation:\n1st case: f(t), f(t′) ≥ 0. Hence, ∣∣|f(t)| − |f(t′)|∣∣ = ∣∣f(t)− f(t′)∣∣ f Lipschitz≤ LI(f)|t− t′|.\n2nd case: f(t) ≥ 0, f(t′) ≤ 0. Note, |y| = −y, iff y ≤ 0. Hence, ∣∣|f(t)| − |f(t′)|∣∣ ≤ ∣∣|f(t)| + |f(t′)|∣∣ = ∣∣|f(t)| − f(t′)∣∣ = ∣∣f(t)− f(t′)∣∣ ≤ LI(f) |t− t′|. 3rd case: f(t) ≤ 0, f(t′) ≥ 0. Completely analogous to 2nd case.\n4th case: f(t), f(t′) ≤ 0.∣∣|f(t)| − |f(t′)|∣∣ = ∣∣f(t′)− f(t)∣∣ = ∣∣f(t)− f(t′)∣∣ f Lipschitz≤ LI(f)|t− t′|. 2) For arbitrary t, t′ ∈ I we have:∣∣g(f(t)) − g(f(t′))|∣∣ ≤ LJ(g) |f(t) − f(t′)| ≤ LJ(g)LI(f) |t − t′| where the\ntwo inequalities are due to the Lipschitz properties of g and f , respectively.\n3) For arbitrary t, t′ ∈ I, r ∈ R we have:∣∣r f(t)− r f(t′)|∣∣ = |r| |f(t)− f(t′)| ≤ |r|LI(f) |t− t′|. 4) For arbitrary t, t′ ∈ I, r ∈ R we have:∣∣g(t) + f(t)− (g(t′) + f(t′))|∣∣ = ∣∣g(t)− g(t′) + f(t)− f(t′)|∣∣ ≤ ∣∣g(t)− g(t′)∣∣+∣∣f(t)− f(t′)|∣∣ ≤ (LJ(g) + LI(f)) |t− t′|. 5) Let t, t′ ∈ I, d := f(t)− f(t′).∣∣g(t)f(t)− g(t′)f(t′)∣∣ = ∣∣g(t)(f(t′) + d)− g(t′)f(t′)∣∣ = ∣∣(g(t)− g(t′))f(t′) +\ng(t)d ∣∣ ≤ ∣∣g(t)−g(t′)∣∣|f(t′)|+∣∣g(t)∣∣ |d| ≤ LI(g)|t−t′||f(t′)|+∣∣g(t)∣∣LI(f)|t−t′| ≤\nLI(g)|t−t′| supt′∈I{|f(t′)|}+supt∈I{ ∣∣g(t)∣∣}LI(f)|t−t′|= (LI(g) supt′∈I{|f(t′)|}+\nsupt∈I{ ∣∣g(t)∣∣}LI(f))|t− t′|.\n6) Proof in ”‘ Nick Weaver, Lipschitz algebras”’. 7) Let t, t′ ∈ I. ∣∣ 1 f(t)− 1 f(t′) ∣∣= ∣∣ f(t′)f(t′)f(t)− f(t)f(t′)f(t) ∣∣= ∣∣f(t′)−f(t)∣∣∣∣f(t′)∣∣∣∣f(t)∣∣ ≤ LI(f)|t−t′|inft∈I |f(t)| . 8) Define ` := supt∈I |ḟ(t)| = LI(f). In two steps, we show that ` is the smallest Lipschitz constant. Firstly, we show that it is a Lipschitz constant: Let t, t′ ∈ I, t < t′. Due to the mean value theorem ∃ξ ∈ [t, t′] ⊂ I : |f(t)−f(t ′)|\n|t−t′| = |ḟ(ξ)| ≤ `. Secondly, we show that ` is the smallest Lipschitz constant: Let ¯̀ be another Lipschitz constant such that ¯̀≤ `. Since I is compact and ḟ is continuous there is some ξ ∈ I such that ḟ(ξ) = `. Pick any sequence (tk) ∞ k=1 such that tk\nk→∞−→ ξ. ∀k : tk ∈ I and ¯̀ is a Lipschitz constant on I. Hence, ¯̀≥ |f(tk)−f(ξ)||tk−ξ|\nk→∞−→ |ḟ(ξ)| = `. Thus, ¯̀= `.\n9) Immediate consequence of 8).\n10) L(f2) = L(f f) ≤ s(f)L(f) +L(f)s(f) where the last inequality follows from property 5).\n11) L(fq) 8) = supτ∈I | dd tf q(τ)| = |q| supτ∈I |fq−1(τ) ḟ(τ)|.\nNotice, that several of the inequalities in the Lemma are not tight (Eg. Ineq. (5), (10) ). Therefore, it may sometimes be better not to apply it if instead one is able to determine the Lipschitz constant directly to yield a lower Lipschitz number.\nLemma B.2. For 0 < a < b let J ⊂ R+ be the domain interval of square root function √ · : J → R+, t 7→ √ t such that inf J = a and sup J = b. We have LJ( √ ·) ≤ 1\n2 √ a\nwhere LJ( √ ·) denotes the Lipschitz constant of the square root\nfunction on J .\nProof. Applying Lem. B.1 and leveraging differentiability of the square root function reduces the problem of determining a Lipschitz constant to finding supt∈J | d √ · dt (t)| = supt∈J | 1 2 √ t |. Since d 2 dt2 √ · = − 1 4 √ ·3 attains only negative values on J ⊂ R+ we know that the first derivative d √ · dt = 1 2 √ · is strictly monotonously decreasing. Thus, supt∈J | d √ · dt (t)| = d √ · dt (inf J) = 1 2 √ inf J =\n1 2 √ a .\nB.2 An alternative collision-criterion function and the derivation of its Lipschitz number\nTheorem B.3 (Alternative collision criterion function). Let spatial dimensionality D = 2. Let δa ∈ (0, 1) denote the maximum upper bound on instantaneous collision probability at time t agent a ∈ A is allowed to tolerate. Let µa(t) ∈ RD be the mean of trajectory xa and Caij(t) be the spatial between dimensions i and j at time t. For i ∈ {1, 2}, j ∈ {1, 2} − {i} let\nrai (t) := √ 1 2δa √ Caii(t) + √ Caii(t)C a jj(t)(C a ii(t)C a jj(t)−(Caij(t))2)\nCajj(t) .\nLet a, r be two agents’ plants whose radii sum to Λa,r with state trajectories xa, xr, respectively. Define\nba,rj (t, t ′) := raj (t) + r r j(t ′) + Λa,r.\nThe function\nγa,r(t) := max j∈{1,...,D} {|µaj (t)− µrj(t)| − b a,r j (t, t)}\nis a valid criterion function. That is, γa,r(t) > 0⇒ Pr[Ca,r(t)] < δa.\nProof. (Sketch) Let t ∈ I be an arbitrary but fixed time. It is straight-forward to adapt the proof of Thm. 2 in [20] to our case showing that Pr[Ca,r(t)] < δa if |µaj (t) − µrj(t, t′)| − bj(t, t′) > 0 for at least one j ∈ {1, . . . , D}. Hence, {t ∈ I|γa,r(t, t) > 0} ⊂ {t ∈ I|Pr[Ca,r(t)] < δa}.\nDefinition B.4. For future reference we define s : f 7→ supt∈I |f(t)| and ι : f 7→ inft∈I |f(t)| on the space of continuous functions on interval I.\nTheorem B.5. Let D = 2 be the dimensionality of state space. For any agent a let µaj : I = [t0, tf ] → R denote the jth component of a’s mean function and Caij(t) the covariance of agent a’s trajectory between dimension j and i at time t.\nFor q ∈ {a, r} and all i, j ∈ {1, . . . , D} assume the µqj , C q ij are Lipschitz on\nI with Lipschitz numbers L(µqj ) and Lipschitz numbers L(C q ij), respectively.\nLet γa,r denote the collision criterion function between agents a and r as defined in Thm. B.3.\nThen γa,r is Lipschitz on I with Lipschitz constant\nL(γa,r) ≤ max j∈{1,...,D} {L(µaj − µrj) + L(b a,r j )}\n≤ max j∈{1,...,D} {L(µaj ) + L(µrj) + L(b a,r j )}\nwhere γa,r, ba,r, αa,r are defined as in Def. B.3 and ∀i ∈ {1, 2}, j ∈ {1, 2} − {i} ∀q ∈ {a, r} we have:\n1. L(ba,rj ) ≤ 12 ( L(αaj ) + L(α r j) ) ,\n2. L(αqi ) ≤ √ 1 2δq 1 ι(gi) L(gi)\nwhere gi(t) := C q ii(t) + √ (Cqii) 2 − Cqii ( Cqij )2 Cqjj and\nwhere (i)L(gi) ≤ L(Cqii)+QL ( (Cqii) 2 ) +Qs( ( Cqij )2 )L ( Cqii Cqjj ) +QL( ( Cqij )2 )s ( Cqii Cqjj ) , and\n(ii)L(gi) ≤ L(Cqii)+QL ( (Cqii) 2 ) +Qs(Cqii)L (( Cqij )2 Cqjj ) +QL ( Cqii ) s (( Cqij )2 Cqjj ) .\nHere, Q = inft∈I ( (Cqii(t)) 2 − Cqii(t) ( Cqij(t) )2 Cqjj(t) ) = inft∈I(gi − Cqii)2(t).\n3. also, L(αqj ) ≤ 12√aL ( Cqjj Cqii ) s(αqi )+s (√ Cqjj Cqii ) L(αq1), where a = inft∈I Cqjj(t) Cqjj(t) ,\n4. L ( Cqii Cqjj ) ≤ L(Cqjj)ι(C q jj) −2s(Cqii)+s( 1 Cqjj\n)L(Cqii) if ι(Cjj) = inft∈I |Cjj(t)| > 0,\n5. and similarly, L ( (Cqij) 2\nCqjj\n) ≤ L(Cqjj)ι(C q jj) −2s((Cqij)\n2) + s( 1 Cqjj )L((Cqij) 2) if\nι(Cqjj) = inft∈I |C q jj(t)| > 0.\n6. ∀i, j ∈ {1, 2} : L ( (Cqij) 2 ) ≤ 2 s(Cqij)L ( Cqij ) .\nProof. The equalities follow from successively applying Lem. B.1 to the definitions of the parts of the criterion function given in Thm. B.3. In our derivations we will note which of the properties of the Lemma we utilized as a superscript above the inequality sign. We have\nL(γa,r) def. = L(maxj∈{1,...,D}{|µaj − µrj | − b a,r j }) (6) = maxj∈{1,...,D} L(|µaj − µrj | − b a,r j ) ≤ maxj∈{1,...,D} L(|µaj − µrj |) + L(b a,r j ) (1,3,4)\n≤ maxj∈{1,...,D} L(µaj ) + L(µrj) + L(b a,r j ).\nProof of Ineq. 1): By definition, L(ba,rj ) = L( 1 2 (α a j (t) + α r j(t ′)) + ∆a,r)\n(3,4)\n≤ 12 (L((α a j ) + L(α r j)) + L(∆ a,r) (9) = 12 (L((α a j ) + L(α r j)).\nFurthermore, to prove the remaining inequalities, assume q ∈ {a, r}.\nProof of Ineq. 2): Let g(t) := Cqii(t)+ √ (Cqii) 2 − Cqii ( Cqij )2 Cqjj . Then, L(αq1) (3) =√\n2 δa L(\n√ g) ≤ √ 2 δq 1 2ι(g)L(g)\nwhere the last inequality follows from Lem. B.2 and Lem. B.1.(2) as before.\nFurthermore, L(g) (4) ≤ L(Cqii) + L( √ (Cqii) 2 − Cqii ( Cqij )2 Cqjj )\n= L(Cqii) + L (√ (Cqii) 2 − Cqii ( Cqij )2 Cqjj ) = L(Cqii) + QL ( (Cqii) 2 − Cqii ( Cqij )2 Cqjj ) where according to Lem. B.2, Q =\nι (\n(Cqii) 2−Cqii\n( Cqij )2 Cqjj ) . Hence, L(g) ≤ L(Cqii) +QL ( (Cqii) 2 ) +QL ( Cqii ( Cqij )2 Cqjj ) .\nProof of Ineq. 3): We have L(αqj (t)) def = L( √ Cqjj Cqii αqi )\n(5) ≤ s( √\nCqjj Cqii )L(αqi ) + L( √ Cqjj Cqii )s(αqi )\n(2) ≤ s( √\nCq22 Cqii )L(αqi ) + LJ( √ ·)L(C q jj Cqii )s(αqi ) where J = Cqjj Cqii (I). Inequality 2) now\nfollows from applying Lem. B.2.\nFrom here we can make two alternative derivations: i) L(g) ≤ L(Cq11)+QL ( (Cq11) 2 ) +Qs( ( Cq12 )2 )L ( Cq11 Cq22 ) +QL( ( Cq12 )2 )s ( Cq11 Cq22 ) . Alternatively, one can obtain:\nii) L(g) ≤ L(Cq11)+QL ( (Cq11) 2 ) +Qs(Cq11)L (( Cq12 )2 Cq22 ) +QL ( Cq11 ) s (( Cq12 )2 Cq22 ) .\nProof of Ineq. 4): L ( Cqii Cqjj ) = L ( Cqii 1 Cqjj ) (5) ≤ L ( 1 Cqjj ) s ( Cqii ) +L ( Cqii ) s ( 1 Cqjj )\n(7) ≤ b−2 L ( Cqjj ) s ( Cqii ) + L ( Cqii ) s (\n1 Cqjj\n) where b ∈ R+ chosen such that\nCqjj(I) ∩ [−b, b] = ∅ (we assume such a b exists). A valid choice certainly is b := inft∈I |Cqjj(t)|.\nProof of Ineq. 5): Completely, analogous to proof of 4).\nProof of Ineq. 6): Consequence of Lem. B.1.(10).\nThe theorem provides a recipe to find a Lipschitz bound for the collision criterion function given known Lipschitz numbers of the trajectories’ means and spatial covariance mappings.\nHowever, since most equalities are not tight one should attempt to determine Lipschitz numbers directly wherever possible rather than using the inequalities provided in Lem. B.1. For instance, if one can determine the best Lipschitz number for L ( (Cqij) 2 )\ndirectly (e.g. by utilizing Lem B.1.11) this would normally yield a better Lipschitz constant than obtained by expanding into 2 s(Cqij)L ( Cqij )\ndue to application of Lem. B.1.6. Examining the terms in the inequalities we notice the occurrence of suprema\nof covariances s(Cij) or inverted covariances of the form s( 1 Cii\n). The latter requires non-vanishing uncertainty in our model. Furthermore, note, the need to evaluate know the extrema is not to burdensome as they can be rapidly found by pre-existing Lipschitz optimizers which are highly efficient. However, in many cases the optima are known a priori. For instance, if one knows that the uncertainty monotonously increases over time we have e.g. s(Cqij) = C q ij(inf I) and s( 1 Cqij ) = Cqij(sup I). Alternatively, the covariances may allow for an analytic closed-form solution of the extremum which may be analytically derived before run-time.\nWe will revisit these issues in Sec. B.3 where we examine a concrete application of the theorem to a multi-agent control scenario.\nB.3 A Lipschitz number for the criterion function of our feedback-controlled agents\nLet a ∈ A be an agent with controlled plant dynamics given by the Ito-SDE\ndxa = K(ξa − xa)dt+B dW.\nHere xa(t) ∈ RD denotes the agent a′s state (e.g. location), ξa(t) ∈ RD is the agent’s setpoint signal at time t ∈ I = [t0, tf ]. Furthermore, K = diag(k1, ..., kD) > 0 is the controller’s gain matrix and B = diag( √ ν1, ..., √ νD) reflects the magnitude of the uncertainties (disturbances). Let uncertain start state xa(t0) be a normally distributed random vector. Assume a’s plan is\npa = ( (tai , ζ a i ) )Ha 0=1 where each ζai = (ζ a i,j) D j=1. Let t ≥ t0, i = arg maxi{ti ≤ t0},\ni = arg mini{ti ≥ t} and I := {i ∈ {1, ...,Ha}|i < i ≤ i}. Furthermore, let ξaj denote the jth component of step-function reference signal ξa.\nFor ease of notation we will drop the agent superscripts throughout the remainder of this subsection. The solution to agent a’s SDE is a Gaussian process with vector-valued mean function µa : [t0, tf ]→ RD and matrix-valued covariance function Ca : [t0, tf ]\n2 → RD×D. By applying Ito-calculus to the suitable expectations of the SDE we can show that we have\nµaj (t) = e kaj (t0−t) 〈xaj (t0)〉+ kaj e−k a j t ∫ t t0 ek a j t̃ξaj (t̃)dt̃.\nThe covariance matrix function is (s, t) 7→ diag(cova11(s, t), ..., covaDD(s, t)) where\ncovajj(s, t) = e −kaj (t+s−2t0)(〈 ( xaj (t0) )2〉 − 〈xaj (t0)〉2) +\nνaj 2kaj [e−k a j |t−s| − ek a j (2t0−(s+t))].\nUsing the notation of Thm. B.5 we have Cajj(t) = cov a jj(t, t)\n= e−k a j 2(t−t0)(〈 ( xaj (t0) )2〉 − 〈xaj (t0)〉2) + νaj2kaj [1− ekaj 2(t0−t)] = e−k a j 2(t−t0) ( Cajj(t0)−\nνaj 2kaj\n) +\nνaj 2kaj .\nwhere Cajj(t0) is assumed to be a known quantification of the initial state uncertainty.\nNext we will derive Lipschitz constants for the the component means and covariances which is necessary to derive a Lipschitz number for the collision criterion function.\nFirstly, we consider the mean function. Defining va(t) := ek a j (t0−t) 〈xaj (t0)〉,\nwa(t) := kaj e −kaj t and q̇a(t) := ek a j tξaj (t) we we can restate the component mean function maj as µaj (t) = v a j (t) + w a j (t) q a j (t).\nLeveraging Lem. B.1 we see that L ( µaj ) ≤ L(vaj ) + s(waj )L(qaj ) + s(qaj )L(waj ) (5) ≤ s(v̇aj ) + s(waj ) s(q̇aj ) + s(qaj ) s(waj ) (6)\nwhere as before s(f) = supt∈I |f(t)| for any function f . Evaluation of the suprema depends on the setpoint signal ξ and on the kj . For instance, choosing a constant setpoint ξ and kj > 0 would yield:\n• s(v̇aj ) = supt∈[t0,tf ] | − k a j 〈xaj (t0)〉ek\na j t0e−k a j t| = |kj〈xaj (t0)〉| where the last\nequality holds since e−k a j t decreases monotonically,\n• s(waj ) = supt∈[t0,tf ] |k a j e −kaj t| = |kaj |e−k a j t0 ,\n• s(q̇aj ) = supt∈[t0,tf ] |ξ a j e kaj t| = |ξaj | ek a j tf ,\n• s(qaj ) = supt∈[t0,tf ] | ∫ t t0 ek a j t̃ξaj dt̃| = | ξaj kaj [ek a j tf − ek a j t0 ]|. Here we leveraged\nthe monotonicity of the exponential function.\nNext, we derive Lipschitz constants for the covariances:\nNote the cross-covariances are zero Caij(t) = 0,∀t, i 6= j. Fortunately, the diagonal of the covariance matrix function are also continuously differentiable. In particular, we have Ċajj(t) = −kaj 2e−k a j 2(t−t0) ( Cajj(t0) − νaj 2kaj ) . We can once again utilize Lem. B.1 yielding a Lipschitz bound\nL(Cajj) ≤ s ( Ċajj )\n≤ sup t∈[t0,tf ]\n|kaj 2 ( Cajj(t0)−\nνaj 2kaj\n) |e−k a j 2(t−t0)\n= |kaj 2 ( Cajj(t0)−\nνaj 2kaj\n) |.\nwhere the last equality follows from the fact that t 7→ exp(−kj2(t − t0)) is monotonically decreasing.\nIn summary, we have found\nL(Cajj) ≤ |kaj 2 ( Cajj(t0)−\nνaj 2kaj\n) |, (7)\nL(Ca12) = L(C a 21) = 0, (8)\nL(µaj ) ≤ s(v̇aj ) + s(waj )s(q̇aj ) + s(qaj )s(waj ), (9)\n=|kaj 〈xaj (t0)〉|+ |kaj ||ξaj | ek a j (tf−t0) + |ξaj [ek a j (tf−t0) − 1]|. (10)\nNext, we combine our estimates of the mean and covariances with Lem. B.1 and Thm. B.5 to derive a Lipschitz number for the criterion function defined in Thm. B.3. Let q ∈ {a, r}. Since L(Cq12) = 0 we have gi(t) :=\nCqii(t) + √ (Cqii) 2 − Cqii ( Cqij )2 Cqjj = 2Cqii(t). By Thm. B.5.2, this implies L(α q i ) ≤√\n1 2δq 1 ι(gi)\nL(gi) = √ 1 2δq 1 ι(2Cqii) L(2Cqii) = √ 1 2δq 1 ι(Cqii) L(Cqii) where the last equal-\nity is due to Lem. B.1.3 and due to the fact that inft |r f(t)| = |r| inft |f(t)| for all constants r, functions f . Next, we determine ι(Cqii). By inspecting its derivative, we notice that Cqii is strictly monotonously increasing iff C q ii(t0)− vqi 2kqi < 0 and monotonously decreasing otherwise. Also, Cqii does not attain negative values implying Cqii =\n∣∣Cqii∣∣. Hence, ι(Cqii) = inf{|C q ii(I)|} = inf{C q ii(I)}\n= C q ii(t0), if C q ii(t0) < vqi 2kqi ;\nCqii(tf ), if C q ii(t0) ≥ vqi 2kqi ; Now, we have all the necessary ingredients\nto utilize Thm. B.5 in order to wrap-up:\nL(γa,r) ≤ maxj{L(µaj ) + L(µrj) + L(b a,r j )}\n≤ maxj{L(µaj ) + L(µrj) + 12L(α a j ) + 1 2L(α r j)} ≤ maxj { |kajµaj (t0)| + |kaj ||ξaj |ek a j (tf−t0) + |ξaj [ek a j (tf−t0) − 1]| + |krjµrj(t0)| + |krj ||ξrj |ek r j (tf−t0)+|ξrj [ek r j (tf−t0)−1]|+ 12 √ 1 2δa 1 ι(Cajj) L(Cajj)+ 1 2 √ 1 2δr 1 ι(Crjj) L(Crjj) } .\nWe can see that this Lipschitz number might adopt large values in certain parts of the domain. Therefore, it might be helpful to recompute the Lipschitz numbers adaptively for different parts of the domain."
    }, {
      "heading" : "C Utilising priors encoding belief over change",
      "text" : "of sign of a criterion function\nDetection of collisions is based on excluding the possibility of negative criterion function values. However, as these functions are non-convex any numerical procedure executed on a digital computer has to achieve this with only a finite number of function evaluations. Given this, what is our confidence in not having missed a negative criterion function value?\nThus far, we have proposed using a knowledge (i.e. a prior) about a Lipschitz number of the criterion function to rule out collisions in continuous time based on a finite number of samples. In addition to the Lipschitz-based method presented above, we will now consider an alternative method that assumes a prior belief about the anticipated change of sign of a criterion function.\nBefore commencing it will prove helpful to introduce the notion of a sign change point (SCP). An SCP is a time step which is the border between two changes in sign of a function. More precisely, time t is an SCP of function f if there exist open intervals I ′ := (t′, t) and I ′′ := (t, t′′) such that sgn(f(τ ′)) 6= sgn(f(τ ′′)),∀τ ′ ∈ I ′, τ ′′ ∈ I ′′.\nTo give an example, consider the function\nφ : t 7→ −t χR−(t) + 0χ[0,1](t) + (t− 1)χR>1(t).\nAs before, χS denotes the indicator function of set S. Function φ has exactly two SCPs – at t = 0 and t = 1.\nResuming with our discussion, assume we are given f(t0), ..., f(tk) on a lattice of times (0 = t0 < ... < tk = T ). If f(ti) ≤ 0 for some ti we will want to conservatively assume a collision has occurred. On the other hand, if all evaluations are positive we desire to specify our confidence that all intermittent unobserved values are. This is the case if no SCPs occur. The presence of an odd number of SCPs between two time steps ti, ti+1 is detectable by checking sgn(f(ti)) 6= sgn(f(ti+1)). In fact, if the total number n of SCPs in [0, T ] is\nodd we will detect a change of sign. By contrast, if an even number of SCPs occur we have sgn(f(ti)) = sgn(f(ti+1)) and hence, will be oblivious of negative function values in the interval (ti, ti+1).\nNow, assume we are given a distribution Q : N → [0, 1] representing our belief over the number of occurring SCPs. By the law of total probability, our belief that we will miss the existence of a collision is∑\nn∈2N Pn,kQ[n] (11)\nwhere Pn,k denotes the probability of missing the existence of a collision during collision detection given that n SCPs occur in the interior of the lattice.\nIn preparation of the next theorem we need the following result:\nLemma C.1 (Improved bound). Given a set S = {s1, ..., sn} of n ∈ 2N objects let P be the number of ways the set can be partitioned into pairs, i.e. P = |{{P1, ...,Pn/2}|∀i 6= j : Pi ∩ Pj = ∅, ⋃ iPi = {s1, ..., sn},∀i∃q 6= r : Pi = {sq, sr}}|. We have P ≤ ( n(n−1)/2\nn/2\n) .\nProof. We can create (n2 − n)/2 = n(n− 1)/2 distinct sets of the form {sq, sr} of cardinality two. That is, |T | = n(n − 1)/2 where T = {{si, sj}|i 6= j, i, j = 1, ..., n}.\nTo generate a partition {P1, ...,Pn/2} we need to select a subset of T containing n/2 two-element sets. Conservatively (not taking into account that not every n/2 -element subset is an actual partition), this could be done in at most( n(n−1)/2\nn/2\n) ways. Hence P ≤ ( n(n−1)/2\nn/2\n) .\nTheorem C.2. Assume we are given n ∈ 2N0 SCPs s1, ..., sn whose locations are drawn independently from an identical distribution (drawn i.i.d.). Furthermore, we are given a grid of test points 0 = t0 < t1 < ... < tk = T where the intermediate times are chosen such that ∀i ∈ {1, ..., n}, j ∈ {1, ..., k} : Pr[si ∈ (tj−1, tj)] = 1/k. The probability of missing the existence of a collision by looking for non-positive elements in the sample f(t0), ..., f(tk) is:\nPn,k ≤ P√ kn ≤\n( n(n−1)/2\nn/2 ) √ kn\nwhere P is a function of n (but not of k) as defined in Lemma C.1. In particular, we have limk→∞ Pn,k = 0.\nProof. We define the sample space Ω := {(b1, ..., bn) ∈ {1, ..., k}n} where each bi ∈ {1, ..., k} denotes the index of the time interval (“bin”) (tbi−1 , tbi ] the ith SCP si falls into (i = 1, ..., n). Due to the assumption that the assignment of SCP to bin is i.i.d., each sample has equal probability and we can compute Pn,k as a Laplace probability. That is, Pn,k = |G| |Ω| where G is the set of events\ndescribing that no bin contains an odd number of SCPs (because if at least one does contain an odd number we detect the presence of a collision).\nObviously, |Ω| = kn. On the other hand, G = {(v1, ..., vk)| ∑k j=1 vj = n, ∀j ∈ {1, ..., k} : vj ∈ {0, ..., n}∩2N0} where vj ∈ {0, ..., n} denotes the number of SCPs falling into bin j ∈ {1, ..., k}. We will find an upper bound on G′s cardinality by constructing a finite set H for whose cardinality one can easily establish √ k n P as an upper bound. We show that one can define an injective function ψ : G → H. The latter establishes that |G| ≤ |H|. Thus, |G||Ω| ≤ |H| |Ω| ≤ P√ k n which will hence conclude the proof. We generate H by invoking a two-stage process (where in each stage it is easy to enumerate all possible elements that are generated). In the first stage, we partition the SCPs into n/2 pairs (which we always can since we assumed n to be even). In the second stage, we assign these pairs to the bins in which the pairs are merged into joint sets of SCPs. Therefore, H = {(M1, ...,Mk)|M1 ⊂ {s1, ..., sn}, ...,Mk ⊂ {s1, ..., sn}, |M1|, ..., |Mk| ∈ 2N0, |M1|+ ...+ |Mk| = n,H =⋃ iMi}.\nLet P be the number of ways in which one can partition the n SCPs into n/2 (unordered) pairs i.e. P = |{{P1, ...,Pn/2}|∀i 6= j : Pi ∩Pj = ∅, ⋃ iPi = {s1, ..., sn},∀i∃q 6= r : Pi = {sq, sr}}|. (Cf. Lem. C.1 for a bound). In the second stage, the pairs are distributed among the k bins (intervals) (which can be done in B = kn/2 ways) before the sets within each bin are merged. The number of different paths the process can take to generate an element in H is P (number of partitions into pairs) multiplied with B (number of ways the pairs constituting the partition can then be distributed into the bins).\nBy construction, each final assignment (subsets of SCPs to bins) generated by the two-stage process is an element of H. Conversely, let (M1, ...,Mk) ∈ H then it is easy to verify it could be generated by the two-stage process (however, there may be multiple paths in the process generating the same element of H). Hence, |H| ≤ P B.\nWe finalize our considerations by defining the function ψ : G→ H, (v1, ..., vn) 7→ (M1, ...,Mk) where M1 := {s1, ..., sv1} and for i > 1: Mi := {s1+wi , ..., svi+wi} where wi = ∑ j<i vj . It is easy to see that ψ maps different (v1, ..., vn) ∈ G to different (M1, ...,Mk) ∈ H. Hence, ψ is injective. Since both H and G are finite this implies |G| ≤ |H|. Wrapping up, |G||Ω| ≤ |H| |Ω| ≤ PB kn ≤ Pkn/2 kn\n= P kn/2\nLem.C.1 ≤ ( n(n−1)/2 n/2 )√ kn .\nIn conjunction with Eq. 11, Thm. C.2 can provides a recipe how to do collision detection based on a finite number of criterion function samples such that our confidence in not having overlooked an existing collision is above a certain threshold θ. To this end we require a prior Q over the number of SCPs. Let N be a random variable quantifying the number of occurring SCPs and let M denote the event that we would not detect the existence of an SCP.\nBy the law of total probability we have Pr[M |k] = ∑ n∈N0 Pr[M |N = n, k]Q[N = n] (12)\n= ∑ n∈2N0 Pr[M |N = n, k]Q[N = n] (13)\n= ∑ n∈2N0 Pn,kQ[N = n] (14)\nwhere the last equality follows from Pr[M |N = n, k] = 0, (n ∈ 2N− 1), k ≥ 1. Given a threshold θ ∈ (0, 1) we can then utilize Thm. C.2 to choose a lattice resolution k such that\nPr[M |k] ! < θ.\nTo illustrate this we provide to simple examples:\nExample C.3 (Finite-support prior). As a simplistic example, assume we desire to detect a collision between two agents a, r with plans containing two setpoints each (stabilizing their start and goal state each) and with linear dynamics. We know that at their start and goal locations, no collisions occur. Given this our belief over the number n of SCPs may be Q[N = 0] = 0.5 Q[N = 1] = .1, Q[N = 2] = .4. Furthermore, in the given time interval [0,T] we assume a flat prior distribution giving rise to an equidistant lattice 0 = t0 < t1 < ... < tk = T of samples during collision detection. That is, ti+1 − ti = T/k for some k. Our collision detection method now inspects our criterion function values Γa,r(t0), ...,Γ\na,r(tk). If all values are positive we assume no collision has occurred. How large should we set k in order to ensure that our confidence in this assertion is at least θ ∈ (0, 1)? By Thm. C.2, we know that the probability of having missed a collision with this simple method is less than 0.4√\nk2 . Therefore,\nwe need to set k such that 1− 0.4√ k2 ≥ θ which is equivalent to setting the number k of criterion function evaluations to k ≥ 0.41−θ ."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "Existing work in multi-agent collision prediction and avoid-<lb>ance typically assumes discrete-time trajectories with Gaus-<lb>sian uncertainty or that are completely deterministic. We pro-<lb>pose an approach that allows detection of collisions even be-<lb>tween continuous, stochastic trajectories with the only restric-<lb>tion that means and covariances can be computed. To this<lb>end, we employ probabilistic bounds to derive criterion func-<lb>tions whose negative sign provably is indicative of probable<lb>collisions. For criterion functions that are Lipschitz, an al-<lb>gorithm is provided to rapidly find negative values or prove<lb>their absence. We propose an iterative policy-search approach<lb>that avoids prior discretisations and, upon termination, yields<lb>collision-free trajectories with adjustably high certainty. We<lb>test our method with both fixed-priority and auction-based<lb>protocols for coordinating the iterative planning process. Re-<lb>sults are provided in collision-avoidance simulations of feedback<lb>controlled plants.",
    "creator" : "LaTeX with hyperref package"
  }
}