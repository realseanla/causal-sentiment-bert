{
  "name" : "1609.05621.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "EXTENDING UNIFICATION IN EL TO DISUNIFICATION: THE CASE OF DISMATCHING AND LOCAL DISUNIFICATION",
    "authors" : [ ],
    "emails" : [ "Franz.Baader@tu-dresden.de", "Stefan.Borgwardt@tu-dresden.de", "Barbara.Morawska@tu-dresden.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 9.\n05 62\n1v 1\n[ cs\n.L O\n] 1\n9 Se"
    }, {
      "heading" : "1. Introduction",
      "text" : "Description logics (DLs) [10] are a family of logic-based knowledge representation formalisms, which can be used to represent the conceptual knowledge of an application domain in a structured and formally well-understood way. They are employed in various application areas, but their most notable success so far is the adoption of the DL-based language OWL [26] as standard ontology language for the semantic web. DLs allow their users to define the important notions (classes, relations) of the domain using concepts and roles; to state constraints on the way these notions\n1998 ACM Subject Classification: F.4.1, I.2.3, I.2.4. Key words and phrases: Knowledge Representation, Description Logics, Unification, Disunifica-\ntion, Computational Complexity. Supported by DFG under grant BA 1122/14-2.\nLOGICAL METHODS IN COMPUTER SCIENCE DOI:10.2168/LMCS-???\nc© F. Baader, S. Borgwardt, and B. Morawska Creative Commons\n1\ncan be interpreted using terminological axioms; and to deduce consequences such as subsumption (subclass) relationships from the definitions and constraints. The expressivity of a particular DL is determined by the constructors available for building concepts.\nThe DL EL, which offers the concept constructors conjunction (⊓), existential restriction (∃r.C), and the top concept (⊤), has drawn considerable attention in the last decade since, on the one hand, important inference problems such as the subsumption problem are polynomial in EL, even with respect to expressive terminological axioms [18]. On the other hand, though quite inexpressive, EL is used to define biomedical ontologies, such as the large medical ontology SNOMEDCT.1 For these reasons, the most recent OWL version, OWL2, contains the profile OWL2EL,2 which is based on a maximally tractable extension of EL [11]. Unification in Description Logics was introduced in [4] as a novel inference service that can be used to detect redundancies in ontologies. It is shown there that unification in the DL FL0, which differs from EL in that existential restriction is replaced by value restriction (∀r.C), is ExpTime-complete. The applicability of this result was not only hampered by this high complexity, but also by the fact that FL0 is not used in practice to formulate ontologies. In contrast, as mentioned above, EL is employed to build large biomedical ontologies for which detecting redundancies is a useful inference service. For example, assume that one developer of a medical ontology defines the concept of a patient with severe head injury as\nPatient ⊓ ∃finding.(Head_injury ⊓ ∃severity.Severe), (1.1)\nwhereas another one represents it as\nPatient ⊓ ∃finding.(Severe_finding ⊓ Injury ⊓ ∃finding_site.Head). (1.2)\nFormally, these two concepts are not equivalent, but they are nevertheless meant to represent the same concept. They can obviously be made equivalent by treating the concept names Head_injury and Severe_finding as variables, and substituting the first one by Injury ⊓ ∃finding_site.Head and the second one by ∃severity.Severe. In this case, we say that the concepts are unifiable, and call the substitution that makes them equivalent a unifier. In [1], we were able to show that unification in EL is of considerably lower complexity than unification in FL0: the decision problem for EL is NP-complete. The main idea underlying the proof of this result is to show that any solvable EL-unification problem has a local unifier, i.e., a unifier built from a polynomial number of so-called atoms determined by the unification problem. However, the brute-force “guess and then test” NP-algorithm obtained from this result, which guesses a local substitution and then checks (in polynomial time) whether it is a unifier, is not useful in practice. We thus developed a goal-oriented unification algorithm for EL, which is more efficient since nondeterministic decisions are only made if they are triggered by “unsolved parts” of the unification problem. Another option\n1http://www.ihtsdo.org/snomed-ct/ 2http://www.w3.org/TR/owl2-profiles/\nfor obtaining a more efficient unification algorithm is a translation to satisfiability in propositional logic (SAT): in [2] it is shown how a given EL-unification problem Γ can be translated in polynomial time into a propositional formula whose satisfying valuations correspond to the local unifiers of Γ. Intuitively, a unifier of two EL concepts proposes definitions for the concept names that are used as variables: in our example, we know that, if we define Head_injury as Injury ⊓ ∃finding_site.Head and Severe_finding as ∃severity.Severe, then the two concepts (1.1) and (1.2) are equivalent w.r.t. these definitions. Of course, this example was constructed such that the unifier (which is actually local) provides sensible definitions for the concept names used as variables. In general, the existence of a unifier only says that there is a structural similarity between the two concepts. The developer that uses unification as a tool for finding redundancies in an ontology or between two different ontologies needs to inspect the unifier(s) to see whether the definitions it suggests really make sense. For example, the substitution that replaces Head_injury by Patient⊓ Injury⊓∃finding_site.Head and Severe_finding by Patient⊓∃severity.Severe is also a local unifier, which however does not make sense since findings (i.e. Head_Injury or Severe_finding) cannot be patients. Unfortunately, even small unification problems like the one in our example can have too many local unifiers for manual inspection. In [13] we propose to restrict the attention to so-called minimal unifiers, which form a subset of all local unifiers. In our example, the nonsensical unifier is indeed not minimal. In general, however, the restriction to minimal unifiers may preclude interesting local unifiers. In addition, as shown in [13], computing minimal unifiers is actually harder than computing local unifiers (unless the polynomial hierarchy collapses). In the present paper, we propose disunification as a more direct approach for avoiding local unifiers that do not make sense. In addition to positive constraints (requiring equivalence or subsumption between concepts), a disunification problem may also contain negative constraints (preventing equivalence or subsumption between concepts). In our example, the nonsensical unifier can be avoided by adding the dissubsumption constraint\nHead_injury 6⊑? Patient (1.3)\nto the equivalence constraint (1.1) ≡? (1.2). We add a superscript ·? to the relation symbols (like 6⊑ and ≡) to make clear that these are not axioms that are stated to hold, but rather constraints that need to be solved by finding an appropriate substitution.\nUnification and disunification in DLs is actually a special case of unification and disunification modulo equational theories (see [4] and [1] for the equational theories respectively corresponding to FL0 and EL). Disunification modulo equational theories has, e.g., been investigated in [19, 20]. It is well-known in unification theory that for effectively finitary equational theories, i.e., theories for which finite complete sets of unifiers can effectively be computed, disunification can be reduced to unification: to decide whether a disunification problem has a solution, one computes a finite complete set of unifiers of the equations and then checks whether any of the unifiers in this set also solves the disequations. Unfortunately, for FL0 and EL, this approach is not feasible since the corresponding equational theories have unification type zero [1, 4],\nand thus finite complete sets of unifiers need not even exist. Nevertheless, it was shown in [6] that the approach used in [4] to decide unification (reduction to language equations, which are then solved using tree automata) can be adapted such that it can also deal with disunification. This yields the result that disunification in FL0 has the same complexity (ExpTime-complete) as unification.\nFor EL, going from unification to disunification appears to be more problematic. In fact, the main reason for unification to be decidable and in NP is locality: if the problem has a unifier then it has a local unifier. We will show that disunification in EL is not local in this sense by providing an example of a disunification problem that has a solution, but no local solution. Decidability and complexity of disunification in EL remains an open problem, but we provide partial solutions that are of interest in practice. On the one hand, we investigate dismatching problems, i.e., disunification problems where the negative constraints are dissubsumptions C 6⊑? D for which either C or D is ground (i.e., does not contain a variable). Note that the dissubsumption (1.3) from above actually satisfies this restriction since Patient is not a variable. We prove that (general) solvability of dismatching problems can be reduced to local disunification, i.e., the question whether a given EL-disunification problem has a local solution, which shows that dismatching in EL is NP-complete. On the other hand, we develop two specialized algorithms to solve local disunification problems that extend the ones for unification [1, 2]: a goal-oriented algorithm that reduces the amount of nondeterministic guesses necessary to find a local solution, as well as a translation to SAT. The reason we present two kinds of algorithms is that, in the case of unification, they have proved to complement each other well in first evaluations [12]: the goaloriented algorithm needs less memory and finds minimal solutions faster, while the SAT reduction generates larger data structures, but outperforms the goal-oriented algorithm on unsolvable problems. The remainder of this article is organized as follows. Section 2 introduces syntax and semantics of EL and recalls some basic results about (dis)subsumption in EL. In Section 3, we introduce disunification and the special case of unification, and recall known results about unification in EL and local solutions. Section 4 contains our reduction from dismatching to local disunification, while Sections 5 and 6 describe the two algorithms for local disunification. We discuss related work in Section 7, and summarize our results as well as sketch directions for future research in Section 8. This is an extended version of the conference paper [15]. In this paper, we give full proofs of all our results, and add some results on how to actually compute local solutions using the decision procedures presented in Sections 5 and 6."
    }, {
      "heading" : "2. Subsumption and dissubsumption in EL",
      "text" : "The syntax of EL is defined based on two sets NC and NR of concept names and role names, respectively. Concept terms are built from concept names using the constructors conjunction (C ⊓ D), existential restriction (∃r.C for r ∈ NR), and top (⊤). An interpretation I = (∆I , ·I) consists of a non-empty domain ∆I and an interpretation function that maps concept names to subsets of ∆I and role names to\nbinary relations over ∆I . This function is extended to concept terms as shown in the semantics column of Table 1.\nA concept term C is subsumed by a concept term D (written C ⊑ D) if for every interpretation I it holds that CI ⊆ DI . We write a dissubsumption C 6⊑ D to abbreviate the fact that C ⊑ D does not hold. The two concept terms C and D are equivalent (written C ≡ D) if C ⊑ D and D ⊑ C, i.e. they are always interpreted as the same set. The binary subsumption relation ⊑ on concept terms is reflexive and transitive, and ≡ is an equivalence relation, which justifies the notation. Note that we use “=” to denote syntactic equality between concept terms, whereas “≡” denotes semantic equivalence. Since conjunction is interpreted as set intersection, we can treat ⊓ as a commutative and associative operator, and thus dispense with parentheses in nested conjunctions. An atom is a concept name or an existential restriction. Hence, every concept term C is a conjunction of atoms or ⊤. We call the atoms in this conjunction the top-level atoms of C. Obviously, C is equivalent to the conjunction of its top-level atoms, where the empty conjunction corresponds to ⊤. An atom is flat if it is a concept name or an existential restriction of the form ∃r.A with A ∈ NC. Subsumption in EL is decidable in polynomial time [9] and can be checked by recursively comparing the top-level atoms of the two concept terms.\nLemma 1 ([1]). For two atoms C,D, we have C ⊑ D iff C = D is a concept name or C = ∃r.C ′, D = ∃r.D′, and C ′ ⊑ D′. If C,D are concept terms, then C ⊑ D iff for every top-level atom D′ of D there is a top-level atom C ′ of C such that C ′ ⊑ D′.\nWe obtain the following contrapositive formulation characterizing dissubsumption.\nLemma 2. For two concept terms C,D, we have C 6⊑ D iff there is a top-level atom D′ of D such that for all top-level atoms C ′ of C it holds that C ′ 6⊑ D′.\nIn particular, C 6⊑ D is characterized by the existence of a top-level atom D′ of D for which C 6⊑ D′ holds. By further analyzing the structure of atoms, we obtain the following.\nLemma 3. Let C,D be two atoms. Then we have C 6⊑ D iff either\n(1) C or D is a concept name and C 6= D; or\n(2) D = ∃r.D′, C = ∃s.C ′, and r 6= s; or\n(3) D = ∃r.D′, C = ∃r.C ′, and C ′ 6⊑ D′."
    }, {
      "heading" : "3. Disunification",
      "text" : "As described in the introduction, we now partition the set NC into a set of (concept) variables (Nv) and a set of (concept) constants (Nc). A concept term is ground if it does not contain any variables. We define a quite general notion of disunification problems that is similar to the equational formulae used in [20].\nDefinition 4. A disunification problem Γ is a formula built from subsumptions of the form C ⊑? D, where C and D are concept terms, using the logical connectives ∧, ∨, and ¬. We use equations C ≡? D to abbreviate (C ⊑? D) ∧ (D ⊑? C), dissubsumptions C 6⊑? D for ¬(C ⊑? D), and disequations C 6≡? D instead of (C 6⊑? D)∨(D 6⊑? C). A basic disunification problem is a conjunction of subsumptions and dissubsumptions. A dismatching problem is a basic disunification problem in which all dissubsumptions C 6⊑? D are such that either C or D is ground. Finally, a unification problem is a conjunction of subsumptions.\nTo define the semantics of disunification problems, we now fix a finite signature Σ ⊆ NC ∪NR and assume that all disunification problems contain only concept terms constructed over the symbols in Σ. A substitution σ maps every variable in Σ to a ground concept term constructed over the symbols of Σ. This mapping can be extended to all concept terms (over Σ) in the usual way. A substitution σ solves a subsumption C ⊑? D if σ(C) ⊑ σ(D); it solves Γ1 ∧ Γ2 if it solves both Γ1 and Γ2; it solves Γ1 ∨ Γ2 if it solves Γ1 or Γ2; and it solves ¬Γ if it does not solve Γ. A substitution that solves a given disunification problem is called a solution of this problem. A disunification problem is solvable if it has a solution. By disunification we refer to the decision problem of checking whether a given disunification problem is solvable, and will similarly talk of dismatching and unification. In contrast to unification, in disunification it does make a difference whether or not solutions may contain variables from Nv∩Σ or additional symbols from (NC∪NR)\\Σ [19]. In the context of the application sketched in the introduction, restricting solutions to ground terms over the signature of the ontology to be checked for redundancy is appropriate: since a solution σ is supposed to provide definitions for the variables in Σ, it should not use the variables themselves to define them; moreover, definitions that contain newly generated symbols would be meaningless to the user.\n3.1. Reduction to basic disunification problems. We will consider only basic disunification problems in the following. The reason is that there is a straightforward NP-reduction from solvability of arbitrary disunification problems to solvability of basic disunification problems. In this reduction, we view all subsumptions occurring in the disunification problem as propositional variables and guess a satisfying valuation of the resulting propositional formula in nondeterministic polynomial time. It then\nsuffices to check solvability of the basic disunification problem obtained as the conjunction of all subsumptions evaluated to true and the negations of all subsumptions evaluated to false. This reduction consists of polynomially many guesses followed by a polynomial satisfaction check. Hence, doing this before the NP-algorithms for the problems considered in the following sections leaves the overall complexity in NP. In fact, in contrast to the use of an NP-oracle within an NP-algorithm, all the tests that are applied are deterministic polynomial time. Overall, there are polynomially many guesses (in the reduction and the NP-algorithm) with deterministic polynomial tests at the end.\nHence, from now on we restrict our considerations to basic disunification problems. For simplicity, we will call them disunification problems and consider them to be sets containing subsumptions and dissubsumptions.\n3.2. Reduction to flat disunification problems. We further simplify our analysis by considering flat disunification problems, which means that they may only contain flat dissubsumptions of the form C1 ⊓ · · · ⊓ Cn 6⊑\n? D1 ⊓ · · · ⊓ Dm for flat atoms C1, . . . , Cn, D1, . . . , Dm with m,n ≥ 0,\n3 and flat subsumptions of the form C1 ⊓ · · · ⊓ Cn ⊑\n? D1 for flat atoms C1, . . . , Cn, D1 with n ≥ 0. This restriction is without loss of generality: to flatten concept terms, one can simply introduce new variables and equations to abbreviate subterms [1]. Moreover, a subsumption of the form C ⊑? D1 ⊓ · · · ⊓Dm is equivalent to the conjunction of C ⊑ ? D1, . . . , C ⊑ ? Dm. Any solution of a disunification problem Γ can be extended to a solution of the resulting flat disunification problem Γ′, and conversely every solution of Γ′ also solves Γ. This flattening procedure also works for unification problems. However, dismatching problems cannot without loss of generality be restricted to being flat since the introduction of new variables to abbreviate subterms may destroy the property that one side of each dissubsumption is ground (see also Section 4).\n3.3. Local disunification. For solving flat unification problems, it has been shown that it suffices to consider so-called local solutions [1], which are restricted to use only the atoms occurring in the input problem. We define this notion here for disunification.\nLet Γ be a flat disunification problem. We denote by At the set of all (flat) atoms occurring as subterms in Γ, by Var the set of variables occurring in Γ, and by Atnv := At \\ Var the set of non-variable atoms of Γ. Let S : Var → 2\nAtnv be an assignment (for Γ), i.e. a function that assigns to each variable X ∈ Var a set SX ⊆ Atnv of non-variable atoms. The relation >S on Var is defined as the transitive closure of {(X, Y ) ∈ Var × Var | Y occurs in an atom of SX}. If this defines a strict partial order, i.e. >S is irreflexive, then S is called acyclic. In this case, we can define the substitution σS inductively along >S as follows: if X is minimal w.r.t. >S, then\n3Recall that the empty conjunction is ⊤.\nall elements of SX are ground and we simply take\nσS(X) := l\nD∈SX\nD;\notherwise, we assume that σS(Y ) is defined for all Y ∈ Var with X >S Y , and set\nσS(X) := l\nD∈SX\nσS(D).\nIt is easy to see that the concept terms σS(D) are ground and constructed from the symbols of Σ, and hence σS is a valid candidate for a solution of Γ according to Definition 4.\nDefinition 5. Let Γ be a flat disunification problem. A substitution σ is called local (w.r.t. Γ) if there exists an acyclic assignment S for Γ such that σ = σS. The disunification problem Γ is locally solvable if it has a local solution, i.e. a solution that is a local substitution. Local disunification is the problem of checking flat disunification problems for local solvability.\nNote that assignments and local solutions are defined only for flat disunification problems, because both are based on the assumption that all subterms occurring in the input problem are flat. Although solvability of disunification problems is equivalent to solvability of flat disunification problems, it is not straightforward to extend the notion of local solutions to general disunification problems Γ. In particular, there may be several flat disunification problems that are equivalent to Γ w.r.t. solvability, but they induce different sets of flat atoms, and hence different kinds of local substitutions.\nObviously, local disunification is decidable in NP: We can guess an assignment S, and check it for acyclicity and whether the induced substitution solves the disunification problem in polynomial time. The corresponding complexity lower bound follows from NP-hardness of (local) solvability of unification problems in EL [1].\nFact 3.1. Local disunification in EL is NP-complete.\nIt has been shown that unification in EL is local in the sense that the equivalent flattened problem has a local solution iff the original problem is solvable, and hence (general) solvability of unification problems in EL can be decided in NP [1]. The next example shows that disunification in EL is not local in this sense.\nExample 6. Consider the flat disunification problem\nΓ := {X ⊑? B, A ⊓B ⊓ C ⊑? X, ∃r.X ⊑? Y, ⊤ 6⊑? Y, Y 6⊑? ∃r.B}\nwith concept variables X, Y and concept constants A,B,C. The substitution σ with σ(X) := A ⊓ B ⊓ C and σ(Y ) := ∃r.(A ⊓ C) is a solution of Γ. For σ to be local, the atom ∃r.(A ⊓ C) would have to be of the form σ(D) for a non-variable atom D occurring in Γ. But the only candidates for D are ∃r.X and ∃r.B, none of which satisfy ∃r.(A ⊓ C) = σ(D). We show that Γ cannot have another solution that is local. Assume to the contrary that Γ has a local solution γ. We know that γ(Y ) cannot be ⊤ since γ must solve\n⊤ 6⊑? Y . Furthermore, none of the constants A,B,C can be a top-level atom of γ(Y ) since this would contradict ∃r.X ⊑? Y (see Lemma 1). That leaves only the nonvariable atoms ∃r.γ(X) and ∃r.B, which are, however, ruled out by Y 6⊑? ∃r.B since both γ(X) and B are subsumed by B (see Lemma 3).\nThe decidability and complexity of general disunification in EL is still open. In the following, we first consider the special case of solving dismatching problems, for which we show a similar result as for unification: every dismatching problem can be polynomially reduced to a flat problem that has a local solution iff the original problem is solvable. The main difference is that this reduction is nondeterministic. In this way, we reduce dismatching to local disunification. We then provide two different NPalgorithms for the latter problem by extending the rule-based unification algorithm from [1] and adapting the SAT encoding of unification problems from [2]. These algorithms are more efficient than the brute-force “guess and then test” procedure on which our argument for Fact 3.1 was based."
    }, {
      "heading" : "4. Reducing dismatching to local disunification",
      "text" : "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29]. In particular, the matching problems for EL investigated in [3] are similar to our dismatching problems in that there subsumptions are restricted to ones where one side is ground. Another motivation comes from our experience that dismatching problems already suffice to formulate most of the negative constraints one may want to put on unification problems, as described in the introduction.\nAs mentioned in Section 3, we cannot restrict our attention to flat dismatching problems without loss of generality. Instead, the nondeterministic algorithm we present in the following reduces any dismatching problem Γ to a flat disunification problem Γ′ with the property that local solvability of Γ′ is equivalent to the solvability of Γ. Since the algorithm takes at most polynomial time in the size of Γ, this shows, together with Fact 3.1, that dismatching in EL is NP-complete. For simplicity, we assume that the subsumptions and the non-ground sides of the dissubsumptions have already been flattened using the approach mentioned in the previous section. This retains the property that all dissubsumptions have one ground side and does not affect the solvability of the problem.\nOur procedure exhaustively applies a set of rules to the (dis)subsumptions in a dismatching problem (see Figures 1 and 2). Each rule consists of a condition under which it is applicable to a given subsumption or dissubsumption s, and an action that is executed on s. Actions usually include the removal of s from the input problem, and often new subsumptions or dissubsumptions are introduced to replace it. Actions can fail, which indicates that the current dismatching problem has no solution. In all rules, C1, . . . , Cn and D1, . . . , Dm denote atoms. The rule Left Decomposition includes the special case where the left-hand side of s is ⊤, in which case s is simply removed from the problem. We use the rule Flattening Left-Ground Subsumptions to eliminate"
    }, {
      "heading" : "Right Decomposition:",
      "text" : ""
    }, {
      "heading" : "Left Decomposition:",
      "text" : ""
    }, {
      "heading" : "Atomic Decomposition:",
      "text" : "the non-flat, left-ground subsumptions that may be introduced by Flattening RightGround Dissubsumptions.\nNote that at most one rule is applicable to any given (dis)subsumption. The choice which (dis)subsumption to consider next is don’t care nondeterministic, but the choices in the rules Right Decomposition and Solving Left-Ground Dissubsumptions are don’t know nondeterministic.\nAlgorithm 7. Let Γ0 be a dismatching problem. We initialize Γ := Γ0. While any of the rules of Figures 1 and 2 is applicable to any element of Γ, choose one such element and apply the corresponding rule. If any rule application fails, return “failure”.\nNote that each rule application takes only polynomial time in the size of the chosen (dis)subsumption. In particular, subsumptions between ground atoms can be checked in polynomial time [9].\nLemma 8. Every run of Algorithm 7 terminates in time polynomial in the size of Γ0.\nProof. Let Γ0, . . . , Γk be the sequence of disunification problems created during a run of the algorithm, i.e.\n• Γ0 is the input dismatching problem;\n• for all j, 0 ≤ j ≤ k − 1, Γj+1 is the result of successfully applying one rule to a (dis)subsumption in Γj ; and\n• either no rule is applicable to any element of Γk, or a rule application to a (dis)subsumption in Γk failed."
    }, {
      "heading" : "Flattening Right-Ground Dissubsumptions:",
      "text" : ""
    }, {
      "heading" : "Flattening Left-Ground Subsumptions:",
      "text" : ""
    }, {
      "heading" : "Solving Left-Ground Dissubsumptions:",
      "text" : "We prove that k is polynomial in the size of Γ0 by measuring the size of subsumptions and dissubsumptions via the function c that is defined as follows:\nc(C 6⊑? D) := c(C ⊑? D) := |C| · |D|,\nwhere |C| is the size of the concept term C; the latter is measured in the number of symbols it takes to write down C, where we count each concept name as one symbol, and “∃r.” is also one symbol. Note that we always have |C| ≥ 1 since C must contain at least one concept name or ⊤, and thus also c(s) ≥ 1 for any (dis)subsumption s. We now define the size c(Γ) of a disunification problem Γ as the sum of the sizes c(s) for all s ∈ Γ to which a rule is applicable. Since c(Γ0) is obviously polynomial in the size of Γ0, it now suffices to show that c(Γj) > c(Γj+1) holds for all j, 0 ≤ j ≤ k− 1. To show this, we consider the rule that was applied to s ∈ Γj in order to obtain Γj+1:\n• Right Decomposition: Then s = C1 ⊓ · · · ⊓ Cn 6⊑ ? D1 ⊓ . . .Dm and we must have\nm > 1 since we assumed that the rule application was successful. Thus, we get |C1 ⊓ · · · ⊓ Cn| · |D1 ⊓ · · · ⊓ Dm| > |C1 ⊓ · · · ⊓ Cn| · |Di| for every choice of i ∈ {1, . . . , m}, and thus c(Γj) > c(Γj+1).\n• Left Decomposition: Then s = C1 ⊓ · · · ⊓ Cn 6⊑ ? D and, if n = 0, then we have\nc(Γj) = c(Γj+1) + c(s) ≥ c(Γj+1) + 1 > c(Γj+1). Otherwise, n > 1, and thus\n|C1 ⊓ · · · ⊓ Cn| · |D| = (|C1|+ · · ·+ |Cn|+ (n− 1)) · |D|\n> |C1| · |D|+ · · ·+ |Cn| · |D|.\n• Atomic Decomposition: It suffices to consider Case e) since Case a) is impossible and the other cases are trivial. Then s = ∃r.C ′ 6⊑? ∃r.D′, and we get |∃r.C ′| · |∃r.D′| = (|C ′|+ 1) · (|D′|+ 1) > |C ′| · |D′|.\n• Flattening Right-Ground Dissubsumptions: Then s = X 6⊑? ∃r.D is replaced by X 6⊑? ∃r.XD and D ⊑\n? XD. To the dissubsumption, no further rule is applicable, and hence it does not count towards c(Γj). Regarding the subsumption, we have |X| · |∃r.D| = |D|+ 1 > |D| = |D| · |XD|.\n• Flattening Left-Ground Subsumptions: Then the subsumption s is of the form C1 ⊓ · · · ⊓ Cn ⊓ ∃r1.D1 ⊓ · · · ⊓ ∃rm.Dm ⊑\n? X and only to the subsumptions D1 ⊑ ? XD1, . . . , Dm ⊑ ? XDm this rule may be applicable again. But we have\n|C1 ⊓ · · · ⊓ Cn ⊓ ∃r1.D1 ⊓ · · · ⊓ ∃rm.Dm| · |X|\n= |C1|+ · · ·+ |Cn|+ |∃r1.D1|+ · · ·+ |∃rm.Dm|+ (n+m− 1)\n≥ |∃r1.D1|+ · · ·+ |∃rm.Dm|\n> |D1|+ · · ·+ |Dm|\n= |D1| · |XD1 |+ · · ·+ |Dm| · |XDm|.\n• Solving Left-Ground Dissubsumptions: Then s = C1 ⊓ · · · ⊓ Cn 6⊑ ? X and to a\ngenerated subsumption of the form X ⊑? A or X ⊑? ∃r.Z no further rule is applicable. If n = 0, then no further dissubsumptions are generated, and thus c(Γj) > c(Γj+1). Otherwise, we denote by |si| the size of the dissubsumption resulting from applying Atomic Decomposition to Ci 6⊑\n? ∃r.Z, 1 ≤ i ≤ n, where we consider this number to be 0 if the dissubsumption was simply discarded (c.f. Cases b)–d) of Atomic Decomposition).\nIf |si| = 0, we obtain |Ci| ≥ 1 > 0 = |si|. But also in Case e), we have Ci = ∃r.C ′ i, and thus |Ci| = |C ′ i|+ 1 = |C ′ i| · |Z|+ 1 > |si|. Hence, we get\n|C1 ⊓ · · · ⊓ Cn| · |X| = |C1|+ · · ·+ |Cn|+ (n− 1)\n≥ |C1|+ · · ·+ |Cn|\n> |s1|+ · · ·+ |sn|,\nand thus again c(Γj) > c(Γj+1).\nNote that the rule Solving Left-Ground Dissubsumptions is not limited to nonflat dissubsumptions, and thus the algorithm completely eliminates all left-ground dissubsumptions from Γ. It is also easy to see that, if the algorithm is successful, then the resulting disunification problem Γ is flat. We now prove that this nondeterministic procedure is correct in the following sense.\nLemma 9. The dismatching problem Γ0 is solvable iff there is a successful run of Algorithm 7 such that the resulting flat disunification problem Γ has a local solution.\nProof. For soundness (i.e. the “if” direction), let σ be the local solution of Γ and consider the run of Algorithm 7 that produced Γ. It is easy to show by induction on the reverse order in which the rules have been applied that σ solves all subsumptions that have been considered. Indeed, this follows from simple applications of Lemmata 1–3 and the properties of subsumption. This implies that σ is also a solution of Γ0.\nShowing completeness (i.e. the “only if” direction) is a little more involved. Let γ be a solution of Γ0. We guide the rule applications of Algorithm 7 and extend γ to the newly introduced variables in such a way to maintain the invariant that “γ solves all (dis)subsumptions of Γ”. This obviously holds after the initialization Γ := Γ0. Afterwards, we will use γ to define a local solution of Γ. Consider a (dis)subsumption s ∈ Γ (which is solved by γ) to which one of the rules of Figures 1 and 2 is applicable. We make a case distinction on which rule is to be applied:\n• Right Decomposition: Then s is of the form C1 ⊓ · · · ⊓ Cn 6⊑ ? D1 ⊓ · · · ⊓Dm for\nm 6= 1. Since γ(C1 ⊓ · · · ⊓ Cn) 6⊑ γ(D1 ⊓ · · · ⊓Dm), by applying Lemma 2 twice, we can find an index i ∈ {1, . . . , m} such that γ(C1 ⊓ · · · ⊓ Cn) 6⊑ γ(Di). Thus, we can choose this index in the rule application in order to satisfy the invariant.\n• Left Decomposition: Then s is of the form C1 ⊓ · · · ⊓ Cn 6⊑ ? D, where n 6= 1 and\nD is a non-variable atom. This means that γ(D) is also an atom, and thus by Lemma 2 we know that γ(Ci) 6⊑ γ(D) holds for all i ∈ {1, . . . , n}, as required. • Atomic Decomposition: Then s is of the form C 6⊑? D for two non-variable atoms C and D. Since γ(C) 6⊑ γ(D), Case a) cannot apply. If one of the Cases b)–d) applies, then s is simply removed from Γ and there is nothing to show. Otherwise, we have D = ∃r.D′ and C = ∃r.C ′, and the new dissubsumption C ′ 6⊑? D′\nis added to Γ. Moreover, we have γ(C) = ∃r.γ(C ′) and γ(D) = ∃r.γ(D′), and thus by Lemma 3 we know that γ(C ′) 6⊑ γ(D′).\n• Flattening Right-Ground Dissubsumptions: Then s is of the form X 6⊑? ∃r.D. By defining γ(XD) := D, γ solves X 6⊑ ? ∃r.XD and D ⊑ ? XD.\n• Flattening Left-Ground Subsumptions: Then the subsumption s is of the form C1 ⊓ · · · ⊓ Cn ⊓ ∃r1.D1 ⊓ · · · ⊓ ∃rm.Dm ⊑\n? X, where all D1, . . . , Dm are ground. If we extend γ by defining γ(XDi) := Di for all i ∈ {1, . . . , m}, then this obviously satisfies the new subsumptions D1 ⊑ ? XD1 , . . . , Dm ⊑ ? XDm , and C1⊓ · · ·⊓Cn ⊓∃r1.XD1 ⊓ · · ·⊓∃rm.XDm ⊑ ? X by our assumption that γ solves s.\n• Solving Left-Ground Dissubsumptions: Then the dissubsumption s is of the form C1 ⊓ · · · ⊓ Cn 6⊑\n? X, where X is a variable and C1, . . . , Cn are ground atoms. By Lemma 2, there must be a ground top-level atom D of γ(X) such that C1 ⊓ · · · ⊓ Cn 6⊑ D, i.e. C1 6⊑ D, . . . , Cn 6⊑ D. If D is a concept constant, we can choose this in the rule application since we know that γ(X) ⊑ D. Otherwise, we have D = ∃r.D′. By extending γ to γ(Z) := D′, we ensure that\nX ⊑? ∃r.Z, C1 6⊑ ? ∃r.Z, . . .Cn 6⊑ ? ∃r.Z are solved by γ. The remaining claim follows as for Atomic Decomposition above.\nOnce no more rules can be applied, we obtain a flat disunification problem Γ of which the extended substitution γ is a (possibly non-local) solution. To obtain a local solution, we denote by At, Var, and Atnv the sets as defined in Section 3 and define the assignment S induced by γ as in [2]:\nSX := {D ∈ Atnv | γ(X) ⊑ γ(D)},\nfor all (old and new) variables X ∈ Var. It was shown in [2] that S is acyclic and the substitution σS solves all subsumptions in Γ.\n4 Furthermore, it is easy to show that γ(C) ⊑ σS(C) holds for all concept terms C.\nSince Γ contains no left-ground dissubsumptions anymore, it remains to show that σS solves all remaining right-ground dissubsumptions in Γ and all flat dissubsumptions created by an application of the rule Flattening Right-Ground Dissubsumptions. Consider first any flat right-ground dissubsumption X 6⊑? D in Γ. We have already shown that γ(X) 6⊑ D holds. Since γ(X) ⊑ σS(X), by the transitivity of subsumption σS(X) ⊑ D cannot hold, and thus σS also solves the dissubsumption.\nConsider now a dissubsumption X 6⊑? ∃r.XD that was created by an application of the rule Flattening Right-Ground Dissubsumptions to X 6⊑? ∃r.D. By the same argument as above, from γ(X) 6⊑ ∃r.D we can derive that σS(X) 6⊑ ∃r.D holds. We now show that σS(XD) ⊑ D holds, which implies that σS(∃r.XD) ⊑ ∃r.D, and thus by the transitivity of subsumption it cannot be the case that σS(X) ⊑ σS(∃r.XD), which concludes the proof by showing that σS solves Γ. We show that σS(XC) ⊑ C holds for all variables XC for which a subsumption C ⊑? XC was introduced by a Flattening rule. We prove this claim by induction on the role depth of C, which is the maximum nesting depth of existential restrictions occurring in it. Let C1, . . . , Cn be the top-level atoms of C. Then Γ contains a flat subsumption C ′1⊓· · ·⊓C ′ n ⊑ ? XC , where Ci = C ′ i if Ci is flat, and Ci = ∃r.Di and C ′ i = ∃r.XDi otherwise. Since the role depth of each such Di is strictly smaller than that of C, by induction we know that σS(XDi) ⊑ Di, and thus σS(C ′ 1⊓· · ·⊓C ′ n) ⊑ C1⊓· · ·⊓Cn = C by Lemma 1. Furthermore, for all i ∈ {1, . . . , n} we have γ(XC) = C ⊑ Ci = γ(C ′ i) and C ′i ∈ Atnv. Thus, C ′ i ∈ SXC by the definition of S. The definition of σS now yields that σS(XC) ⊑ σS(C ′ 1 ⊓ · · · ⊓ C ′ n) ⊑ C (see Section 3.3).\nThe disunification problem of Example 6 is in fact a dismatching problem. Applying Algorithm 7 to this problem, we can use the rule Solving Left-Ground Dissubsumptions to replace ⊤ 6⊑? Y with Y ⊑? ∃r.Z. The presence of the new atom ∃r.Z makes the solution σ introduced in Example 6 local.\nTogether with Fact 3.1 and the NP-hardness of unification in EL [1], this shows the following complexity result.\nTheorem 10. Dismatching in EL is NP-complete.\n4More precisely, it was shown that γ induces a satisfying valuation of a SAT problem, which in turn induces the solution σS above. For details, see [2] or Sections 6.1 and 6.2.\nAdditionally, one can see from the proof of Lemma 9 that any local solution of the constructed disunification problem Γ is also a solution of the original problem Γ0. Hence, if we are interested in actually computing solutions of Γ0 in order to show them to the user, we can collect the solutions of the flat problems Γ produced by the successful runs of Algorithm 7."
    }, {
      "heading" : "5. A goal-oriented algorithm for local disunification",
      "text" : "In this section, we present a sound and complete algorithm that provides a more goal-directed way to solve local disunification problems than blindly guessing an assignment as described in Section 4. The approach is based on transformation rules that are applied to subsumptions and dissubsumptions in order to derive a local solution. To solve the subsumptions, we reuse the rules of the goal-oriented algorithm for unification in EL [1, 14], which produces only local unifiers. Since any local solution of the disunification problem is in particular a local unifier of the subsumptions in the problem, one might think that it is then sufficient to check whether any of the produced unifiers also solves the dissubsumptions. This would not be complete, however, since the goal-oriented algorithm for unification does not produce all local unifiers. For this reason, we have additional rules for solving the dissubsumptions. Both rule sets contain (deterministic) eager rules that are applied with the highest priority, and nondeterministic rules that are only applied if no eager rule is applicable. The goal of the eager rules is to enable the algorithm to detect obvious contradictions as early as possible in order to reduce the number of nondeterministic choices it has to make.\nLet now Γ0 be the flat disunification problem for which we want to decide local solvability, and let the sets At, Var, and Atnv be defined as in Section 3. We assume without loss of generality that the dissubsumptions in Γ0 have only a single atom on the right-hand side. If this is not the case, it can easily be achieved by exhaustive application of the nondeterministic rule Right Decomposition (see Figure 1) without affecting the complexity of the overall procedure. Starting with Γ0, the algorithm maintains a current disunification problem Γ and a current acyclic assignment S, which initially assigns the empty set to all variables. In addition, for each subsumption or dissubsumption in Γ, it maintains the information on whether it is solved or not. Initially, all subsumptions of Γ0 are unsolved, except those with a variable on the right-hand side, and all dissubsumptions in Γ0 are unsolved, except those with a variable on the left-hand side and a non-variable atom on the right-hand side.\nSubsumptions of the form C1 ⊓ · · · ⊓ Cn ⊑ ? X and dissubsumptions of the form X 6⊑? D, for a non-variable atom D, are called initially solved. Intuitively, they only specify constraints on the assignment SX . More formally, this intuition is captured by the process of expanding Γ w.r.t. the variable X, which performs the following actions:\n• every initially solved subsumption s ∈ Γ of the form C1 ⊓ · · · ⊓ Cn ⊑ ? X is\nexpanded by adding the subsumption C1 ⊓ · · · ⊓Cn ⊑ ? E to Γ for every E ∈ SX , and\n• every initially solved dissubsumption X 6⊑? D ∈ Γ is expanded by adding E 6⊑? D to Γ for every E ∈ SX .\nA (non-failing) application of a rule of our algorithm does the following:\n• it solves exactly one unsolved subsumption or dissubsumption,\n• it may extend the current assignment S by adding elements of Atnv to some set SX ,\n• it may introduce new flat subsumptions or dissubsumptions built from elements of At, and\n• it keeps Γ expanded w.r.t. all variables X.\nSubsumptions and dissubsumptions are only added by a rule application or by expansion if they are not already present in Γ. If a new subsumption or dissubsumption is added to Γ, it is marked as unsolved, unless it is initially solved (because of its form). Solving subsumptions and dissubsumptions is mostly independent, except for expanding Γ, which can add new unsolved subsumptions and dissubsumptions at the same time, and may be triggered by solving a subsumption or a dissubsumption.\nThe rules of our algorithm are depicted in Figures 3 and 4. The rules dealing with subsumptions are essentially the same as in [14]; note that several of these may be applicable to the same subsumption. In the rule Local Extension, the left-hand side of s may be a variable, and then s is of the form Y 6⊑? X. This dissubsumption is not initially solved, because X is not a non-variable atom.\nAlgorithm 11. Let Γ0 be a flat disunification problem. We initialize Γ := Γ0 and SX := ∅ for all variables X. While Γ contains an unsolved element, do the following:\n(1) Eager rule application: If any eager rules (Figure 3) are applicable to some unsolved element s ∈ Γ, apply an arbitrarily chosen one to s. If the rule application fails, return “failure”.\n(2) Nondeterministic rule application: If no eager rule is applicable, let s be an unsolved subsumption or dissubsumption in Γ. If one of the nondeterministic rules (Figure 4) applies to s, choose one and apply it. If none of these rules apply to s or the rule application fails, return “failure”.\nOnce all elements of Γ are solved, return the substitution σS that is induced by the current assignment.\nAs with Algorithm 7, the choice which (dis)subsumption to consider next and which eager rule to apply is don’t care nondeterministic, while the choice of which nondeterministic rule to apply and the choices inside the rules are don’t know nondeterministic. Each of these latter choices may result in a different solution σS.\n5.1. Termination.\nLemma 12. Every run of Algorithm 11 terminates in time polynomial in the size of Γ0."
    }, {
      "heading" : "Eager Ground Solving:",
      "text" : ""
    }, {
      "heading" : "Eager Solving:",
      "text" : ""
    }, {
      "heading" : "Eager Extension:",
      "text" : ""
    }, {
      "heading" : "Eager Top Solving:",
      "text" : ""
    }, {
      "heading" : "Eager Left Decomposition:",
      "text" : ""
    }, {
      "heading" : "Eager Atomic Decomposition:",
      "text" : "Proof. Each rule application solves one subsumption or dissubsumption. We show that only polynomially many subsumptions and dissubsumptions are produced during a run of the algorithm, and thus there can be only polynomially many rule applications during one run of the algorithm.\nA new subsumption or dissubsumption may be created only by an application of the rules Decomposition, Eager Left Decomposition, or Eager Atomic Decomposition, and then it is of the form C ⊑? D or C 6⊑? D, with C,D ∈ At. Obviously, there are only polynomially many such (dis)subsumptions."
    }, {
      "heading" : "Decomposition:",
      "text" : ""
    }, {
      "heading" : "Extension:",
      "text" : ""
    }, {
      "heading" : "Local Extension:",
      "text" : "Now, we consider (dis)subsumptions created by expanding Γ. They can have the following forms, where D,E ∈ Atnv:\n(1) C1 ⊓ · · · ⊓ Cn ⊑ ? E, for C1 ⊓ · · · ⊓ Cn ⊑ ? X in Γ, (2) E 6⊑? D, for X 6⊑? D in Γ.\nDissubsumptions of the type (2) are also of the form described above. For the subsumptions of type (1), note that C1 ⊓ · · · ⊓ Cn is either the left-hand side of a subsumption from the original problem Γ0, or was created by a Decomposition rule, in which case we have n = 1. Thus, there can also be at most polynomially many subsumptions of the first type.\nFinally, each rule application takes at most polynomial time.\n5.2. Soundness. Assume that a run of the algorithm terminates with success, i.e. all subsumptions and dissubsumptions are solved. Let Γ̂ be the set of all subsumptions and dissubsumptions produced by this run, S be the final assignment, and σS the induced substitution (see Section 3). Observe that the algorithm never removes elements from the current disunification problem, but only marks them as solved, and hence Γ̂ contains Γ0. To show that σS solves Γ̂, and thus Γ0, we use induction on the following order on (dis)subsumptions.\nDefinition 13. Consider any (dis)subsumption s of the form C1 ⊓ · · · ⊓ Cn ⊑ ? Cn+1 or C1 ⊓ · · · ⊓ Cn 6⊑ ? Cn+1 in Γ̂.\n• We define m(s) := (m1(s), m2(s)), where – m1(s) := {X1, . . . , Xm} is the multiset containing all occurrences of variables in the concept terms C1, . . . , Cn, Cn+1 (and hence m1(s) = ∅ if s is ground);\n– m2(s) := |s| is the size of s, i.e. the number of symbols in s (see the proof of Lemma 8).\n• The strict partial order ≻ on such pairs is the lexicographic order, where the second components are compared w.r.t. the usual order on natural numbers, and the first components are compared w.r.t. the multiset extension of >S [5].\n• We extend ≻ to Γ̂ by setting s1 ≻ s2 iff m(s1) ≻ m(s2).\nSince multiset extensions and lexicographic products of well-founded strict partial orders are again well-founded [5], ≻ is a well-founded strict partial order on Γ̂.\nLemma 14. The substitution σS is a solution of Γ̂, and thus also of its subset Γ0.\nProof. Consider a (dis)subsumption s ∈ Γ̂ and assume that σS solves all s ′ ∈ Γ̂ with s ′ ≺ s. Since s is solved, either it has been solved by a rule application or it was initially solved.\nIf s is a dissubsumption that is initially solved, then s = X 6⊑? D, where X is a variable and D a non-variable atom. By expansion, for every E ∈ SX , we have sE = E 6⊑\n? D ∈ Γ̂. We know that s ≻ sE , because E may only contain a variable strictly smaller than X, and thus m1(s) > m1(sE). Hence by induction, σS solves all dissubsumptions sE with E ∈ SX . Since the top-level atoms of σS(X) are exactly those of the form σS(E) for E ∈ SX , by Lemma 2 we know that σS also solves s.\nIf s is a subsumption that is initially solved, then s = C1 ⊓ · · · ⊓ Cn ⊑ ? X,\nwhere X is a variable. By expansion, for every E ∈ SX , there is a subsumption sE = C1 ⊓ · · · ⊓ Cn ⊑\n? E in Γ̂. We have sE ≺ s since m1(sE) < m1(s), for every E ∈ SX . Hence, by induction all subsumptions sE are solved by σS . By the definition of σS(X) and Lemma 1, σS solves s.\nIf s was solved by a rule application, we consider which rule was applied.\n• Eager Ground Solving: Then s is ground and holds under any substitution.\n• Eager Solving: Since this rule fails for all dissubsumptions to which it is applicable, but we assumed that the run was successful, we have s = C1 ⊓ · · · ⊓ Cn ⊑ ? D\nand σS(D) occurs on the top-level of σS(C1)⊓ · · · ⊓σS(Cn). Hence, σS solves the subsumption.\n• (Eager) Extension: Then s = X⊓C1⊓· · ·⊓Cn ⊑ ? D for a variable X and D ∈ SX .\nBy the definition of σS, we have σS(X) ⊑ σS(D) and thus σS solves s.\n• Eager Top Solving: This rule cannot have been applied since we assumed the run to be successful.\n• Eager Left Decomposition: Then either s = C1 ⊓ · · · ⊓ Cn 6⊑ ? D with n > 1,\nor s = ⊤ 6⊑? D, for a non-variable atom D. In the latter case, σS solves s by Lemma 2. In the former case, for each i ∈ {1, . . . , n} we have si := Ci 6⊑\n? D ∈ Γ̂. Notice that m1(s) ≥ m1(si) and m2(s) > m2(si) and hence s ≻ si. Thus, by induction we have that σS(Ci) 6⊑ σS(D). By applying Lemma 2 twice, we conclude that σS(C1) ⊓ · · · ⊓ σS(Cn) 6⊑ σS(D).\n• Eager Atomic Decomposition: Then s = C 6⊑? D, where C and D are non-variable atoms. Since we assume that the run was successful, Case a) cannot apply. In\nCases b)–d), σS must solve s by Lemma 3. Finally, in Case e), we have C = ∃r.C ′, D = ∃r.D′, and s′ = C ′ 6⊑? D′ ∈ Γ̂. Notice that s ≻ s′, because m1(s) = m1(s ′) and m2(s) > m2(s ′). Hence, by induction we get σS(C ′) 6⊑ σS(D ′) and thus σS(C) 6⊑ σS(D) by Lemma 3. • Decomposition: Then s = C1 ⊓ · · · ⊓ Cn ⊑ ? ∃s.D with Ci = ∃s.C for some\ni ∈ {1, . . . , n} and we have s′ = C ⊑? D ∈ Γ̂. We know that s′ ≺ s, because m1(s ′) ≤ m1(s) and m2(s ′) < m2(s). By induction, we get σS(C) ⊑ σS(D), and hence σS solves s. • Local Extension: Then s = C1 ⊓ · · · ⊓ Cn 6⊑ ? X and there is a non-variable atom\nD ∈ SX such that s ′ = C1 ⊓ · · · ⊓Cn 6⊑ ? D ∈ Γ̂. We have s ≻ s′, because D may only contain a variable strictly smaller than X, and thus m1(s) > m1(s\n′). Hence by induction, σ solves s′. Since σS(D) is a top-level atom of σS(X), σS solves s by Lemma 2.\n5.3. Completeness. Assume now that Γ0 has a local solution σ. We show that σ can guide the choices of Algorithm 11 to obtain a local solution σ′ of Γ0 such that, for every variable X, we have σ(X) ⊑ σ′(X). The following invariants will be maintained throughout the run of the algorithm for the current set of (dis)subsumptions Γ and the current assignment S:\n(I) σ is a solution of Γ.\n(II) For each D ∈ SX , we have σ(X) ⊑ σ(D).\nBy Lemma 1, chains of the form σ(X1) ⊑ σ(∃r1.X2), . . .σ(Xn−1) ⊑ σ(∃rn−1.Xn) with X1 = Xn are impossible, and thus invariant (II) implies that S is acyclic. Hence, if extending S during a rule application preserves this invariant, this extension will not cause the algorithm to fail.\nLemma 15. The invariants are maintained by the operation of expanding Γ.\nProof. Since expansion does not affect the assignment S, we have to check only invariant (I). Consider a subsumption s = C1 ⊓ · · · ⊓ Cn ⊑\n? X in Γ, for which a new subsumption sE = C1 ⊓ · · · ⊓ Cn ⊑\n? E is created because E ∈ SX . By the invariants, σ solves s and σ(X) ⊑ σ(E). Hence by transitivity of subsumption, σ also solves sE, i.e. invariant (I) is satisfied after adding sE to Γ.\nFor a dissubsumption s = X 6⊑? D ∈ Γ and E ∈ SX , a new dissubsumption sE = E 6⊑\n? D is created. Since σ solves s and σ(X) ⊑ σ(E) by invariant (II), we have σ(E) 6⊑ σ(D) by transitivity of subsumption, i.e. σ solves sE .\nNow we show that if the invariants are satisfied, the eager rules maintain the invariants and do not lead to failure.\nLemma 16. The application of an eager rule never fails and maintains the invariants.\nProof. There are six eager rules to consider:\n• Eager Ground Solving: By invariant (I), σ solves all ground (dis)subsumptions in Γ, and thus they must be valid. Therefore the rule cannot fail, and obviously it preserves the invariants.\n• Eager Solving: The rule does not affect the invariants. It could fail only in the case that Γ contains a dissubsumption s = C1 ⊓ · · · ⊓ Cn 6⊑\n? D for which there exists an index i ∈ {1, . . . , n} such that Ci = D or Ci is a variable and D ∈ SCi . By invariant (I) and Lemma 1, the former case is impossible. In the latter case, invariant (II) similarly yields a contradiction to invariant (I).\n• Eager Extension: Consider any C1 ⊓ · · · ⊓ Cm ⊑ ? D ∈ Γ such that there is an\nindex i ∈ {1, . . . , n} with Ci = X ∈ Var and {C1, . . . , Cm} \\ {X} ⊆ SX . By the invariants and Lemma 1, we have σ(X) ⊑ σ(C1)⊓ · · ·⊓σ(Cm) ⊑ σ(D), and thus adding D to SX maintains invariant (II). Therefore, the application of the rule does not cause S to be cyclic, and does not fail. Invariant (I) is not affected by this rule.\n• Eager Top Solving: By invariant (I), this rule will never be applied since σ(C) 6⊑? ⊤ is impossible by Lemma 2.\n• Eager Left Decomposition: This rule never fails. Furthermore, S is not affected by the rule, and hence invariant (I) is preserved. Finally, if σ solves C1⊓· · ·⊓Cn 6⊑\n? D, then it must also solve Ci 6⊑ ? D for each i ∈ {1, . . . , n} by Lemma 2.\n• Eager Atomic Decomposition: Case a) cannot apply since σ is a solution of Γ. Invariant (II) is not affected, because S is not changed by these rules. The fact that invariant (I) is maintained in Case e) follows from Lemma 3.\nNow we show that the nondeterministic rules can be applied in such a way that the invariants are maintained and the application does not lead to failure.\nLemma 17. If s is an unsolved (dis)subsumption of Γ to which no eager rule applies, then there is a nondeterministic rule that can be successfully applied to s while maintaining the invariants.\nProof. If s is an unsolved subsumption, then it is of the form C1 ⊓ · · · ⊓ Cn ⊑ ? D, where D is a non-variable atom. By invariant (I), we have σ(C1)⊓· · ·⊓σ(Cn) ⊑ σ(D). By Lemma 1, there is an index i ∈ {1, . . . , n} and a top-level atom E of σ(Ci) such that E ⊑ σ(D).\n• If Ci is a constant, then by Lemma 1 we have Ci = E = D, and thus Eager Solving is applicable, which contradicts the assumption.\n• If Ci = ∃r.C ′, then σ(Ci) = ∃r.σ(C ′) = E and by Lemma 1 we must have D = ∃r.D′ and σ(C ′) ⊑ σ(D′). Thus, the Decomposition rule can be successfully applied to s and results in a new subsumption C ′ ⊑? D′ that is solved by σ.\n• If Ci is a variable, then invariant (II) is preserved by adding D to SCi since σ(Ci) ⊑ E ⊑ σ(D). Thus, we can successfully apply the Extension rule to s.\nIf s is an unsolved dissubsumption, then it must be of the form C1⊓· · ·⊓Cn 6⊑ ? X since otherwise one of the eager rules in Figure 3 would be applicable to it. We have σ(C1)⊓· · ·⊓σ(Cn) 6⊑ σ(X) by invariant (I). By Lemma 2, there is a top-level atom E\nof σ(X) such that σ(C1)⊓ · · · ⊓ σ(Cn) 6⊑ E. Since σ is local, we must have E = σ(D) for some D ∈ Atnv. Hence, adding D to SX maintains invariant (II), and adding C1 ⊓ · · · ⊓ Cn 6⊑\n? D to Γ maintains invariant (I). Thus, we can successfully apply the Local Extension rule to s.\nThis concludes the proof of correctness of Algorithm 11. Moreover, together with Lemma 8, we obtain an alternative proof of Fact 3.1.\nTheorem 18. The flat disunification problem Γ0 has a local solution iff there is a successful run of Algorithm 11 on Γ0.\nWe have restricted the nondeterministic choices of Algorithm 11 in such way that non-variable atoms are only added to the assignment S if this is necessary to directly solve some (dis)subsumption in Γ. Hence, the algorithm cannot be used to compute all local solutions of Γ, but already selects the more “interesting” ones. As described in the introduction, further dissubsumptions of the form X 6⊑? D with X ∈ Var and D ∈ Atnv can be added to Γ in order to further restrict the solution space."
    }, {
      "heading" : "6. Encoding local disunification into SAT",
      "text" : "In the following, we consider an alternative algorithm for local disunification that is based on a polynomial encoding into a SAT problem. This reduction is a generalization of the one developed for unification problems in [2]. We again consider a flat disunification problem Γ and the sets At, Var, and Atnv as in Section 3. Since we are restricting our considerations to local solutions, we can without loss of generality assume that the sets Nv, Nc, and NR contain exactly the variables, constants, and role names occurring in Γ. To further simplify the reduction, we assume in the following that all flat dissubsumptions in Γ are of the form X 6⊑? Y for variables X, Y . This is without loss of generality, which can be shown using a transformation similar to that of Section 3.2. The translation uses the propositional variables [C ⊑ D] for all C,D ∈ At. The SAT problem consists of a set of clauses Cl(Γ) over these variables that express properties of (dis)subsumption in EL and encode the elements of Γ. The intuition is that a satisfying valuation of Cl(Γ) induces a local solution σ of Γ such that σ(C) ⊑ σ(D) holds whenever [C ⊑ D] is true under the valuation. The solution σ is constructed by first extracting an acyclic assignment S out of the satisfying valuation and then computing σ := σS. We additionally introduce the variables [X > Y ] for all X, Y ∈ Nv to ensure that the generated assignment S is indeed acyclic. This is achieved by adding clauses to Cl(Γ) that express that >S is a strict partial order, i.e. irreflexive and transitive. We further use the auxiliary variables pC,X,D for all X ∈ Nv, C ∈ At, and D ∈ Atnv to express the restrictions imposed by dissubsumptions of the form C 6⊑? X in clausal form. More precisely, whenever [C ⊑ X ] is false for some X ∈ Nv and C ∈ At, then the dissubsumption σ(C) 6⊑ σ(X) should hold. By Lemma 2, this means that we need to find an atom D ∈ Atnv that is a top-level atom of σ(X) and satisfies σ(C) 6⊑ σ(D).\nThis is enforced by making the auxiliary variable pC,X,D true, which makes [X ⊑ D] true and [C ⊑ D] false (see Definition 19(IV) and Lemma 22 for details). To denote propositional clauses, we use the implicative form φ → ψ, where φ is the conjunction of all negative literals of the clause, and ψ is the disjunction of all positive literals. We use ⊤ to denote an empty conjunction, and ⊥ for an empty disjunction.\nDefinition 19. The set Cl(Γ) contains the following propositional clauses:\n(I) Translation of Γ. a. For every subsumption C1 ⊓ · · · ⊓ Cn ⊑ ? D in Γ with D ∈ Atnv:\n⊤ → [C1 ⊑ D] ∨ · · · ∨ [Cn ⊑ D]\nb. For every subsumption C1 ⊓ · · · ⊓ Cn ⊑ ? X in Γ with X ∈ Nv, and every\nE ∈ Atnv:\n[X ⊑ E] → [C1 ⊑ E] ∨ · · · ∨ [Cn ⊑ E]\nc. For every dissubsumption X 6⊑? Y in Γ: [X ⊑ Y ] → ⊥\n(II) Properties of subsumptions between non-variable atoms. a. For every A ∈ Nc: ⊤ → [A ⊑ A]\nb. For every A,B ∈ Nc with A 6= B: [A ⊑ B] → ⊥\nc. For every ∃r.A, ∃s.B ∈ Atnv with r 6= s: [∃r.A ⊑ ∃s.B] → ⊥\nd. For every A ∈ Nc and ∃r.B ∈ Atnv:\n[A ⊑ ∃r.B] → ⊥ and [∃r.B ⊑ A] → ⊥\ne. For every ∃r.A, ∃r.B ∈ Atnv:\n[∃r.A ⊑ ∃r.B] → [A ⊑ B] and [A ⊑ B] → [∃r.A ⊑ ∃r.B]\n(III) Transitivity of subsumption. For every C1, C2, C3 ∈ At: [C1 ⊑ C2] ∧ [C2 ⊑ C3] → [C1 ⊑ C3] (IV) Dissubsumptions of the form C 6⊑? X with a variable X. For every C ∈ At, X ∈ Nv:\n⊤ → [C ⊑ X ] ∨ ∨\nD∈Atnv\npC,X,D,\nand additionally for every D ∈ Atnv:\npC,X,D → [X ⊑ D] and pC,X,D ∧ [C ⊑ D] → ⊥\n(V) Properties of >. a. For every X ∈ Nv: [X > X ] → ⊥\nb. For every X, Y, Z ∈ Nv: [X > Y ] ∧ [Y > Z] → [X > Z]\nc. For every X, Y ∈ Nv and ∃r.Y ∈ At: [X ⊑ ∃r.Y ] → [X > Y ]\nThe main difference to the encoding in [2] lies in the clauses (IV) that ensure the presence of a non-variable atom D that solves the dissubsumption C 6⊑? X (cf. Lemma 2). We also need some additional clauses in (II) to deal with dissubsumptions.\nIt is easy to see that Cl(Γ) can be constructed in time cubic in the size of Γ (due to the clauses in (III) and (V)b). We prove the correctness of this reduction in the following two sections.\n6.1. Soundness. Let τ be a valuation of the propositional variables that satisfies Cl(Γ). We define the assignment Sτ as follows:\nSτX := {D ∈ Atnv | τ([X ⊑ D]) = 1}.\nWe show the following property of >Sτ ; the proof is exactly the same as in [2], but uses a different notation.\nLemma 20. The relation >Sτ is irreflexive.\nProof. We first show that X >Sτ Y implies τ([X > Y ]) = 1 for all X, Y ∈ Nv. If Y occurs in an atom of SτX , then this atom must be of the form ∃r.Y with r ∈ NR. By construction of Sτ , this implies that τ([X ⊑ ∃r.Y ]) = 1. Since τ satisfies the clauses in (V)c, we have τ([X > Y ]) = 1. By definition of >Sτ and the transitivity clauses in (V)b, we conclude that τ([X > Y ]) = 1 whenever X >Sτ Y .\nAssume now that X >Sτ X holds for some X ∈ Nv. By the claim above, this implies that τ([X > X ]) = 1. But this is impossible since τ satisfies the clauses in (V)a.\nThis in particular shows that Sτ is acyclic. In the following, let στ denote the substitution σSτ induced by S τ . We show that στ is a solution of Γ.\nLemma 21. If C,D ∈ At such that τ([C ⊑ D]) = 1, then στ (C) ⊑ στ (D).\nProof. We show this by induction on the pairs (rd(στ (D)),Var(D)), where Var(D) is either the variable that occurs in D, or ⊥ if D is ground. These pairs are compared by the lexicographic extension of the order > on natural numbers for the first component and the order >Sτ for the second component, which is extended by Y >Sτ ⊥ for all Y ∈ Nv.\nWe make a case distinction on the form of C and D and consider first the case that D is a variable. Let στ (E) be any top-level atom of στ (D), which means that τ([D ⊑ E]) = 1. By the clauses in (III), we also have τ([C ⊑ E]) = 1. Since rd(στ (D)) ≥ rd(στ (E)) and Var(D) = D >Sτ Var(E), by induction we get στ (C) ⊑ στ (E). Since στ (D) is equivalent to the conjunction of all its top-level atoms, by Lemma 1 we obtain στ (C) ⊑ στ (D).\nIf D is a non-variable atom and C is a variable, then στ (C) ⊑ στ (D) holds by construction of Sτ and Lemma 1.\nIf C,D are both non-variable atoms, then by the clauses in (II) they must either be the same concept constant, or be existential restrictions using the same role name. In the first case, the claim follows immediately. In the latter case, let C = ∃r.C ′ and D = ∃r.D′. By the clauses in (II)e, we have τ([C ′ ⊑ D′]) = 1. Since rd(στ (D)) > rd(στ (D ′)), by induction we get στ (C ′) ⊑ στ (D\n′), and thus στ (C) ⊑ στ (D) by Lemma 1.\nWe now show that the converse of this lemma also holds.\nLemma 22. If C,D ∈ At such that τ([C ⊑ D]) = 0, then στ (C) 6⊑ στ (D).\nProof. We show this by induction on the tuples (rd(στ (C)),Var(C),Var(D)) and make a case distinction on the form of C and D. If D is a variable, then by the clauses in (IV) there must be a D′ ∈ Atnv such that τ(pC,D,D′) = 1. This implies that τ([D ⊑ D′]) = 1 and τ([C ⊑ D′]) = 0. By construction of Sτ , στ (D\n′) is a toplevel atom of στ (D) and Var(D) >Sτ Var(D\n′). Since rd(στ (C)) = rd(στ (C)) and Var(C) = Var(C), by induction we get στ (C) 6⊑ στ (D\n′), and thus στ (C) 6⊑ στ (D) by Lemma 2.\nIf D is a non-variable atom and C is a variable, then consider any top-level atom στ (E) of στ (C), which means that we have τ([C ⊑ E]) = 1. By the clauses in (III) this implies that τ([E ⊑ D]) = 0. Since we have rd(στ (C)) ≥ rd(στ (E)) and Var(C) = C >Sτ Var(E), by induction we get στ (E) 6⊑ στ (D). Since στ (C) is equivalent to the conjunction of all its top-level atoms, by Lemma 2 we get στ (C) 6⊑ στ (D). If C,D are both non-variable atoms, then by the clauses in (II), they are either different constants, a constant and an existential restriction, or two existential restrictions. In the first two cases, στ (C) 6⊑ στ (D) holds by Lemma 1. In the last case, they can either contain two different roles or the same role. Again, the former case is covered by Lemma 1, while in the latter case we have C = ∃r.C ′, D = ∃r.D′, and τ([C ′ ⊑ D′]) = 0 by the clauses in (II)e. Since rd(στ (C)) > rd(στ (C\n′)), by induction we get στ (C ′) 6⊑ στ (D ′), and thus στ (C) 6⊑ στ (D) by Lemma 2.\nThis suffices to show soundness of the reduction.\nLemma 23. The local substitution στ solves Γ.\nProof. Consider any flat subsumption C1 ⊓ · · · ⊓ Cn ⊑ ? D in Γ. If D ∈ Atnv, then we have στ (Ci) ⊑ στ (D) for some i, 1 ≤ i ≤ n, by the clauses in (I) and Lemma 21. By Lemma 1, στ solves the subsumption.\nIf D is a variable, then consider any top-level atom στ (E) of στ (D), for which we must have τ([D ⊑ E]) = 1. By the clauses in (I), there must be an i, 1 ≤ i ≤ n, such that τ([Ci ⊑ E]) = 1, and thus στ (Ci) ⊑ στ (E) by Lemma 21. Again, by Lemma 1 this implies that στ solves the subsumption.\nFinally, consider a dissubsumption X 6⊑? Y in Γ. Then by the clauses in (I) and Lemma 22 we have στ (X) 6⊑ στ (Y ) i.e. στ solves the dissubsumption.\n6.2. Completeness. Let now σ be a ground local solution of Γ and >σ the resulting partial order on Nv, defined as follows for all X, Y ∈ Nv:\nX >σ Y iff σ(X) ⊑ ∃r1. . . .∃rn.σ(Y ) for some r1, . . . , rn ∈ NR with n ≥ 1.\nNote that >σ is irreflexive since X >σ X is impossible by Lemma 1, and it is transitive since ⊑ is transitive and closed under applying existential restrictions on both sides.\nThus, >σ is a strict partial order. We define a valuation τσ as follows for all C,D ∈ At, E ∈ Atnv, and X, Y ∈ Nv:\nτσ([C ⊑ D]) :=\n{\n1 if σ(C) ⊑ σ(D)\n0 otherwise\nτσ(pC,X,E) :=\n{\n1 if σ(X) ⊑ σ(E) and σ(C) 6⊑ σ(E)\n0 otherwise\nτσ([X > Y ]) :=\n{\n1 if X >σ Y\n0 otherwise\nLemma 24. The valuation τσ satisfies all clauses of Cl(Γ).\nProof. For (I)a, consider any flat subsumption C1⊓· · ·⊓Cn ⊑ ? D in Γ with D ∈ Atnv. Since σ solves Γ, we have σ(C1) ⊓ · · · ⊓ σ(Cn) ⊑ σ(D). Since σ(D) is an atom, by Lemma 1 there must be an i, 1 ≤ i ≤ n, and a top-level atom E of σ(Ci) such that σ(Ci) ⊑ E ⊑ σ(D). By the definition of τσ, this shows that τσ([Ci ⊑ D]) = 1, and thus the clause is satisfied.\nConsider now an arbitrary flat subsumption C1 ⊓ · · · ⊓Cn ⊑ ? X from Γ where X is a variable, and any E ∈ Atnv such that τσ([X ⊑ E]) = 1. This implies that we have σ(C1) ⊓ · · · ⊓ σ(Cn) ⊑ σ(X) ⊑ σ(E), and thus as above there is a top-level atom F of some σ(Ci) such that σ(Ci) ⊑ F ⊑ σ(E), which shows that τσ([Ci ⊑ E]) = 1, as required for the clause in (I)b.\nFor every dissubsumption X 6⊑? Y in Γ, we must have σ(X) 6⊑ σ(Y ), and thus τσ([X ⊑ Y ]) = 0, satisfying the clause in (I)c.\nFor A ∈ Nc, we have σ(A) ⊑ σ(A), and thus τσ([A ⊑ A]) = 1. Similar arguments show that the remaining clauses in (II) are also satisfied (see Lemma 1). For (III), consider C1, C2, C3 ∈ At with τσ([C1 ⊑ C2]) = τσ([C2 ⊑ C3]) = 1, and thus σ(C1) ⊑ σ(C2) ⊑ σ(C3). By transitivity of ⊑, we infer τσ([C1 ⊑ C3]) = 1.\nFor all C ∈ At, X ∈ Nv, and D ∈ Atnv with τσ(pC,X,D) = 1, we must have τσ([X ⊑ D]) = 1 and τσ([C ⊑ D]) = 0 by the definition of τσ. Furthermore, whenever τσ([C ⊑ X ]) = 0, we have σ(C) 6⊑ σ(X), and thus by Lemma 2 there must be a toplevel atom E of σ(X) such that σ(C) 6⊑ E. Since σ is a local solution, E must be of the form σ(F ) for some F ∈ Atnv, and thus we obtain σ(X) ⊑ σ(F ) and σ(C) 6⊑ σ(F ), and hence τσ(pC,X,F ) = 1. This shows that all clauses in (IV) are satisfied by τσ.\nFor (V)a, recall that >σ is irreflexive. Transitivity of >σ yields satisfaction of the clauses in (V)b. Finally, if σ(X) ⊑ σ(∃r.Y ) = ∃r.σ(Y ) for some X, Y ∈ Nv with ∃r.Y ∈ At, we have X >σ Y by definition, and thus the clauses in (V)c are satisfied by τσ.\nThis completes the proof of the correctness of the translation presented in Definition 19, which provides us with a reduction of local disunification (and thus also of dismatching) to SAT. Since the size of Cl(Γ) is polynomial in the size of Γ, we obtain yet another proof of Fact 3.1.\nTheorem 25. The flat disunification problem Γ has a local solution iff Cl(Γ) is satisfiable.\nRegarding the computation of actual solutions, we note that the definition of Sτ in Section 6.1 describes how to obtain local solutions of Γ from the satisfying valuations of Cl(Γ). From a syntactic point of view, this approach does not yield all local solutions. In fact, the transitivity clauses (III) may force us to add atoms to Sτ that are, syntactically, not necessary to solve Γ. Also note that different satisfying valuations τ may sometimes yield equivalent unifiers, because some atoms in the substitution στ (X) of a variable X may be subsumed by others. Nevertheless, we can show that, by applying the construction of Section 6.1 to the satisfying valuations of Cl(Γ), we obtain all local solutions of Γ modulo equivalence. We call two solutions σ and γ equivalent if σ(X) ≡ γ(X) holds for all X ∈ Nv.\nLemma 26. Let σ be a local solution of the flat disunification problem Γ. Then there is a satisfying valuation τ of Cl(Γ) such that σSτ is equivalent to σ.\nProof. Let S be the acyclic assignment underlying σ, τ := τσ be the satisfying valuation induced by σ as defined in Section 6.2, and Sτ and γ := σSτ be as defined in Section 6.1. We first show that SX ⊆ S τ X holds for all X ∈ Nv. To this end, consider any non-variable atom D ∈ SX . Since σ(D) is a top-level atom of σ(X), by Lemma 1 we have σ(X) ⊑ σ(D). Hence, the definitions of τ and Sτ yield that τ([X ⊑ D]) = 1 and D ∈ SτX , as required. We can now show by induction on the well-founded strict partial order >Sτ that σ(X) ≡ γ(X) holds for all X ∈ Nv. Assume that σ(Y ) ≡ γ(Y ) holds for all variables Y <Sτ X, and hence σ(D) ≡ γ(D) holds for all non-variable atoms D ∈ S τ X , including those in SX (it trivially holds if D is ground). Since σ(X) consists exactly of the toplevel atoms σ(D), D ∈ SX , and similarly γ(X) consists exactly of the top-level atoms γ(D), D ∈ SτX , we thus know that each top-level atom of σ(X) is equivalent to a toplevel atom of γ(X). Hence, γ(X) ⊑ σ(X) holds by Lemma 1. For the other direction, consider any top-level atom of γ(X), which must be of the form γ(D) with D ∈ SτX . By the definition of Sτ , we obtain τ([X ⊑ D]) = 1, which yields σ(X) ⊑ σ(D) by the definition of τ . Hence, there must be a top-level atom of σ(X) that is subsumed by γ(D) ≡ σ(D), and thus Lemma 1 yields σ(X) ⊑ γ(X).\nThe SAT reduction has been implemented in our prototype system UEL,5 which uses SAT4J6 as external SAT solver. First experiments show that disunification is indeed helpful for reducing the number and the size of solutions. For example, a slightly modified version of the example from the introduction has 128 solutions without any dissubsumptions (see [12] for more details). Each additional dissubsumption disallowing a particular non-variable atom in the assignments (e.g. the dissubsumption (1.3) from the introduction) roughly halves the number of remaining solutions. The runtime performance of the solver for local disunification problems is comparable to the one for pure unification problems, even on larger problems.\n5version 1.4.0, available at http://uel.sourceforge.net/ 6http://www.sat4j.org/"
    }, {
      "heading" : "7. Related work",
      "text" : "Since Description Logics and Modal Logics are closely related [32], results on unification in one of these two areas carry over to the other one. In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31]. An important open problem in the area is the question whether unification in the basic modal logic K, which corresponds to the DL ALC, is decidable. It is only known that relatively minor extensions of K have an undecidable unification problem [33]. Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30]. To be more precise, a normal modal logic L induces an equational theory EL that axiomatizes equivalence in this logic, where the formulas are viewed as terms. Validity is then just equivalence to ⊤ and inconsistency is equivalence to ⊥. An inference rule is of the form\nA1, . . . , Am B1, . . . , Bn (7.1)\nwhere A1, . . . , Bn are formulas (terms) that may contain variables. More precisely, it is not a single rule but a rule schema that stands for all its instances\nσ(A1), . . . , σ(Am) σ(B1), . . . , σ(Bn) (7.2)\nwhere σ is a substitution. The semantics of such a rule (7.2) is the following: whenever all of its premises are valid, then one of the consequences must be valid as well. We only admit the inference rule (7.1) for the logic L if all its instances (7.2) satisfy this requirement. Thus, we say that the inference rule (7.1) is admissible for L if\nσ(A1) =EL ⊤ ∧ . . . ∧ σ(Am) =EL ⊤ implies σ(B1) =EL ⊤ ∨ . . . ∨ σ(Bn) =EL ⊤\nfor all substitutions σ. Obviously, this is the case iff the disunification problem\n{A1 ≡ ? ⊤, . . . , Am ≡ ? ⊤, B1 6≡ ? ⊤, . . . , Bn 6≡ ? ⊤}\ndoes not have a solution. As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19–21]. As shown in [1], equivalence in EL can be axiomatized by the equational theory of semilattices with monotone functions, which extends the theory ACUI of an associative-commutativeidempotent binary function symbol ∗ (corresponding to ⊓) with unit (corresponding to ⊤) by unary function symbols hr (corresponding to ∃r) that are monotone in the sense that they satisfy the identities hr(x) ∗ hr(x ∗ y) = hr(x ∗ y). Perhaps the closest to our present work is thus the investigation of disunification in ACUI with free function symbols (i.e., additional function symbols of arbitrary arity that satisfy no non-trivial identities). This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28]. To be more precise, the NP upper bound is shown in [7] for the theory ACI with free function symbols, using general combination results for disunification developed in the same article. However, it is easy to see that the approach applied in [7] also\nworks for ACUI. In contrast, the NP upper bound in [22] is shown for ACUI with free function symbols by directly designing a dedicated algorithm for disunification in this theory."
    }, {
      "heading" : "8. Conclusions",
      "text" : "We have considered disunification in the description logic EL. While the complexity of the general problem remains open, we have identified two restrictions under which the complexity does not increase when compared to plain unification in EL, i.e. remains in NP. We developed a nondeterministic polynomial reduction from dismatching problems to local disunification problems, and presented two algorithms to solve the latter. These procedures extend known algorithms for unification in EL without a large negative impact on their performance. Regarding future work, we want to investigate the decidability and complexity of general disunification in EL, and consider also the case where non-ground solutions are allowed. In contrast to unification, these extensions make the problem harder to solve. From a more practical point of view, we plan to implement also the goaloriented algorithm for local disunification, and to evaluate the performance of both presented algorithms on real-world problems. In addition, we will investigate whether a reduction to answer set programming (ASP) [17, 23] rather than SAT leads to a better performance."
    }, {
      "heading" : "37–47, 2012.",
      "text" : "[15] Franz Baader, Stefan Borgwardt, and Barbara Morawska. Dismatching and local disunification in EL. In Maribel Fernández, editor, Proc. of the 26th Int. Conf. on Rewriting Techniques and Applications (RTA’15), volume 36 of Leibniz International Proceedings in Informatics, pages 40–56. Dagstuhl Publishing, 2015. doi:10.4230/LIPIcs.RTA.2015.40. [16] Sergey Babenyshev, Vladimir V. Rybakov, Renate Schmidt, and Dmitry Tishkovsky. A tableau method for checking rule admissibility in S4. In Proc. of the 6th Workshop on Methods for Modalities (M4M-6), 2009. [17] Chitta Baral. Knowledge Representation, Reasoning and Declarative Problem Solving. Cambridge University Press, 2003.\n[18] Sebastian Brandt. Polynomial time reasoning in a description logic with existential restrictions, GCI axioms, and—what else? In Ramon López de Mántaras and Lorenza Saitta, editors, Proc. of the 16th Eur. Conf. on Artificial Intelligence (ECAI’04), pages 298–302. IOS Press, 2004. [19] W. L. Buntine and H.-J. Bürckert. On solving equations and disequations. Journal of the ACM, 41(4):591–629, 1994. doi:10.1145/179812.179813. [20] H. Comon. Disunification: A survey. In J.-L. Lassez and G. Plotkin, editors, Computational Logic: Essays in Honor of Alan Robinson, pages 322–359. MIT Press, Cambridge, MA, 1991. [21] Hubert Comon and Pierre Lescanne. Equational problems and disunification. Journal of Logic and Computation, 7(3/4):371–425, 1989. doi:10.1016/S0747-7171(89)80017-3. [22] Agostino Dovier, Carla Piazza, and Enrico Pontelli. Disunification in ACI1 theories. Constraints, 9(1):35–91, 2004. doi:10.1023/B:CONS.0000006182.84033.6e. [23] Michael Gelfond and Vladimir Lifschitz. The stable model semantics for logic programming. In Robert A. Kowalski and Kenneth A. Bowen, editors, Proc. of the 5th Int. Conf. and Symp. on Logic Programming (ICLP’88), pages 1070–1080. MIT Press, 1988. [24] Silvio Ghilardi. Unification through projectivity. Journal of Logic and Computation, 7(6):733–752, 1997. doi:10.1093/logcom/7.6.733. [25] Silvio Ghilardi. Unification in intuitionistic logic. Journal of Symbolic Logic, 64 (2):859–880, 1999. doi:10.2307/2586506. [26] Ian Horrocks, Peter F. Patel-Schneider, and Frank van Harmelen. From SHIQ and RDF to OWL: The making of a web ontology language. Journal of Web Semantics, 1(1):7–26, 2003. doi:10.1016/j.websem.2003.07.001. [27] Rosalie Iemhoff and George Metcalfe. Proof theory for admissible rules. Annals of Pure and Applied Logic, 159(1-2):171–186, 2009. doi:10.1016/j.apal.2008.10.011. [28] Deepak Kapur and Paliath Narendran. Complexity of unification problems with associative-commutative operators. Journal of Automated Reasoning, 9:261–288, 1992. doi:10.1007/BF00245463. [29] Ralf Küsters. Chapter 6: Matching. In Non-Standard Inferences in Description Logics, volume 2100 of Lecture Notes in Computer Science, pages 153–227. Springer-Verlag, 2001. doi:10.1007/3-540-44613-3_6. [30] Vladimir V. Rybakov. Admissibility of logical inference rules, volume 136 of Studies in Logic and the Foundations of Mathematics. North-Holland Publishing Co., Amsterdam, 1997. [31] Vladimir V. Rybakov. Multi-modal and temporal logics with universal formula - reduction of admissibility to validity and unification. Journal of Logic and Computation, 18(4):509–519, 2008. doi:10.1093/logcom/exm078. [32] Klaus Schild. A correspondence theory for terminological logics: Preliminary report. In John Mylopoulos and Raymond Reiter, editors, Proc. of the 12th Int. Joint Conf. on Artificial Intelligence (IJCAI’91), pages 466–471. Morgan Kaufmann, 1991.\n[33] Frank Wolter and Michael Zakharyaschev. Undecidability of the unification and admissibility problems for modal and description logics. ACM Transactions on Computational Logic, 9(4):25:1–25:20, 2008. doi:10.1145/1380572.1380574."
    } ],
    "references" : [ {
      "title" : "Unification in the description logic EL",
      "author" : [ "Franz Baader", "Barbara Morawska" ],
      "venue" : "Logical Methods in Computer Science,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2010
    }, {
      "title" : "SAT encoding of unification in EL",
      "author" : [ "Franz Baader", "Barbara Morawska" ],
      "venue" : "Proc. of the 17th Int. Conf. on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR’10),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "Matching with respect to general concept inclusions in the description logic EL",
      "author" : [ "Franz Baader", "Barbara Morawska" ],
      "venue" : "Proc. of the 37th German Conf. on Artificial Intelligence (KI’14),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "Unification of concept terms in description logics",
      "author" : [ "Franz Baader", "Paliath Narendran" ],
      "venue" : "J. of Symbolic Computation,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2001
    }, {
      "title" : "Term Rewriting and All That",
      "author" : [ "Franz Baader", "Tobias Nipkow" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1999
    }, {
      "title" : "Solving language equations and disequations with applications to disunification in description logics and monadic set constraints",
      "author" : [ "Franz Baader", "Alexander Okhotin" ],
      "venue" : "Proc. of the 18th Int. Conf. on Logic for Programming, Artifical Intelligence, and Reasoning (LPAR’12),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2012
    }, {
      "title" : "Combination techniques and decision problems for disunification",
      "author" : [ "Franz Baader", "Klaus U. Schulz" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1995
    }, {
      "title" : "Matching in description logics",
      "author" : [ "Franz Baader", "Ralf Küsters", "Alex Borgida", "Deborah L. McGuinness" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1999
    }, {
      "title" : "Computing least common subsumers in description logics with existential restrictions",
      "author" : [ "Franz Baader", "Ralf Küsters", "Ralf Molitor" ],
      "venue" : "Proc. of the 16th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1999
    }, {
      "title" : "The Description Logic Handbook: Theory, Implementation, and Applications",
      "author" : [ "Franz Baader", "Diego Calvanese", "Deborah McGuinness", "Daniele Nardi", "Peter F. Patel-Schneider", "editors" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2003
    }, {
      "title" : "Pushing the EL envelope further",
      "author" : [ "Franz Baader", "Sebastian Brandt", "Carsten Lutz" ],
      "venue" : "Proc. of the 4th Int. Workshop on OWL: Experiences and Directions (OWLED’08DC),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2008
    }, {
      "title" : "UEL: Unification solver for EL",
      "author" : [ "Franz Baader", "Stefan Borgwardt", "Julian Alfredo Mendez", "Barbara Morawska" ],
      "venue" : "Proc. of the 25th Int. Workshop on Description Logics (DL’12),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    }, {
      "title" : "Computing minimal EL-unifiers is hard",
      "author" : [ "Franz Baader", "Stefan Borgwardt", "Barbara Morawska" ],
      "venue" : "Proc. of the 9th Int. Conf. on Advances in Modal Logic (AiML’12),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "A goal-oriented algorithm for unification in EL w.r.t. cycle-restricted TBoxes",
      "author" : [ "Franz Baader", "Stefan Borgwardt", "Barbara Morawska" ],
      "venue" : "Proc. of the 25th Int. Workshop on Description Logics (DL’12),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2012
    }, {
      "title" : "Dismatching and local disunification in EL",
      "author" : [ "Franz Baader", "Stefan Borgwardt", "Barbara Morawska" ],
      "venue" : "Proc. of the 26th Int. Conf. on Rewriting Techniques and Applications (RTA’15),",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2015
    }, {
      "title" : "A tableau method for checking rule admissibility in S4",
      "author" : [ "Sergey Babenyshev", "Vladimir V. Rybakov", "Renate Schmidt", "Dmitry Tishkovsky" ],
      "venue" : "In Proc. of the 6th Workshop on Methods for Modalities",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "Chitta Baral" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2003
    }, {
      "title" : "Polynomial time reasoning in a description logic with existential restrictions, GCI axioms, and—what else",
      "author" : [ "Sebastian Brandt" ],
      "venue" : "Proc. of the 16th Eur. Conf. on Artificial Intelligence",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2004
    }, {
      "title" : "On solving equations and disequations",
      "author" : [ "W.L. Buntine", "H.-J. Bürckert" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1994
    }, {
      "title" : "Disunification: A survey",
      "author" : [ "H. Comon" ],
      "venue" : "Computational Logic: Essays in Honor of Alan Robinson,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1991
    }, {
      "title" : "Equational problems and disunification",
      "author" : [ "Hubert Comon", "Pierre Lescanne" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1989
    }, {
      "title" : "Disunification in ACI1",
      "author" : [ "Agostino Dovier", "Carla Piazza", "Enrico Pontelli" ],
      "venue" : "theories. Constraints,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2004
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "Michael Gelfond", "Vladimir Lifschitz" ],
      "venue" : "Proc. of the 5th Int. Conf. and Symp. on Logic Programming",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1988
    }, {
      "title" : "Unification through projectivity",
      "author" : [ "Silvio Ghilardi" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1997
    }, {
      "title" : "Unification in intuitionistic logic",
      "author" : [ "Silvio Ghilardi" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1999
    }, {
      "title" : "From SHIQ and RDF to OWL: The making of a web ontology language",
      "author" : [ "Ian Horrocks", "Peter F. Patel-Schneider", "Frank van Harmelen" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2003
    }, {
      "title" : "Proof theory for admissible rules",
      "author" : [ "Rosalie Iemhoff", "George Metcalfe" ],
      "venue" : "Annals of Pure and Applied Logic,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2009
    }, {
      "title" : "Complexity of unification problems with associative-commutative operators",
      "author" : [ "Deepak Kapur", "Paliath Narendran" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1992
    }, {
      "title" : "Non-Standard Inferences in Description Logics, volume 2100 of Lecture Notes in Computer Science, pages 153–227",
      "author" : [ "Ralf Küsters" ],
      "venue" : null,
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2001
    }, {
      "title" : "Admissibility of logical inference rules, volume 136 of Studies in Logic and the Foundations of Mathematics",
      "author" : [ "Vladimir V. Rybakov" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1997
    }, {
      "title" : "Multi-modal and temporal logics with universal formula - reduction of admissibility to validity and unification",
      "author" : [ "Vladimir V. Rybakov" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2008
    }, {
      "title" : "A correspondence theory for terminological logics: Preliminary report",
      "author" : [ "Klaus Schild" ],
      "venue" : "Proc. of the 12th Int. Joint Conf. on Artificial Intelligence",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 1991
    }, {
      "title" : "Undecidability of the unification and admissibility problems for modal and description logics",
      "author" : [ "Frank Wolter", "Michael Zakharyaschev" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Description logics (DLs) [10] are a family of logic-based knowledge representation formalisms, which can be used to represent the conceptual knowledge of an application domain in a structured and formally well-understood way.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 25,
      "context" : "They are employed in various application areas, but their most notable success so far is the adoption of the DL-based language OWL [26] as standard ontology language for the semantic web.",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 17,
      "context" : "C), and the top concept (⊤), has drawn considerable attention in the last decade since, on the one hand, important inference problems such as the subsumption problem are polynomial in EL, even with respect to expressive terminological axioms [18].",
      "startOffset" : 242,
      "endOffset" : 246
    }, {
      "referenceID" : 10,
      "context" : "For these reasons, the most recent OWL version, OWL2, contains the profile OWL2EL, which is based on a maximally tractable extension of EL [11].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 3,
      "context" : "Unification in Description Logics was introduced in [4] as a novel inference service that can be used to detect redundancies in ontologies.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 0,
      "context" : "In [1], we were able to show that unification in EL is of considerably lower complexity than unification in FL0: the decision problem for EL is NP-complete.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "for obtaining a more efficient unification algorithm is a translation to satisfiability in propositional logic (SAT): in [2] it is shown how a given EL-unification problem Γ can be translated in polynomial time into a propositional formula whose satisfying valuations correspond to the local unifiers of Γ.",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 12,
      "context" : "In [13] we propose to restrict the attention to so-called minimal unifiers, which form a subset of all local unifiers.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 12,
      "context" : "In addition, as shown in [13], computing minimal unifiers is actually harder than computing local unifiers (unless the polynomial hierarchy collapses).",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "Unification and disunification in DLs is actually a special case of unification and disunification modulo equational theories (see [4] and [1] for the equational theories respectively corresponding to FL0 and EL).",
      "startOffset" : 131,
      "endOffset" : 134
    }, {
      "referenceID" : 0,
      "context" : "Unification and disunification in DLs is actually a special case of unification and disunification modulo equational theories (see [4] and [1] for the equational theories respectively corresponding to FL0 and EL).",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 18,
      "context" : ", been investigated in [19, 20].",
      "startOffset" : 23,
      "endOffset" : 31
    }, {
      "referenceID" : 19,
      "context" : ", been investigated in [19, 20].",
      "startOffset" : 23,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "Unfortunately, for FL0 and EL, this approach is not feasible since the corresponding equational theories have unification type zero [1, 4],",
      "startOffset" : 132,
      "endOffset" : 138
    }, {
      "referenceID" : 3,
      "context" : "Unfortunately, for FL0 and EL, this approach is not feasible since the corresponding equational theories have unification type zero [1, 4],",
      "startOffset" : 132,
      "endOffset" : 138
    }, {
      "referenceID" : 5,
      "context" : "Nevertheless, it was shown in [6] that the approach used in [4] to decide unification (reduction to language equations, which are then solved using tree automata) can be adapted such that it can also deal with disunification.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 3,
      "context" : "Nevertheless, it was shown in [6] that the approach used in [4] to decide unification (reduction to language equations, which are then solved using tree automata) can be adapted such that it can also deal with disunification.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "On the other hand, we develop two specialized algorithms to solve local disunification problems that extend the ones for unification [1, 2]: a goal-oriented algorithm that reduces the amount of nondeterministic guesses necessary to find a local solution, as well as a translation to SAT.",
      "startOffset" : 133,
      "endOffset" : 139
    }, {
      "referenceID" : 1,
      "context" : "On the other hand, we develop two specialized algorithms to solve local disunification problems that extend the ones for unification [1, 2]: a goal-oriented algorithm that reduces the amount of nondeterministic guesses necessary to find a local solution, as well as a translation to SAT.",
      "startOffset" : 133,
      "endOffset" : 139
    }, {
      "referenceID" : 11,
      "context" : "The reason we present two kinds of algorithms is that, in the case of unification, they have proved to complement each other well in first evaluations [12]: the goaloriented algorithm needs less memory and finds minimal solutions faster, while the SAT reduction generates larger data structures, but outperforms the goal-oriented algorithm on unsolvable problems.",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 14,
      "context" : "This is an extended version of the conference paper [15].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 8,
      "context" : "Subsumption in EL is decidable in polynomial time [9] and can be checked by recursively comparing the top-level atoms of the two concept terms.",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "Lemma 1 ([1]).",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 19,
      "context" : "We define a quite general notion of disunification problems that is similar to the equational formulae used in [20].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 18,
      "context" : "In contrast to unification, in disunification it does make a difference whether or not solutions may contain variables from Nv∩Σ or additional symbols from (NC∪NR)\\Σ [19].",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 0,
      "context" : "This restriction is without loss of generality: to flatten concept terms, one can simply introduce new variables and equations to abbreviate subterms [1].",
      "startOffset" : 150,
      "endOffset" : 153
    }, {
      "referenceID" : 0,
      "context" : "For solving flat unification problems, it has been shown that it suffices to consider so-called local solutions [1], which are restricted to use only the atoms occurring in the input problem.",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 0,
      "context" : "The corresponding complexity lower bound follows from NP-hardness of (local) solvability of unification problems in EL [1].",
      "startOffset" : 119,
      "endOffset" : 122
    }, {
      "referenceID" : 0,
      "context" : "It has been shown that unification in EL is local in the sense that the equivalent flattened problem has a local solution iff the original problem is solvable, and hence (general) solvability of unification problems in EL can be decided in NP [1].",
      "startOffset" : 243,
      "endOffset" : 246
    }, {
      "referenceID" : 0,
      "context" : "We then provide two different NPalgorithms for the latter problem by extending the rule-based unification algorithm from [1] and adapting the SAT encoding of unification problems from [2].",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 1,
      "context" : "We then provide two different NPalgorithms for the latter problem by extending the rule-based unification algorithm from [1] and adapting the SAT encoding of unification problems from [2].",
      "startOffset" : 184,
      "endOffset" : 187
    }, {
      "referenceID" : 2,
      "context" : "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29].",
      "startOffset" : 164,
      "endOffset" : 174
    }, {
      "referenceID" : 7,
      "context" : "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29].",
      "startOffset" : 164,
      "endOffset" : 174
    }, {
      "referenceID" : 28,
      "context" : "Our investigation of dismatching is motivated in part by the work on matching in description logics, where similar restrictions are imposed on unification problems [3, 8, 29].",
      "startOffset" : 164,
      "endOffset" : 174
    }, {
      "referenceID" : 2,
      "context" : "In particular, the matching problems for EL investigated in [3] are similar to our dismatching problems in that there subsumptions are restricted to ones where one side is ground.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 8,
      "context" : "In particular, subsumptions between ground atoms can be checked in polynomial time [9].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 1,
      "context" : "To obtain a local solution, we denote by At, Var, and Atnv the sets as defined in Section 3 and define the assignment S induced by γ as in [2]:",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 1,
      "context" : "It was shown in [2] that S is acyclic and the substitution σS solves all subsumptions in Γ.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : "1 and the NP-hardness of unification in EL [1], this shows the following complexity result.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 1,
      "context" : "For details, see [2] or Sections 6.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 0,
      "context" : "To solve the subsumptions, we reuse the rules of the goal-oriented algorithm for unification in EL [1, 14], which produces only local unifiers.",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 13,
      "context" : "To solve the subsumptions, we reuse the rules of the goal-oriented algorithm for unification in EL [1, 14], which produces only local unifiers.",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 13,
      "context" : "The rules dealing with subsumptions are essentially the same as in [14]; note that several of these may be applicable to the same subsumption.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 4,
      "context" : "the multiset extension of >S [5].",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 4,
      "context" : "orders are again well-founded [5], ≻ is a well-founded strict partial order on Γ̂.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 1,
      "context" : "This reduction is a generalization of the one developed for unification problems in [2].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 1,
      "context" : "The main difference to the encoding in [2] lies in the clauses (IV) that ensure the presence of a non-variable atom D that solves the dissubsumption C 6⊑ X (cf.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 1,
      "context" : "We show the following property of >Sτ ; the proof is exactly the same as in [2], but uses a different notation.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 11,
      "context" : "For example, a slightly modified version of the example from the introduction has 128 solutions without any dissubsumptions (see [12] for more details).",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 31,
      "context" : "Since Description Logics and Modal Logics are closely related [32], results on unification in one of these two areas carry over to the other one.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 23,
      "context" : "In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31].",
      "startOffset" : 105,
      "endOffset" : 117
    }, {
      "referenceID" : 24,
      "context" : "In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31].",
      "startOffset" : 105,
      "endOffset" : 117
    }, {
      "referenceID" : 30,
      "context" : "In Modal Logics, unification has mostly been considered for expressive logics with all Boolean operators [24, 25, 31].",
      "startOffset" : 105,
      "endOffset" : 117
    }, {
      "referenceID" : 32,
      "context" : "It is only known that relatively minor extensions of K have an undecidable unification problem [33].",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 15,
      "context" : "Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30].",
      "startOffset" : 140,
      "endOffset" : 152
    }, {
      "referenceID" : 26,
      "context" : "Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30].",
      "startOffset" : 140,
      "endOffset" : 152
    }, {
      "referenceID" : 29,
      "context" : "Disunification also plays an important role in Modal Logics since it is basically the same as the admissibility problem for inference rules [16, 27, 30].",
      "startOffset" : 140,
      "endOffset" : 152
    }, {
      "referenceID" : 18,
      "context" : "As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19–21].",
      "startOffset" : 139,
      "endOffset" : 146
    }, {
      "referenceID" : 19,
      "context" : "As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19–21].",
      "startOffset" : 139,
      "endOffset" : 146
    }, {
      "referenceID" : 20,
      "context" : "As already mentioned in the introduction, (dis)unification in EL is actually a special case of (dis)unification modulo equational theories [19–21].",
      "startOffset" : 139,
      "endOffset" : 146
    }, {
      "referenceID" : 0,
      "context" : "As shown in [1], equivalence in EL can be axiomatized by the equational theory of semilattices with monotone functions, which extends the theory ACUI of an associative-commutativeidempotent binary function symbol ∗ (corresponding to ⊓) with unit (corresponding to ⊤) by unary function symbols hr (corresponding to ∃r) that are monotone in the sense that they satisfy the identities hr(x) ∗ hr(x ∗ y) = hr(x ∗ y).",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 6,
      "context" : "This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28].",
      "startOffset" : 37,
      "endOffset" : 44
    }, {
      "referenceID" : 21,
      "context" : "This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28].",
      "startOffset" : 37,
      "endOffset" : 44
    }, {
      "referenceID" : 27,
      "context" : "This problem is shown to be in NP in [7, 22]; NP-hardness follows from NP-hardness of ACUI-unification with free function symbols [28].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 6,
      "context" : "To be more precise, the NP upper bound is shown in [7] for the theory ACI with free function symbols, using general combination results for disunification developed in the same article.",
      "startOffset" : 51,
      "endOffset" : 54
    }, {
      "referenceID" : 6,
      "context" : "However, it is easy to see that the approach applied in [7] also",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 21,
      "context" : "In contrast, the NP upper bound in [22] is shown for ACUI with free function symbols by directly designing a dedicated algorithm for disunification in this theory.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 16,
      "context" : "In addition, we will investigate whether a reduction to answer set programming (ASP) [17, 23] rather than SAT leads to a better performance.",
      "startOffset" : 85,
      "endOffset" : 93
    }, {
      "referenceID" : 22,
      "context" : "In addition, we will investigate whether a reduction to answer set programming (ASP) [17, 23] rather than SAT leads to a better performance.",
      "startOffset" : 85,
      "endOffset" : 93
    } ],
    "year" : 2017,
    "abstractText" : "Unification in Description Logics has been introduced as a means to detect redundancies in ontologies. We try to extend the known decidability results for unification in the Description Logic EL to disunification since negative constraints can be used to avoid unwanted unifiers. While decidability of the solvability of general EL-disunification problems remains an open problem, we obtain NP-completeness results for two interesting special cases: dismatching problems, where one side of each negative constraint must be ground, and local solvability of disunification problems, where we consider only solutions that are constructed from terms occurring in the input problem. More precisely, we first show that dismatching can be reduced to local disunification, and then provide two complementary NP-algorithms for finding local solutions of disunification problems.",
    "creator" : "LaTeX with hyperref package"
  }
}