{
  "name" : "1706.04582.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The Opacity of Backbones and Backdoors Under a Weak Assumption",
    "authors" : [ "Lane A. Hemaspaandra", "David E. Narváez" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 6.\n04 58\n2v 1\n[ cs\n.A I]\nBackdoors and backbones of Boolean formulas are hidden structural properties that are relevant to the analysis of the hardness of instances of the SAT problem. The development and analysis of algorithms to find and make use of these properties is thus useful to improve the performance of modern solvers and our general understanding of SAT. In this work we show that, under the assumption that P 6= NP, there are easily-recognizable sets of Boolean formulas for which it is hard to determine whether they have a backbone. We also show that, under the same assumption, there are easily-recognizable families of Boolean formulas with strong backdoors that are easy to find, for which it is hard to determine whether they are satisfiable or not."
    }, {
      "heading" : "1 Introduction",
      "text" : "Many algorithms for the Boolean satisfiability problem exploit hidden structural properties of formulas in order to find a satisfying assignment or prove that no such assignment exists. These structural properties are called hidden because they are not explicit in the input formula. A natural question that arises then is what is the computational complexity associated with these hidden structures. In this paper we focus on two hidden structures: backbones and strong backdoors [WGS03].\nThe complexity of decision problems associated with backbones and backdoors has been studied by Kilby, Slaney, Thiébaux, and Walsh [KSTW05] and Dilkina, Gomes, and Sabharwal [DGS14], among others.\nHemaspaandra and Narváez [HN17] show a separation between the complexity of finding backbones and that of finding the values to which the backbone variables must be set to under the assumption that P 6= NP ∩ coNP. In the present paper, we add to this line of research by showing that, under the assumption that P 6= NP, there are families of formulas that are easy to recognize (i.e., can be recognized by polynomial-time algorithms) but no polynomial-time algorithm can decide whether a formula in these families has a backbone. We also show that, under the same assumption, there are easily-recognizable families of formulas with backdoors that are easy to find, yet the problem of determining whether these formulas are satisfiable or not remains hard.\nThe rest of this paper is organized as follows. Section 2 defines the notation we will use throughout this paper. Sections 3 and 4 contain our results related to backbones and backdoors respectively. Finally, Section 5 adds some concluding remarks."
    }, {
      "heading" : "2 Definitions and Notations",
      "text" : "For a Boolean formula F , we denote by V (F ) the set of variables of F . A partial assignment of F is a function aS : S → {True,False} that assigns Boolean values to the variables in a set S ⊆ V (F ). For a Boolean value v ∈ {True,False} and a variable x ∈ V (F ), the notation F [v/x] denotes the formula F after replacing every occurrence of x by v and simplifying. This extends to partial assignments in the natural way.\nIn theorems about the frequency of hardness of the sets we define in this paper, we will refer to input strings of length at most n. For an alphabet Σ, in a slight abuse of notation we denote by Σ≤n the set of strings over Σ whose length is less than or equal to n."
    }, {
      "heading" : "3 Results on Backbones",
      "text" : "For the sake of completeness, we start this section by restating the definition of backbones as presented by Williams, Gomes, and Selman [WGS03]. We restrict ourselves to the Boolean domain, since we only deal with Boolean formulas in this paper.\nDefinition 3.1 (Backbone [WGS03]). For a Boolean formula F , a subset S of its variables is a backbone if there is a unique partial assignment aS such that F [aS ] is satisfiable.\nThe size of a backdoor S is the number of variables in S. One can readily see from Definition 3.1 that all satisfiable formulas have at least one backbone, namely, the empty set. This backbone is called the trivial backbone, while backbones of size at least one are called nontrivial backbones. Another conclusion one can derive from Definition 3.1 is that unsatisfiable formulas do not have backbones. This will be a key observation in our results related to backbones. Notice, however, that the original paper by Monasson et al. introducing the concept of backbones [MZK+99] defines a backbone as a set of variables that are “fully constrained” by the formula, a definition that does not require the formula to be satisfiable.\nOur first result states that if P 6= NP then there are families of Boolean formulas that are easy to recognize, with the property that deciding whether or not a formula in these families has a nontrivial backbone is hard.\nTheorem 3.2. If P 6= NP then for any real number 0 < β < 1, there is a set A ∈ P of Boolean formulas such that the language\nLA = {G | G ∈ A and G has a nontrivial backbone S with |S| ≥ β |V (G)|}\nis not in P.\nProof. For a Boolean formula F , let q (F ) = ⌈\nβ|V (F )| 1−β\n⌉\n. Define\nA = { F ∧ ( new1 ∧ new2 ∧ · · · ∧ newq(F ) ) | F is a boolean formula } ,\nwhere we define newi as the i-th (in lexicographical order) legal variable name that does not appear in F . For instance, if F contains literals x1, x2, x3, and x3, and if our legal variable universe is x1, x2, x3, x4, . . ., then new1 would be x4. Note that new1∧new2∧· · ·∧newq(F ) is a backbone if and only if F ∈ SAT, thus under the assumption that P 6= NP, no polynomial-time algorithm can decide LA. The size of this backbone is q (F ) > 0 which, by definition, satisfies q (F ) ≥ β (|V (F )|+ q (F )).\nAs in Hemaspaandra and Narváez [HN17], we address the concern that the hard instances for the decision problems we just introduced may be so infrequent that the relevance of Theorem 3.2 is undercut. The following theorem argues against that possibility by proving that, unless all NP sets are very frequently easy, some sets of our form are not frequently easy.\nTheorem 3.3. If h is any nondecreasing function and for some set B ∈ NP it holds that each polynomial-time algorithm for membership testing in B errs, at infinitely many lengths n (resp., almost everywhere), on at least h (n) of the inputs up to that length, then there will exist an ǫ > 0 and a set A ∈ P of Boolean formulas satisfying the conditions of Theorem 3.2, yet being such that each polynomial-time algorithm g, at infinitely many lengths n (resp., almost everywhere), will fail to correctly determine membership in LA for at least h (n ǫ) inputs of length at most n.\nProof. Let rB be a polynomial-time function that transforms inputs to B (viewed as a membershiptesting problem) into Boolean formulas, such that rB (x) ∈ SAT if and only if x ∈ B, and rB is one-to-one (we show an explicit construction of such a function in Appendix A of [HN16]). As in Theorem 3.2, we define q (F ) = ⌈\nβ|V (F )| 1−β\n⌉\nfor any Boolean formula F and\nA = { rB (x) ∧ ( new1 ∧ new2 ∧ · · · ∧ newq(rB(x)) ) | x ∈ Σ∗ } .\nBecause rB is computable in polynomial time, there is a polynomial b of degree k such that for every input x of length at most n, the length of rB (x) is at most b (n). Also, since the length of rB (x) is at least a constant times the number of its variables, there is a constant c such that ∣ ∣\nnew1 ∧ new2 ∧ · · · ∧ newq(rB(x)) ∣ ∣ ≤ c · b (n). Let N be a natural number such that, for all n ≥ N\nand for every input x, |x| ≤ n implies ∣ ∣rB (x) ∧ ( new1 ∧ new2 ∧ · · · ∧ newq(rB(x)) ) ∣ ∣ ≤ nk+1. Let g be a polynomial-time heuristic for LA. Notice that g ◦ rB is a polynomial-time heuristic for B since rB (x)∧ ( new1 ∧ new2 ∧ · · · ∧ newq(rB(x)) )\n∈ LA ⇔ rB (x) ∈ SAT ⇔ x ∈ B. Let nB ≥ N be such that there is a set of strings SnB ⊆ Σ\n≤nB , |SnB | ≥ h (nB), having the property that for all x ∈ SnB , g ◦rB fails to determine the membership of x in B. Consequently, there is a set of strings TnB ⊆ Σ ≤nk+1 B , |TnB | ≥ h (nB), such that for all x ∈ TnB , g fails to determine the membership of x in LA, namely, the set\nTnB = { rB (x) ∧ ( new1 ∧ new2 ∧ · · · ∧ newq(rB(x)) ) |x ∈ SnB } .\nUsing a variable renaming nA = n k+1 B , we have proved that every length nB ≥ N at which g ◦ rB (a heuristic for B) errs in at least h (nB) inputs of length up to nB has a corresponding length nA\nat which g (a heuristic for LA) errs in at least h\n(\nn 1 k+1\nA\n)\ninputs of length up to nA. Our hypothesis\nguarantees the existence of infinitely many such nB ≥ N (resp., almost all n ≥ N can take the role of nB), each with a corresponding nA. Setting ǫ = 1 k+1 then proves our theorem."
    }, {
      "heading" : "4 Results on Backdoors to CNF Formulas",
      "text" : "In this section we focus on Boolean formulas in conjunctive normal form, or CNF. A CNF formula is a conjunction of disjunctions, and the disjunctions are called the clauses of the formula. Following Dilkina, Gomes, and Sabharwal [DGS14], we define satisfiability of CNF formulas using the language of set theory. We do this by formalizing the intuition that, in order for an assignment to satisfy a CNF formula, it must set at least one literal in every clause to True. We can then define a CNF formula F to be a collection of clauses, each clause being a set of literals. F ∈ SAT if and only if there exists an assignment aV (F ) such that for all clauses C ∈ F there exists a literal l ∈ C such\nthat aV (F ) assigns l to True. Under this formalization, two trivial cases arise: F is trivially in SAT if F is empty, and F is trivially not in SAT if ∅ ∈ F . We can also formalize simplification using this notation: after assigning a variable x to True (resp., False), the formula is simplified by removing all clauses that contain the literal x (resp., x) and removing the literal x (resp., x) from the remaining clauses. This formalization extends to simplification of a formula over a partial assignment in the natural way.\nSince CNFSAT (the satisfiability problem restricted to CNF formulas) is well-known to be NPcomplete, a polynomial-time algorithm to determine the satisfiability of CNF formulas is unlikely to exist. Nevertheless, there are several subclasses of CNF formulas for which satisfiability can be decided in polynomial time. When a formula does not belong to any of these subclasses, it may have a set of variables that, once the formula is simplified over a partial assignment of these variables, the resulting formula belongs to one of these tractable subclasses. A formalization of this idea is the concept of backdoors.\nDefinition 4.1 (Subsolver [WGS03]). An algorithm A is a subsolver if, for an input formula F , it satisfies all the following conditions.\n1. A either rejects the input F or “determines” F correctly (returning a solution if satisfiable).\n2. A runs in polynomial time.\n3. A can determine if F is trivially True or trivially False.\n4. If A determines F , then for any variable x and value v, A determines F [v/x].\nDefinition 4.2 (Strong Backdoor [WGS03]). For a Boolean formula F , a nonempty subset S of its variables is a strong backdoor for a subsolver A if, for all partial assignments aS, A returns a satisfying assignment or concludes unsatisfiability of F [aS ].\nMany examples of subsolvers can be found in the literature (for instance, in Table 1 of [DGS14]). The subsolver that is of particular relevance to this paper is the unit propagation subsolver, which operates over unit clauses. Unit clauses are clauses with just one literal. They play an important role in the process of finding models because the literal in that clause must be set to True in order to find a satisfying assignment. The process of finding a model by searching for a unit clause, fixing the value of the variable in the unit clause, and simplifying the formula resulting from that assignment is known in the SAT literature as unit propagation. Unit propagation is an important building block in the seminal DPLL algorithm for SAT [DP60, DLL62]. Notice that CNF formulas for which a model can be found by just applying unit propagation iteratively constitute a tractable subclass of SAT. The unit propagation subsolver attempts to decide the satisfiability of an input formula by using only unit propagation and empty clause detection. If a model cannot be found this way, the subsolver rejects the input formula. Szeider [Sze05] classified the parameterized complexity of finding backdoors with respect to the unit propagation subsolver.\nWe are now ready to prove our main result about backdoors: that under the assumption that P 6= NP, there are families of Boolean formulas that are easy to recognize and have strong unit propagation backdoors that are easy to find, yet deciding whether the formulas in these families are satisfiable or not remains NP-complete.\nTheorem 4.3. If P 6= NP, for each k ∈ {1, 2, 3, . . .} there is a set A of Boolean formulas such that all the following hold.\n1. A ∈ P and A ∩ SAT is NP-complete.\n2. Each formula G in A has a strong backdoor S with respect to the unit propagation subsolver,\nwith |S| ≤ |V (G)| 1 k .\n3. Indeed, there even is a polynomial-time algorithm that, given G ∈ A, finds a strong backdoor having property 2.\nProof. Consider\nA = { F ∧ (\nnew1 ∧ · · · ∧ new|V (F )|k−|V (F )|\n) | F is a CNF formula }\nwhere, as in the proof of Theorem 3.2, newi is the i-th variable that does not appear in F . The backdoor is the set of variables of F , which can be found in polynomial time by parsing. It is clear that the formula resulting from simplification after assigning values to all the variables of F only has unit clauses and potentially an empty clause, so satisfiability for this formula can be decided by the unit propagation subsolver. Finally, it is easy to see that F ∧ (\nnew1 ∧ · · · ∧ new|V (F )|k−|V (F )|\n)\n∈\nSAT ⇔ F ∈ SAT so under the assumption that P 6= NP, deciding satisfiability for the formulas in A is hard.\nAs before, we address the frequency of hardness of the sets we define in Theorem 4.3.\nTheorem 4.4. If h is any nondecreasing function and for some set B ∈ NP it holds that each polynomial-time algorithm for membership testing in B errs, at infinitely many lengths n (resp., almost everywhere), on at least h (n) of the inputs up to that length, then there will exist an ǫ > 0 and a set A ∈ P of Boolean formulas satisfying Theorem 4.3’s conditions, yet being such that each polynomial-time algorithm g, at infinitely many lengths n (resp., almost everywhere), will fail to determine membership in A ∩ SAT for at least h (nǫ) inputs of length at most n.\nProof. We define rB as in Theorem 3.3 with the additional condition that the formula output by rB is in conjunctive normal form. For a given k, we define\nA = { rB (x) ∧ (\nnew1 ∧ · · · ∧ new|V (rB(x))|k−|V (rB(x))|\n) | x ∈ Σ∗ }\nand since rB (x) ∧ (\nnew1 ∧ · · · ∧ new|V (rB(x))|k−|V (rB(x))|\n)\n∈ SAT ⇔ rB (x) ∈ SAT ⇔ x ∈ B, we can\nnow proceed as in the proof of Theorem 3.3."
    }, {
      "heading" : "5 Conclusions",
      "text" : "We described easily-recognizable families of Boolean formulas that provide hard instances for decision problems related to backbones and backdoors under the assumption that P 6= NP. We did this by exploiting the fact that, under such assumption, SAT ∈ NP−P. In the particular case of backbones our proof hinges on the fact that unsatisfiable formulas, by definition, do not have backbones. We have also shown that if any problem in NP is frequently hard, then the families of Boolean formulas we describe are frequently hard as well."
    } ],
    "references" : [ {
      "title" : "Tradeoffs in the complexity of backdoors to satisfiability: dynamic sub-solvers and learning during search",
      "author" : [ "B. Dilkina", "C. Gomes", "A. Sabharwal" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Dilkina et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Dilkina et al\\.",
      "year" : 2014
    }, {
      "title" : "A machine program for theorem-proving",
      "author" : [ "M. Davis", "G. Logemann", "D. Loveland" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Davis et al\\.,? \\Q1962\\E",
      "shortCiteRegEx" : "Davis et al\\.",
      "year" : 1962
    }, {
      "title" : "A computing procedure for quantification theory",
      "author" : [ "M. Davis", "H. Putnam" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Davis and Putnam.,? \\Q1960\\E",
      "shortCiteRegEx" : "Davis and Putnam.",
      "year" : 1960
    }, {
      "title" : "The opacity of backbones",
      "author" : [ "L. Hemaspaandra", "D. Narváez" ],
      "venue" : "Technical Report arXiv:1606.03634 [cs.AI],",
      "citeRegEx" : "Hemaspaandra and Narváez.,? \\Q2017\\E",
      "shortCiteRegEx" : "Hemaspaandra and Narváez.",
      "year" : 2017
    }, {
      "title" : "The opacity of backbones",
      "author" : [ "L. Hemaspaandra", "D. Narváez" ],
      "venue" : "In Proceedings of the 31st AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Hemaspaandra and Narváez.,? \\Q2017\\E",
      "shortCiteRegEx" : "Hemaspaandra and Narváez.",
      "year" : 2017
    }, {
      "title" : "Backbones and backdoors in satisfiability",
      "author" : [ "P. Kilby", "J. Slaney", "S. Thiébaux", "T. Walsh" ],
      "venue" : "In Proceedings of the 20th National Conference on Artificial Intelligence,",
      "citeRegEx" : "Kilby et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Kilby et al\\.",
      "year" : 2005
    }, {
      "title" : "Determining computational complexity from characteristic ‘phase transitions",
      "author" : [ "R. Monasson", "R. Zecchina", "S. Kirkpatrick", "B. Selman", "L. Troyansky" ],
      "venue" : "Nature, 400:133–137,",
      "citeRegEx" : "Monasson et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Monasson et al\\.",
      "year" : 1999
    }, {
      "title" : "Backdoor sets for DLL subsolvers",
      "author" : [ "S. Szeider" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Szeider.,? \\Q2005\\E",
      "shortCiteRegEx" : "Szeider.",
      "year" : 2005
    }, {
      "title" : "Backdoors to typical case complexity",
      "author" : [ "R. Willams", "C. Gomes", "B. Selman" ],
      "venue" : "In Proceedings of the 18th International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Willams et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Willams et al\\.",
      "year" : 2003
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Backdoors and backbones of Boolean formulas are hidden structural properties that are relevant to the analysis of the hardness of instances of the SAT problem. The development and analysis of algorithms to find and make use of these properties is thus useful to improve the performance of modern solvers and our general understanding of SAT. In this work we show that, under the assumption that P 6= NP, there are easily-recognizable sets of Boolean formulas for which it is hard to determine whether they have a backbone. We also show that, under the same assumption, there are easily-recognizable families of Boolean formulas with strong backdoors that are easy to find, for which it is hard to determine whether they are satisfiable or not.",
    "creator" : "LaTeX with hyperref package"
  }
}