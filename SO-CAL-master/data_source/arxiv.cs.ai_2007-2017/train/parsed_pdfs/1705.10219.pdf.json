{
  "name" : "1705.10219.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Automatic White-Box Testing of First-Order Logic Ontologies",
    "authors" : [ "Javier Álvez", "Montserrat Hermo", "Paqui Lucio", "German Rigau" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 5.\n10 21\n9v 1\n[ cs\n.A I]\n2 9\nA long-standing dream of Artificial Intelligence (AI) has pursued to encode commonsense knowledge into computer programs enabling machines to reason about our world and problems. This work offers a new practical insight towards the automatic testing of first-order logic (FOL) ontologies. We introduce a novel fully automatic white-box testing framework for first-order logic (FOL) ontologies. The application of the proposed testing method is fully automatic since a) the automated generation of tests is only guided by the syntax of axioms and b) the evaluation of tests is performed by automated theorem provers. Our proposal enables the detection of defective axioms and, additionally, it also serves to demonstrate the suitability for reasoning purposes of those formulas included into FOL ontologies. We validate our proposal by its practical application to different FOL ontologies. In particular, DOLCE —consisting of around 200 axioms—, FPK (formal proof of the Kepler conjecture) —which has been derived from the Flyspeck project for its use in the CADE ATP System Competition CASC-J8—, and AdimenSUMO —which is an ontology with more than 7,000 axioms derived from SUMO—. As result, we have detected several non-trivial defects that were hidden in those ontologies. Further, we have obtained an improved version of Adimen-SUMO (v2.6) by correcting all the defects detected during the practical application of our white-box testing method.\nKeywords: White-box testing, Automated theorem proving, Knowledge representation\nPreprint submitted to Artificial Intelligence May 30, 2017"
    }, {
      "heading" : "1. Introduction",
      "text" : "Recently, Artificial Intelligence (AI) has shown great advances in many different research areas, but there is one critical area where progress has shown limited progress: commonsense representation and commonsense reasoning [23, 24, 6]. The work introduced in this paper proposes to advance a step forward in this research line a novel fully automatic white-box testing framework for first-order logic (FOL) ontologies.\nFormal ontology development is a discipline whose goal is to derive explicit formal specifications of terms in a domain and relations among them [30, 15, 35]. As other software artefacts, ontologies have to fulfil some previously specified requirements. Usually both the creation of ontologies and the verification of its requirements are manual tasks that require a significant amount of human effort [1]. In the literature, there exist some methodologies that collect the experience in ontology development [14] and, more concretely, in ontology verification [10].\nRoughly speaking, most of the methodologies for ontology verification focus on validating functional requirements and are based on the use of competency questions (CQs) [16, 2]. That is, according to the requirements of a given ontology, a set of goals that are expected to be answered is defined for testing the ontology. Thus, the definition of tests does not depend on the particular specification of the knowledge proposed by the ontology. In this sense, these methods can be classified as black-box testing [26] according to the classical definition in software engineering. It is well-known that software testing has a main disadvantage, as stated by Dijkstra [7]: “Program testing can be used to show the presence of bugs, but never to show their absence!”. But black-box testing has some additional disadvantages. For example, it is hard to determine the coverage level of a set of tests, since different black-box tests can repeatedly check the same portions of software. Further, usually the process of obtaining CQs is not automatic but creative [9]. Thus, depending on the size and complexity of the ontology, creating a suitable set of CQs is by itself a very challenging and costly task.\nIn contrast to black-box testing, a different strategy is also used in software engineering for creating tests: the so-called white-box testing [31]. In fact, both black-box and white-box testing can be used in a complementary manner since no single approach guaranties the complete correctness of a software artefact. Likewise, multiple approaches looking at the same piece of code from different angles are likely to uncover a different class of defects.\nHowever, neither black-box nor white-box testing provide any information about some other requirements of software artefacts, such as quality of the codification/specification, readability or maintainability [27].\nRegarding white-box testing, tests are not created upon functional requirements of software, but on the particular codification/specification that is used. Thus, white-box testing refers to test methods that rely on the internal structure of software. The rationale behind these methods is that it is impossible to detect a fault in some piece of code if that code is never executed.\nNevertheless, testing an ontology exclusively upon its functional and nonfunctional requirements does not enable the detection of many defects. One non-functional requirement of ontologies is to be consistent (satisfiable or logically non-equivalent to false), since any arbitrary formula is entailed by an inconsistent ontology (that is, by false). But consistency itself does not prevent the existence of many other defects in ontologies.\nIn this paper, we propose to systematically create conjectures on the basis of the syntactical form of formulas with the purposes of (a) detecting defects and (b) classifying formulas as suitable for reasoning purposes. In particular, our proposal enables to detect typos, tautologies, redundancies and hidden inconsistencies in formulas. Additionally, a formula is classified as suitable when no defect can be detected by following our strategy. For example, we detect that the following formula extracted from Adimen-SUMO [1]\n∀?c ( $instance(?c, Circle) → ∃?p (CenterOfCircleFn(?c) =?p) ) (1)\nis defective by means of the next conjecture which is obtained from the consequent of its implication:\n∀?c ∃?p ( CenterOfCircleFn(?c) =?p ) (2)\nThe above conjecture is trivially proved since equality is reflexive, thus we can conclude that formula (1) is a tautology. In addition, we propose 8 different conjectures in order to classify the following formula obtained from Adimen-SUMO as suitable for reasoning purposes:\n∀?d ( $instance(?d,Driving) → ∃?v ( $instance(?v, V ehicle) ∧ patient(?d, ?v) ) )\n(3)\nThen, we proceed to automatically check whether the proposed conjectures are entailed with the help of automated theorem provers (ATPs). Following\nthis procedure, we have been able to detect many defects in FOL ontologies such as DOLCE [12], FPK (formal proof of the Kepler conjecture) [18] and Adimen-SUMO [1] in a fully automatic way.\nThe contributions of this paper are twofold. First, we introduce a completely automatic methodology for the evaluation of FOL ontologies that is not based on a set of manually created CQs, unlike all the previous methodologies proposed in the literature. We also include a whole description of the logical foundations of our methodology and formal proofs ensuring its correctness. Second, we describe the application of our methodology to DOLCE, FPK and Adimen-SUMO. In particular, we review in detail the kind of defects that have been detected in those ontologies and provide a deep analysis of the evaluation results. In addition, we also introduce an improved version of Adimen-SUMO (v2.6), that has been obtained by correcting all the defects detected following our proposal.\nThe paper is organized as follows. First, we briefly describe DOLCE, FPK and Adimen-SUMO in Section 2 and the methodology for the evaluation of ontologies using ATPs in Section 3. Next, we introduce our strategy for obtaining tests in Section 4. Then, we formally define the set of tests that are proposed for a given formula in Section 5 and provide a complete example in Section 6. Next, we prove the correctness of the proposed tests in Section 7 and provide a summary of our experimental results in Section 8. Finally, we give some conclusions and discuss future work. Formal proofs are provided in Appendix."
    }, {
      "heading" : "2. FOL Ontologies",
      "text" : "In this section, we introduce the main features of the FOL ontologies that will be used for the evaluation of our white-box testing strategy —DOLCE, FPK and Adimen-SUMO— and provide some figures about their content.\nDOLCE (Descriptive Ontology for Linguistic and Cognitive Engineering) is the first-module of a Library of Foundational Ontologies being developed within the WonderWeb project [12]. Its main purposes are supporting effective cooperation among multiple artificial agents and establishing consensus in a mixed society where artificial agents cooperate with human beings. The partial mappings from WordNet [8] to DOLCE [11] enable the connection of DOLCE to other semantic resources such as the Multilingual Central Repository (MCR) [5] and its application to advanced Natural Language Processing, Knowledge Engineering and Semantic Web tasks. The domain of discourse\nof DOLCE is restricted to the notion of particulars —entities which have no instances—. Likewise, particulars are characterized and organized around a taxonomy of 37 universals—entities that can have instances— and universals are organized around the notion of world. However, no particular and no world is explicitly defined. DOLCE is originally expressed in KIF (Knowledge Interchange Format [13]) according to the standard proposed in [19]1 and simplified translations into various logical languages have been proposed (DOLCE-Lite-Plus2). The KIF version of DOLCE uses row variables — which produces variable-arity relations— and quantified predicate symbols. Hence, we apply the translation described in [1] for its transformation into a pure FOL formula (from now on, KIF-DOLCE). As result, we obtain 257 non-atomic formulas as the following one\n∀?w ∀?f ( (universal(?f) ∧ world(?w)) → nep(?w, ?f) ) (4)\nwhere nep is used to state that universals are non-empty sets of particulars. Vampire v4.1 [34] proves that KIF-DOLCE is consistent. In addition, a simplified translation of DOLCE into CASL [4] (from now on, CASL-DOLCE) is available in Hets [25] and its consistency is proved in [21]. This translation consists of 416 non-atomic formulas like\n∃?y ( pED(?y) ) (5)\nwhere pED is used to state that the universal Endurant has some particular.3 Both FOL versions of DOLCE —KIF-DOLCE and CASL-DOLCE— were expected to be non-defective due to its reduced size and its mature state of development.\nFPK (formal proof of the Kepler conjecture) is an ontology that has been derived from the Flyspeck project [18] for its use in the CADE ATP System Competition CASC-J8 [37]. The purpose of the Flyspeck project is to give a formal proof of the Kepler conjecture, which asserts that no packing of congruent balls in three-dimensional Euclidean space has density greater than that of the face-centered cubic packing [17]. Its participants claim that it “is the most complex formal proof ever undertaken” and estimate that it may take about twenty work-years to complete the formalization. To this\n1http://logic.stanford.edu/kif/dpans.html 2http://www.loa.istc.cnr.it/old/DOLCE.html 337 formulas like (5) are used in CASL-DOLCE for stating the property in formula (4).\nend, every logical inference is checked against the foundational axioms of mathematics with the help of a computer and, although obvious, no step is skipped. We use FPK just as provided to the CASC competition since it already consists in a pure FOL formula with 78,500 axioms as the next one:\n∀?a ∀?x ∀?y ( s(?a, ?x) = s(?a, ?y) → s(?a, ?y) = s(?a, ?x) )\nLike DOLCE, FPK has also reached a mature state of development, so we did not expect to discover many defects although being much larger than DOLCE.\nFinally, Adimen-SUMO has been derived from SUMO (Suggested Upper Merged Ontology)4 [28], which was promoted by a group of engineers from the IEEE Standard Upper Ontology Working Group as formal ontology standard in the nineties of the past century. Their goal was to develop a standard upper ontology to promote data interoperability, information search and retrieval, automated inference and natural language processing. SUMO is expressed in SUO-KIF (Standard Upper Ontology Knowledge Interchange Format [32]), which is a dialect of KIF, and its syntax goes beyond FOL. Consequently, SUMO cannot be directly used by FOL ATPs without a suitable transformation. Further, in order to support higher-order aspects, a translation of SUMO is also required for its use by means of pure higher-order theorem provers [33]. In [1], we use ATPs for reengineering around 88% of the top and the middle levels of SUMO into Adimen-SUMO,5 which can be expressed as a FOL formula. Our translation is based on a small set of metapredicates —and its axiomatization— that are required to define the knowledge of SUMO according to its organization around four kinds of concepts:\n4http://www.ontologyportal.org 5The first version of Adimen-SUMO is v2.2.\nobjects, classes, relations and properties. Some of these meta-predicates are $instance, $subclass, $disjoint and $partition. In addition, we also propose a suitable translation of domain (or type) information of relations, which is separately provided by means of domain axioms. Finally, Adimen-SUMO —like DOLCE— also uses row variables and quantified predicate symbols. In [2], we introduce an evolved version of Adimen-SUMO (v2.4) and demonstrate its inference capabilities in practice. More concretely, we exploit the whole mapping of WordNet to SUMO [29] in order to obtain a set of CQs by following a black-box testing strategy. As reported in [2], we have experimentally tested Adimen-SUMO v2.4 using the resulting set of CQs and no defect has been detected. Additionally, we have used Adimen-SUMO v2.4 and the same set of CQs for an experimental comparison of several FOL ATPs in [3]. The state of development of Adimen-SUMO v2.4 was not mature and we have been able to detect various defects by following the white-box testing methodology introduced in this paper. As result of correcting all the detected defects, we have obtained Adimen-SUMO v2.6.\nIn Table 1, we summarize some figures about DOLCE, FPK and AdimenSUMO (v2.4 and v2.6). More specifically, the number of FOL atomic formulas (unit clauses) and FOL non-atomic formulas (general clauses) that result from its transformation into a pure FOL formula (no transformation is required for FPK), and the total number of clauses."
    }, {
      "heading" : "3. Methodology for the Automatic Evaluation of Ontologies",
      "text" : "In this section, we describe the framework proposed in [2] for the evaluation of ontologies using an existing set of CQs. This framework enables the automatic evaluation of the conjectures obtained by the white-box testing method described in Sections 4 and 5.\nIn [16], the authors propose a methodology for the design and evaluation of ontologies on the basis of a set of CQs. The only requirement for applying the proposed methodology is the existence of a decision algorithm for the underlying logic. An adaptation of this methodology to FOL ontologies is introduced in [2], which enables to automatically evaluate ontologies by means of the use of FOL ATPs. In this adaptation, the set of CQs is partitioned into two sets: truth-tests and falsity-tests, depending on whether one expects the conjecture to be entailed by the ontology (truth-tests) or not (falsity-tests). An example of truth-test is “Siblings have the same mother”,\nwhich belongs to the CSR domain of the Thousands of Problems for Theorem Provers (TPTP) problem library6 [36], because it is expected to be entailed:\n(=> (6)\n(and\n(mother ?ORG1 ?ORG2)\n(sibling ?ORG1 ?ORG3))\n(mother ?ORG3 ?ORG2))\nOn the contrary, the conjecture “Some herbivores eat animals” —belonging to the set of CQs proposed in [2]— is a falsity-test since it is not expected to be entailed by the ontology:\n(exists (?HERBIVORE ?ANIMAL) (7)\n(and\n($instance ?HERBIVORE Herbivore)\n($instance ?ANIMAL Animal)\n($instance ?EATING Eating)\n(agent ?EATING ?HERBIVORE)\n(patient ?EATING ?ANIMAL)))\nIn order to check if CQs are entailed or not by a particular ontology, we propose to use ATPs that work by refutation. Thus, the proof that a conjecture is entailed by the ontology consists in demonstrating that the conjunction of the ontology and the negation of the conjecture is unsatisfiable. In addition, since theorem proving in FOL is a very hard problem, it is not reasonable to expect ATPs to find a proof for every entailed conjecture [20]. At the same time, we do not expect ATPs to find a model for non-entailed conjectures when working by refutation. Consequently, a CQ is decided to be entailed by the ontology only if ATPs are able to find a proof within the provided execution-time limit. According to this decision, CQs are classified as either (i) passing, (ii) non-passing or (iii) unknown using the following criteria:\n• If ATPs find a proof, then truth-tests are classified as passing since the corresponding conjectures are expected to be entailed, while falsitytests are classified as non-passing, because the corresponding conjectures are expected not to be entailed. For example, ATPs easily prove\n6http://www.tptp.org\nthat conjecture (6) is entailed by Adimen-SUMO v2.6, thus the truthtest is classified as passing.\n• Otherwise, if no proof is found, then we classify both truth- and falsitytests as unknown because we do not know whether the corresponding conjectures are entailed or not. For example, conjecture (7) is classified as unknown in Adimen-SUMO v2.6.\nInstead of CQs, in this paper we propose to use conjectures defined on the basis of the syntactic form of formulas. Our main assumption is that the formulas in an ontology are suitable for reasoning purposes and, thus, non-defective. Therefore, we propose truth-tests that (if passing) allow the classification of formulas as suitable, while the proposed falsity-tests enable the detection of defects (if non-passing)."
    }, {
      "heading" : "4. A White-Box Testing Strategy",
      "text" : "In this section, we propose a white-box testing strategy for FOL ontologies defined on the basis of the syntactical form of the formulas that are obtained from its axioms. The rationale behind our proposal is to ensure that the formula obtained from any axiom can be chosen by ATPs when working by refutation. Our purpose is twofold: on one hand, the detection of defects; on the other hand, the classification of axioms as suitable for reasoning purposes.\nWe assume that the reader has some familiarity with the syntax and basic notions of FOL. We call sentence to any FOL formula such that all its variable occurrences are in the scope of (or bound by) a quantifier. We use capital Greek letters (e.g. Φ) for (finite) sets of sentences, that equivalently can be seen as conjunctions of all its members. We use lower-case Greek letters for arbitrary formulas. The notation φ[α] represents the formula φ and, at the same time, means that the α is a subformula of φ. We denote by φ[α/γ] the formula that results from replacing every occurrence of α (as subformula of φ) with γ.\nGiven any FOL formula φ, the expressions (φ)∃ and (φ)∀ respectively denote the existential and universal closure of φ. Note that if φ is a sentence, then (φ)∃ and (φ)∀ are identical to φ. In addition, any (possibly empty) prefix of quantifiers Q1?x1 . . . Qn?xn such that n ≥ 0 and Qi ∈ {∃, ∀} for each 1 ≤ i ≤ n is abbreviated by Q?x. Two formulas φ and ψ are semantically (or logically) equivalent, in symbols φ ≡ ψ, if and only if they have exactly\nthe same models. Given any set of sentences Φ, we say that two formulas α and β are Φ-equivalent if and only if Φ |= (α ↔ β)∀.\nWe deal with a set of sentences Φ that together form an ontology. Most of the non-fact axioms in an ontology are (implicitly universally closed) implications. Actually, non-fact axioms in ontologies are usually called rules. For the sake of a more uniform treatment and a clear presentation, we use the equivalence ψ → γ ≡ (¬ψ) ∨ γ to transform implications into disjunctions. Hence, a subformula α∨β can be seen as the result of transforming (and simplifying) the implication (¬α) → β. And, by commutativity of disjunction, it can also be seen as (¬β) → α.\nOur strategy consists in searching for redundancy in implications or disjunctions, which reveals the existence of some defects in the ontology. Redundancy is not prevented by the consistency of the ontology. For example, given a consistent ontology Φ that includes an implication of the form (γ → ψ)∀, the formula Φ∧ (ψ)∃ could be inconsistent and, thus, ψ would be redundant in (γ → ψ)∀. However, this defect would remain hidden if (γ)∃ were not entailed by Φ —that is, if Φ 6|= (γ)∃— because (γ → ψ)∀ would not be used. In order to overcome this problem, we propose to create conjectures which ensure that implications can be chosen by ATPs when working by refutation. In the above example, checking by refutations that Φ |= (¬γ)∀ consists in refuting the set Φ∪{γ∃}. We say that (¬γ)∀ triggers the implication (γ → ψ)∀ when the refutation of Φ∪{γ∃} resolves pairs of complementary literals taken from clauses that come from γ∃ and (¬γ ∨ ψ)∀. In this sense, we say that conjectures trigger implications.\nConsequently, given a formula of the form φ[α ∨ β] in Φ we propose the following falsity-tests in order to detect defects by searching for redundant subformulas: (α)∀, (β)∀, (¬α)∀ and (¬β)∀.\nRoughly speaking, when (α)∀ is non-passing in Φ —that is, when Φ |= (α)∀—we detect that the antecedent of the interpreted implication (¬α) → β is unsatisfiable in Φ, hence β is redundant. Symmetrically, α is redundant in the interpreted implication (¬β) → α if (β)∀ is non-passing in Φ. Note that both falsity-tests (α)∀ and (β)∀ enable to trigger the interpreted implications.\nSimilarly, if some of the falsity-tests (¬α)∀ and (¬β)∀ are non-passing in Φ, we have that the antecedent of some of the implications (¬α) → β or (¬β) → α is interpreted as true in every possible model of Φ. Hence, ¬α and ¬β are respectively redundant in those implications. At the same time, the consequent of the implication (¬β) → α (resp. (¬α) → β) is interpreted as false in every possible model of Φ when (¬α)∀ (resp. (¬β)∀)\nis non-passing in Φ. Thus, the falsity-tests (¬α)∀ and (¬β)∀ enable to detect that the implications (¬β) → α and (¬α) → β yield to contradiction when triggered.\nNext, we illustrate our strategy for the creation of falsity-tests by means of an example.\nExample 1. Consider the following set of axioms that belong to the ontology Adimen-SUMO v2.4:7\n($instance sibling IrreflexiveRelation) (8)\n($domain sibling 1 Organism) (9)\n($domain sibling 2 Organism) (10)\n(=> (11)\n(and\n($instance ?BROOD Brood)\n(member ?MEMBER1 ?BROOD)\n(member ?MEMBER2 ?BROOD))\n(sibling ?MEMBER1 ?MEMBER2))\nAccording to the type information in axioms (9-10), both arguments of member are restricted to be instance of Organism. Consequently, we obtain the next formula from axiom (11) (see [1] for more details):\n∀?m1 ∀?m2 ∀?b ( ( ¬ ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) ) ) ∨\nsibling(?m1, ?m2) )\n(12)\nIn the above formula, it is easy to see that its inner subformula\n( ¬ ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) ) )\n︸ ︷︷ ︸ α\n∨ sibling(?m1, ?m2) ︸ ︷︷ ︸\nβ\n(13)\n7In this paper, all the axioms are to be considered universally closed.\nis disjunctive. Thus, we propose the following four falsity-tests\n∀?m1 ∀?m2 ∀?b ¬ ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) )\n(14)\n∀?m1 ∀?m2 ( sibling(?m1, ?m2) ) (15)\n∀?m1 ∀?m2 ∀?b ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) )\n(16)\n∀?m1 ∀?m2 ( ¬ sibling(?m1, ?m2) ) (17)\nfor detecting defects in subformula (13). By following the evaluation methodology described in Section 3, conjecture (14) is classified as non-passing, while conjectures (15-17) are classified as unknown. Thus, conjecture (14) enables to detect a defect: the antecedent of the implication in axiom (11) is unsatisfiable and, therefore, axiom (11) can be decided to be defective.8\nRegarding suitability, a formula is classified as suitable when no defect (that is, no redundant subformula) can be found by following the above white-box testing strategy. Being Φ consistent, a formula and its negation cannot be both entailed by Φ. Consequently, given any falsity-test θ, we know that no defect can be detected by means of θ if its negation ¬θ is entailed by Φ. Therefore, our strategy for the classification of the subformulas of Φ as suitable consists in using as truth-tests the negation of the falsity-tests proposed for Φ. In the case of a formula of the form φ[α∨ β] occurring in Φ, we propose the truth-tests (¬α)∃, (¬β)∃, (α)∃ and (β)∃.\nExample 2. By considering subformula (13) in Example 1, we propose the following truth-tests\n∃?m1 ∃?m2 ∃?b ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) )\n(18)\n8Axiom (11) has been corrected in Adimen-SUMO v2.6.\n∃?m1 ∃?m2 ( ¬ sibling(?m1, ?m2) ) (19)\n∃?m1 ∃?m2 ∃?b ¬ ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) )\n(20)\n∃?m1 ∃?m2 ( sibling(?m1, ?m2) ) (21)\nwhich are respectively obtained by the negation of falsity-tests (14-17). Conjecture 18 is classified as unknown (like expected, because its corresponding falsity-test is classified as non-passing), while conjectures (19-21) are classified as passing since ATPs find a proof. Thus, we can conclude that no additional defect can be detected by means of conjectures (15-17).\nBeing a testing strategy, it is obvious that our proposed conditions for the detection of defects and for the classification of subformulas as suitable are sufficient but not necessary, as stated by Dijkstra [7]."
    }, {
      "heading" : "5. Calculating White-Box Tests",
      "text" : "In this section, we introduce the definition of two functions that respectively computes the sets of falsity- and truth-tests proposed for a sentence φ. The first function is defined by induction in the sentence φ, which is assumed to belong to the language\nφ ::= ℓ | φ ∨ φ | φ ∧ φ | ∀xφ | ∃xφ\nwhere ℓ stands for literal (atom or negated atom). In addition, we can suppose that any quantifier in φ has a different variable symbol. Our assumption is not a limitation since it is well-known that any FOL formula can be transformed into a logically equivalent one in the above language. The transformation follows the three initial steps of the standard algorithm that transforms any FOL formula into its conjunctive normal form:\n1. Elimination of variable clashing. This is done by renaming clashing variables. As result, each quantifier has a unique variable.\n2. Transformation into arrow-free form. This is done by repeatedly applying the following two logical equivalences until no one can be applied:\n• ψ ↔ γ ≡ (ψ → γ) ∧ (γ → ψ)\n• ψ → γ ≡ (¬ψ) ∨ γ\n3. Transformation into negation normal form. This is done by repeatedly applying the following five logical equivalences until no one can be applied:\n• ¬¬ψ ≡ ψ\n• ¬(ψ ∧ γ) ≡ (¬ψ) ∨ (¬γ)\n• ¬(ψ ∨ γ) ≡ (¬ψ) ∧ (¬γ)\n• ¬∀?x ψ ≡ ∃?x ¬ψ\n• ¬∃?x ψ ≡ ∀?x ¬ψ\nIn the sequel, we say that the formulas in the above language are in arrowfree and negation normal form (af-nnf). It is worth to note that formula (12) in Example 1 is in af-nnf.\nNext, we define the function FT ( ), which is used to compute the set of falsity-tests proposed for any af-nnf sentence φ by following the white-box testing strategy introduced in Section 4. To this end, our proposal for the detection of defects by exclusively focusing on disjunction is extended to any connective and quantifier occurring in a disjunctive subformula of φ in the following way.\nDefinition 1. For any af-nnf formula φ, the function FT ( ) is recursively defined as\nFT (φ) =\n \n\n∅ if φ is a literal\nFT0(φ) if φ = α ∨ β\nFT (α) ∪ FT (β) if φ = α ∧ β\nFT (α) if φ = ∀?x α or φ = ∃?x α\nwhere:\nFT0(φ) =\n  \n \n∅ if φ is a literal\n{ (α)∀, (β)∀, (¬α)∀, (¬β)∀ } ∪\nFT0(α) ∪ FT0(β) if φ = α ∨ β or φ = α ∧ β\n{ (α)∀, (¬α)∀ } ∪ FT0(α) if φ = ∀?x α or φ = ∃?x α\nThe idea behind the above extension of the strategy for the detection of defects can be summed up as follows: for any falsity-tests {(δ)∀, (¬δ)∀} ⊆\nFT (φ), the sentence φ is logically equivalent to a (possibly quantified) conjunction of two formulas such that the first one is equal to a disjunction with Q?y δ as subformula for some prefix of quantifiers Q?y. The next lemma state this fact in a precise way.\nLemma 1. For any af-nnf sentence φ, if {(δ)∀, (¬δ)∀} ⊆ FT (φ) then φ is logically equivalent to a formula of the form\nQ?x ( ((Q?y δ) ∨ γ) ∧ ψ )\nfor some formulas γ and ψ and some (possibly empty) prefixes of quantifiers Q?x and Q?y. Moreover, γ is always different from the constant false, but ψ could be the constant true.\nProof. A proof by induction on the number of calls to FT ( ) and FT0( ) for checking that {(δ)∀, (¬δ)∀} ⊆ FT (φ) can be found in Appendix.\nIn the sequel, we say that (Q?y δ) ∨ γ) is the formula associated to φ by the pair of falsity-tests {(δ)∀, (¬δ)∀}.\nIt is obvious that the function FT ( ) could produce many repeated tests. For example, for φ = ∀?x ((∃?y α) ∨ (∀?z β)) we have that\nFT (φ) = FT (∀?x ((∃?y α) ∨ (∀?z β))) ∀ = FT0((∃?y α) ∨ (∀?z β)) ∨ = { (∃?y α)∀, (∀?z β)∀, (¬∃?y α)∀, (¬∀?z β)∀ } ∪\nFT0(∃?y α) ∪ FT0(∀?z β) ∃,∀ = { (∃?y α)∀, (∀?z β)∀, (¬∃?y α)∀, (¬∀?z β)∀ } ∪\n{ (α)∀, (¬α)∀ } ∪ FT0(α) ∪ { (β)∀, (¬β)∀ } ∪ FT0(β)\nwhere (∀?z β)∀ is equal to (β)∀ and (¬∃?y α)∀ is equal to (¬α)∀. However, it is not difficult to avoid repetitions in practice if necessary. We provide some figures about the final amount of falsity- and truth-tests in Section 8.\nWith respect to the creation of truth-tests, the function TT ( ) is simply defined on the basis of FT ( ) as follows.\nDefinition 2. For any af-nnf formula φ, the function TT ( ) is defined as:\nTT (φ) = {¬θ | θ ∈ FT (φ)}\nThe above definitions of the functions FT ( ) and TT ( ) consider disjunction and conjunction as binary connectives, but the extension to n-ary connectives is trivial."
    }, {
      "heading" : "6. A Detailed Example",
      "text" : "In this section, we provide a complete example of the set of tests that are obtained from a formula by using the definitions introduced in Section 5.\nFor the example, we consider the next axioms:\n($domain component 1 CorpuscularObject) (22)\n($domain component 2 CorpuscularObject) (23)\n(=> (24)\n($instance ?ATOM Atom)\n(exists (?PROTON ?ELECTRON)\n(and\n(component ?PROTON ?ATOM)\n(component ?ELECTRON ?ATOM)\n($instance ?PROTON Proton)\n($instance ?ELECTRON Electron))))\nUsing the type information in axioms (22-23) (see [1]), we can assume that the FOL formula obtained from axiom (24) is an af-nnf formula of the form\nφ = ∀?a (\nψ1 ︷ ︸︸ ︷ (¬i(?a, co)) ∨ (¬i(?a, am)) ∨ ∃?p ∃?e ( i(?p, co) ∧ i(?e, co) ∧\nc(?p, ?a) ∧ c(?e, ?a) ∧ i(?p, pn) ∧ i(?e, en) ︸ ︷︷ ︸\nψ2\n) )\n(25)\nwhere we have conveniently renamed the original predicate and function symbols as follows:\n• The predicates $instance and component have been renamed as i and c respectively.\n• The constants CorpuscularObject, Atom, Proton and Electron have been renamed as co, am, pn and en respectively.\n• The variables ?ATOM, ?PROTON and ?ELECTRON have been renamed as ?a, ?p and ?e respectively.\nSince the definitions of falsity- and truth-tests are dual, in this example we concentrate on falsity-tests. For the formula φ, we initially obtain\nFT (φ) = FT (∀?a (ψ1 ∨ ∃?p ∃?e ψ2)) ∀ = FT (ψ1 ∨ ∃?p ∃?e ψ2) ∨ = FT0(ψ1 ∨ ∃?p ∃?e ψ2) ∨ = { (ψ1) ∀, (¬ψ1) ∀ } ∪ FT0(ψ1) ∪\n{ (∃?p ∃?e ψ2) ∀, (¬∃?p ∃?e ψ2) ∀ } ∪\nFT0(∃?p ∃?e ψ2)\nwhere (ψ1) ∀, (¬ψ1) ∀, (∃?p ∃?e ψ2) ∀ and (¬∃?p ∃?e ψ2) ∀ respectively denote the conjectures:\n∀?a ( (¬i(?a, co)) ∨ (¬i(?a, am)) ) (26)\n∀?a ( i(?a, co) ∧ i(?a, am) ) (27)\n∀?a ∃?p ∃?e ( i(?p, co) ∧ i(?e, co) ∧ c(?p, ?a) ∧ c(?e, ?a)∧ i(?p, pn) ∧ i(?e, en) )\n(28)\n∀?a ¬ ∃?p ∃?e ( i(?p, co) ∧ i(?e, co) ∧ c(?p, ?a) ∧ c(?e, ?a)∧ i(?p, pn) ∧ i(?e, en) )\n(29)\nThen, we proceed to obtain the falsity-test proposed for ψ1:\nFT0(ψ1) = FT0((¬i(?a, co)) ∨ (¬i(?a, am))) ∨ = { (¬i(?a, co))∀, (i(?a, co))∀ } ∪ FT0(¬i(?a, co)) ∪\n{ (¬i(?a, am))∀, (i(?a, am))∀ } ∪ FT0(¬i(?a, am)) ¬ = { (¬i(?a, co))∀, (i(?a, co))∀ } ∪\n{ (¬i(?a, co))∀, (i(?a, co))∀ } ∪\n{ (¬i(?a, am))∀, (i(?a, am))∀ } ∪\n{ (¬i(?a, am))∀, (i(?a, am))∀ }\nIt is easy to see that all the falsity-tests proposed for ψ1 are defined twice. Next, we continue with the falsity-tests obtained from ∃?p ∃?e ψ2:\nFT0(∃?p ∃?e ψ2) = { (∃?e ψ2) ∀, (¬∃?e ψ2) ∀ } ∪ FT0(∃?e ψ2) ∃ = { (∃?e ψ2) ∀, (¬∃?e ψ2) ∀ } ∪\n{ (ψ2) ∀, (¬(ψ2)) ∀ } ∪ FT0(ψ2)\nAmong the above tests, (¬∃?e ψ2) ∀ and (¬ψ2) ∀ are identical. Finally, we enumerate the tests that are obtained from ψ2:\nFT0(ψ2) = FT0(i(?p, co) ∧ i(?e, co) ∧ c(?p, ?a) ∧ c(?e, ?a) ∧\ni(?p, pn) ∧ i(?e, en)) ∧ = { (i(?p, co))∀, (¬i(?p, co))∀ } ∪ FT0(i(?p, co)) ∪\n{ (i(?e, co))∀, (¬i(?e, co))∀ } ∪ FT0(i(?e, co)) ∪ { (c(?p, ?a))∀, (¬c(?p, ?a))∀ } ∪ FT0(c(?p, ?a)) ∪ { (c(?e, ?a))∀, (¬c(?e, ?a))∀ } ∪ FT0(c(?e, ?a)) ∪ { (i(?p, pn))∀, (¬i(?p, pn))∀ } ∪ FT0(i(?p, pn)) ∪\n{ (i(?e, en))∀, (¬i(?e, en))∀ } ∪ FT0(i(?e, en)) literal = { (i(?p, co))∀, (¬i(?p, co))∀ } ∪ ∅ ∪\n{ (i(?e, co))∀, (¬i(?e, co))∀ } ∪ ∅ ∪\n{ (c(?p, ?a))∀, (¬c(?p, ?a))∀ } ∪ ∅ ∪\n{ (c(?e, ?a))∀, (¬c(?e, ?a))∀ } ∪ ∅ ∪\n{ (i(?p, pn))∀, (¬i(?p, pn))∀ } ∪ ∅ ∪\n{ (i(?e, en))∀, (¬i(?e, en))∀ } ∪ ∅\nIn the above set, some of the tests are redundant: that is, although the tests (i(?p, co))∀ and (i(?e, co))∀ (also its negations) are not syntactically identical, (i(?p, co))∀ can be obtained from (i(?e, co))∀ by renaming the universally quantified variable ?p with ?e. Therefore, both expressions are denoting equivalent tests. Additionally, the test (i(?a, co))∀, which is also equivalent, belongs to FT0(ψ1). Consequently, the number of tests in FT (φ) can be substantially reduced by removing redundant tests. In total, 28 falsity-tests are obtained from FT (φ), from where 13 redundant tests can be removed. It is worth to note that additional redundant tests can arise when combining FT (φ) with the falsity-tests proposed for other formulas. To sum up, the set of falsity-tests proposed for φ is:\nFT (φ) = { (ψ1) ∀, (¬ψ1) ∀, (∃?e ψ2) ∀, (¬∃?e ψ2) ∀,\n(¬i(?a, co))∀, (i(?a, co))∀, (¬i(?a, am))∀,\n(i(?a, am))∀, (ψ2) ∀, (c(?p, ?a))∀, (¬c(?p, ?a))∀, (i(?p, pn))∀, (¬i(?p, pn))∀,\n(i(?e, en))∀, (¬i(?e, en))∀ }\nAmong the above falsity-tests, (ψ1) ∀ is classified as non-passing, while the remaining ones are classified as unknown. Therefore, we detect that the antecedent of the implication in axiom (24) is unsatisfiable and, consequently, axiom (24) is defective. In Adimen-SUMO v2.6, we have corrected axiom (24) by replacing the relation component with part in the consequent of its implication.\nWith respect to truth-tests, we obtain the following set of tests by negating the falsisty-tests in FT (φ):\nTT (φ) = { (¬ψ1) ∃, (ψ1) ∃, (¬∃?e ψ2) ∃, (∃?e ψ2) ∃,\n(i(?a, co))∃, (¬i(?a, co))∃, (i(?a, am))∃,\n(¬i(?a, am))∃, (¬ψ2) ∃, (¬c(?p, ?a))∃, (c(?p, ?a))∃, (¬i(?p, pn))∃, (i(?p, pn))∃,\n(¬i(?e, en))∃, (i(?e, en))∃ }\nAll the above truth-tests are classified as passing except for (¬ψ1) ∃, (¬∃?e ψ2) ∃ and (∃?e ψ2) ∃, which are classified as unknown. Consequently, we can conclude that all the tested subformulas of φ are suitable for reasoning purposes except for ψ1 —which has been already detected as defective— and ψ2."
    }, {
      "heading" : "7. Correctness",
      "text" : "In this section, we discuss about the correctness of the proposed tests. As explained in Sections 4 and 5, our white-box testing strategy is related to the existence of redundant subformulas in disjunctive subformulas. That is, the detection of defects consists in searching for redundant subformulas, while formulas are classified as suitable if no defect can be detected.\nNext, we first introduce our notion of redundancy.\nDefinition 3. Let Φ be a set of sentences and φ a sentence such that φ ∈ Φ. We say that φ contains a redundancy (according to Φ) if there exists a sentence φ′[α ∨ β] that is logically equivalent to φ such that φ′[(α ∨ β)/γ] is Φ-equivalent to φ for γ ∈ {α, β}. Moreover, when γ = α (resp. γ = β) we say that β (resp. α) is redundant in the subformula α ∨ β.\nIn words, redundancy means that some subformula (of a sentence) can be eliminated without loss of essential information, and such subformula is redundant. In practice, the sentence φ′ mentioned in the above definition is provided by Lemma 1.\nNext, we present the notion of correctness which refers to redundancy.\nDefinition 4. Let Φ be any set of af-nnf sentences and φ any sentence such that φ ∈ Φ. If (δ)∀ ∈ FT (φ) (resp. (¬δ)∀ ∈ FT (φ)), we say that (δ)∀ (resp. (¬δ)∀) is a correct falsity-test for Φ whenever φ contains some redundancy if Φ |= δ∀ (resp. Φ |= (¬δ)∀).\nIf δ∀ or (¬δ)∀ is correct, then the redundant subformula of φ′ is a superformula of δ. Redundant subformulas reveals the existence of defects. In addition, the proof obtained for falsity-tests can assist the correction of defects, but the correction itself is still a manual task. This is due to the fact that some defects spread its effect on several axioms, as described in the next section.\nFinally, we provide a formal proof of correctness for falsity-tests.\nTheorem 1. For any consistent set of af-nnf sentences Φ such that φ ∈ Φ, each conjecture in FT (φ) is a correct falsity-test for Φ.\nProof. Let {(δ)∀, (¬δ)∀} ⊆ FT (φ). By Lemma 1, φ is logically equivalent to:\nφ′ = Q?x ( (Q?y δ) ∨ γ ) ∧ ψ )\nHence, we are going to check the following two statements:\n(a) If Φ |= (δ)∀, then Φ |= φ′ ↔ φ′[( (Q?y δ) ∨ γ )/(Q?y δ)].\n(b) If Φ |= (¬δ)∀, then Φ |= φ′ ↔ φ′[( (Q?y δ) ∨ γ )/γ].\nNote that each statement not only ensures that the corresponding subformula is redundant in φ′, but also the substitution specifies what the redundant subformula is.\nIn order to check (a) and (b), we proceed by substitutivity of subformulas that are equivalents in (all models of) Φ, i.e. subformulas that are Φ-equivalents.\nFor (a), if Φ |= (δ)∀, then it is trivial that Φ |= (Q?y δ)∀. Hence, (Q?y δ)∨ γ is Φ-equivalent to Q?y δ.\nFor (b), if Φ |= (¬δ)∀, then Φ |= (¬Qy δ)∀. Hence, (Q?y δ) ∨ γ is Φ-equivalent to γ.\nFinally, since truth-tests are the negations of falsity-tests, assuming that Φ is consistent, if Φ |= ¬θ for some ¬θ ∈ TT (φ) and some φ ∈ Φ, then Φ 6|= θ with θınFT (φ). In other words, the fact of passing a truth-test warrants the absence of a possible defect. Consequently, the suitability of a sentence φ ∈ Φ in the ontology depends on passing every test in TT (φ)."
    }, {
      "heading" : "8. Experimentation",
      "text" : "In this section, we report on the results obtained by the application of our white-box testing method using ATPs. First, we introduce in detail and with examples the kind of defects that can be automatically discovered by following our proposal and also the different levels of suitability in which clauses can be classified. Then, we describe the process of testing KIFDOLCE, CASL-DOLCE, FPK and Adimen-SUMO in Subsections 8.2-8.4. Some figures about the process of testing of those ontologies are summarized in Table 2. In particular:\n• The total number of general clauses (non-atomic axioms) in each ontology (also reported in Table 1 and the amount of tested clauses (General Clauses columns).\n• The total amount of falsity-tests proposed for each ontology and the number of different falsity-tests (Falsity-tests columns).\nObviously, the amount of truth-tests is equal to the amount of falsity-tests in each case. Additionally, in Subsection 8.4 we also provide some figures about the process of improving Adimen-SUMO from v2.4 to v2.6.\nIn our experimentation, we have used Vampire [34] (v2.6, v3.0 and v4.1), with an execution time limit of 600 seconds, running on an Intel R© Xeon R© CPU E5-2640v3@2.60GHz with 2GB of RAM memory per processor. All the ontologies —KIF-DOLCE, CASL-DOLCE, FPK and Adimen-SUMO—, the sets of tests and the program for its generation, and the execution reports are freely available at http://adimen.si.ehu.es."
    }, {
      "heading" : "8.1. A Classification of Defects and Suitability Levels",
      "text" : "In this subsection, we introduce the kind of defects that are detected by following our proposal, which are classified in four main categories: typos, tautologies, redundant axioms, simple or trivial redundancies and hidden inconsistencies. Additionally, we also introduce the different levels of suitability for the classification of non-defective axioms according to the evaluation of the proposed truth-tests.\nThe first category of defects is typos: that is, simple (often syntactical) errors that lead to inconsistent formulas that are really easy to correct. An example of typo could be found in the axiomatization of OrchestralConducting given by the following former axiom of Adimen-SUMO\n(=> (30)\n(and\n($instance ?CONDUCT OrchestralConducting)\n(patient ?CONDUCT ?GRP))\n($instance ?CONDUCT Orchestra))\nwhich is pretending to state that every patient of an instance of the process OrchestralConducting is instance of Orchestra. However, the variable ?CONDUCT is incorrectly placed in the consequent of the implication instead of ?GRP. In order to correct this typo, in Adimen-SUMO v2.6 we have replaced axiom (30) with:\n(=> (31)\n(and\n($instance ?CONDUCT OrchestralConducting)\n(patient ?CONDUCT ?GRP))\n($instance ?GRP Orchestra))\nTautologies —formulas that are trivially equivalent to true— are the second category of defects than can be found by following our white-box testing method. For example, by the transformation of the following former axiom of Adimen-SUMO\n(=> (32)\n($instance ?C Circle)\n(exists (?P)\n(equal (CenterOfCircleFn ?C) ?P)))\ninto a FOL formula we obtain (1), which is a tautology since equality is reflexive. This defect can be detected by means of conjecture (2) which is proposed for triggering the reverse of the implication in axiom (32). This defect is corrected in Adimen-SUMO v2.6 by simply removing the tautological axiom, although a suitable definition of CenterOfCircleFn would be required.\nOur strategy also enables the detection of a restricted class of redundant axioms. While redundant axioms are those which can be inferred from the remaining conjunction of axioms, our strategy focuses on the particular case of axioms of the form of implications where its antecedent is unsatisfiable: that is, axioms where its main implication cannot be triggered. For example, conjecture (26) is proposed for discovering that the antecedent of the implication in axiom (24) is unsatisfiable. This conjecture enables the detection of a defect since it is entailed by Adimen-SUMO: Atom is subclass of Substance and does not have common instances with CorpuscularObject because Substance and CorpuscularObject are disjoint. Consequently, axiom (24) is classified as redundant since its implication cannot be triggered. In Adimen-SUMO v2.6, we correct axiom (24) by substituting the relation part for component. It is worth to note that conjecture (29), which is proposed for discovering that the implication in axiom (24) would lead to inconsistency if triggered, is also entailed by Adimen-SUMO: as Atom, Proton (also Electron) is subclass of Substance and, therefore, it does not have common instances with CorpuscularObject.\nThe fourth category of defects detected by our strategy is simple (trivial) redundancies, which corresponds to subformulas than can be simply removed from axioms without affecting the semantics of the whole formula. This kind of defects is sometimes introduced by some automatic transformation of axioms into a particular form, like the translation of domain axioms in Adimen-SUMO or the transformation of KIF-DOLCE into CASL-DOLCE. An example is given by the next clauses belonging to CASL-DOLCE, which define the disjointness of the top classes endurant, perdurant and quality with abstract:\n∀?y0 ( aB(?y0) → pT (y0) ) (33)\n∀?x1 ( eDorPDorQ(x1) → pT (x1)) ) (34)\n∀?x0 ( pT (?x0) → ¬(aB(x0) ∧ eDorPDorQ(x0)) ) (35)\nBy considering any of the implications in formulas (33-34), it is clear that\nformula (35) is equivalent to\n∀?x0 ¬(aB(x0) ∧ eDorPDorQ(x0)) (36)\nwhere we have replaced its antecedent with true. Finally, the last category of defects is hidden inconsistencies, which consists of consistent formulas that lead to contradiction when triggered. An example of hidden inconsistency is given by axiom (11). Working by refutation, ATPs could prove that Adimen-SUMO entailed conjecture (14), which triggers the next implication inherited from subformula (13):\n∀?m1 ∀?m2 ∀?b ( ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) ) ) → sibling(?m1, ?m2) )\n(37)\nFirst, by negating conjecture (14), we obtain:\n∃?m1 ∃?m2 ∃?b ( $instance(?m1, Organism) ∧ $instance(?m2, Organism) ∧ $instance(?b, Brood) ∧ member(?m1, ?b) ∧ member(?m2, ?b) )\n(38)\nSecond, the above formula is logically equivalent to\n∃?m ∃?b ( $instance(?m,Organism) ∧ $instance(?b, Brood) ∧ member(?m, ?b) )\n(39)\nbecause conjunction is idempotent. Then, from formulas (12,39) it follows that\n∃?m ( sibling(?m, ?m) )\nwhich easily yields to contradiction since sibling is irreflexive, as stated by axiom (8). Therefore, conjecture (14) enables the detection of a defect in subformula (13) that was hidden because of the lack of instances of Organism and Brood related by member. In Adimen-SUMO v2.6, we correct this defect by replacing axiom (11) with:\n(=> (40)\n(and\n($instance ?BROOD Brood)\n(member ?MEMBER1 ?BROOD)\n(member ?MEMBER2 ?BROOD)\n(not\n(equal ?MEMBER1 ?MEMBER2)))\n(sibling ?MEMBER1 ?MEMBER2))\nWith respect to notion of suitability of non-defective axioms (all the proposed falsity-tests are classified as unknown), we distinguish 3 different levels. The first level is completely suitable, which corresponds to the axioms where all the proposed truth-tests are classified as passing. The second level is partially suitable, which corresponds to the axioms where some of the proposed truth-tests are classified as passing while some other truth-tests are classified as unknown. Finally, axioms are said to be unsuitable if all the proposed truth-tests are classified as unknown. For example, from the following axioms of Adimen-SUMO v2.6\n($domain connected 1 Object) (41)\n($domain connected 1 Object) (42)\n(=> (43)\n(connected ?OBJ1 ?OBJ2)\n(or\n(meetsSpatially ?OBJ1 ?OBJ2)\n(overlapsSpatially ?OBJ1 ?OBJ2)))\nwe obtain the next formula by using the type information in axioms (41-42) (see [1]):\n∀?o1 ∀?o2 ( ( $instance(?o1, Object) ∧ $instance(?o2, Object) ∧ connected(?o1, ?o2) ) → ( meetsSpatially(?o1, ?o2) ∨\noverlapsSpatially(?o1, ?o2) ) )\n(44)\nBy following our proposal, we obtain 7 truth-tests which are classified as passing according to the methodology described in Section 3. Therefore,\nformula (44) and, consequently, axiom (43) are decided to be completely suitable for reasoning purposes."
    }, {
      "heading" : "8.2. Testing DOLCE",
      "text" : "In this subsection, we report on the results of testing DOLCE using the proposed white-box testing methodology. As introduced in Section 2, we consider two different FOL versions of DOLCE: KIF-DOLCE, which has been obtained by following the translation described in [1], and CASL-DOLCE, which has been obtained from the simplified translation of DOLCE into CASL [4] that is available in Hets [25].\nWith respect to KIF-DOLCE, we have obtained 10,151 falsity-tests for testing 215 axioms, as described in Table 2. Among the proposed falsity-tests, 2,138 are unique. Thus, we have also obtained 10,151 truth-test 2,138 are unique. By applying the methodology described in Section 3, the falsity-test\n(forall (?W ?X ?Y) (45)\n(not\n(psb ?W ?X ?Y)\nobtained from9\n(=> (46)\n(and\n(world ?W0)\n(universal ?F)\n(universal ?G))\n(equiv\n(psb ?W0 ?F ?G)\n(and\n(sb ?W0 ?F ?G)\n(not\n(sb ?W0 ?F ?G)))))\nis classified as non-passing, where sb is the subsumption relation of universals and psb, the proper subsumption relation. This classification enables to discover a typo in axiom (46) which is easily corrected as follows:\n9In KIF-DOLCE, psb is defined by means of the KIF predicate defrelation, which yields axiom (46).\n# Classification Evaluation Coverage\nNP P D CS PS U NA PA\nFalsity-tests 2,138 112 - 213 - - - 71 27.63% Truth-tests 2,138 - 407 - 0 2 0 44 17.12% Total - - - - - - - 77 29.96%\nAfter correcting axiom (46), we repeat our experimentation and discover that the falsity-test\n(forall (?W) (48)\n(not\n(world ?W)\nobtained from the next axiom10\n10The definition of dj also uses defrelation and its translation into a FOL formula is based on the predicate holds.\n(=> (49)\n(and\n(world ?W0)\n(universal ?F)\n(universal ?G))\n(equiv\n(dj ?W0 ?F ?G)\n(forall (?W ?X)\n(=>\n(and\n(wldr ?W0 ?W)\n(world ?W)\n(particular ?X))\n(not\n(and\n(holds ?F ?W ?X)\n(holds ?G ?W ?X)))))))\nis classified as non-passing, where dj is the disjointness relation of universals. Thus, axiom (49) can be classified as redundant and, consequently, this implies that dj has not associated semantics in KIF-DOLCE. By analysing the proof provided by ATPs, we discover that the problem comes from the axiomatization in KIF-DOLCE, which prevents the introduction of worlds and particulars. Actually, KIF-DOLCE is proven to be consistent, but the definition of any world or any particular yields to contradiction. There are 91 different falsity-tests that are classified as non-passing due to the same defect and its solution is non-trivial. The results of testing KIF-DOLCE are summarized in Table 3 as follows. First, the amount of proposed tests (# column) and its classification: the number non-passing tests (NP column) and passing-test (P column). It is worth to recall that only falsity-tests (resp. truth-tests) can be classified as non-passing (resp. passing). Second, the amount of axioms than can be classified as defective (D column), completely suitable (CS column), partially suitable (PS column) and unsuitable (U column). Again, only falsity-tests enable the detection of defective axioms, while truth-tests are used for the classification of non-defective axioms as either completely suitable, partially suitable or unsuitable. Finally, the\nnumber (NA column) and percentage (PA column) of different axioms that are used in some proof of the tests. As described in Table 3, among the proposed 2,138 falsity-tests, only 112 (5.24%) are classified as non-passing, while 407 truth-tests are classified as passing. However, among the tested axioms (215 from a total of 257 general clauses), non-passing falsity-tests enable to classify 213 axioms (99.07%) as defective and the remaining 2 non-defective axioms are classified partially suitable. Finally, only 77 axioms (29.96% of total) are used by ATPs, from which 71 axioms are used in the proofs of falsity-tests. Hence, we can conclude that ATPs are repeatedly using the same small subset of axioms in proofs.\nRegarding CASL-DOLCE, we have obtained 6,337 falsity-tests for testing 378 axioms (90.87% of 416 axioms), from which 1,266 falsity-tests are unique (see Table 2). Thus, we also have 1,266 truth-tests from a total of 6,337 truth-tests. The results of testing CASL-DOLCE are summarized in Table 4, which follows the same structure than Table 3. Only 30 (NP column) from the total of 1,266 falsity-tests (4.7%) are classified as non-passing. In all cases, the detected defects consist in trivial redundancies that are introduced by the automatic translation from CASL into TPTP syntax. In particular, the translation of dj (disjointness of universals) artificially introduces implications where its antecedent is redundant (detected by 20 different falsity-tests). Non-passing falsity test enables to classify 30 axioms as defective (D column), but all those axioms are correct although containing trivial redundancies. In addition, 1,093 truth-tests (P column, 86.33% of total) are classified as passing, which enables to classify 242 axioms as completely suitable (CS column, 64.02% of tested axioms) and 106 axioms as partially suitable (PS column, 28.04% of tested axioms). 324 different axioms (NA column) are used in the proofs of those 1,093 truth-tests, which are 77.88% (PA column) of total axioms. Consequently, the practical application of our proposal to CASL-DOLCE does not enable the detection of any critical de-\nfect, whereas nearly two thirds of the axioms are classified as completely suitable. It is worth to remark that CASL-DOLCE is a simplification of KIF-DOLCE and that its semantics is not equivalent. For example, we cannot check whether conjecture (48) is entailed by CASL-DOLCE because the predicate world is not translated into CASL."
    }, {
      "heading" : "8.3. Testing FPK",
      "text" : "Next, we review the results of testing FPK. As described in Table 2, we have obtained 144,902 falsity-tests for testing 5,753 axioms, from which 37,698 falsity-tests are unique, and also the same amount of (unique) truthtests.\nIn Table 5 —which follows the same structure than Table 3—, we summarize the results of testing FPK according the methodology described in Section 3 for the classification of tests. 581 falsity-tests (NP column, 1.54% of total) are classified as non-passing. Analysing the proofs, we discover that most of the detected defects are trivial redundancies. This is non-surprising since the objective of the Flyspeck project requires to check every logical inference, also trivial ones. For example, the truth-value true is encoded in the ontology by means of the following axiom (called aTRUTH):11\np(s(bool, t)) (50)\nThe above expression p(s(bool, t)) is used as subformula in 19 axioms, which produces 14 unique falsity-tests involving p(s(bool, t)). Those 14 falsity-tests enable the detection of the redundant uses of p(s(bool, t)). In particular, p(s(bool, t)) is redundantly used in axiom aREFLu CLAUSE\n∀?a ∀?x ( (s(?a, ?x) = s(?a, ?x)) → p(s(bool, t)) ) (51)\n11Indeed, axiom aEXISTSu UNIQUEu DEF is identical to aTRUTH.\nwhich is related to the reflexivity property. For the above axiom, our approach proposes the next falsity-test\n∀?a ∀?x ( s(?a, ?x) = s(?a, ?x) ) (52)\nwhich is a tautology since equality is defined as reflexive in FOL. Consequently, we are able to detect two redundant subformulas in axiom aREFLu CLAUSE by following our white-box testing method. Non-passing falsitytests enable to classify 610 axioms (D column, 10.60%) as defective. Thus, we can conclude that the number of defects detected in FPK is not high. Indeed, only 336 different axioms (NA column) are used in the proofs of the 581 non-passing falsity-tests.\nWith respect to suitability, 22,825 truth-tests (P column, 60.55% of total) are classified as passing, enabling to decide that 649 axioms are completely suitable (CS column, 11.28% of tested axioms). In the proofs for passing truth-tests, only 2,969 different axioms (NA column, 3.78% of 78,500 axioms) are used, which demonstrates that most of the axioms in FPK have not been used by ATPs when trying to find a proof for truth-tests. In our opinion, this is due to the large number of axioms in FPK and leads to conclude that more truth-tests could be classified as passing by enlarging the resources provided to ATPs (time and memory limits). It is worth to mention that set of axioms used in the proofs of truth- and falsity-tests are disjoint."
    }, {
      "heading" : "8.4. Testing and Improving Adimen-SUMO",
      "text" : "In this subsection, we describe the process of testing and improving Adimen-SUMO v2.4 by correcting all the defects detected using our proposal. As result, we have obtained Adimen-SUMO v2.6, which is also evaluated using our white-box testing method.\nBy the application of our testing proposal to Adimen-SUMO v2.4, we have obtained 27,392 falsity-tests for testing 1,622 axioms (58.24% of 2.785\ngeneral clauses). Among the proposed tests, 7,996 falsity-tests are unique (see Table 2). The results of testing Adimen-SUMO v2.4 by following the methodology described in Section 3 are summarized in Table 6. Although no defect was found by using the set of CQs proposed in [2], most of the falsity-tests are classified as non-passing (NP column, 7,991 falsity-tests), which enable to classify all the tested axioms as defective (D column, 1,622 axioms). At the same time, the truth-tests proposed as negation of the 5 falsity-tests classified as unknown are proved by ATPs. As in the case of KIF-DOLCE, the proofs for non-passing falsity-tests are based on a really small subset of axioms: 96 axioms (NA column), only 1.29% of total. This fact illustrates again the fact that some defects spread its effects on several axioms. We have proceeded to correct the detected set of defective axioms and apply again our testing proposal to the resulting ontology, but additional defective axioms have arisen. Consequently, the initial subset of defective axioms were hidden some other defects. Then, we have corrected the new detected defects and applied our testing proposal again.\nWe have iteratively proceeded in this way until no new defect is found. As result, we have obtained Adimen-SUMO v2.6. In total, we have completed 9 iterations of the process of testing and improving Adimen-SUMO. In this process, we have corrected 21 typos, 3 tautologies, 17 hidden inconsistencies and 44 redundancies that were detected by following our white-box method. In addition, 24 axioms detected to be defective in preliminary experimentations were already corrected in Adimen-SUMO v2.4.\nIn the last iteration, we have tested Adimen-SUMO v2.6. As described in Table 2, we have obtained 23,298 falsity-tests for testing 1,629 axioms (58.20% of 2,799 general clauses), from which 8,010 falsity-tests are unique, and the same amount of (unique) truth-tests. In Table 7, we summarize our testing results. No falsity-test is classified as non-passing by following the methodology described in Section 3, while 6,698 truth-tests (P column,\n83.62% of total) are classified as passing. Those passing truth-tests enables to classify 881 axioms as completely suitable (CS column, 54.08% of tested axioms) and 748 axioms as partially suitable (PS column, 45.92% of tested axioms). Further, 3,830 different axioms (NA and PA columns, 51.53% of total axioms) are used in the proofs of the 6,698 passing truth-tests. Thus, we can conclude that more than a half of Adimen-SUMO v2.6 has been validated by following our proposal. As in the case of FPK, we also think that we could validate a larger portion of Adimen-SUMO by enlarging the resources provided to ATPs."
    }, {
      "heading" : "9. Conclusions and Future Work",
      "text" : "A long-standing dream of Artificial Intelligence (AI) has pursued to enrich computer programs with commonsense knowledge enabling machines to reason about our world [22]. This work offers a new practical insight towards the automatic testing of first-order logic (FOL) ontologies. Next, we review the main contributions and results reported in this paper and discuss future work.\nTo the best of our knowledge, our proposal is the first attempt of exhaustively testing FOL ontologies in a fully automatic way by using ATPs. In addition, we provide formal proofs of the correctness of the proposed tests and report on the practical application of our methodology to four different FOL ontologies: Adimen-SUMO, KIF-DOLCE, CASL-DOLCE and FPK. By means of our methodology, we have been able to detect some defects in all of those ontologies, although in the last two ones, each defect can be trivially solved.\nIn the case of Adimen-SUMO, we have applied our white-box testing approach to Adimen-SUMO v2.4 and manually corrected all the defects that have been detected. After 9 iterations of the process of testing and correcting, we have obtained Adimen-SUMO v2.6, where we have detected no defect. Further, 54.32% of the axioms in Adimen-SUMO v2.6 have been classified as completely suitable for reasoning purposes and 83.25% of the tested subformulas have been classified as suitable.\nIt is worth to remark that testing the suitability for reasoning purposes of axioms is often much more interesting than checking the consistency of ontologies. For example, KIF-DOLCE is proved to be consistent by Vampire v4.1 although 99% of its axioms are classified as defective and none is classified as suitable for reasoning purposes. Dually, it is also really interesting to\nevaluate the competency of axioms by following black-box testing strategies, such as the one proposed in [2].\nAll the resources that have been used and developed during this work are available in a single package, including:12 a) the ontologies; b) tools for the creation of tests, its experimentation and the analysis of results; and c) the resulting tests for each ontology and the output obtained from different ATPs.\nRegarding future work, we have just introduced some white-box testing strategies for FOL ontologies by initially focusing on disjunction and then extending our proposal to the remaining connectives, but different ones could be proposed. Thus, we plan to study new white-box testing strategies in the future. We also plan to apply our white-box testing methodology to all the future versions of Adimen-SUMO."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work has been partially funded by the Spanish Projects TUNER (TIN2015-65308-C5-1-R) and COMMAS (TIN2013-46181-C2-2-R), the Basque Project LoRea (GIU15/30) and grant BAILab (UFI11/45)."
    }, {
      "heading" : "Appendix A. Proofs",
      "text" : "Lemma 1. For any af-nnf sentence φ, if {(δ)∀, (¬δ)∀} ⊆ FT (φ) then φ is logically equivalent to a formula of the form\nQ?x ( ((Q?y δ) ∨ γ) ∧ ψ )\nfor some formulas γ and ψ and some (possibly empty) prefixes of quantifiers Q?x and Q?y. Moreover, γ is always different from the constant false, but ψ could be the constant true.\nProof. The proof is by induction on the number of calls to FT ( ) and FT0( ) that are made to check that {(δ)∀, (¬δ)∀} ⊆ FT (φ).\nWe are going to prove that for any subformula χ (could be non-sentence) of φ, if {(δ)∀, (¬δ)∀} ⊆ FT (χ) then χ is logically equivalent to some formula of the form Q?x ( ((Q?y δ)∨ γ)∧ψ ) and, moreover, the variables ?x, ?y are the variables in some quantifier of a subformula of χ.\nIt is worthy to note that φ has not variable clashing (see Section 5), hence the variables occurring in some quantifier of a subformula χ cannot appear in any quantifier of some subformula of φ different from χ.\nThe base step is when χ = δ ∨ γ so that FT (φ) = FT0(δ ∨ γ) = {(δ)∀, (¬δ)∀}∪{(γ)∀, (¬γ)∀}∪FT0(δ)∪FT0(γ). So that the property holds for empty prefixes of quantifiers and ψ = true. Symmetrically for χ = γ ∨ δ, since disjunction is commutative.\nFor the inductive step, we distinguish the following cases according to the definition of FT ( ) and FT0( ):\n• FT (χ) = FT0(α1 ∧ β1) ∨ β) ⊃ FT0(α1 ∧ β1) ∪ FT0(β), and then {(δ)∀, (¬δ)∀} ⊇ FT0(α1) or {(δ) ∀, (¬δ)∀} ⊆ FT0(β1).\nWe prove only the case {(δ)∀, (¬δ)∀} ⊇ FT0(α1), since for β1 the proof is identical by commutativity of conjunction.\nBy induction hypothesis, if {(δ)∀, (¬δ)∀} ⊆ FT0(α1), then there exists γ′ and ψ′ such that:\nα1 ≡ Q?x ( ((Q?y δ) ∨ γ ′) ∧ ψ′ )\nwhere variables ?x, ?y cannot appear neither in β1 nor in β. Therefore:\nχ ≡ ( ( Q?x ( ((Q?y δ) ∨ γ′) ∧ ψ′ ) ) ∧ β1 ) ∨ β\n≡ ( Q?x ( ((Q?y δ) ∨ γ′) ∧ (ψ′ ∧ β1) ) ) ∨ β ≡ Q?x ( ((Q?y δ) ∨ (γ′ ∨ β)) ∧ ((ψ′ ∧ β1) ∨ β) )\nHence, we can take γ′∨β as γ and (ψ′∧β1)∨β as ψ, and the property of variables ?x, ?y is trivially preserved.\n• FT (χ) = FT0((∀z α)∨β) ⊃ FT0(α)∪FT0(β), and then {(δ) ∀, (¬δ)∀} ⊆\nFT0(α). By induction hypothesis, there exists γ ′ and ψ′ such that:\nα ≡ Q?x ( ((QQy δ) ∨ γ′) ∧ ψ′ ; )\nTherefore:\nχ ≡ ∀?z ( Q?x ( ((Q?y δ) ∨ γ′) ∧ ψ′ ) ) ∨ β\nSince ?z and ?x, ?y does not appear in β, we have that:\nχ ≡ ∀?z Q?x ( ((Q?y δ) ∨ (γ′ ∨ β)) ∧ (ψ′ ∨ β) )\nThus, the property holds for an extension of the outermost prefix with ?z, and for γ′ ∨ β as γ and ψ′ ∨ β as ψ.\n• The proof for FT (χ) = FT0((∃?z α) ∨ β) ⊃ FT0(α) ∪ FT0(β) and {(δ)∀, (¬δ)∀} ⊆ FT0(α), is identical to the previous one.\n• Suppose that FT (χ) = FT (α∧β) = FT (α)∪FT (β) and {(δ)∀, (¬δ)∀} ⊆ FT (α). By induction hypothesis\nα ≡ Q?x ( ((Q?y δ) ∨ γ′) ∧ ψ′ )\nfor some γ′ and ψ′. Therefore, since ?x does not appear in β\nχ ≡ ( Q?x ( ((Q?y δ) ∨ γ′) ∧ ψ′ ) ) ∧ β\n≡ Q?x ( ((Q?y δ) ∨ γ′) ∧ (ψ′ ∧ β) )\nand the lemma property is true for γ = γ′ and ψ = ψ′ ∧ β.\n• For FT (χ) = FT (∀?z α) ⊃ FT (α) and {(δ)∀, (¬δ)∀} ⊆ FT (α). By induction hypothesis\nα ≡ Q?x ( ((Q?y δ) ∨ γ) ∧ ψ )\nfor some γ and ψ. Therefore:\nχ ≡ ∀?z Q?x ( ((Q?y δ) ∨ γ) ∧ ψ )\nThis ensures the lemma property by enlarging the outermost prefix of quantifiers with ?z.\n• The proof for FT (χ) = FT (∃?z α) ⊃ FT (α) and {(δ)∀, (¬δ)∀} ⊆ FT (α) is identical to the previous one."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "A long-standing dream of Artificial Intelligence (AI) has pursued to encode<lb>commonsense knowledge into computer programs enabling machines to rea-<lb>son about our world and problems. This work offers a new practical insight<lb>towards the automatic testing of first-order logic (FOL) ontologies. We intro-<lb>duce a novel fully automatic white-box testing framework for first-order logic<lb>(FOL) ontologies. The application of the proposed testing method is fully<lb>automatic since a) the automated generation of tests is only guided by the<lb>syntax of axioms and b) the evaluation of tests is performed by automated<lb>theorem provers. Our proposal enables the detection of defective axioms<lb>and, additionally, it also serves to demonstrate the suitability for reasoning<lb>purposes of those formulas included into FOL ontologies. We validate our<lb>proposal by its practical application to different FOL ontologies. In partic-<lb>ular, DOLCE —consisting of around 200 axioms—, FPK (formal proof of<lb>the Kepler conjecture) —which has been derived from the Flyspeck project<lb>for its use in the CADE ATP System Competition CASC-J8—, and Adimen-<lb>SUMO —which is an ontology with more than 7,000 axioms derived from<lb>SUMO—. As result, we have detected several non-trivial defects that were<lb>hidden in those ontologies. Further, we have obtained an improved version<lb>of Adimen-SUMO (v2.6) by correcting all the defects detected during the<lb>practical application of our white-box testing method.",
    "creator" : "LaTeX with hyperref package"
  }
}