{
  "name" : "1309.6297.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Generating Explanations for Biomedical Queries",
    "authors" : [ "ESRA ERDEM", "UMUT OZTOK", "Esra Erdem", "Umut Oztok" ],
    "emails" : [ "esraerdem@sabanciuniv.edu)", "uoztok@sabanciuniv.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "KEYWORDS: answer set programming, explanation generation, query answering, biomedical queries\n1 Introduction\nRecent advances in health and life sciences have led to generation of a large amount of biomedical data, represented in various biomedical databases or ontologies. That these databases and ontologies are represented in different formats and constructed/maintained independently from each other at different locations, have brought about many challenges for answering complex biomedical queries that require integration of knowledge represented in these ontologies and databases. One of the challenges for the users is to be able to represent such a biomedical query in a natural language, and get its answers in an understandable form. Another challenge is to extract relevant knowledge from different knowledge resources, and integrate them appropriately using also definitions, such as, chains of gene-gene interactions, cliques of genes based on gene-gene relations, or similarity/diversity of genes/drugs. Furthermore, once an answer is found for a complex query, the experts may need further explanations about the answer.\nTable 1 displays a list of complex biomedical queries that are important from the point of view of drug discovery. In the queries, drug-drug interactions present negative interactions among drugs, and gene-gene interactions present both negative and positive interactions among genes. Consider, for instance the query Q6. New molecule synthesis by changing substitutes of parent compound may lead to different biochemical and physiological effects; and each trial may lead to different indications. Such studies are important for fast inventions of new molecules. For example, while developing the drug Lovastatin (a member of the drug class of Hmg-coa reductase inhibitors, used for lowering cholesterol) from Aspergillus terreus (a sort of fungus) in 1979, scientists at Merck derived a new molecule named Simvastatin that also belongs to the same drug category (a hypolipidemic drug used\nar X\niv :1\n30 9.\n62 97\nv1 [\ncs .A\nI] 2\n4 Se"
    }, {
      "heading" : "2 Esra Erdem, Umut Oztok",
      "text" : "to control elevated cholesterol) targeting the same gene. Therefore, identifying genes targeted by a group of drugs automatically by means of queries like Q6 may be useful for experts.\nOnce an answer to a query is found, the experts may ask for an explanation to have a better understanding. For instance, an answer for the query Q3 in Table 1 is “ADRB1”. A shortest explanation for this answer is as follows:\nThe drug Epinephrine targets the gene ADRB1 according to CTD. The gene DLG4 interacts with the gene ADRB1 according to BIOGRID.\nAn answer for the query Q8 is “CASK”. A shortest explanation for this answer is as follows:\nThe distance of the gene CASK from the start gene is 2. The gene CASK interacts with the gene DLG4 according to BIOGRID. The distance of the gene DLG4 from the start gene is 1.\nThe gene DLG4 interacts with the gene ADRB1 according to BIOGRID. ADRB1 is the start gene.\n(Statements with more indentations provide explanations for statements with less indentations.)\nTo address the first two challenges described above (i.e., representing complex queries in natural language and finding answers to queries efficiently), novel methods and a software system, called BIOQUERY-ASP (Erdem et al. 2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):\nGenerating Explanations for Biomedical Queries 3\n• Erdem and Yeniterzi (Erdem and Yeniterzi 2009) developed a controlled natural language, BIOQUERY-CNL, for expressing biomedical queries related to drug discovery. For instance, queries Q1–Q10 in Table 1 are in this language. Recently, this language has been extended (called BIOQUERY-CNL*) to cover queries Q11– Q13 (Oztok 2012). Some algorithms have been introduced to translate a given query in BIOQUERY-CNL (resp. BIOQUERY-CNL*) to a program in ASP as well. • Bodenreider et al. (Bodenreider et al. 2008) introduced methods to extract biomedical information from various knowledge resources and integrate them by a rule layer. This rule layer not only integrates those knowledge resources but also provides definitions of auxiliary concepts. • Erdem et al. (Erdem et al. 2011) have introduced an algorithm for query answering by identifying the relevant parts of the rule layer and the knowledge resources with respect to a given query.\nThe details of representing biomedical queries in natural language and answering them using ASP are explained in a companion article. The focus of this article is the last challenge: generating explanations for biomedical queries.\nMost of the existing biomedical querying systems (e.g., web services built over the available knowledge resources) support keyword search but not complex queries like the queries in Table 1. None of the existing systems can provide informative explanations about the answers, but point to related web pages of the knowledge resources available online.\nThe contributions of this article can be summarized as follows.\n• We have formally defined “explanations” in ASP, utilizing properties of programs and graphs. We have also defined variations of explanations, such as “shortest explanations” and “k different explanations”. • We have introduced novel generic algorithms to generate explanations for biomedical queries. These algorithms can compute shortest or k different explanations. We have analyzed the termination, soundness, and complexity of those algorithms. • We have developed a computational tool, called EXPGEN-ASP, that implements these explanation generation algorithms. • We have showed the applicability of our methods to generate explanations for answers of complex biomedical queries related to drug discovery. • We have embedded EXPGEN-ASP into BIOQUERY-ASP so that the experts can obtain explanations regarding the answers of biomedical queries, in a natural language.\nThe rest of the article is organized as follows. In Section 2, we provide a summary of Answer Set Programming. Next, in Section 3, we give an overview of BIOQUERYASP, in particular, the earlier work done on answering biomedical queries in ASP. Then, in Sections 4–6, we provide some definitions and algorithms related to generating shortest or k different explanations for an answer, also in ASP. Next, Section 7 illustrates the usefulness of these algorithms on some complex queries over the biomedical knowledge resources PHARMGKB (McDonagh et al. 2011),1 DRUGBANK (Knox et al. 2010),2\n1 http://www.pharmgkb.org/ 2 http://www.drugbank.ca/"
    }, {
      "heading" : "4 Esra Erdem, Umut Oztok",
      "text" : "BIOGRID (Stark et al. 2006),3 CTD (Davis et al. 2011),4 SIDER (Kuhn et al. 2010),5 DISEASE ONTOLOGY (Schriml et al. 2012)6 and ORPHADATA.7 In Sections 8 and 9, we discuss how to present explanations to the user in a natural language, and embedding of these algorithms in BIOQUERY-ASP. In Section 10, we provide a detailed analysis of the related work on “justifications” (Pontelli et al. 2009) in comparison to explanations; and in Section 11, we briefly discuss other related work. We conclude in Section 12 by summarizing our contributions and pointing out some possible future work. Proofs are provided in the online appendix of the paper.\n3 http://thebiogrid.org/ 4 http://ctd.mdibl.org/ 5 http://sideeffects.embl.de/ 6 http://disease-ontology.org 7 http://www.orphadata.org\nGenerating Explanations for Biomedical Queries 5\n2 Answer Set Programming\nAnswer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems. The idea is to represent a problem as a “program” whose models (called “answer sets” (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions. The answer sets for the given program can then be computed by special implemented systems called answer set solvers. ASP has a high-level representation language that allows recursive definitions, aggregates, weight constraints, optimization statements, and default negation.\nASP also provides efficient solvers, such as CLASP (Gebser et al. 2007). Due to the continuous improvement of the ASP solvers and highly expressive representation language of ASP which is supported by a strong theoretical background that results from a years of intensive research, ASP has been applied fruitfully to a wide range of areas. Here are, for instance, three applications of ASP used in industry:\n• Decision Support Systems: An ASP-based system was developed to help flight controllers of space shuttle solve some planning and diagnostic tasks (Nogueira et al. 2001) (used by United Space Alliance). • Automated Product Configuration: A web-based commercial system uses an ASPbased product configuration technology (Tiihonen et al. 2003) (used by Variantum Oy). • Workforce Management: An ASP-based system is developed to build teams of employees to handle incoming ships by taking into account a variety of requirements, e.g., skills, fairness, regulations (Ricca et al. 2012) (used by Gioia Tauro seaport).\nLet us briefly explain the syntax and semantics of ASP programs and describe how a computational problem can be solved in ASP.\n2.1 Programs\nSyntax The input language of ASP programs are composed of three sets namely constant symbols, predicate symbols, and variable symbols where intersection of constant symbols and variable symbols is empty. The basic elements of the ASP programs are atoms. An atom p(~t) is composed of a predicate symbol p and terms ~t = t1, . . . , tk where each ti (1 ≤ i ≤ k) is either a constant or a variable. A literal is either an atom p(~t) or its negated form not p(~t).\nAn ASP program is a finite set of rules of the form:\nA← A1, . . . , Ak, not Ak+1, . . . , not Am (1) where m ≥ k ≥ 0 and each Ai is an atom; whereas, A is an atom or ⊥.\nFor a rule r of the form (1), A is called the head of the rule and denoted by H(r). The conjunction of the literals A1, . . . , Ak, not Ak+1, . . . , not Am is called the body of r. The set {A1, ..., Ak} of atoms (called the positive part of the body) is denoted by B+(r), and the set {Ak+1, ..., Am} of atoms (called the negative part of the body) is denoted by B−(r), and all the atoms in the body are denoted by B(r) = B+(r) ∪B−(r)."
    }, {
      "heading" : "6 Esra Erdem, Umut Oztok",
      "text" : "We say that a rule r is a fact if B(r) = ∅, and we usually omit the← sign. Furthermore, we say that a rule r is a constraint if the head of r is ⊥, and we usually omit the ⊥ sign.\nSemantics (Answer Sets) Answer sets of a program are defined over ground programs. We call an atom, rule, or program ground, if it does not contain any variables. Given a program Π, the set UΠ represents all the constants in Π, and the set BΠ represents all the ground atoms that can be constructed from atoms in Π with constants in UΠ. Also, Ground(Π) denotes the set of all the ground rules which are obtained by substituting all variables in rules with the set of all possible constants in UΠ.\nA subset I of BΠ is called an interpretation for Π. A ground atom p is true with respect to an interpretation I if p ∈ I; otherwise, it is false. Similarly, a set S of atoms is true (resp., false) with respect to I if each atom p ∈ S is true (resp., false) with respect to I . An interpretation I satisfies a ground rule r, if H(r) is true with respect to I whenever B+(r) is true and B−(r) is false with respect to I . An interpretation I is called a model of a program Π if it satisfies all the rules in Π.\nThe reduct ΠI of a program Π with respect to an interpretation I is defined as follows:\nΠI = {H(r)← B+(r) | r ∈ Ground(Π) s.t. I ∩B−(r) = ∅} An interpretation I is an answer set for a program Π, if it is a subset-minimal model\nfor ΠI , and AS(Π) denotes the set of all the answer sets of a program Π. For example, consider the following program Π1:\np← not q (2) and take an interpretation I = {p}. The reduct ΠI1 is as follows:\np (3)\nThe interpretation I is a model of the reduct (3). Let us take a strict subset I ′ of I which is ∅. Then, the reduct ΠI′1 is again equal to (3); however, I ′ does not satisfy (3). Therefore, I = {p} is a subset-minimal model; hence an answer set of Π1. Note also that {p} is the only answer set of Π.\n2.2 Generate-And-Test Representation Methodology with Special ASP Constructs\nThe idea of ASP (Lifschitz 2008) is to represent a computational problem as a program whose answer sets correspond to the solutions of the problem, and to find the answer sets for that program using an answer set solver.\nWhen we represent a problem in ASP, two kinds of rules play an important role: those that “generate” many answer sets corresponding to “possible solutions”, and those that can be used to “eliminate” the answer sets that do not correspond to solutions. The rules\np← not q q ← not p (4)\nare of the former kind: they generate the answer sets {p} and {q}. Constraints are of the latter kind. For instance, adding the constraint\n← p\nGenerating Explanations for Biomedical Queries 7\nto program (4) eliminates the answer sets for the program that contain p. In ASP, we use special constructs of the form\n{A1, . . . , An}c (5)\n(called choice expressions), and of the form\nl ≤ {A1, . . . , Am} ≤ u (6)\n(called cardinality expressions) where each Ai is an atom and l and u are nonnegative integers denoting the “lower bound” and the “upper bound” (Simons et al. 2002). Programs using these constructs can be viewed as abbreviations for normal nested programs defined in (Ferraris and Lifschitz 2005). Expression (5) describes subsets of {A1, . . . , An}. Such expressions can be used in heads of rules to generate many answer sets. For instance, the answer sets for the program\n{p, q, r}c ← (7) are arbitrary subsets of {p, q, r}. Expression (6) describes the subsets of the set {A1, . . . , Am} whose cardinalities are at least l and at most u. Such expressions can be used in constraints to eliminate some answer sets. For instance, adding the constraint\n← 2 ≤ {p, q, r} to program (7) eliminates the answer sets for (7) whose cardinalities are at least 2. We abbreviate the rules\n{A1, . . . , Am}c ← Body ← not (l ≤ {A1, . . . , Am}) ← not ({A1, . . . , Am} ≤ u)\nby the rule\nl ≤ {A1, . . . , Am}c ≤ u← Body. In ASP, there are also special constructs that are useful for optimization problems. For instance, to compute answer sets that contain the maximum number of elements from the set {A1, . . . , Am}, we can use the following optimization statement.\nmaximize〈{A1, . . . , Am}〉\n2.3 Presenting Programs to Answer Set Solvers\nOnce we represent a computational problem as a program whose answer sets correspond to the solutions of the problem, we can use an answer set solver to compute the solutions of the problem. To present a program to an answer set solver, like CLASP, we need to make some syntactic modifications.\nRecall that answer sets for a program are defined over ground programs. Thus, the input of ASP solvers should be ground instantiations of the programs. For that, programs go through a “grounding” phase in which variables in the program (if exists) are substituted by constants. For CLASP, we use the “grounder” GRINGO (Gebser et al. 2011).\nAlthough the syntax of the input language of GRINGO is somewhat more restricted than the class of programs defined above, it provides a number of useful special constructs. For"
    }, {
      "heading" : "8 Esra Erdem, Umut Oztok",
      "text" : "instance, the head of a rule can be an expression of one of the forms\n{A1, . . . , An}c l ≤ {A1, . . . , An}c {A1, . . . , An}c ≤ u l ≤ {A1, . . . , An}c ≤ u\nbut the superscript c and the sign ≤ are dropped. The body can also contain cardinality expressions but the sign ≤ is dropped. In the input language of GRINGO, :- stands for←, and each rule is followed by a period. For facts← is dropped. For instance, the rule\n1 ≤ {p, q, r}c ≤ 1←\ncan be presented to GRINGO as follow:\n1{p,q,r}1.\nVariables in a program are represented by strings whose initial letters are capitalized. The constants and predicate symbols, on the other hand, start with a lowercase letter. For instance, the program Πn\npi ← not pi+1 (1 ≤ i ≤ n)\ncan be presented to GRINGO as follows:\nindex(1..n). p(I) :- not p(I+1), index(I).\nHere, the auxiliary predicate index is a “domain predicate” used to describe the ranges of variables. Variables can be also used “locally” to describe the list of formulas. For instance, the rule\n1 ≤ {p1, . . . , pn} ≤ 1 can be expressed in GRINGO as follows\nindex(1..n). 1{p(I) : index(I)}1.\n3 Answering Biomedical Queries\nWe have earlier developed the software system BIOQUERY-ASP (Erdem et al. 2011) (see Figure 1) to answer complex queries that require appropriate integration of relevant knowledge from different knowledge resources and auxiliary definitions such as chains of drugdrug interactions, cliques of genes based on gene-gene relations, or similar/diverse genes. As depicted in Figure 1, BIOQUERY-ASP takes a query in a controlled natural language and transforms it into ASP. Meanwhile, it extracts knowledge from biomedical databases and ontologies, and integrates them in ASP. Afterwards, it computes an answer to the given query using an ASP solver.\nLet us give an example to illustrate these stages; the details of representing biomedical queries in natural language and answering them using ASP are explained in a companion article though.\nGenerating Explanations for Biomedical Queries 9\nFirst of all, let us mention that knowledge related to drug discovery is extracted from the biomedical databases/ontologies and represented in ASP. If the biomedical ontology is in RDF(S)/OWL then we can extract such knowledge using the ASP solver DLVHEX (Eiter et al. 2006) by making use of external predicates. For instance, consider as an external theory a Drug Ontology described in RDF. All triples from this theory can be exported using the external predicate &rdf:\ntriple_drug(X,Y,Z) :- &rdf[\"URI for Drug Ontology\"](X,Y,Z).\nThen the names of drugs can be extracted by DLVHEX using the rule:\ndrug_name(A) :- triple_drug(_,\"drugproperties:name\",A).\nSome knowledge resources are provided as relational databases, or more often as a set of triples (probably extracted from ontologies in RDF). In such cases, we use short scripts to transform the relations into ASP.\nTo relate the knowledge extracted from the biomedical databases or ontologies and also provide auxiliary definitions, a rule layer is constructed in ASP. For instance, drugs targeting genes are described by the relation drug_gene defined in the rule layer as follows:\ndrug_gene(D,G) :- drug_gene_pharmgkb(D,G). drug_gene(D,G) :- drug_gene_ctd(D,G).\nwhere drug_gene_pharmgkb and drug_gene_ctd are relations for extracting knowledge from relevant knowledge resources. The auxiliary concept of reachability of a gene from another gene by means of a chain of gene-gene interactions is defined in the rule layer as well:\ngene_reachable_from(X,1) :- gene_gene(X,Y), start_gene(Y). gene_reachable_from(X,N+1) :- gene_gene(X,Z),\ngene_reachable_from(Z,N), 0 < N, N < L, max_chain_length(L).\nNow, consider, for instance, the query Q11 from Table 1.\nQ11 What are the drugs that treat the disease Depression and that do not target the gene ACYP1?\nThis type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer’s Viagra (Gower 2009).\nThis query is then translated into the following program in the language of GRINGO:\nwhat_be_drugs(DRG) :- cond1(DRG), cond2(DRG). cond1(DRG) :- drug_disease(DRG,\"Depression\"). cond2(DRG) :- drug_name(DRG), not drug_gene(DRG,\"ACYP1\"). answer_exists :- what_be_drugs(DRG). :- not answer_exists."
    }, {
      "heading" : "10 Esra Erdem, Umut Oztok",
      "text" : "where cond1 and cond2 are invented relations, drug_name, drug_disease and drug_gene are defined in the rule layer.\nOnce the query and the rule layer are in ASP, the parts of the rule layer that are relevant to the given query are identified by an algorithm (Erdem et al. 2011). For some queries, the relevant part of the program is almost 100 times smaller than the whole program (considering the number of ground rules).\nThen, given the query as an ASP program and the relevant knowledge as an ASP program, we can find answers to the query by computing an answer set for the union of these two programs using CLASP. For the query above an answer computed in this way is “Fluoxetine”.\n4 Explaining an Answer for a Query\nOnce an answer is found for a complex biomedical query, the experts may need informative explanations about the answer, as discussed in the introduction. With this motivation, we study generating explanations for complex biomedical queries. Since the queries, knowledge extracted from databases and ontologies, and the rule layer are in ASP, our studies focus on explanation generation within the context of ASP.\nBefore we introduce our methods to generate explanations for a given query, let us introduce some definitions regarding explanations in ASP.\nLet Π be the relevant part of a ground ASP program with respect to a given biomedical query Q (also a ground ASP program), that contains rules describing the knowledge extracted from biomedical ontologies and databases, the knowledge integrating them, and the background knowledge. Rules in Π ∪ Q generally do not contain cardinality/choice expressions in the head; therefore, we assume that in Π ∪ Q only bodies of rules contain cardinality expressions. Let X be an answer set for Π∪Q. Let p be an atom that characterizes an answer to the query Q. The goal is to find an “explanation” as to why p is computed as an answer to the query Q, i.e., why is p in X? Before we introduce a definition of an explanation, we need the following notations and definitions.\nWe say that a set X of atoms satisfies a cardinality expression C of the form\nl ≤ {A1, . . . , Am} ≤ u\nif the cardinality of X ∩ {A1, . . . , Am} is within the lower bound l and upper bound u. Also X satisfies a set SC of cardinality expressions (denoted by X |= SC), if X satisfies every element of SC.\nLet Π be a ground ASP program, r be a rule in Π, p be an atom in Π, and Y and Z be two sets of atoms. Let Bcard(r) denote the set of cardinality expressions that appear in the body of r. We say that r supports an atom p using atoms in Y but not in Z (or with respect to Y but Z), if the following hold:\nH(r) = p, B+(r) ⊆ Y \\Z, B−(r) ∩ Y = ∅, Y |= Bcard(r)\n(8)\nWe denote the set of rules in Π that support p with respect to Y but Z, by ΠY,Z(p).\nGenerating Explanations for Biomedical Queries 11\nWe now introduce definitions about explanations in ASP. We first define a generic tree whose vertices are labeled by either atoms or rules.\nDefinition 1 (Vertex-labeled tree) A vertex-labeled tree 〈V,E, l,Π, X〉 for a program Π and a set X of atoms is a tree 〈V,E〉 whose vertices are labeled by a function l that maps V to Π ∪X . In this tree, the vertices labeled by an atom (resp., a rule) are called atom vertices (resp., rule vertices).\nFor a vertex-labeled tree T = 〈V,E, l,Π, X〉 and a vertex v in V , we introduce the following notations:\n• ancT (v) denotes the set of atoms which are labels of ancestors of v. • desT (v) denotes the set of rule vertices which are descendants of v. • childE(v) denotes the set of children of v. • siblingE(v) denotes the set of siblings of v. • outE(v) denotes the set of out-going edges of v. • degE(v) denotes the degree of v and equals to |outE(v)|. • If degE(v) = 0, then v is a leaf vertex. • leaf (T ) denotes the set of leaves of T . • The root of T is the root of 〈V,E〉. • T is empty if 〈V,E〉 = 〈∅, ∅〉.\nWe now define a specific class of vertex-labeled trees which contains all possible “explanations” for an atom.\nDefinition 2 (And-or explanation tree) Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X . The and-or explanation tree for p with respect to Π and X is a vertex-labeled tree T = 〈V,E, l,Π, X〉 that satisfies the following:\n(i) for the root v ∈ V of the tree, l(v) = p; (ii) for every atom vertex v ∈ V ,\noutE(v) = {(v, v′) | (v, v′) ∈ E, l(v′) ∈ ΠX,ancT (v′)(l(v))};\n(iii) for every rule vertex v ∈ V ,\noutE(v) = {(v, v′) | (v, v′) ∈ E, l(v′) ∈ B+(l(v))};\n(iv) each leaf vertex is a rule vertex.\nLet us explain conditions (i)− (iv) in Definition 2 in detail.\n(i) The root of the and-or explanation tree T is labeled by the atom p. Intuitively, T contains all possible explanations for p.\n(ii) For every atom vertex v ∈ V , there is an out-going edge (v, v′) to a rule vertex v′ ∈ V under the following conditions: the rule that labels v′ supports the atom that labels v, using atoms in X but not any atom that labels an ancestor of v′. We want to exclude the atoms labeling ancestors of v′ to ensure that the height of the and-or explanation tree is finite (e.g., otherwise, due to cyclic dependencies the tree may be infinite)."
    }, {
      "heading" : "12 Esra Erdem, Umut Oztok",
      "text" : "(iii) For every rule vertex v ∈ V , there is an out-going edge (v, v′) to an atom vertex if the atom that labels v′ is in the positive body of the rule that labels v. In this way, we make sure that every atom in the positive body of the rule that labels v takes part in explaining the head of the rule that labels v. (iv) Together with Conditions (ii) and (iii) above, this condition guarantees that the leaves of the and-or explanation tree are rule vertices that are labeled by facts in the reduct of the given ASP program Π with respect to the given answer set X . Intuitively, this condition expresses that the leaves are self-explanatory.\nExample 1 Let Π be the program\na← b, c a← d d← b← c c←\nand X = {a, b, c, d}. The and-or explanation tree for a with respect to Π and X is shown in Figure 2. Intuitively, the and-or explanation tree includes all possible “explanations” for an atom. For instance, according to Figure 2, the atom a has two explanations:\n• One explanation is characterized by the rules that label the vertices in the left subtree of the root: a is in X because the rule\na← b, c\nsupport a. Moreover, this rule can be “applied to generate a” because b and c, the atoms in its positive body, are in X . Further, b is in X because the rule\nb← c\nsupports b. Further, c is in X because c is supported by the rule\nc←\nwhich is self-explanatory. • The other explanation is characterized by the rules that label the vertices in the right\nsubtree of the root: a is in X because the rule\na← d\nsupports a. Further, this rule can be “applied to generate a” because d is in X . In addition, d is in X because d is supported by the rule\nd←\nwhich is self-explanatory.\nProposition 1 Let Π be a ground ASP program and X be an answer set for Π. For every p in X , the and-or explanation tree for p with respect to Π and X is not empty.\nNote that in the and-or explanation tree, atom vertices are the “or” vertices, and rule vertices are the “and” vertices. Then, we can obtain a subtree of the and-or explanation tree that contains an explanation, by visiting only one child of every atom vertex and every child of every rule vertex, starting from the root of the and-or explanation tree. Here is precise definition of such a subtree, called an explanation tree.\nDefinition 3 (Explanation tree) Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X . An explanation tree in T is a vertex-labeled tree T ′ = 〈V ′, E′, l,Π, X〉 such that\n(i) 〈V ′, E′〉 is a subtree of 〈V,E〉; (ii) the root of 〈V ′, E′〉 is the root of 〈V,E〉;\n(iii) for every atom vertex v′ ∈ V ′, degE′(v′) = 1; (iv) for every rule vertex v′ ∈ V ′, outE(v′) ⊆ E′.\nExample 2 Let T be the and-or explanation tree in Figure 2. Then, Figure 3 illustrates the explanation trees in T . These explanation trees characterize the two explanations for a explained in Example 1.\nAfter having defined the and-or explanation tree and an explanation tree for an atom, let us now define an explanation for an atom.\nDefinition 4 (Explanation) Let Π be a ground ASP program, X be an answer set for Π, and p be an atom in X . A vertex-labeled tree 〈V ′, E′, l,Π, X〉 is an explanation for p with respect to Π and X if there exists an explanation tree 〈V,E, l,Π, X〉 in the and-or explanation tree for p with respect to Π and X such that\n(i) V ′ = {v | v is a rule vertex inV }; (ii) E′ = {(v1, v2) | (v1, v), (v, v2) ∈ E, for some atom vertex v ∈ V }. Intuitively, an explanation can be obtained from an explanation tree by “ignoring” its\natom vertices.\nExample 3 Let Π and X be defined as in Example 1. Then, Figure 4 depicts two explanations for a with respect to Π and X , described in Example 1.\nSo far, we have considered only positive programs in the examples. Our definitions can also be used in programs that contain negation and aggregates in the bodies of rules.\nExample 4 Let Π be the program\na← b, c, not e a← d, not b a← d, 1 ≤ {b, c} ≤ 2 d← b← c c←\nand X = {a, b, c, d}. The and-or explanation tree for a with respect to Π and X is shown in Figure 5(a). Here, the rule a← d, not b is not included in the tree as b is in X , whereas the rule a ← b, c, not e is in the tree as e is not in X and, b and c are in X . Also, the rule a ← d, 1 ≤ {b, c} ≤ 2 is in the tree as d is in X and the cardinality expression 1 ≤ {b, c} ≤ 2 is satisfied by X . An explanation for a with respect to Π and X is shown in Figure 5(b).\nNote that our definition of an and-or explanation tree considers positive body parts of the rules only to provide explanations. Therefore, explanation trees do not provide further explanations for negated literals (e.g., why an atom is not included in the answer set), or aggregates (e.g., why a cardinality constraint is satisfied) as seen in the example above.\n5 Generating Shortest Explanations\nAs can be seen in Figure 4, there might be more than one explanation for a given atom. Hence, it is not surprising that one may prefer some explanations to others. Consider biomedical queries about chains of gene-gene interactions like the query Q8 in Table 1. Answers of such queries may contain chains of gene-gene interactions with different lengths. For instance, an answer for this query is “CASK”. Figure 6 shows an explanation for this answer. Here, “CASK” is related to “ADRB1” via a gene-gene chain interaction of length 2 (the chain “CASK”–“DLG4”–“ADRB1”). Another explanation is partly shown in Figure 7. Now, “CASK” is related to “ADRB1” via a gene-gene chain interaction of length 3 (the chain “CASK”–“ DLG1”–“DLG4”–“ADRB1”). Since gene-gene interactions are important for drug discovery, it may be more desirable for the experts to reason about chains with shortest lengths.\nWith this motivation, we consider generating shortest explanations. Intuitively, an explanation S is shorter than another explanation S′ if the number of rule vertices involved in S is less than the number of rule vertices involved in S′. Then we can define shortest explanations as follows.\nDefinition 5 (Shortest explanation) Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and S be an explanation (with vertices V ) for p with respect to Π and X . Then, S is a shortest explanation for p with respect to Π and X if there exists no explanation S′ (with vertices V ′) for p with respect to Π and X such that |V ′| < |V |.\nExample 5 Let Π and X be defined as in Example 1. Then, Figure 4(b) is the shortest explanation for a with respect to Π and X .\nTo compute shortest explanations, we define a weight function that assigns weights to the vertices of the and-or explanation tree. Basically, the weight of an atom vertex (“or”\nGenerating Explanations for Biomedical Queries 17\nvertex) is equal to the minimum weight among weights of its children and the weight of a rule vertex (“and” vertex) is equal to sum of weights of its children plus 1. Then the idea is to extract a shortest explanation by propagating the weights of the leaves up and then traversing the vertices that contribute to the weight of the root. Let us define the weight of vertices in the and-or explanation tree.\nDefinition 6 (Weight function) Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X . The weight function WT for T maps vertices in V to a positive integer and it is defined as follows.\nWT (v) = { min{WT (c) | c ∈ childE(v)} if v is an atom vertex in V ; 1 +\n∑ c ∈ childE(v) WT (c) otherwise.\nAlgorithm 1: Generating Shortest Explanations Input: Π : ground ASP program, X : answer set for Π, p : atom in X . Output: a shortest explanation for p w.r.t Π and X , or an empty vertex-labeled tree.\n1 〈V,E, l,Π, X〉 := createTree(Π, X, p, {}); 2 if 〈V,E〉 is not empty then 3 v ← root of 〈V,E〉; 4 calculateWeight(Π, X, V, l, v, E,WT ); 5 〈V ′, E′, l,Π, X〉 := extractExp(Π, X, V, l, v, E,WT , ∅,min); 6 return 〈V ′, E′, l,Π, X〉; 7 else 8 return 〈∅, ∅, l,Π, X〉;\nUsing this weight function, we develop Algorithm 1 to generate shortest explanations. Let us describe this algorithm. Algorithm 1 starts by creating the and-or explanation tree T for p with respect to Π and X (Line 1); for that it uses Algorithm 2. If T is not empty, then Algorithm 1 assigns weights to the vertices of T (Line 4), using Algorithm 3. As the final step, Algorithm 1 extracts a shortest explanation from T (Line 5), using Algorithm 4. The idea is to traverse an explanation tree of T , by the help of the weight function, and construct an explanation, which would be a shortest one, by contemplating only the rule vertices in the traversed explanation tree. If T is empty, Algorithm 1 returns an empty vertex-labeled tree.\nAlgorithm 2 (with the call createTree(Π, X, p, {})) creates the and-or explanation tree for p with respect to Π and X recursively. With a call createTree(Π, X, d, L), where L intuitively denotes the atoms labeling the atom vertices created so far, the algorithm considers two cases: d being an atom or a rule. In the former case, 1) the algorithm creates an atom vertex v for d, 2) it identifies the rules that support d, 3) for each such rule, it creates a vertex labeled tree (i.e., a subtree of the resulting and-or explanation tree), and 4) it connects these trees to the atom vertex v. In the latter case, if d is a rule in Π, 1) the algorithm creates a rule vertex v for d, 2) it identifies the atoms in the positive part of the"
    }, {
      "heading" : "18 Esra Erdem, Umut Oztok",
      "text" : "Algorithm 2: createTree Input: Π : ground ASP program, X : answer set for Π, d : an atom in X or a rule in\nΠ, L : set of atoms in X . Output: A vertex-labeled tree.\n1 V := ∅, E := ∅ ; 2 if d ∈ X\\L then 3 v ← Create an atom vertex s.t. l(v) = d ; 4 L := L ∪ {d}, V := V ∪ {v} ; 5 foreach r ∈ ΠX,L(d) do 6 〈V ′, E′, l,Π, X〉 := createTree(Π, X, r, L); 7 if 〈V ′, E′〉 6= 〈∅, ∅〉 then 8 v′ ← root of 〈V ′, E′〉 s.t. l(v′) = r; 9 V := V ∪ V ′, E := E ∪ {(v, v′)} ∪ E′ ;\n10 if E = ∅ then return 〈∅, ∅, l,Π, X〉; 11 else if d ∈ Π then 12 v ← Create a rule vertex s.t. l(v) = d ; 13 foreach a ∈ B+(d) do 14 〈V ′, E′, l,Π, X〉 := createTree(Π, X, a, L); 15 if 〈V ′, E′〉 = 〈∅, ∅〉 then return 〈∅, ∅, l,Π, X〉; 16 v′ ← root of 〈V ′, E′〉 s.t. l(v′) = a; 17 V := V ∪ V ′, E := E ∪ {(v, v′)} ∪ E′;\n18 return 〈V,E, l,Π, X〉;\nrule, 3) it creates the and-or explanation tree for each such atom, and 4) it connects these trees to the rule vertex v.\nOnce the and-or explanation tree is created, Algorithm 3 assigns weights to all vertices in the tree by propagating the weights of the leaves (i.e., 1) up to the root in a bottom-up fashion using the weight function definition (i.e., Definition 6).\nAfter that, Algorithm 1 (with the call extractExp(Π, X, V, l, v, E,WT , ∅,min)) extracts a shortest explanation in a top-down fashion starting from the root by examining the weights of the vertices. In particular, if a visited vertex v is an atom vertex then the algorithm proceeds with the child of v with the minimum weight; otherwise, it considers all the children of v.\nThe execution of Algorithm 1 is also illustrated in Figure 8. First, the and-or explanation tree is generated, which has a generic structure as in Figure 8(a). Here, yellow vertices denote atom vertices and blue vertices denote rule vertices. Then, this tree is weighted as in Figure 8(b). Then, starting from the root, a subtree of the and-or explanation tree is traversed by visiting minimum weighted child of every atom vertex and every child of every rule vertex. This process is shown in Figure 8(c), where red vertices form the traversed subtree. From this subtree, an explanation is extracted by ignoring atom vertices and keeping the parent-child relationship of the tree as it is. The resulting explanation is depicted in Figure 8(d).\nGenerating Explanations for Biomedical Queries 19\nAlgorithm 3: calculateWeight Input: Π : ground ASP program, X : answer set for Π, V : set of vertices,\nl : V → Π ∪X , v : vertex in V , E : set of edges, WT : candidate weight function.\nOutput: Weight of v. 1 if l(v) ∈ X then 2 foreach c ∈ childE(v) do WT (c) := calculateWeight(Π, X, V, l, c, E,WT ); 3 WT (v) := min{WT (c) | c ∈ childE(v)}; 4 else if l(v) ∈ Π then 5 WT (v) := 1; 6 foreach c ∈ childE(v) do\nWT (v) := WT (v) + calculateWeight(Π, X, V, l, c, E,WT );\n7 return WT (v);\nAlgorithm 4: extractExp Input: Π : ground ASP program, X : answer set for Π, Vt : set of vertices,\nl : Vt → Π ∪X , v : vertex in Vt, Et : set of edges, WT : weight function of T , r : rule vertex in Vt or ∅, op: string min or max.\nOutput: A vertex-labeled tree 〈V,E, l,Π, X〉. 1 V := ∅, E := ∅; 2 if l(v) ∈ X then 3 c← Pick op weighted child of v ; 4 if r 6= ∅ then E := E ∪ {(r, c)}; 5 〈V ′, E′, l,Π, X〉 := extractExp(Π, X, Vt, l, c, Et,WT , r, op); 6 V := V ∪ V ′, E := E ∪ E′; 7 else if l(v) ∈ Π then 8 V := V ∪ {v}; 9 foreach c ∈ childEt(v) do\n10 〈V ′, E′, l,Π, X〉 := extractExp(Π, X, Vt, l, c, Et,WT , v, op); 11 V := V ∪ V ′, E := E ∪ E′;\n12 return 〈V,E, l,Π, X〉;\nProposition 2 Given a ground ASP program Π, an answer set X for Π, and an atom p in X , Algorithm 1 terminates.\nProposition 3 Given a ground ASP program Π, an answer set X for Π, and an atom p in X , Algorithm 1 either finds a shortest explanation for p with respect to Π and X or returns an empty vertexlabeled tree.\n20 Esra Erdem, Umut Oztok\nProposition 4 Given a ground ASP program Π, an answer set X for Π, and an atom p in X , the time complexity of Algorithm 1 is O(|Π||X| × |BΠ|).\nWe generate the complete and-or explanation tree while finding a shortest explanation. In fact, we can find a shortest explanation by creating a partial and-or explanation tree using a branch-and-bound idea. In particular, the idea is to compute the weights of vertices during the creation of the and-or explanation tree and, in case there exists a branch of the and-or explanation tree that exceeds the weight of a vertex computed so far, to stop branching on unnecessary parts of the and-or explanation tree. Then, a shortest explanation can be extracted by the same method used previously, i.e., by traversing a subtree of the andor explanation tree and ignoring the atom vertices in this subtree. For instance, consider Figure 8(b). Assume that we first create the right branch of the root. Since the weight of an atom vertex is equal to the minimum weight among its children weights, we know that\nGenerating Explanations for Biomedical Queries 21\nAlgorithm 5: Generating k Different Explanations Input: Π: ground ASP program, X: answer set for Π, p: atom in X , k : a positive\ninteger. Assume there are n different explanations for p w.r.t Π and X . Output: min{n, k} different explanations for p with respect to Π and X .\n1 K := ∅, R0 := ∅; 2 〈V,E, l,Π, X〉 := createTree(Π, X, p, {}); 3 v ← root of 〈V,E〉; 4 for i = 1, 2, . . . k do 5 calculateDifference(Π, X, V, l, v, E,Ri−1,WT,Ri−1); 6 if WT,Ri−1(v) = 0 then return K; 7 〈V ′, E′, l,Π, X〉 := extractExp(Π, X, V, l, v, E,WT,Ri−1 , ∅,max); 8 Ki ← 〈V ′, E′, l,Π, X〉; 9 K := K ∪ {Ki};\n10 Ri := Ri−1 ∪ {v | rule vertex v ∈ V ′}; 11 return K;\nthe weight of the root is at most 2. Now, we check whether it is necessary to branch on the left child of the root. Note that the weight of a rule vertex is equal to 1 plus the sum of its children weights. As R1 has two children, its weight is at least 3. Therefore, it is redundant to branch on the left child of the root. This improvement is not implemented and is a future work.\n6 Generating k Different Explanations\nWhen there is more than one explanation for an answer of a query, it might be useful to provide the experts with several more explanations that are different from each other. For instance, consider the query Q5 in Table 1.\nQ5 What are the drugs that treat the disease Asthma or that react with the drug Epinephrine?\nAn answer for this query is “Doxepin”. According to one explanation, “Doxepin” reacts with “Epinephrine” with respect to DRUGBANK. At this point, the expert may not be convinced and ask for a different explanation. Another explanation for this answer is that “Doxepin” treats “Asthma” according to CTD. Motivated by this example, we study generating different explanations.\nWe introduce an algorithm (Algorithm 5) to compute k different explanations for an atom p in X with respect to Π and X . For that, we define a distance measure ∆D between a set Z of (previously computed) explanations, and an (to be computed) explanation S. We consider the rule vertices RZ and RS contained in Z and S, respectively. Then, we define the function ∆D that measures the distance between Z and S as follows:\n∆D(Z, S) = |RS\\RZ |.\nIn the following, we sometimes use RZ and RS instead of Z and S in ∆D. Also, we denote by RVertices(S) the set of rule vertices of a vertex-labeled tree S."
    }, {
      "heading" : "22 Esra Erdem, Umut Oztok",
      "text" : "Algorithm 6: calculateDifference Input: Π : ground ASP program, X : answer set for Π, V : set of vertices,\nl : V → Π ∪X , v : vertex in V , E : set of edges, R : set of rule vertices in V , DR : candidate distance function.\nOutput: distance of v. 1 if l(v) ∈ X then 2 foreach c ∈ childE(v) do 3 DR(c) := calculateDifference(Π, X, V, l, c, E,R,DR);\n4 DR(v) := max{DR(c) | c ∈ childE(v)}; 5 else if l(v) ∈ Π then 6 if v /∈ R then DR(v) := 1; 7 else DR(v) := 0; 8 foreach c ∈ childE(v) do 9 DR(v) := DR(v) + calculateDifference(Π, X, V, l, c, E,R,DR);\n10 return DR(v);\nLet us now explain Algorithm 5. It computes a set K of k different explanations iteratively. Initially, K = ∅. First, we compute the and-or explanation tree T (Line 2). Then, we enter into a loop that iterates at most k times (Line 4). At each iteration i, an explanation Ki that is most distant from the previously computed i − 1 explanations is extracted from T . Let us denote the rule vertices included in the previously computed i − 1 explanations by Ri−1. Then, essentially, at each iteration we pick an explanation Ki such that ∆D(Ri−1,RVertices(Ki)) is maximum. To be able to find such a Ki, we need to define the “contribution” of each vertex v in T to the distance measure ∆D(Ri−1,RVertices(Ki)) if v is included in explanation Ki:\nWT,Ri−1(v) =    max{WT,Ri−1(v′) | v′ ∈ childE(v)} if v is an atom vertex;∑ v′∈childE(v) WT,Ri−1(v ′) if v is a rule vertex and v ∈ Ri−1;\n1 + ∑\nv′∈childE(v) WT,Ri−1(v ′) otherwise.\nNote that this function is different from WT . Intuitively, v contributes to the distance measure if it is not included in Ri−1. The contributions of vertices in T are computed by Algorithm 6 (Line 5) by propagating the contributions up in the spirit of Algorithm 3. Then, Ki is extracted from weighted-T by using Algorithm 4 (Line 7).\nThe execution of Algorithm 5 is also illustrated in Figure 9. Similar to Algorithm 1, which generates shortest explanations, first the and-or explanation tree is created, which has a generic structure as shown in Figure 9(a). Recall that yellow vertices denote atom vertices and blue vertices denote rule vertices. For the sake of example, assume that R = {R2, R6}. Then, the goal is to generate an explanation that contains different rule vertices from the rule vertices in R as much as possible. For that, the weights of vertices are assigned according to the weight function WT,R as depicted in Figure 9(b). Here, the weight of the root implies that there exists an explanation which contains 4 different rule vertices from the rule vertices in R and this explanation is the most different one. Then, starting\nGenerating Explanations for Biomedical Queries 23\nfrom the root, a subtree of the and-or explanation tree is traversed by visiting maximum weighted child of every atom vertex, and every child of every rule vertex. This subtree is shown in Figure 9(c) by red vertices. Finally, an explanation is extracted by ignoring the atom vertices and keeping the parent-child relationship as it is, from this subtree. This explanation is illustrated in Figure 9(d).\nProposition 5 Given a ground ASP program Π, an answer set X for Π, an atom p in X , and a positive integer k, Algorithm 5 terminates.\nProposition 6 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of different explanations for p with respect to Π and X . Then, Algorithm 5 returns min{n, k} different explanations for p with respect to Π and X .\nFurthermore, at each iteration i of the loop in Algorithm 5 the distance ∆D(Ri−1,Ki) is maximized."
    }, {
      "heading" : "24 Esra Erdem, Umut Oztok",
      "text" : "Proposition 7 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to Π and X . Then, at the end of each iteration i (1 ≤ i ≤ min{n, k}) of the loop in Algorithm 5, ∆D(Ri−1,RVertices(Ki)) is maximized, i.e., there is no other explanation K ′ such that ∆D(Ri−1,RVertices(Ki)) < ∆D(Ri−1,RVertices(K ′)).\nThis result leads us to some useful consequences. First, Algorithm 5 computes “longest” explanations if k = 1. The following corollary shows how to compute longest explanations.\nCorollary 1 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k = 1. Then, Algorithm 5 computes a longest explanation for p with respect to Π and X .\nNext, we show that Algorithm 5 computes k different explanations such that for every i (1 ≤ i ≤ k) the ith explanation is the most distant explanation from the previously computed i− 1 explanations. Corollary 2 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to Π and X . Then, Algorithm 5 computes min{n, k} different explanations K1, . . . ,Kmin{n,k} for p with respect to Π and X such that for every j (2 ≤ j ≤ min{n, k}) ∆D( ⋃j−1 z=1 RVertices(Kz),Kj) is maximized.\nThe following proposition shows that the time complexity of Algorithm 5 is exponential in the size of the given answer set.\nProposition 8 Given a ground ASP program Π, an answer set X for Π, an atom p in X and a positive integer k, the time complexity of Algorithm 5 is O(k × |Π||X|+1 × |BΠ|).\n7 Experiments with Biomedical Queries\nOur algorithms for generating explanations are applicable to the queries Q1, Q2, Q3, Q4, Q5, Q8, Q10, Q11 and Q12 in Table 1. The ASP programs for the other queries involve choice expressions. For instance, the query Q7 asks for cliques of 5 genes. We use the following rule to generate a possible set of 5 genes that might form a clique.\n5{clique(GEN):gene_name(GEN)}5.\nOur algorithms apply to ASP programs that contain a single atom in the heads of the rules, and negation and cardinality expressions in the bodies of the rules. Therefore, our methods are not applicable to the queries which are presented by ASP programs that include choice expressions.\nIn Table 2, we present the results for generating shortest explanations for the queries Q1, Q2, Q3, Q4, Q5, Q8, Q10, Q11 and Q12. In this table, the second column denotes the CPU timings to generate shortest explanations in seconds. The third column consists of the sizes\nGenerating Explanations for Biomedical Queries 25\nof explanations, i.e., the number of rule vertices in an explanation. In the fourth column, the sizes of answer sets, i.e., the number of atoms in an answer set, are given. The fifth column presents the sizes of the and-or explanation trees, i.e., the number of vertices in the tree.\nBefore telling what the last column presents, let us clarify an issue regarding the computation of explanations. Since answer sets contain millions of atoms, the relevant ground programs are also huge. Thus, first grounding the programs and then generating explanations over those grounded programs is an overkill in terms of computational efficiency. To this end, we apply another method and do grounding when it is necessary. To better explain the idea, let us present our method by an example. At the beginning, we have a ground atom for which we are looking for shortest explanations. Assume that this atom is what_be_genes(\"ADRB1\"). Then, we find the rules whose heads are of the form what_be_genes(GN), and instantiate GN with “ADRB1”. For instance, assume that the following rule exists in the program:\nwhat_be_genes(GN)← drug_gene(DRG,GN)\nThen, by such an instantiation, we obtain the following instance of this rule:\nwhat_be_genes(\"ADRB1\")← drug_gene(DRG,\"ADRB1\")\nNext, if the rules that we obtain by instantiating their heads are not ground, we ground them using the grounder GRINGO considering the answer set. We apply the same method for the atoms that are now ground, to find the relevant rules and ground them if necessary. This allows us to deal with a relevant subset of the rules while generating explanations."
    }, {
      "heading" : "26 Esra Erdem, Umut Oztok",
      "text" : "The last column of Table 2 presents the number of times GRINGO is called for such incremental grounding. For instance, for the queries Q1, Q3 and Q5, GRINGO is never called. However, GRINGO is called 193 times during the computation of a shortest explanation for the query Q10.\nAs seen from the results presented in Table 2, the computation time is not very much related to the size of the explanation. As also suggested by the complexity results of Algorithm 1 (i.e., O(|Π||X|× |BΠ)|), the computation time for generating shortest explanations greatly depends on the sizes of the answer set and the and-or explanation tree. For instance, for the query Q4, the answer set contains approximately 19 million atoms, the size of the and-or explanation tree is 6690, and it takes 1245 CPU seconds to compute a shortest explanation, whereas for the query Q8, the answer set approximately contains 1 million atoms, the and-or explanation tree has 28 vertices, and it takes 40 CPU seconds to compute a shortest explanation. Also, the number of times GRINGO is called during the computation affects the computation time. For instance, for the query Q10 the answer set approximately contains 1.6 million atoms, the and-or explanation tree has 3419 vertices, and it takes 1600 CPU seconds to compute a shortest explanation.\nTable 3 shows the computation times for generating different explanations for the answers of the same queries, if exists. As seen from these results, the time for computing 2 and 4 different explanations is slightly different than the time for computing shortest explanations.\nGenerating Explanations for Biomedical Queries 27\n8 Presenting Explanations in a Natural Language\nAn explanation for an answer of a biomedical query may not be easy to understand, since the user may not know the syntax of ASP rules neither the meanings of predicates. To this end, it is better to present explanations to the experts in a natural language.\nObserve that leaves of an explanation denote facts extracted from the biomedical resources. Also some internal vertices contain informative explanations such as the position of a drug in a chain of drug-drug interactions. Therefore, there is a corresponding natural language explanation for some vertices in the tree. Such a correspondence can be stored in a predicate look-up table, like Table 4. Given such a look-up table, a pre-order depth-first traversal of an explanation and generating natural language expressions corresponding to vertices of the explanation lead to an explanation in natural language (Oztok 2012).\nFor instance, the explanation in Figure 6 is expressed in natural language as illustrated in the introduction.\n9 Implementation of Explanation Generation Algorithms\nBased on the algorithms introduced above, we have developed a computational tool called EXPGEN-ASP (Oztok 2012), using the programming language C++. Given an ASP program and its answer set, EXPGEN-ASP generates shortest explanations as well as k different explanations.\nThe input of EXPGEN-ASP are\n• an ASP program Π, • an answer set X for Π, • an atom p in X , • an option that is used to generate either a shortest explanation or k different expla-\nnations,"
    }, {
      "heading" : "28 Esra Erdem, Umut Oztok",
      "text" : "• a predicate look-up table, and the output are\n• a shortest explanation for p with respect to Π and X in a natural language (if shortest explanation option is chosen), • k different explanations for p with respect to Π and X in a natural language (if k different explanations option is chosen).\nFor generating shortest explanations (resp., k different explanations), EXPGEN-ASP utilizes Algorithm 1 (resp., Algorithm 5).\nTo provide experts with further informative explanations about the answers of biomedical queries, we have embedded EXPGEN-ASP into BIOQUERY-ASP by utilizing Table 4 as the predicate look-up table of the system. Figure 10 shows a snapshot of the explanation generation mechanism of BIOQUERY-ASP.\nGenerating Explanations for Biomedical Queries 29\n10 Relating Explanations to Justifications\nThe most similar work to ours is (Pontelli et al. 2009) that study the question “why is an atom p in an answer set X for an ASP program Π”. As an answer to this question, the authors of (Pontelli et al. 2009) finds a “justification”, which is a labeled graph that provides an explanation for the truth values of atoms with respect to an answer set.\nExample 6 Let Π be the program presented in Example 1:\na← b, c a← d d← b← c c←\nand X = {a, b, c, d}. Figure 11 is an offline justification of a+ with respect to X and ∅. Intuitively, a is in X since b and c are also in X and there is a rule in Π that supports a using the atoms b and c. Furthermore, b is in X since c is in X and there is a rule in Π that supports b using the atom c. Finally, c is in X as it is a fact in Π.\nTo relate offline justifications and explanations, we need to introduce the following definitions and notations about justifications defined in (Pontelli et al. 2009).\n10.1 Offline Justifications\nFirst, let us introduce notations related to ASP programs used in (Pontelli et al. 2009). The class of ASP programs studied is normal programs, i.e., programs that consist of the rules of the form\nA← A1, . . . , Ak, not Ak+1, . . . , not Am where m ≥ k ≥ 0 and A and each Ai is an atom. Therefore, the programs we consider are more general. Let Π be a normal ASP program. Then, AΠ is the Herbrand base of Π. An interpretation I for a program Π is defined as a pair 〈I+, I−〉, where I+ ∪ I− ⊆ AΠ and I+ ∩ I− = ∅. Intuitively, I+ denotes the set of atoms that are true, while I− denotes the"
    }, {
      "heading" : "30 Esra Erdem, Umut Oztok",
      "text" : "set of atoms that are false. I is a complete interpretation if I+ ∪ I− = AΠ. The reduct ΠI of Π with respect to I is defined as\nΠI = {H(r)← B+(r) | r ∈ Π, B−(r) ∩ I+ = ∅}\nA complete interpretation M for a program Π is an answer set for Π if M+ is an answer set for ΠM . Also, a literal is either an atom or a formula of the form not a where a is an atom. The set of atoms which appear as negated literals in Π is denoted by NANT (Π). For an atom a, a+ denotes that the atom a is true and a− denotes that a− is false. Then, a+ and a− are called the annotated versions of a. Moreover, it is defined that atom(a+) = a and atom(a−) = a. For a set S of atoms, the following sets of annotated atoms are defined.\n• Sp = {a+ | a ∈ S} • Sn = {a− | a ∈ S}\nFinally, the set not S is defined as not S = {not a | a ∈ S}. Apart from the answer set semantics, there is another important semantics of logic programs, called the well-founded semantics (Gelder et al. 1991). Since this semantics is important to build the notion of a justification, we now briefly describe the well-founded semantics. We consider the definition proposed in (Apt and Bol 1994), instead of the original definition proposed in (Gelder et al. 1991), as the authors of (Pontelli et al. 2009) considered.\nDefinition 7 (Immediate consequence) Let Π be a normal ASP program, and S and V be two sets of atoms from AΠ. Then, the immediate consequence of S with respect to Π and V , denoted by TΠ,V (S) is the set defined as follows:\nTΠ,V (S) = {a | ∃ r ∈ Π, H(r) = a, B+(r) ⊆ S, B−(r) ∩ V = ∅}.\nWe denote by lfp(TΠ,V ) the least fixpoint of TΠ,V when V is fixed.\nDefinition 8 (The well-founded model) Let Π be a normal ASP program, Π+ = {r | r ∈ Π, B−(r) = ∅}. The sequence 〈Ki, Ui〉i≥0 is defined as follows:\nK0 = lfp(TΠ+), U0 = lfp(TΠ,K0), Ki = lfp(TΠ,Ui−1), Ui = lfp(TΠ,Ki).\nLet j be the first index of the computation such that 〈Kj , Uj〉 = 〈Kj+1, Uj+1〉. Then, the well-founded model of Π is WFΠ = 〈W+,W−〉 where W+ = Kj and W− = AΠ\\Uj .\nExample 7 Let Π be the program\na← b, not d d← b, not a b← c c←\nGenerating Explanations for Biomedical Queries 31\nThen, the well-founded model of Π is computed as follows:\nK0 = {b, c}, U0 = {a, b, c, d}, K1 = {b, c}, U0 = {a, b, c, d}.\nThus, WFΠ = 〈{b, c}, ∅〉.\nWe now provide definitions regarding the notion of an offline justification. First, we introduce the basic building of an offline justification, a labeled graph called as e-graph.\nDefinition 9 (e-graph) Let Π be a normal ASP program. An e-graph for Π is a labeled, directed graph (N,E), where N ⊆ ApΠ ∪ AnΠ ∪ {assume,>,⊥} and E ⊆ N × N × {+,−}, which satisfies following properties:\n(i) the only sinks (i.e., nodes without out-going edges) in the graph are assume,>,⊥; (ii) for every b ∈ N ∩ ApΠ, (b, assume,−) /∈ E and (b,⊥,−) /∈ E;\n(iii) for every b ∈ N ∩ AnΠ, (b, assume,+) /∈ E and (b,>,+) /∈ E; (iv) for every b ∈ N , if for some l ∈ {assume,>,⊥} and s ∈ {+,−}, (b, l, s) ∈ E,\nthen (b, l, s) is the only out-going edge originating from b.\nAccording to this definition, an edge of an e-graph connects two annotated atoms or an annotated atom with one of the nodes in {assume,>,⊥} and is marked by a label from {+,−}. An edge is called as positive (resp., negative) if it is labeled by + (resp.,−). Also, a path in an e-graph is called as positive if it has only positive edges, whereas it is called as negative if it has at least one negative edge. The existence of a positive path between two nodes v1 and v2 is denoted by (v1, v2) ∈ E∗,+. In the offline justification, > is used to explain facts, ⊥ to explain atoms which do not have defining rules, and assume is for atoms for which explanations are not needed, i.e., they are assumed to be true or false.\nExample 8 Let Π be the program presented in Example 1, and X = {a, b, c, d}. Then, Figure 12 is an e-graph for Π. Intuitively, the true state of a depends on the true state of b and the false state of c, where b is assumed to be true and c is assumed to be false."
    }, {
      "heading" : "32 Esra Erdem, Umut Oztok",
      "text" : "In an e-graph, a set of elements that directly contributes to the truth value of an atom can be obtained through the out-going edges of a corresponding node. This set is defined as follows.\nDefinition 10 (support(b,G)) Let Π be a normal ASP program, G = (N,E) be an e-graph for Π and b ∈ N ∩(ApΠ∪AnΠ) be a node in G. Then, support(b,G) is defined as follows.\n• support(b,G) = {l}, if for some l ∈ {assume,>,⊥} and s ∈ {+,−}, (b, l, s) is in E; • support(b,G) = {atom(c) | (b, c,+) ∈ E} ∪ {not atom(c) | (b, c,−) ∈ E}, otherwise.\nExample 9 Let G be the e-graph in Figure 12. Then, support(a,G) = {b, not c}, support(b,G) = {assume} and support(c,G) = {assume}.\nTo define the notion of a justification, an e-graph should be enriched with explanations of truth values of atoms that are derived from the rules of the program. For that, the concept of one step justification of a literal is defined as follows.\nDefinition 11 (Local Consistent Explanation (LCE)) Let Π be a normal ASP program, b be an atom, J be a possible interpretation for Π, U ⊆ AΠ be a set of atoms, and S ⊆ AΠ ∪ notAΠ ∪ {assume,>,⊥} be a set of literals. We say that\n• S is an LCE of b+ with respect to (J, U), if b ∈ J+ and\n- S = {assume} or - S ∩ AΠ ⊆ J+, {c | not c ∈ S} ⊆ J− ∪ U , and there is a rule r ∈ Π such that H(r) = b and B(r) = S. In case, B(r) = ∅, S is denoted by the set {>}.\n• S is an LCE of b− with respect to (J, U), if b ∈ J− ∪ U and\n- S = {assume} or - S ∩ A ⊆ J− ∪ U , {c |not c ∈ S} ⊆ J+, and S is a minimal set of literals\nsuch that for every rule r ∈ Π if H(r) = b, then B+(r) ∩ S 6= ∅ or B−(r) ∩ {c | not c ∈ S} 6= ∅. In case, S = ∅, S is denoted by the set {⊥}.\nThe set of all the LCEs of b+ with respect to (J, U) is denoted by LCEpΠ(b, J, U) and the set of all the LCEs of b− with respect to (J, U) is denoted by LCEnΠ(b, J, U).\nHere, a possible interpretation J denotes an answer set. The set U consists of atoms that are assumed to be false (which will be called as Assumptions in the notion of justification later on). The need for U comes from the fact that the truth value of some atoms is first guessed while computing answer sets. Intuitively, if an atom a is true, an LCE consists of the body of a rule which is satisfied by J and has a in its head; if a is false, an LCE consists of a set of literals that are false in J and falsify all rules whose head are a.\nGenerating Explanations for Biomedical Queries 33\nExample 10 Let Π and X be defined as in Example 8. Then, the LCEs of the atoms with respect to (X, ∅) is as follows.\nLCEpΠ(a,X, ∅) = {{b, c}, {d}, {assume}} LCEpΠ(b,X, ∅) = {{c}, {assume}} LCEpΠ(c,X, ∅) = {{>}, {assume}} LCEpΠ(d,X, ∅) = {{>}, {assume}}\nAccordingly, a class of e-graphs where edges represent LCEs of the corresponding nodes are defined as follows.\nDefinition 12 ((J, U)-based e-graph) Let Π be a normal ASP program, J be a possible interpretation for Π, U ⊆ AΠ be a set of atoms and b be an element in ApΠ ∪ AnΠ. A (J, U)-based e-graph G = (N,E) of b is an e-graph such that\n(i) every node c ∈ N is reachable from b, (ii) for every c ∈ N\\{assume,>,⊥}, support(c,G) is an LCE of c with respect to\n(J, U);\nA (J, U)-based e-graph (N,E) is safe if for all b+ ∈ N, (b+, b+) /∈ E∗,+, i.e., there is no positive cycle in the graph.\nWe now introduce a special class of (J, U)-based e-graphs where only false elements can be assumed.\nDefinition 13 (Offline e-graph) Let Π be a normal ASP program, J be a partial interpretation for Π, U ⊆ AΠ be a set of atoms and b be an element in Ap ∪ An. An offline e-graph G = (N,E) of b with respect to J and U is a (J, U)-based e-graph of b that satisfies following properties:\n(i) there exists no p+ ∈ N such that (p+, assume,+) ∈ E; (ii) (p−, assume,−) ∈ E if and only if p ∈ U .\nE(b, J, U) is the set of all offline e-graphs of b with respect to J and U .\nHere, the roles of J and U are the same as their roles in Definition 11. Observe that true atoms cannot be assumed due to the first condition and only elements in the set U are assumed due to the second condition.\nWe said earlier that in a (J, U)-based e-graph J represents an answer set and U consists of atoms that are assumed to be false. Here, U is chosen based on some characteristics of J . In particular, we want U to be a set of atoms such that when its elements are assumed to be false, the truth value of other atoms in the program can be uniquely determined and leads to J . We now introduce regarding definitions formally."
    }, {
      "heading" : "34 Esra Erdem, Umut Oztok",
      "text" : "Definition 14 (Tentative Assumptions) Let Π be a normal ASP program, M be an answer set for Π and WFΠ =< WF+Π ,WF − Π > be the well-founded model of Π. The tentative assumptions T AΠ(M) of Π with respect to M are defined as\nT AΠ(M) = {a | a ∈ NANT (Π) ∧ a ∈M−, a /∈ (WF+Π ∪WF−Π )} (9)\nExample 11 Let Π be the program:\nc← a, not d d← a, not c a← b b←\nThen, X = {a, b, c} is an answer set for Π and 〈{a, b}, ∅〉 is the well-founded model of Π. Given that, T AΠ(X) = {d} as d ∈ NANT (Π), d /∈ X and d /∈ (WF+Π ∪WF−Π ). In fact, tentative assumptions is a set of atoms whose subsets might “potentially” form U .\nWe provide a definition that would allow one to obtain a program from a given program Π and a set V of atoms by assuming all the atoms in V as false.\nDefinition 15 (Negative Reduct) Let Π be a normal ASP program, M be an answer set for Π, and U ⊆ T AΠ(M) be a set of tentative assumption atoms. The negative reduct NR(Π, U) of Π with respect to U is the set of rules defined as\nNR(Π, U) = Π\\{r |H(r) ∈ U} (10) Finally, the concept of assumptions can be introduced formally.\nDefinition 16 (Assumption) Let Π be a normal ASP program, M be an answer set for Π. An assumption of Π with respect to M is a set U of atoms that satisfies the following properties:\n(i) U ⊆ T AΠ(M); (ii) the well-founded model of NR(Π, U) is equal to M .\nAssumptions(Π,M) is the set of all assumptions of Π with respect to M .\nExample 12 Let Π and X be defined as in Example 11. Let U = {d}. Then, NR(Π, U) is:\nc← a, not d a← b b←\nand 〈{a, b, c}, ∅〉 is the well-founded model of NR(Π, U). Thus, U is an assumption of Π with respect to X .\nNote that assumptions are nothing but subsets of tentative assumptions that would allow to obtain the answer set J .\nAt last, we are ready to define the notion of offline justification.\nGenerating Explanations for Biomedical Queries 35\nDefinition 17 (Offline Justification) Let Π be a normal ASP program, M be an answer set for Π, U be an assumption in Assumptions(Π,M) and b be an annotated atom inAp ∪An. An offline justification of b with respect to M and U is an element (N,E) of E(b,M,U) which is safe.\nAccording to the definition, a justification is a (J, U)-based e-graph where J is an answer set and U is an assumption. Also, justifications do not allow the creation of positive cycles in the justification of true atoms. For instance, for Π and X defined as in Example 1, Figure 11 illustrates an offline justification of a+ with respect to X and ∅.\nIn (Pontelli et al. 2009), the authors prove the following proposition which shows that for every atom in the program, there exists an offline justification.\nProposition 9 Let Π be a ground normal ASP program, X be an answer for Π. Then, for each atom a in Π, there is an offline justification of with respect to X and X−\\WF−Π which does not contain negative cycles.\n10.2 From Justifications to Explanations\nWe relate a justification to an explanation. In particular, given an offline justification, we show that one can obtain an explanation tree whose atom vertices are formed by utilizing the “annotated atoms” of the justification and rule vertices are formed by utilizing the “support” of annotated atoms. To compute such explanation trees, we develop Algorithm 7.\nLet us now explain the algorithm in detail. Algorithm 7 takes as input a ground normal ASP program Π , an answer set X for Π, an atom p in X , and a justification (V,E) of p+ with respect to X and some U ∈ Assumptions(Π, X). Our goal is to obtain an explanation tree in the and-or explanation tree for p with respect to Π and X from the justification (V,E). The algorithm starts by creating two sets V ′ and E′ (Line 1). Here, V ′ and E′ corresponds to the set of vertices and the set of edges of the explanation tree, respectively. By Condition (ii) in Definition 3 and Condition (i) in Definition 2, we know that the label of the root of an explanation tree for p with respect to Π and X is p. Thus, a vertex v with label p is defined (Line 2), and added into the queue Q (Line 3). Then, the algorithm enters into a “while” loop which executes until Q becomes empty. At every iteration of the loop, an element v from Q is first extracted (Line 5) and added into V ′ (Line 6). This implies that every element added into Q is also added into V ′. For instance, the vertex defined at Line 2 is the first vertex extracted from Q and also added into V ′, which makes sense since we know that the root of an explanation tree is an atom vertex with label v. Then, according to the type of the extracted vertex, its out-going edges are defined. Let v′ be a vertex extracted from Q at Line 5 in some iteration of the loop. Consider the following two cases.\nCase 1 Assume that v′ is an atom vertex. Then, the algorithm directly goes to Line 13. By Condition (i) in Definition 3, we know that an explanation tree is a subtree of the and-or explanation tree. Hence, we need to define out-going edges of v′ by taking into account Condition (ii) in Definition 2, which implies that a child of v′ must"
    }, {
      "heading" : "36 Esra Erdem, Umut Oztok",
      "text" : "Algorithm 7: Justification to Explanation Input: Π : ground normal ASP program, X : answer set for Π, p : atom in X , (V,E) :\njustification of p+ w.r.t X and some U ∈ Assumptions(Π, X). Output: A vertex-labeled tree 〈V ′, E′, l,Π, X〉.\n1 V ′ := ∅, E′ := ∅; 2 v ← Create a vertex v s.t. l(v) = p; 3 Q← v; 4 while Q 6= ∅ do 5 v′ ← Dequeue an element from Q; 6 V ′ := V ′ ∪ {v′}; 7 if l(v′) ∈ Π then // v′ is a rule vertex 8 foreach a ∈ B+(l(v′)) do 9 v′′ ← Create a vertex v′′ s.t. l(v′′) = a;\n10 E′ := E′ ∪ {(v′, v′′)} // edge from rule vertex to atom vertex; 11 Enqueue v′′ to Q;\n12 else if l(v′) ∈ X then // v′ is an atom vertex 13 r ← Create a rule r s.t. H(r) = l(v′) and B(r) = support(l(v′)+, G); 14 v′′ ← Create a vertex v′′ s.t. l(v′′) = r; 15 E′ := E′ ∪ {(v′, v′′)} // edge from atom vertex to rule vertex; 16 Enqueue v′′ to Q;\n17 return 〈V ′, E′, l,Π, X〉;\nbe a rule vertex v′′ such that the rule that labels v′′ “supports” the atom that labels v′. Thus, a rule r that supports the atom that labels v′ is created (Line 13). We ensure “supportedness” property by utilizing the annotated atoms in the given offline justification which supports the annotated version of the atom that labels v′. Then, a vertex v′′ with label r is created (Line 14), and a corresponding child of v′ is added into E′ (Line 15). By Condition (iii) in Definition 3, we know that every atom vertex of an explanation tree has a single child. Therefore, another child of v′ is not created. Then, before finishing the iteration of the loop, the child v′′ of v′ is added into Q so that its children can be formed in the next iterations of the loop.\nCase 2 Assume that v′ is a rule vertex. Then, the condition at Line 7 is satisfied and the algorithm goes to Line 8. In this case, while forming the children of v′, we should consider Condition (iii) in Definition 2, which implies that a child v′′ of v′ must be an atom vertex such that the atom that labels v′′ is in the positive body of the rule that labels v′. Also, by Condition (iv) in Definition 3, we should ensure that for every atom a in the positive body of the rule that labels v′, there exists a child va of v′ such that the atom that labels va is equal to a. Thus, the loop between Lines 8–11 iterates for every atom a in the positive body of the label of v′ and a vertex v′′ with label a is created (Line 9). Then, v′′ becomes a child of v′ (Line 10). To form the children of v′′ in the next iterations of the “while” loop, the child v′′ of v′ is added into Q (Line 11).\nWhen the algorithm finishes processing the elements of Q, i.e., Q becomes empty, the “while” loop terminates. Then, the algorithm returns a vertex-labeled tree (Line 17). We now provide the proposition about the soundness of Algorithm 7.\nProposition 10 Given a ground normal ASP program Π, an answer set X for Π, an atom p in X , an assumption U in Assumption(Π, X), and an offline justification G = (V,E) of p+ with respect to X and U , Algorithm 7 returns an explanation tree 〈V ′, E′, l,Π, X〉 in the and-or explanation tree for p with respect to Π and X .\nExample 13 Let Π and X be defined as in Example 8. Figure 13(a) is an offline justification of a+ with respect to X and ∅. Figure 13(b) shows a corresponding explanation tree in the and-or explanation tree for a with respect to Π and X that is obtained by using Algorithm 7.\n10.3 From Explanations to Justifications\nWe relate an explanation to a justification. In particular, given an explanation tree whose labels of vertices are unique, we show that one can obtain an offline justification by utilizing the labels of atom vertices of the explanation tree. For that, we design Algorithm 8.\nLet us now describe the algorithm in detail. Algorithm 8 takes as input a ground normal ASP program Π, an answer set X for Π, an atom p in X , and an explanation tree T ′ = 〈V ′, E′, l,Π, X〉 in the and-or explanation tree for p with respect to Π and X . Our goal is to obtain an offline justification (V,E) of p+ in ΠX with respect to X and ∅. The reason to obtain the offline justification in the reduct of Π with respect to X is that our definition of explanation is not defined for the atoms that are not in the answer set. Algorithm 8 starts by creating two sets V and E which will correspond to the set of nodes and the set of edges"
    }, {
      "heading" : "38 Esra Erdem, Umut Oztok",
      "text" : "Algorithm 8: Explanation to Justification Input: Π : ground normal ASP program, X : answer set for Π, p : atom in X ,\n〈V ′, E′, l,Π, X〉 : an explanation tree in the and-or explanation tree for p w.r.t Π and X .\nOutput: (V,E) : justification of p+ w.r.t X and ∅. 1 V := ∅, E := ∅; 2 Q← root of 〈V ′, E′〉; 3 while Q 6= ∅ do 4 v ← Dequeue an element from Q; 5 V := V ∪ {l(v)+}; 6 v′ ← child of v in 〈V ′, E′〉; 7 if l(v′) is a fact in ΠX then 8 E := E ∪ {(l(v)+,>,+)}; 9 foreach v′′ ∈ childE′(v′) do\n10 E := E ∪ {(l(v)+, l(v′′)+,+)}; 11 Enqueue v′′ to Q;\n12 V := V ∪ {>}; 13 return (V,E);\nof the offline justification, respectively (Line 1). Then, the root of 〈V ′, E′〉 is added into the queue Q (Line 2) and we enter into a “while” loop that iterates until Q becomes empty. At every iteration of the loop, first an element v is extracted from Q (Line 4) and l(v)+ is added into V (Line 5). Then, we form the out-going edges of l(v)+. Due to Condition (iii) in Definition 3, every atom vertex in an explanation tree has a single child, which is a rule vertex due to Condition (i) in Definition 3 and Condition (ii) in Definition 2. Then, we extract the child v′ of v at Line 6 and consider two cases. Note that v′ is a rule vertex.\nCase 1 Assume that l(v′) is a fact in ΠX . Then, l(v′) satisfies the condition at Line 7 and we add (l(v)+,>,+) into E at Line 8. The key insight behind that is as follows. Due to Condition (ii) in Definition 12, support(l(v)+, (V,E)) must be an LCE of l(v)+. Due to Condition (i) in Definition 3 and Condition (ii) in Definition 2, the head of l(v′) is l(v). As l(v′) is a fact in ΠX , i.e., its body is empty in ΠX , {>} becomes an LCE of l(v)+ with respect to (X, ∅), due to Definition 11. Thus, by adding (l(v)+,>,+) to E, support(l(v)+, (V,E)) becomes {>}. Case 2 Assume that l(v′) is not a fact in ΠX . Then, for every child v′′ of v′, we add (l(v)+, l(v′′)+,+) into E at Line 10. The intuition behind this is to make sure that support(l(v)+, (V,E)) is an LCE of l(v)+. Due to Condition (i) in Definition 3, an explanation tree is a subtree of the corresponding and-or explanation tree. Then, due to Condition (ii) in Definition 2, for every atom vertex v in an explanation tree, the atoms in the positive body of the rule that labels the child v′ of v are in the given answer set X . Thus, due to Definition 11, adding (l(v)+, l(v′′)+,+) into E for every child v′′ of v′ ensures that support(l(v)+, (V,E)) is an LCE of l(v)+ with respect\nGenerating Explanations for Biomedical Queries 39\nto (X, ∅). Also, we add v′′ into V so that its children in V are formed in the next iterations of the “while” loop.\nDue to Line 8, there are incoming edges of >. But, > is not added into V inside the “while” loop. Thus, when the “while” loop terminates, before returning (V,E) at Line 13, we add > into V .\nAlgorithm 8 creates an offline justification of the given atom in the reduct of the given ASP program with respect to the given answer set, provided that labels of the vertices of the given explanation tree are unique.\nProposition 11 Given a ground normal ASP program Π , an answer set X for Π, an atom p in X , and an explanation tree 〈V ′, E′, l,Π, X〉 in the and-or explanation tree for p with respect to Π and X such that for every v, v′ ∈ V ′, l(v) = l(v′) if and only if v = v′, Algorithm 8 returns an offline justification of p+ in ΠX with respect to X and ∅.\nExample 14 Let Π be the program:\na← b, c, not d b← not e c←\nand X = {a, b, c}. Figure 14(a) is an explanation tree T in the and-or explanation tree for a with respect to Π and X . Then, given Π, X, a and T , Algorithm 8 creates an offline justification of a+ in ΠX with respect to Π and ∅ as in Figure 14(b).\n11 Other Related Work\nThe most recent work related to explanation generation in ASP are (Brain and Vos 2005; Syrjanen 2006; Gebser et al. 2008; Pontelli et al. 2009; Oetsch et al. 2010; Oetsch et al."
    }, {
      "heading" : "40 Esra Erdem, Umut Oztok",
      "text" : "2011), in the context of debugging ASP programs. Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set. As we study the problem of explaining the reasons why atoms are in the answer set, our work differs from those two work.\nIn (Brain and Vos 2005), similar to our work, the question “why is an atom p in an answer set X for an ASP program Π” is studied. As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in Π that supports X with respect to Π; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules).\nPontelli et al. (2009) also introduce the notion of an online justification that aims to justify the truth values of atoms during the computation of an answer set. In (Oetsch et al. 2011), a framework where the users can construct interpretations through an interactive stepping process is introduced. As a result, (Pontelli et al. 2009) and (Oetsch et al. 2011) can be used together to provide the users with justifications of the truth values of atoms during the construction of interpretations interactively through stepping.\n12 Conclusion\nWe have formally defined explanations in the context of ASP. We have also introduced variations of explanations, such as “shortest explanations” and “k different explanations”.\nWe have proposed generic algorithms to generate explanations for biomedical queries. In particular, we have presented algorithms to compute shortest or k different explanations. We have analyzed termination, soundness and complexity of these algorithms. In particular, the complexity of generating a shortest explanation for an answer (in an answer set X) is O(|Π||X| × |BΠ|) where |Π| is the number of ASP rules representing the query, the knowledge extracted from biomedical resources and the rule layer, and |BΠ| is the number of atoms in Π. The complexity of generating k different explanations is O(k× |Π||X|+1× |BΠ|). For k different explanations, we have defined a distance measure based on the number of different ASP rules between explanations.\nWe have developed a computational tool EXPGEN-ASP which implements these algorithms. We have embedded EXPGEN-ASP into BIOQUERY-ASP to generate explanations regarding the answers of complex biomedical queries. We have proposed a method to present explanations in a natural language. No existing biomedical query answering system is capable of generating explanations; our methods have fulfilled this need in biomedical query answering.\nWe have illustrated the applicability of our methods to answer complex biomedical queries over large biomedical knowledge resources about drugs, genes, and diseases, such as PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY and ORPHADATA. The total number of the facts extracted from these resources to answer queries is approximately 10.3 million.\nIt is important to emphasize here that our definitions and methods for explanation generation are general, so they can be applied to other applications (e.g., debugging, query answering in other domains).\nOne line of future work is to generalize the notion of an explanation to queries (like Q7) that contain choice expressions.\nGenerating Explanations for Biomedical Queries 41\n13 Acknowledgments\nWe would like to thank Yelda Erdem (Sanovel Pharmaceutical Inc.) for her help in identifying biomedical queries relevant to drug discovery, and Halit Erdogan (Sabanci University) for his help with an earlier version of BIOQUERY-ASP which he implemented as part of his MS thesis studies. We would like to thank Hans Tompits (Vienna University of Technology) for his useful comments about the work presented in the paper, and pointing out relevant references in the context of debugging ASP programs. We also would like to thank anonymous reviewers for their useful comments and suggestions on an earlier draft. This work was partially supported by TUBITAK Grant 108E229.\nReferences\nAPT, K. R. AND BOL, R. N. 1994. Logic programming and negation: A survey. J. Log. Program. 19/20, 9–71.\nBARAL, C. 2003. Knowledge Representation, Reasoning and Declarative Problem Solving. Cambridge University Press."
    }, {
      "heading" : "BODENREIDER, O., COBAN, Z. H., DOGANAY, M. C., ERDEM, E., AND KOSUCU, H. 2008. A",
      "text" : "preliminary report on answering complex queries related to drug discovery using answer set programming. In Proc. of ALPSWS.\nBRAIN, M. AND VOS, M. D. 2005. Debugging logic programs under the answer set semantics. In Proc. of ASP.\nBREWKA, G., EITER, T., AND TRUSZCZYNSKI, M. 2011. Answer set programming at a glance. Commun. ACM 54, 12, 92–103.\nCHONG, C. R. AND SULLIVAN, D. J. 2007. New uses for old drugs. Nature 448, 645–646. DAVIS, A. P., KING, B. L., MOCKUS, S., MURPHY, C. G., SARACENI-RICHARDS, C., ROSEN-\nSTEIN, M., WIEGERS, T., AND MATTINGLY, C. J. 2011. The Comparative Toxicogenomics Database: update 2011. Nucleic Acids Research 39, Database issue, D1067–D1072.\nEITER, T., G.IANNI, R.SCHINDLAUER, AND H.TOMPITS. 2006. Effective integration of declarative rules with external evaluations for Semantic-Web reasoning. In Proc. of ESWC.\nERDEM, E., ERDEM, Y., ERDOGAN, H., AND OZTOK, U. 2011. Finding answers and generating explanations for complex biomedical queries. In Proc. of AAAI.\nERDEM, E., ERDOGAN, H., AND OZTOK, U. 2011. BIOQUERY-ASP: Querying biomedical ontologies using answer set programming. In Proc. of RuleML2011@BRF Challenge.\nERDEM, E. AND YENITERZI, R. 2009. Transforming controlled natural language biomedical queries into answer set programs. In Proc. of the Workshop on BioNLP. 117–124.\nFERRARIS, P. AND LIFSCHITZ, V. 2005. Weight constraints as nested expressions. Theory and Practice of Logic Programming 5, 45–74.\nGEBSER, M., KAMINSKI, R., KOENIG, A., AND SCHAUB, T. 2011. Advances in gringo series 3. In Proc of. LPNMR. Vol. 6645. 345–351.\nGEBSER, M., KAUFMANN, B., NEUMANN, A., AND SCHAUB, T. 2007. clasp: A conflict-driven answer set solver. In Proc. of LPNMR. 260–265.\nGEBSER, M., PUEHRER, J., SCHAUB, T., AND TOMPITS, H. 2008. A meta-programming technique for debugging answer-set programs. In Proc. of AAAI.\nGELDER, A. V., ROSS, K. A., AND SCHLIPF, J. S. 1991. The well-founded semantics for general logic programs. J. ACM 38, 3, 620–650.\nGELFOND, M. AND LIFSCHITZ, V. 1988. The stable model semantics for logic programming. In Proc. of ICLP. MIT Press, 1070–1080."
    }, {
      "heading" : "42 Esra Erdem, Umut Oztok",
      "text" : "GELFOND, M. AND LIFSCHITZ, V. 1991. Classical negation in logic programs and disjunctive databases. New Generation Computing 9, 365–385.\nGOWER, T. 2009. Born again. Proto Magazine Summer, 14–19."
    }, {
      "heading" : "KNOX, C., LAW, V., JEWISON, T., LIU, P., LY, S., FROLKIS, A., PON, A., BANCO, K., MAK, C.,",
      "text" : "NEVEU, V., DJOUMBOU, Y., EISNER, R., GUO, A. C., AND WISHART, D. S. 2010. Drugbank 3.0: a comprehensive resource for ‘omics’ research on drugs. Nucleic Acids Research 39, Database issue, D1035–D1041.\nKUHN, M., CAMPILLOS, M., LETUNIC, I., JENSEN, L. J., AND BORK, P. 2010. A side effect resource to capture phenotypic effects of drugs. Molecular Systems Biology 6, 343.\nLIFSCHITZ, V. 2002. Answer set programming and plan generation. Artificial Intelligence 138, 39–54.\nLIFSCHITZ, V. 2008. What is answer set programming? In Proc. of AAAI. MIT Press, 1594–1597. MAREK, V. AND TRUSZCZYŃSKI, M. 1999. Stable models and an alternative logic programming\nparadigm. In The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375– 398."
    }, {
      "heading" : "MCDONAGH, E. M., WHIRL-CARRILLO, M., GARTEN, Y., ALTMAN, R. B., AND KLEIN, T. E.",
      "text" : "2011. From pharmacogenomic knowledge acquisition to clinical applications: the PharmGKB as a clinical pharmacogenomic biomarker resource. Biomarkers in Medicine 5, 6, 795–806.\nNIEMELÄ, I. 1999. Logic programs with stable model semantics as a constraint programming paradigm. Annals of Mathematics and Artificial Intelligence 25, 241–273.\nNOGUEIRA, M., BALDUCCINI, M., GELFOND, M., WATSON, R., AND BARRY, M. 2001. An A-Prolog decision support system for the space shuttle. In Proc. of PADL. Springer, 169–183.\nOETSCH, J., PUEHRER, J., AND TOMPITS, H. 2010. Catching the ouroboros: On debugging nonground answer-set programs. TPLP 10, 4-6, 513–529.\nOETSCH, J., PUEHRER, J., AND TOMPITS, H. 2011. Stepping through an answer-set program. In LPNMR. 134–147.\nOZTOK, U. 2012. Generating explanations for complex biomedical queries. PONTELLI, E., SON, T. C., AND EL-KHATIB, O. 2009. Justifications for logic programs under\nanswer set semantics. Theory and Practice of Logic Programming, 1–56."
    }, {
      "heading" : "RICCA, F., GRASSO, G., ALVIANO, M., MANNA, M., LIO, V., IIRITANO, S., AND LEONE, N.",
      "text" : "2012. Team-building with answer set programming in the Gioia-Tauro seaport. Theory and Practice of Logic Programming 12."
    }, {
      "heading" : "SCHRIML, L. M., ARZE, C., NADENDLA, S., CHANG, Y.-W. W., MAZAITIS, M., FELIX, V.,",
      "text" : "FENG, G., AND KIBBE, W. A. 2012. Disease Ontology: a backbone for disease semantic integration. Nucleic Acids Research 40, Database issue, D940–D946.\nSIMONS, P., NIEMELÄ, I., AND SOININEN, T. 2002. Extending and implementing the stable model semantics. Artificial Intelligence 138, 181–234.\nSTARK, C., BREITKREUTZ, B.-J., REGULY, T., BOUCHER, L., BREITKREUTZ, A., AND TYERS, M. 2006. BioGRID: a general repository for interaction datasets. Nucleic Acids Research 34, Database issue, D535–D539.\nSYRJANEN, T. 2006. Debugging inconsistent answer set programs. In Proc. of NMR. TIIHONEN, J., SOININEN, T., AND SULONEN, R. 2003. A practical tool for mass-customising\nconfigurable products. In Proc. of the International Conference on Engineering Design. 1290– 1299.\n1 Online appendix for the paper\nGenerating Explanations for Biomedical Queries published in Theory and Practice of Logic Programming\nESRA ERDEM, UMUT OZTOK Sabancı University, Orhanlı, Tuzla, İstanbul 34956, Turkey\n(e-mail: {esraerdem,uoztok}@sabanciuniv.edu)\nsubmitted 25 October 2012; revised 17 July 2013; accepted 19 August 2013\nAppendix A Proofs\nWe provide proofs of the theoretical results presented in the paper: the algorithmic analysis for generating shortest explanations (Propositions 2, 3, and 4), the algorithmic analysis for generating k different explanations (Propositions 5, 6, and 8), and the analysis for the relationship between an explanation and a justification. (Propositions 10 and 11).\nA.1 Generating Shortest Explanations\nIn Section 5 of the paper, we have analyzed three properties of Algorithm 1, namely termination, soundness and complexity, resulting in Propositions 2, 3, and 4. In the following, we show the proofs of these results.\nA.1.1 Proof of Proposition 2 – Termination of Algorithm 1\nTo prove that Algorithm 1 terminates we need the following lemma.\nLemma 1 Given a ground ASP program Π, an answer set X for Π, an atom p in X , and a set L of atoms in X , Algorithm 2 terminates."
    }, {
      "heading" : "Proof of Lemma 1",
      "text" : "It is sufficient to show that the recursion tree generated by Algorithm 2 is finite. That is, the branching factor of the recursion tree and the height of the recursion tree are finite. Note that each node of the recursion tree denotes a call to createTree(Π, X, d, L) for some atom or rule d and a set L of atoms.\nPart (1) We show that the branching factor of the tree is finite. Branches in the tree are created in loops at Lines 5 and 13. The loop at Line 5 iterates at most the number of rules in Π and the loop at Line 13 iterates at most the number of atoms in X . As Π and X are finite, the branching factor of the tree is finite.\n2 Part (2) We show that the height of the recursion tree is finite. Let us first make the following observation. Consider a path 〈v1, . . .〉 in the recursion tree. For every node vi that denotes a call to createTree(Π, X, di, Li) where di is an atom in X , the following holds for vi+2 (if exists): Li ⊂ Li+2. This follows from the two consecutive calls to createTree: Li increases at every other call, due to Line 4. Now, assume that the height of the recursion tree is infinite. Then, there exists an infinite path 〈v1, . . .〉 in the recursion tree. Thus, L1 ⊂ L3 ⊂ . . . ⊂ L(2×|X|)+1 ⊂ L(2×|X|)+3 ⊂ . . .. Recall that we add elements into Lis only from X (Line 4). Thus, L(2×|X|)+1 = X . Then, it is not possible to have L(2×|X|)+1 ⊂ L(2×|X|)+3. As we reach a contradiction, the height of the recursion tree is finite.\nNow, we show that Algorithm 1 terminates.\nProposition 2 Given a ground ASP program Π, an answer set X for Π, and an atom p in X , Algorithm 1 terminates."
    }, {
      "heading" : "Proof of Proposition 2",
      "text" : "Algorithm 1 terminates only if Algorithms 2, 3, and 4 terminate. By Lemma 1, we know that Algorithm 2 terminates and that the vertex-labeled tree T returned by Algorithm 2 is finite. Since Algorithm 3 and Algorithm 4 simply traverse T (cf. Lines 2 and 6 in Algorithm 3, and Lines 5 and 10 in Algorithm 4), they also terminate. Thus, Algorithm 1 terminates.\nA.1.2 Proof of Proposition 3 – Soundness of Algorithm 1\nTo show the proof of Proposition 3, we need the following necessary lemmas.\nLemma 2 Let Π be a ground ASP program, X be an answer set for Π, d be an atom in X or a rule in Π and L be a subset of X . If the vertex-labeled tree 〈V,E, l,Π, X〉 returned by createTree(Π, X, d, L) is not empty, then the following hold:\n(i) the root of 〈V,E〉 is created in createTree(Π, X, d, L) and is mapped to d by l; (ii) for every rule vertex v ∈ V ,\noutE(v) = {(v, v′) | (v, v′) ∈ E, l(v′) ∈ B+(l(v))};\n(iii) each leaf vertex is a rule vertex."
    }, {
      "heading" : "Proof of Lemma 2",
      "text" : "Let 〈V,E, l,Π, X〉 be the non-empty vertex-labeled tree returned by createTree(Π, X, d, L). We show one by one that each condition in the lemma holds.\n3 (i) Assume that d is an atom in X . Note that d /∈ L because otherwise 〈V,E〉 = 〈∅, ∅〉. Due to the call createTree(Π, X, d, L), the algorithm, at Line 3, creates a vertex v such that l(v) = d. We know that E 6= ∅. Then, there exists some out-going edges of v. At Line 9, the out-going edges of v are formed. Due to Line 8, each vertex v′ in (v, v′) is the root of a vertex-labeled tree. Moreover, there is no part of the algorithm that adds a “parent” to a vertex. Therefore, v is the root of 〈V,E〉.\nSimilar reasoning can be applied for the case where d is a rule in Π.\n(ii) Let v ∈ V be a rule vertex. Let Sv = {(v, v′) | (v, v′) ∈ E, l(v′) ∈ B+(l(v))} denoting the set of out-going edges of v to atom vertices whose labels are in the positive body of the rule that labels v. We show that outE(v) = Sv .\nLet (v, v′) ∈ outE(v). Then, (v, v′) ∈ E. Edges are created at Lines 9 and 17. As v is a rule vertex, (v, v′) must be created at Line 17. Then, by Line 16 and the condition at Line 13, l(v′) ∈ B+(l(v)). So, (v, v′) ∈ Sv (i.e., outE(v) ⊆ Sv).\nLet (v, v′) ∈ Sv . Then, by the definition of Sv , (v, v′) ∈ E. Thus, (v, v′) ∈ outE(v) (i.e., Sv ⊆ outE(v)).\n(iii) Assume otherwise. Then, there exists an atom vertex v ∈ V such that it is a leaf vertex. Vertices are created at Lines 3 and 12. As v is an atom vertex, it must be created at Line 3. Since it is a leaf vertex, condition at Line 7 never holds. But, then condition at Line 10 holds. Then, the call where v is created returns an empty set of vertices. That is, v cannot be in V .\nLemma 3 Let Π be a ground ASP program and X be an answer set for Π. For the two subsequent calls createTree(Π, X, d, L) and createTree(Π, X, d′, L′) (i.e., createTree(Π, X, d′, L′) being called right after createTree(Π, X, d, L)) on a path in the recursion tree for some execution of Algorithm 2, the following hold\n(i) If d is an atom, then L′ = L ∪ {d}; (ii) If d is a rule, then L′ = L."
    }, {
      "heading" : "Proof of Lemma 3",
      "text" : "Let createTree(Π, X, d, L) and createTree(Π, X, d′, L′) be two subsequent calls on a path in the recursion tree for some execution of Algorithm 2. We show one by one that the conditions in the lemma hold.\n(i) Assume that d is an atom. Then, createTree(Π, X, d′, L′) is called at Line 6. Due to Line 4, L′ = L ∪ {d}.\n(ii) Assume that d is a rule. Then, createTree(Π, X, d′, L′) is called at Line 13. As L is not modified prior to this call, L′ = L.\n4 Lemma 4 Let Π be a ground ASP program, X be an answer set for Π and 〈V,E, l,Π, X〉 be the vertex-labeled tree returned by execution Exc of Algorithm 2. Let createTree(Π, X, d, L) and createTree(Π, X, d′, L′) be the two subsequent calls (i.e., createTree(Π, X, d′, L′) being called right after createTree(Π, X, d, L)) on a path in the recursion tree for Exc, where each call on the path returns a nonempty vertex-labeled tree. Let v and v′ be two vertices created by createTree(Π, X, d, L) and createTree(Π, X, d′, L′), respectively, such that l(v) = d and l(v′) = d′. Then, (v, v′) ∈ E."
    }, {
      "heading" : "Proof of Lemma 4",
      "text" : "Notice that either d is an atom and d′ is a rule or vice versa. We show that the lemma holds for the former case. The latter case can be shown similarly. Assume that d is an atom and d′ is a rule. Then, createTree(Π, X, d′, L′) must be called at Line 6 within createTree(Π, X, d, L). As none of the calls on the path returns empty vertex-labeled tree, the condition at Line 7 holds in createTree(Π, X, d, L). Then, an edge (v, v′) is added to E at Line 9. Note that v is created in createTree(Π, X, d, L) at Line 3 and l(v) = d. Also, due to Line 8, v′ is the root of the vertex-labeled tree returned by createTree(Π, X, d′, L′). Then, by Lemma 2, v′ is a vertex created in createTree(Π, X, d′, L′) and l(v′) = d′.\nLemma 5 Let Π be a ground ASP program, X be an answer set for Π, d be an atom in X and T = 〈V,E, l,Π, X〉 be the vertex-labeled tree returned by createTree(Π, X, d, ∅). If T is not empty, then for every node createTree(Π, X, d′, L′) in the recursion tree for createTree(Π, X, d, ∅), where createTree(Π, X, d′, L′) and its ancestors return nonempty vertex-labeled trees, L′ = ancT (v) where l(v) = d′."
    }, {
      "heading" : "Proof of Lemma 5",
      "text" : "Assume that T is not empty. Then, we prove the lemma by induction on the depth of a node in the recursion tree for createTree(Π, X, d, ∅).\nBase case: Note that the node at depth 0 in the recursion tree for createTree(Π, X, d, ∅) returns a nonempty vertex-labeled tree and it has no ancestors. By Lemma 2, the root v of 〈V,E〉 is mapped to d by l, i.e., l(v) = d = d′. As the root of a tree does not have any ancestors, ancT (v) = ∅ = L′.\nInduction step: As an induction hypothesis, assume that for every node createTree(Π, X, d′, L′) at depth less than n in the recursion tree for createTree(Π, X, d, ∅), where createTree(Π, X, d′, L′) and its ancestors return nonempty vertex-labeled trees, L′ = ancT (v) where l(v) = d′. Let createTree(Π, X, d′, L′) be a node at depth n in the recursion tree for createTree(Π, X, d, ∅), where createTree(Π, X, d′, L′) and its ancestors return nonempty vertex-labeled trees. We show that L′ = ancT (v) where l(v) = d′. For that, we need to consider two cases: d′ is an atom and d′ is a rule. Let createTree(Π, X, p, Lp) be the parent of createTree(Π, X, d′, L′), as illustrated in Figure A 1.\n5 Depth\ncreateTree(Π, X, d, ∅)\n...\n...\ncreateTree(Π, X, p, Lp)\ncreateTree(Π, X, d′, L′)\n...\n...\n...\n... ...\n0\nn− 1\nn\nFig. A 1: Part of the recursion tree for createTree(Π, X, d, ∅).\nCase 1. Assume that d is an atom. Then, p must be a rule. By Lemma 3, L′ = Lp. Notice that the depth of the parent node is n − 1. Then, by the induction hypothesis, Lp = ancT (v) where l(v) = p. Also, by Lemma 4, (v, v′) ∈ E where l(v′) = d′. Since v is a rule vertex, ancT (v) = ancT (v′). Thus, L′ = ancT (v′) where l(v′) = d′.\nCase 2. Assume that d is a rule. Then, p must be an atom. By Lemma 3, L′ = Lp∪{p}. Notice that the depth of the parent node is n − 1. Then, by the induction hypothesis, Lp = ancT (v) where l(v) = p. Also, by Lemma 4, (v, v′) ∈ E where l(v′) = d′. Since v is an atom vertex, ancT (v) ∪ {l(v)} = ancT (v′). Thus, L′ = ancT (v′) where l(v′) = d′.\nProposition 12 (Soundness of Algorithm 2) Let Π be a ground ASP program, X be an answer set for Π, d be an atom in X and T = 〈V,E, l,Π, X〉 be the vertex-labeled tree returned by createTree(Π, X, d, ∅). If T is not empty, then T is the and-or explanation tree for d with respect to Π and X ."
    }, {
      "heading" : "Proof of Proposition 12",
      "text" : "Suppose that T is not empty. We want to show that T is the and-or explanation tree for d with respect to Π and X . For that, T must satisfy conditions (i)− (iv) in Definition 2. As T is not empty, conditions (i), (iii) and (iv) hold due to Lemma 2. To complete the proof, we show condition (ii) also holds in the sequel.\nLet Sv = {(v, v′) | (v, v′) ∈ E, l(v′) ∈ ΠX,ancT (v′)(l(v))}. Our goal is to show that for every atom vertex v ∈ V , outE(v) = Sv . To do so, we show that outE(v) ⊆ Sv and that Sv ⊆ outE(v).\n6 Let v be an atom vertex in V . Now, we show that outE(v) ⊆ S. Take an arbitrary element (v, v′) ∈ outE(v). Then, (v, v′) ∈ E. Throughout the algorithm edges are created at Lines 9 and 17. Since v is an atom vertex, (v, v′) must be created at Line 9. Then, due to the condition at Line 5 and Lemma 5, l(v′) ∈ ΠX,ancE(v′)(l(v)). Thus, (v, v′) ∈ Sv . As the last step, we show that Sv ⊆ outE(v). Let (v, v′) ∈ Sv be an arbitrary element. Then, by the definition of Sv , (v, v′) ∈ E. Thus, trivially, (v, v′) ∈ outE(v).\nLemma 6 Let Π be a ground ASP program, X be an answer set for Π, d be an atom in X , T = 〈VT , ET , l,Π, X〉 be the and-or explanation tree for d with respect to Π and X , v be the root of T and 〈V,E, l,Π, X〉 be the vertex-labeled tree returned by\nextractExp(Π, X, VT , l, v, ET ,WT , ∅,min).\nThen, for each v′ ∈ V , we have\nWT (v ′) ≤ min{WT (s) | s ∈ siblingET (v′)}."
    }, {
      "heading" : "Proof of Lemma 6",
      "text" : "Let v′ ∈ V . Vertices are added to V at Line 8. Then, due to Line 7, v′ is a rule vertex. Also, each vertex added to V corresponds to the 5th parameter of the algorithm. Note that recursive calls are made at Lines 5 and 10. Since the 5th parameter is a rule vertex only in the call at Line 5, the call where v′ is added to V must be initiated at Line 5. Then, due to Line 3, WT (v′) = min{WT (s) | s ∈ siblingET (v′)}.\nLemma 7 Let Π be a ground ASP program, X be an answer set for Π, d be an atom in X , T = 〈VT , ET , l,Π, X〉 be the and-or explanation tree for d with respect to Π and X , v be the root of T , and 〈V,E, l,Π, X〉 be the vertex-labeled tree returned by\nextractExp(Π, X, VT , l, v, ET ,WT , ∅,min).\nLet v1, v2 ∈ V . If (v1, v), (v, v2) ∈ ET for some v ∈ VT , then (v1, v2) ∈ E."
    }, {
      "heading" : "Proof of Lemma 7",
      "text" : "Since v1 ∈ V , it is added to V at Line 8. Then, for each child of v1, the algorithm is recursively called at Line 10. As (v1, v) ∈ ET , we make a call\nextractExp(Π, X, VT , l, v, ET ,WT , v1,min).\nInside that call, we add (v1, c) to E (at Line 4) where c is a minimum weighted child of v (due to Line 3). As (v, v2) ∈ ET and v2 is a minimum weighted child of v due to Lemma 6, c is equal to v2. Thus, (v1, v2) ∈ E.\n7 Lemma 8 Let Π be a ground ASP program, X be an answer set for Π, d be an atom in X , T = 〈VT , ET , l,Π, X〉 be the and-or explanation tree for d with respect to Π and X , and op be a string min. Then, Algorithm 4 returns an explanation 〈V,E, l,Π, X〉 for d with respect to Π and X ."
    }, {
      "heading" : "Proof of Lemma 8",
      "text" : "Let v be the root of T and S = 〈V,E, l,Π, X〉 be the output of\nextractExp(Π, X, VT , l, v, ET ,WT , ∅,min).\nTo prove that S is an explanation for d with respect to Π and X , we need to show that there exists an explanation tree 〈V ′, E′, l,Π, X〉 in T which satisfies Conditions (i) and (ii) in Definition 4 of the paper. That is, the following hold.\n(i) V = {v | v is a rule vertex inV ′}; (ii) E = {(v1, v2) | (v1, v), (v, v2) ∈ E′ for some atom vertex v ∈ V ′}.\nTo do so, we construct a vertex-labeled tree and show that it is an explanation tree in T which satisfies above conditions. Thus, let us define a vertex-labeled tree T ′ = 〈V ′, E′, l,Π, X〉 where\nV ′ = V ∪ {v | v ∈ VT s.t. (v, v′) ∈ ET for some v′ ∈ V } (A1) E′ = {(v, v′) | v, v′ ∈ V ′ s.t. (v, v′) ∈ ET } (A2)\nWe now show that T ′ is an explanation tree in T , i.e., T ′ satisfies Conditions (i)–(iv) in Definition 3.\n(i) Due to Line 8 and that v ∈ VT , V ⊆ VT . So, by (A1), V ′ ⊆ VT . Also, by (A2), E′ ⊆ ET .\n(ii) In the first call of Algorithm 4, v is the root of T . Then, at Line 5, the algorithm is called with a child c of v. Note that c is a rule vertex. Due to Line 8, for some v′ ∈ V , (v, v′) ∈ ET .\n(iii) Let v′ be an atom vertex in V ′. Then, by (A1) and (A2), (v′, v′′) ∈ E′ for some v′′ ∈ V . This ensures that deg′E(v′) ≥ 1. Assume that deg′E(v′) > 1. Then, for some v′′′ ∈ V ′ (v′′ 6= v′′′), (v′, v′′′) ∈ E′. Then, v′′′ ∈ V . This is not possible due to Line 3. Thus, degE(v ′) = 1.\n(iv) Let v′ be a rule vertex in V ′. Then, by (A1) v′ ∈ V and v is added into V at Line 8. Due to Line 9 and (A1), every child c of v is in V ′. Then, by (A2), (v, c) ∈ E′. That is, outET (v) ⊆ E′.\nAs a last step, we show that T ′ satisfies Conditions (i) and (ii) in Definition 4.\n(i) Note that every element in the set {v | v ∈ VT s.t. (v, v′) ∈ ET for some v′ ∈ V } is an atom vertex. Then, by (A1), V = {v | v is a rule vertex inV ′};\n8 (ii) Let S = {(v1, v2) | (v1, v), (v, v2) ∈ E′ for some atom vertex v ∈ V ′}. We show that E = S.\nLet (v1, v2) ∈ E. Then, (v1, v2) is added into E at Line 4. So, due to Lines 2 and 3, we know that there exists an atom vertex v ∈ VT such that (v, v2) ∈ ET . Then, by (A1), v ∈ V ′ and, by (A2), (v, v2) ∈ E′. Also, by Line 9, we know that (v1, v) ∈ ET . Then, by (A2), (v1, v) ∈ E′. Thus, (v1, v2) ∈ S. That is, E ⊆ S.\nLet (v1, v2) ∈ S. Then, for some atom vertex v ∈ V ′, (v1, v), (v, v2) ∈ E′. By (A2), v1, v2 ∈ V and (v1, v), (v, v2) ∈ ET . Then, due to Lemma 7, (v1, v2) ∈ E. That is, S ⊆ E.\nLemma 9 Let Π be a ground ASP program, X be an answer set for Π, and p be an atom in X . Let T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X , T ′ = 〈V ′, E′, l,Π, X〉 be an explanation tree in T and v be a rule vertex in V ′. Then, the following inequality holds for the weight of v\nWT (v) ≤ 1 + |{u′ |u′ ∈ desT ′(v)}|. (A3)"
    }, {
      "heading" : "Proof of Lemma 9",
      "text" : "We prove the lemma by induction on the height of a rule vertex in the explanation tree.\nBase case: Let u be a rule vertex in V ′ at height 0. Then, u is a leaf vertex. By the definition of the weight function, WT (u) = 1. Then, (A3) holds.\nInduction step: As an induction hypothesis, assume that for every rule vertex i ∈ V ′ at height less than n, (A3) holds. We show that (A3) holds for every rule vertex w ∈ V ′ at height n + 1. Let w be a rule vertex at height n + 1. Then, by the definition of the weight function, WT (w) = 1+ ∑ w′∈childE(w) WT (w\n′). Let w′ be a child of w. Note that w′ is an atom vertex. By the definition of an explanation tree, w′ ∈ V ′ and w′ has exactly one child w′′ ∈ V ′ which is a rule vertex. Then, by the definition of the weight function, WT (w′) = min{WT (c) | c ∈ childE(w′)} and thus WT (w′) ≤ WT (w′′). On the other hand, as the height of w′′ is n− 1, by the induction hypothesis, WT (w′′) ≤ 1 + |{d | d ∈ desT ′(w′′)}|. Since w′ has exactly one child w′′ ∈ V ′, we have\n1 + |{d | d ∈ desT ′(w′′)}| = |{u |u ∈ desT ′(w′)}|.\nThat is, WT (w′) ≤ |{u |u ∈ desT ′(w′)}|. Then, we have\nWT (w) = 1 + ∑\nw′∈childE(w) WT (w ′)\n≤ 1 +∑w′∈childE(w) |{u |u ∈ desT ′(w ′)}| = 1 + |{u′ |u′ ∈ desT ′(w)}|.\n9 Lemma 10 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T be the and-or explanation tree (with edges E) for p with respect to Π and X , v be the root of T , and T ′ be an explanation tree (with vertices V ′) in T . Then,\nWT (v) ≤ |{u |u is a rule vertex inV ′}|."
    }, {
      "heading" : "Proof of Lemma 10",
      "text" : "We want to show that the weight of v, WT (v), is at most the number of rule vertices in V ′. Note that v is the root of T ′ and there exists exactly one vertex v′ ∈ V ′ such that v′ ∈ childE(v) (due to Definition 3). Then, we have\nWT (v) = min{WT (c) | c ∈ childE(v)} (by Definition 6) ≤ WT (v′) (as v′ ∈ childE(v)) ≤ 1 + |{v′′ | v′′ ∈ desT ′(v′)}| (by Lemma 9) = |{u |u is a rule vertex inV ′}|. (as v′ is the only child of v in T ′)\nLemma 11 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T be the and-or explanation tree for p with respect to Π and X , v be the root of T , and 〈V,E, l,Π, X〉 be an explanation for p with respect to Π and X . Then, WT (v) ≤ |V |."
    }, {
      "heading" : "Proof of Lemma 11",
      "text" : "We show that the weight of v, WT (v), is at most |V |. By the definition of an explanation, there exists an explanation tree T ′ (with vertices V ′) of T such that |V | = |{v′ | v′ is a rule vertex inV ′}|. By Lemma 10, WT (v) ≤ |{v′ | v′ is a rule vertex inV ′}|. Thus, WT (v) ≤ |V |.\nLemma 12 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X , and T ′ = 〈V ′, E′, l,Π, X〉 be an explanation tree in T . If we have\nWT (v) ≤ min{WT (s) | s ∈ siblingE(v)}. (A4) for every rule vertex v ∈ V ′, then the following holds for every rule vertex v ∈ V ′.\nWT (v) = 1 + |{u′ |u′ ∈ desT ′(v)}|. (A5)"
    }, {
      "heading" : "Proof of Lemma 12",
      "text" : "Assume that (A4) holds for every rule vertex v ∈ V ′. Then, we prove the lemma by induction on the height of a rule vertex in the explanation tree.\nBase case: Let u be a rule vertex in V ′ at height 0. Then, u is a leaf vertex. By the definition of the weight function, WT (u) = 1. As u has no descendants, (A5) holds.\n10\nInduction step: As an induction hypothesis, assume that for every rule vertex i ∈ V ′ at height less than n, (A5) holds. We show that (A5) holds for every rule vertex w ∈ V ′ at height n + 1. Let w ∈ V ′ be a rule vertex at height n + 1. Then, by the definition of the weight function, WT (w) = 1 + ∑ w′∈childE(w) WT (w\n′). Let w′ be a child of w. Note that w′ is an atom vertex. By the definition of an explanation tree, w′ ∈ V ′ and w′ has exactly one child w′′ ∈ V ′, which is a rule vertex. Then, by the definition of the weight function, WT (w′) = min{WT (c) | c ∈ childE(w′)}. Also, by (A4), WT (w′′) ≤ min{WT (s) | s ∈ siblingE(w′′)}. Then, WT (w′′) = min{WT (c) | c ∈ childE(w′)}. Thus, WT (w\n′) = WT (w′′). As the height of w′′ is n−1, by the induction hypothesis, WT (w′′) = 1+|{u |u ∈ desT ′(w′′)}|. As w′′ is the only child of w′, WT (w′) = |{u |u ∈ desT ′(w′)}|. Then, we have\nWT (w) = 1 + ∑\nw′∈childE(w) WT (w ′)\n= 1 + ∑\nw′∈childE(w) |{u |u ∈ desT ′(w ′)}|\n= 1 + |{u′ |u′ ∈ desT ′(w)}|.\nLemma 13 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T be the and-or explanation tree (with edges E) for p with respect to Π and X , v be the root of T , and T ′ be an explanation tree (with vertices V ′) in T . If we have\nWT (v ′) ≤ min{WT (s) | s ∈ siblingE(v′)} (A6)\nfor every rule vertex v′ ∈ V ′, then, the following holds\nWT (v) = |{u |u is a rule vertex inV ′}|."
    }, {
      "heading" : "Proof of Lemma 13",
      "text" : "Assume that (A4) holds for every rule vertex v′ ∈ V ′. Then, we want to show that the weight of v, WT (v), is equal to the number of rule vertices in V ′. Note that v is the root of T ′ and there exists exactly one vertex v′ ∈ V ′ such that v′ ∈ childE(v) (due to Definition 3). Then, we have\nWT (v) = min{WT (c) | c ∈ childE(v)} (by Definition 6) = WT (v ′) (by (A6))\n= 1 + |{u′ |u′ ∈ desT ′(v′)}| (by Lemma 12) = |{u |u is a rule vertex inV ′}|. (as v′ is the only child of v in T ′)\nWe are now ready to prove Proposition 3.\nProposition 3 Given a ground ASP program Π, an answer set X for Π, and an atom p in X , Algorithm 1 either finds a shortest explanation for p with respect to Π and X or returns an empty vertexlabeled tree.\n11"
    }, {
      "heading" : "Proof of Proposition 3",
      "text" : "Algorithm 1 has two return statements; Lines 6 and 8. At Line 8, it returns an empty vertexlabeled tree. We show that what Algorithm 1 returns at Line 6, S = 〈V ′, E′, l,Π, X〉, is an explanation for p with respect to Π and X and that there is no other explanation for p with respect to Π and X , with vertices V ′′, such that |V ′′| < |V ′|.\nDue to the condition at Line 2, the vertex-labeled tree found at Line 1 is not empty. Then, by Proposition 12, we know that T is the and-or explanation tree for p with respect to Π and X . Then, by Lemma 8, we know that 〈V ′, E′, l,Π, X〉 found at Line 5 is an explanation for p with respect to Π and X .\nNow, suppose that there exists another explanation for p with respect to Π and X , with vertices V ′′, such that |V ′′| < |V ′|. Let v be the root of T . Then, by Lemma 11, WT (v) ≤ |V ′′|. Also, since S is an explanation for p with respect to Π and X , there exists an explanation tree with vertices V ′′′ in T such that V ′ = {u |u is a rule vertex inV ′′′}. Due to Lemma 6, WT (v′) ≤ min{WT (s) | s ∈ siblingE(v′)} for each v′ ∈ V ′. Then, by Lemma 13, WT (v) = |{u |u is a rule vertex inV ′′′}|. This implies that |V ′| ≤ |V ′′|. Since this is a contradiction, S is a shortest explanation for p with respect to Π and X .\nA.1.3 Proof of Proposition 4 – Complexity of Algorithm 1\nWe prove Proposition 4 which shows that the time complexity of Algorithm 1 is exponential in the size of the given answer set.\nProposition 4 Given a ground ASP program Π, an answer set X for Π, and an atom p in X , the time complexity of Algorithm 1 is O(|Π||X| × |BΠ|)."
    }, {
      "heading" : "Proof of Proposition 4",
      "text" : "In Algorithm 1, all the lines, expect 1, 4 and 5, take constant amount of time. At Lines 1, 4 and 5, three different algorithms are called. At Line 1, Algorithm 2 is called. This algorithm creates the and-or explanation tree recursively. As shown in Proof of Lemma 1, the branching factor of a vertex in the recursion tree is O(max{|X|, |Π|}) and the height of the tree is O(|X|). Also, at Line 5, for an atom d ∈ X , we check whether a rule in Π supports d in O(|BΠ|). Thus, the time complexity of Algorithm 2, in the worst case, is O(max{|X|, |Π|}|X| × |BΠ|). As |X| ≤ |Π|, it is O(|Π||X| × |BΠ|). At Lines 4 and 5, Algorithm 3 and Algorithm 4 are called, respectively. Algorithm 3 and Algorithm 4 simply traverse the tree T created by Algorithm 2 (cf. Lines 2 and 6 in Algorithm 3, and Lines 5 and 10 in Algorithm 4. By Proposition 12, we know that T is the and-or explanation tree for p with respect to Π and X . Since the height of T is O(|X|) and the branching factor of a vertex in T is max{|X|, |Π|}, the time complexity of Algorithm 2 dominates the time complexities of others. Thus, the time complexity of Algorithm 1, in the worst case, is O(|Π||X| × |BΠ|).\n12\nA.2 Generating k Different Explanations\nIn Section 6 of the paper, we have first analyzed three properties of Algorithm 5, namely termination, soundness and complexity, resulting in Propositions 5, 6, and 8. Then, we show some characteristics of its output, resulting in Proposition 7, Corollary 1 and Corollary 2. In the following, we show the proofs of these results.\nA.2.1 Proof of Proposition 5 – Termination of Algorithm 5\nWe now prove Proposition 5 which shows that Algorithm 5 terminates.\nProposition 5 Given a ground ASP program Π, an answer set X for Π, an atom p in X , and a positive integer k, Algorithm 5 terminates."
    }, {
      "heading" : "Proof of Proposition 5",
      "text" : "Algorithm 5 calls Algorithm 2 at Line 2. By Lemma 1, we know that Algorithm 2 terminates. Then, to show that Algorithm 5 terminates, we need to show that the loop between Lines 4–10 terminates. Due to Line 4, the loop iterates at most k times. If it iterates less than k times, it means that it is terminated at Line 6. Thus, assume that it iterates k times. Then, it is enough to show that every iteration of the loop terminates. Consider the ith (1 ≤ i ≤ k) iteration of the loop. First, at Line 5, Algorithm 6 is called. Observe that this algorithm simply traverses the and-or explanation tree T created at Line 2 (cf. Lines 2, 3, 8 and 9 in Algorithm 6). Since T is finite, Algorithm 6 terminates. Next, Algorithm 4 is called at Line 7. Similar to Algorithm 6, this algorithm also simply traverses a portion of T (cf. Lines 3, 5, 9 and 10 in Algorithm 4). Hence, Algorithm 4 also terminates. As the rest of the loop consists of some assignment statements, the ith (1 ≤ i ≤ k) iteration of the loop terminates. Since every iteration of the loop terminates, Algorithm 5 terminates.\nA.2.2 Proof of Proposition 6 – Soundness of Algorithm 5\nBefore showing the soundness property of Algorithm 5, we provide some necessary lemmas.\nProposition 13 (Completeness of Algorithm 2) Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X . Let T be the and-or explanation tree p with respect to Π and X . Then, createTree(Π, X, p, {}) returns T ."
    }, {
      "heading" : "Proof of Proposition 13",
      "text" : "Let 〈V,E, l,Π, X〉 be the output of Algorithm 2. By Condition (i) in Definition 2, the root of T is an atom vertex with label p. Since p is in X and L = ∅ at the beginning of Algorithm 2, a vertex v with label p is created at Line 3 and added into V at Line 4.\nTake an atom vertex v ∈ V . Then, there should be an out-going edge (v, v′) of v such that l(v′) ∈ ΠX,ancT (v′)(l(v)) (due to Condition (ii) in Definition 2). Note that, the set L in Algorithm 2 is essentially ancT (v′), and l(v′) ∈ ΠX,L(l(v)) is checked at Line 5.\n13\nMoreover, we need to ensure that v′ is a rule vertex. This condition is checked at Line 6 by recursive calls.\nTake a rule vertex v ∈ V . Then, for every atom a in B+(l(v)), there should be an outgoing edge (v, v′) of v such that l(v′) = a (due to Condition (iii) in Definition 2). This is satisfied by the condition at Line 13. Moreover, we need to make sure that v′ is atom vertex. For that, there is a recursive call at Line 14.\nTake a leaf vertex v ∈ V . Then, v must be a rule vertex (due to Condition (iv) in Definition 2). Assume that v is an atom vertex. Thus, no out-going edge is defined for v at Line 9. Then, when the loop at Line 5 terminates, the condition at Line 10 is satisfied. This implies that v is not in V . As it is a contradiction, v must be a rule vertex.\nBy this proposition and Proposition 1, we know that Algorithm 2 returns the and-or explanation tree. Thus, at Line 1 of Algorithm 5, the and-or explanation tree for p with respect to Π and X is created. We prove our statements by keeping this in mind.\nLemma 14 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of different explanations for p with respect to Π and X . Then, for the root vr of T , at each iteration i (1 ≤ i ≤ min{n, k}) of the loop in Algorithm 5, WT,Ri−1(vr) = |RVertices(Ki)\\Ri−1|."
    }, {
      "heading" : "Proof of Lemma 14",
      "text" : "Consider the ith (1 ≤ i ≤ min{n, k}) iteration of the loop. At Line 5, we call Algorithm 6 and calculate WT,Ri−1 for every vertex v in V . According to Algorithm 6, for an atom vertex v ∈ V , due to Line 4, WT,Ri−1(v) = max{WT,Ri−1(v′) | v′ ∈ childE(v)} and for a rule vertex u, due to Lines 6–9, WT,Ri−1(u) = xu + ∑ u′∈childE(u) WT,Ri−1(u\n′) where xu = 1 if u /∈ Ri−1, xu = 0 otherwise. Let v be an atom vertex in V . Let {v′1, . . . , v′vz} be a set of rule vertices that “contribute” to WT,Ri−1(v), i.e., rule vertices that appear in the expanded formula of WT,Ri−1(v). This implies that WT,Ri−1 = xv′1 + . . . + xv′vz where xv′j = 1 if v ′ j /∈ Ri−1, xv′j = 0 otherwise, for 1 ≤ j ≤ vz . Also, at Line 7 in Algorithm 5, we extract an explanation using Algorithm 4. Then, at Line 8, we assign the output 〈V ′, E′, l,Π, X〉 of Algorithm 4 to Ki. Let RVertices(Ki) = {v1, . . . , vz}. Observe in Algorithm 4 that for every atom vertex, we process its maximum weighted child recursively (Line 3), and for every rule vertex we choose every child of it recursively (Line 9). Then, due to the observation and the calculation of WT,Ri−1 , RVertices(Ki) is a set of rule vertices that contribute to WT,Ri−1(vr). Then, WT,Ri−1(vr) = x1 + . . . + xz where xj = 1 if vj /∈ Ri−1, xj = 0 otherwise, for 1 ≤ j ≤ z. That is, WT,Ri−1(vr) = |RVertices(Ki)\\Ri−1|.\nNow, we prove Proposition 6.\nProposition 6 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of different explanations for p with respect to Π and X . Then, Algorithm 5 returns min{n, k} different explanations for p with respect to Π and X .\n14"
    }, {
      "heading" : "Proof of Proposition 6",
      "text" : "First, assume that n ≥ k. Then, we show that Algorithm 5 returns at Line 11 a set K of k different explanations for p with respect to Π and X . Note that an element is added into K at each iteration of the loop between Lines 4–10. Since that loop iterates k times, we need to show that two properties hold: (i) for every iteration i (1 ≤ i ≤ k), Ki (the element added into K at the ith iteration) is an explanation for p with respect to Π and X . (ii) for all iterations i, j (1 ≤ i < j ≤ k), Ki and Kj are different. In the following, we consider those two properties.\n(i) For every iteration i (1 ≤ i ≤ k), Ki is formed at Line 8. According to Line 7, Ki is an output of Algorithm 4. Then, due to Lemma 8, we conclude that Ki is an explanation for p with respect to Π and X .\n(ii) Assume otherwise. Then, there exists i, j (1 ≤ i < j ≤ k) such that Ki = Kj . Consider the jth iteration of the loop. At Line 5, we call Algorithm 6 and calculate WT,Rj−1 for every vertex v in V . Then, at Line 7, we extract an explanation using Algorithm 4. Let Kj = 〈V ′, E′, l,Π, X〉, vr be the root of 〈V ′, E′〉 and RVertices(Kj) = {v1, . . . , vl}. Then, by Lemma 14, WT,Rj−1(vr) = x1 + . . . + xl where xz = 1 if vz /∈ Rj−1, xz = 0 otherwise, for 1 ≤ z ≤ l. Since Ki = Kj , {v1, . . . , vl} = RVertices(Ki). Due to Line 10, we know that RV ertices(Ki) ⊆ Rj−1. Then, for 1 ≤ z ≤ l, vz ∈ Rj−1. Thus, WT,Rj−1(vr) = 0. This implies that for every vertex v ∈ V , WT,Rj−1(v) = 0. That is, every rule vertex in V is also in Rj−1. However, as we are at the jth iteration and at each iteration one explanation is computed, Rj−1 might contain rule vertices for at most j − 1 explanations. We know that n ≥ k. Thus, for some v′ ∈ V , the following should hold: v′ /∈ Rj−1. As we reach a contradiction, Ki 6= Kj .\nNow, assume that n < k. Then, we show that Algorithm 5 returns at Line 6 a set K of n different explanations for p with respect to Π and X . Note that at the end of nth iteration of the loop, K contains n different explanations (due to the same reasoning above). Then, in the next iteration, WT,Rn+1(v) = 0. This is because Rn contains the rule vertices of n different explanations and the total number of explanations for p with respect to Π and X is n. Thus, the condition at Line 6 is satisfied and n different explanations are returned.\nA.2.3 Some Properties of Algorithm 5\nBefore presenting some characteristics of the output of Algorithm 5, we provide some necessary definitions and lemmas.\nDefinition 18 (WT,R) Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X , and R be a set of rule vertices in V . Then, WT,R is a function that maps vertices in V to nonnegative\n15\nintegers as follows.\nWT,R(v) =    max{WT,R(v′) | v′ ∈ childE(v)} if v is an atom vertex;∑ v′∈childE(v) WT,R(v ′) if v is a rule vertex and v ∈ R; 1 +\n∑ v′∈childE(v) WT,R(v ′) otherwise.\nLemma 15 Let Π be a ground ASP program, X be an answer set for Π, and p be an atom in X . Let T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X , T ′ = 〈V ′, E′, l,Π, X〉 be an explanation tree in T and R be a set of rule vertices in V . Then, for every rule vertex v in V ′, the following holds\nWT,R(v) ≥ {\n1 + |{u′ |u′ ∈ (desT ′(v)\\R)}| if v /∈ R; |{u′ |u′ ∈ (desT ′(v)\\R)}| otherwise.\n(A7)"
    }, {
      "heading" : "Proof of Lemma 15",
      "text" : "We prove the lemma by induction on the height of a rule vertex in the explanation tree.\nBase case: Let v be a rule vertex in V ′ at height 0. Then, v is a leaf vertex. By Definition 18, WT,R(v) = xv where xv = 1 if v /∈ R, xv = 0 otherwise. Then, (A7) holds.\nInduction step: As an induction hypothesis, assume that for every rule vertex i ∈ V ′ at height less than n+ 1, (A7) holds. We show that (A7) holds for every rule vertex v ∈ V ′ at height n+1. Let v be a rule vertex in V ′ at height n+1. Then, by Definition 18, WT,R(v) = xv + ∑ v′∈childE(v) WT,R(v\n′) where xv = 1 if v /∈ R, xv = 0 otherwise. Let v′ be a child of v. Note that v′ is an atom vertex. By Conditions (iii) and (iv) in Definition 3, v′ ∈ V ′ and v′ has exactly one child v′′ ∈ V ′ which is a rule vertex. Then, by Definition 18, WT,R(v\n′) = max{WT,R(c) | c ∈ childE(v′)} and thus WT,R(v′) ≥ WT,R(v′′). On the other hand, as the height of v′′ is n − 1, by the induction hypothesis, (A7) holds for v′′. Thus, we obtain the following.\nWT,R(v ′) ≥ { 1 + |{u′ |u′ ∈ (desT ′(v′′)\\R)}| if v′′ /∈ R; |{u′ |u′ ∈ (desT ′(v′′)\\R)}| otherwise.\n(A8)\nSince v′ has exactly one child v′′ ∈ V ′, we derive\n{v′′} ∪ {d | d ∈ desT ′(v′′)} = |{u |u ∈ desT ′(v′)}|. (A9)\nThen, due to (A8) and (A9),\nWT,R(v ′) ≥ |{u |u ∈ (desT ′(v′)\\R)}|. (A10)\nThen, to conclude the proof, we consider two cases. Case 1. Suppose that v /∈ R. Then, we can derive the following.\nWT,R(v) = 1 + ∑\nv′∈childE(v) WT,R(v ′) (by Definition 18)\n≥ 1 +∑v′∈childE(v) |{u |u ∈ (desT ′(v ′)\\R)}| (by (A10)) = 1 + |{u′ |u′ ∈ (desT ′(v)\\R)}|. (as every child of v is an atom vertex)\n16\nCase 2. Suppose that v ∈ R. Then, we can derive the following.\nWT,R(v) = ∑\nv′∈childE(v) WT,R(v ′) (by Definition 18)\n≥ ∑v′∈childE(v) |{u |u ∈ (desT ′(v ′)\\R)}| (by (A10)) = |{u′ |u′ ∈ (desT ′(v)\\R}|. (as every child of v is an atom vertex)\nLemma 16 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T = 〈V,E, l,Π, X〉 be the and-or explanation tree for p with respect to Π and X , v be the root of T , T ′ be an explanation tree (with vertices V ′) in T , and R be a set of rule vertices in V . Then,\nWT,R(v) ≥ |{u |u ∈ (RVertices(T ′)\\R)}|."
    }, {
      "heading" : "Proof of Lemma 16",
      "text" : "We want to show that WT,R(v) is equal to at least the number of rule vertices in V ′ but R. Recall that v is the root of T ′ and there exists exactly one vertex v′ ∈ V ′ such that v′ ∈ childE(v) (due to Condition (iii) in Definition 3). Then, we consider two cases.\nCase 1. Assume that v′ /∈ R. Then, we can derive the following.\nWT,R(v) = max{WT,R(c) | c ∈ childE(v)} (by Definition 18) ≥ WT,R(v′) (as v′ ∈ childE(v)) ≥ 1 + |{v′′ | v′′ ∈ (desT ′(v′)\\R)}| (by Lemma 15) = |{u |u ∈ (RVertices(T ′)\\R)}|. (as v′ is the only child of v in T ′)\nCase 2. Assume that v′ ∈ R. Then, we can derive the following.\nWT,R(v) = max{WT,R(c) | c ∈ childE(v)} (by Definition 18) ≥ WT,R(v′) (as v′ ∈ childE(v)) ≥ |{v′′ | v′′ ∈ (desT ′(v′)\\R)}| (by Lemma 15) = |{u |u ∈ (RVertices(T ′)\\R)}|. (as v′ is the only child of v in T ′)\nLemma 17 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , T be the and-or explanation tree (with vertices V ) for p with respect to Π and X , v be the root of T , T ′ = 〈V ′, E′, l,Π, X〉 be an explanation for p with respect to Π and X , and R be a set of rule vertices in V . Then, WT,R(v) ≥ |RVertices(T ′)\\R|.\n17"
    }, {
      "heading" : "Proof of Lemma 17",
      "text" : "We show that WT,R(v) is equal to at least |RVertices(T ′)\\R|. By Definition 4, there exists an explanation tree T ′′ (with vertices V ′′) in T such that V ′ = {v′ | v′ is a rule vertex inV ′′}. That is, RVertices(T ′) = RVertices(T ′′). By Lemma 16, we know that WT,R(v) ≥ |{u |u ∈ (RVertices(T ′′)\\R)}|. Thus, we conclude that WT,R(v) ≥ |RVertices(T ′)\\R|.\nWe can now prove our main result which simply indicates that at each iteration i of the loop in Algorithm 5 the distance ∆D(Ri−1,Ki) is maximized.\nProposition 7 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to Π and X . Then, at the end of each iteration i (1 ≤ i ≤ min{n, k}) of the loop in Algorithm 5, ∆D(Ri−1,RVertices(Ki)) is maximized, i.e., there is no other explanation K ′ such that ∆D(Ri−1,RVertices(Ki)) < ∆D(Ri−1,RVertices(K ′))."
    }, {
      "heading" : "Proof of Proposition 7",
      "text" : "The proof is by contradiction. Assume that there exists an explanation K ′ such that ∆D(Ri−1,RVertices(Ki)) < ∆D(Ri−1,RVertices(K ′)). That is, |RVertices(K ′)\\Ri−1| > |RVertices(Ki)\\Ri−1|. Let vr be the root of T . Then, by Lemma 17, WT,Ri−1(vr) ≥ |RVertices(K ′)\\Ri−1|. Also, by Lemma 14, we know that WT,Ri−1(vr) = |RVertices(Ki)\\Ri−1|. Therefore, we obtain that |RVertices(Ki)\\Ri−1| ≥ |RVertices(K ′)\\Ri−1|. But, that contradicts the assumption |RVertices(K ′)\\Ri−1| > |RVertices(Ki)\\Ri−1|. Thus, there is no K ′ such that ∆D(Ri−1,RVertices(Ki)) < ∆D(Ri−1,RVertices(K ′)), i.e., ∆D(Ri−1,RVertices(Ki)) is maximized.\nNow, we provide the proof of the corollary that shows how to compute longest explanations.\nCorollary 1 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k = 1. Then, Algorithm 5 computes a longest explanation for p with respect to Π and X ."
    }, {
      "heading" : "Proof of Corollary 1",
      "text" : "Since k = 1, the loop in Algorithm 5 iterates once. At that iteration, by Proposition 6, we know that an explanation K1 for p with respect to Π and X is computed. By Proposition 7, we also know that ∆D(R0,RVertices(K1)) is maximized. That is, there exists no explanation K ′ for p with respect to Π and X such that |RVertices(K ′)\\R0| > |RVertices(K1)\\R0|. Note that R0 is an empty set. Therefore, there exists no explanation K ′ for p with respect to Π and X such that |RVertices(K ′)| > |RVertices(K1)|. As every vertex of an explanation is a rule vertex, we conclude that K1 is a longest explanation for p with respect to Π and X .\n18\nNext, we indicate the proof of the corollary that shows Algorithm 5 computes min{n, k} different explanations such that for every i (1 ≤ i ≤ min{n, k}) the ith explanation is the most distant explanation from the previously computed i− 1 explanations. Corollary 2 Let Π be a ground ASP program, X be an answer set for Π, p be an atom in X , and k be a positive integer. Let n be the number of explanations for p with respect to Π and X . Then, Algorithm 5 computes min{n, k} different explanations K1, . . . ,Kmin{n,k} for p with respect to Π and X such that for every j (2 ≤ j ≤ min{n, k}) ∆D( ⋃j−1 z=1 RVertices(Kz),Kj) is maximized."
    }, {
      "heading" : "Proof of Corollary 2",
      "text" : "By Proposition 6, we know that K1, . . . ,Kmin{n,k} are min{n, k} different explanations for p with respect to Π and X . Also, by Proposition 7, for every i (2 ≤ i ≤ min{n, k}), we obtain that ∆D(Ri−1,Ki) is maximized. Due to Lines 1 and 10 of Algorithm 5, Ri−1 = ⋃i−1 j=0 RVertices(Kj). Since R0 is an empty set, we conclude that ∆D( ⋃i−1 j=1 RVertices(Kj),Ki) is maximized.\nA.2.4 Proof of Proposition 8 – Complexity of Algorithm 5\nWe prove Proposition 8 which shows that the time complexity of Algorithm 5 is exponential in the size of the given answer set.\nProposition 8 Given a ground ASP program Π, an answer set X for Π, an atom p in X and a positive integer k, the time complexity of Algorithm 5 is O(k × |Π||X|+1 × |BΠ|)."
    }, {
      "heading" : "Proof of Proposition 8",
      "text" : "Algorithm 5 calls Algorithm 2 at Line 2. In the proof of Proposition 4, it is shown that the worst case time complexity of Algorithm 2 is O(|Π||X|×BΠ). Moreover, Algorithm 5 has a loop between Lines 4–10, which iterates at most k times. In every iteration of the loop, Algorithm 6 and Algorithm 4 are called at Lines 5 and 7. Algorithm 6 simply traverses the and-or explanation tree T recursively (cf. Lines 2, 3, 8 and 9 in Algorithm 6). The height of T is O(|X|) and the branching factor of a vertex in T is O(|Π|). Also, at Line 8 in Algorithm 6, we check whether a rule vertex in V is in R. As R is a subset of the rule vertices in V , this check can be done in O(|Π| × |BΠ|) time. Thus, the time complexity of Algorithm 6, in the worst case, is O(|Π||X| × |Π| × |BΠ|). Similar to Algorithm 6, Algorithm 4 just traverses a portion of T (cf. Lines 3, 5, 9 and 10 in Algorithm 4). Thus, the time complexity of every iteration of the loop in Algorithm 5 is O(|Π||X|+1 × |BΠ|). As the loop iterates at most k times, the time complexity of Algorithm 5, in the worst case, is O(k × |Π||X|+1 × |BΠ|).\nA.3 Relations between Explanations and Justifications\nIn Section 10 of the paper, we have related explanations to justifications, resulting in Propositions 10 and 11. In the following, we show the proofs of these results.\n19\nA.3.1 Proof of Proposition 10 – Soundness of Algorithm 7\nIn the proof of Proposition 10, the idea is to show that Algorithm 7 returns at Line 17 an explanation tree T ′ in the and-or explanation tree for p with respect to Π and X . That is, T ′ satisfies Conditions (i)–(iv) in Definition 3. Before providing the proof of Proposition 10, we consider some useful lemmas and corollaries.\nLemma 18 Let Π be a ground normal ASP program, X be an answer set for Π, p be an atom in X , U be an assumption in Assumptions(Π, X), G = (V,E) be an offline justification of p+ with respect to X and U , T = 〈V ′, E′, l,Π, X〉 be an output of Algorithm 7 and P = 〈v1, . . . , vn〉 be a path in T . Take any three consecutive elements vi, vi+1 and vi+2 in P such that vi and vi+2 are atom vertices and vi+1 is a rule vertex. Then, (l(vi) +, l(vi+2) +,+) ∈ E holds."
    }, {
      "heading" : "Proof of Lemma 18",
      "text" : "As vi is an atom vertex, its out-going edges are formed at Line 15 of Algorithm 7. Then, due to Lines 13 and 14, vi+1 is a rule vertex such that B(l(vi+1)) = support(l(vi)+, G). As vi+1 is a rule vertex, its out-going edges are formed at Line 10. Then, due to Lines 8 and 9, vi+2 is an atom vertex where l(vi+2) ∈ B+(l(vi+1)). Since B(l(vi+1)) = support(l(vi)\n+, G) and l(vi+2) ∈ B+(l(vi+1)), by Definition 10, (l(vi)+, l(vi+2)+,+) ∈ E holds.\nCorollary 3 Let Π be a ground normal ASP program, X be an answer set for Π, p be an atom in X , U be an assumption in Assumptions(Π, X), G = (N,E) be an offline justification of p+ with respect to X and U , T = 〈V ′, E′, l,Π, X〉 be an output of Algorithm 7 and P = 〈v1, . . . , vn〉 be a path in T where v1 and vn are atom vertices. Then, l(vn)+ is reachable from l(v1)+ by a positive path in G."
    }, {
      "heading" : "Proof of Corollary 3",
      "text" : "Note that an edge in E′ is either defined from an atom vertex to a rule vertex or vice versa due to Lines 10 and 15 of Algorithm 7. By this observation, in P , as v1 is an atom vertex, vi is an atom vertex (resp., rule vertex) if i is an odd number (resp., a even number). Then, by Lemma 18, for 1 ≤ i ≤ n − 2 and i mod 2 6= 0 (i.e., i is an odd number), (l(vi)+, l(vi+2)+,+) ∈ E. Thus, there exists a positive path〈 l(v1) +, l(v3) +, l(v5) +, . . . , l(v+n−2), l(vn) + 〉\nin G. That is, l(vn)+ is reachable from l(v1) + by a positive path in G.\nLemma 19 Let Π be a ground normal ASP program, X be an answer set for Π, p be an atom in X , U be an assumption in Assumptions(Π, X), G = (N,E) be an offline justification of p+ with respect to X and U , T = 〈V ′, E′, l,Π, X〉 be an output of Algorithm 7 and v be an atom vertex in V ′ such that v is the first element added into the queue Q in Algorithm 7. Consider a sequence S = 〈v1 = v, v2, . . . , vn〉 of n elements where vi ∈ V ′ for 1 ≤ i ≤ n\n20\nsuch that vj+1 is added into Q right after vj for 1 ≤ j < n. Then, every vertex vi ∈ V ′ (1 < i ≤ n) is reachable from v by a path in T ."
    }, {
      "heading" : "Proof of Lemma 19",
      "text" : "The proof is by induction on the length of S.\nBase case: Assume that S has two elements, i.e., S = 〈v1 = v, v2〉. Since v is the first vertex added into Q by definition, it is the first vertex dequeued from Q at Line 5. Then, since v is an atom vertex by definition, the second vertex is added into Q at Line 16. By definition of S, v2 is the second vertex added into Q. Thus, by Line 15, (v, v2) ∈ E′, i.e., v2 is reachable from v by a path in T .\nInduction step: As an induction hypothesis, assume that for a sequence S′ = 〈v1 = v, v2, . . . , vk〉 of k elements, where vi ∈ V ′ for 1 ≤ i ≤ k such that vj+1 is added into Q right after vj for 1 ≤ j < k, every vertex vl ∈ V (1 < l ≤ k) is reachable from v by a path in T . Let S′′ = 〈v1 = v, v2, . . . , vk+1〉 be a sequence of k + 1 elements, where vi ∈ V ′ for 1 ≤ i ≤ k + 1 such that vj+1 is added into Q right after vj for 1 ≤ j < k + 1. We show that v reaches every vertex in S′′ by using edges in E′. Consider the subsequence S′′sub of S\n′′ that consists of the first k elements of S′′, i.e., a prefix of S′′ with length k. By the induction hypothesis, every vertex vi ∈ S′′sub is reachable from v by a path in T . Now, we show that vk+1 is reachable from v by a path in T . We consider two cases. Case 1. Assume that vk+1 is an atom vertex. Then, vk+1 is added into V ′ at Line 11. So, by Line 10, there exists a vertex v′ such that (v′, vk+1) ∈ E′. But, due to Line 5, v′ must be added into Q prior to vk+1. That is, v′ ∈ S′′sub. So, by the induction hypothesis, v reaches v′ by a path P in T . Thus, by P and (v′, vk+1), vk+1 is reachable from v by a path in T . Case 2. Assume that vk+1 is a rule vertex. Then, vk+1 is added into V ′ at Line 16. So, by Line 15, there exists a vertex v′ such that (v′, vk+1) ∈ E′. But, due to Line 5, v′ must be added into Q prior to vk+1. That is, v′ ∈ S′′sub. So, by the induction hypothesis, v reaches v′ by a path P in T . Thus, by P and (v′, vk+1), vk+1 is reachable from v by a path in T .\nWe now prove Proposition 10 that shows the soundness of Algorithm 7.\nProposition 10 Given a ground normal ASP program Π, an answer set X for Π, an atom p in X , an assumption U in Assumption(Π, X), and an offline justification G = (V,E) of p+ with respect to X and U , Algorithm 7 returns an explanation tree 〈V ′, E′, l,Π, X〉 in the and-or explanation tree for p with respect to Π and X ."
    }, {
      "heading" : "Proof of Proposition 10",
      "text" : "We show what Algorithm 7 returns at Line 17, T ′ = 〈V ′, E′, l,Π, X〉, is an explanation tree in the and-or explanation tree T = 〈VT , ET , l,Π, X〉 for p with respect to Π and X . That is, T ′ satisfies Conditions (i)–(iv) in Definition 3. In the following, we study each condition separately.\n21\n(ii) To show that the root of 〈V ′, E′〉 is a vertex whose label is p, we need to show three cases hold; (1) there exists a vertex v in V ′ with label p, (2) every vertex v′ ∈ V ′ is reachable from v by a path in T ′. (3) v has no in-going edge. In the following, we show that each case holds. Case 1. Observe that a vertex is in V ′ if and only if it is added into the queue Q. Then, due to Lines 2 and 3, there exists a vertex v ∈ V ′ such that l(v) = p. Case 2. The first element added into Q is an atom vertex v with l(v) = p, due to Lines 2 and 3. Note that a vertex is in V ′ if and only if it is added into Q. Then, as v is added into Q, by the observation, v ∈ V ′. Now, pick a vertex v′ ∈ V ′. By the same observation, v′ is also added into Q. Since v is the first element queued in Q, v′ is queued in V ′ later on. Thus, by Lemma 19, v′ is reachable from v by a path in T ′. Case 3. Assume otherwise. That is, (v′, v) ∈ E′ for some vertex v′ ∈ V ′. The edges in E′ are constructed at Lines 10 and 15. Then, as v is an atom vertex, v′ is a rule vertex. Observe that a vertex is in V ′ if and only if it is added into Q. Then, since v′ is a rule vertex in V ′, it is added into Q at Line 16. So, due to Line 15, there exists an atom vertex v′′ ∈ V ′ such that (v′′, v′) ∈ E′. Thus, as (v′′, v′), (v′, v) ∈ E′, there exists a path 〈v′′, v′, v〉 in T ′. Then, by Corollary 3, l(v)+ is reachable from l(v′′)+ by a positive path P in G. Moreover, as shown in Case 2 above, v′′ is reachable from v by a path 〈v1 = v, v2, . . . , vn = v′′〉 in T ′. So, by Corollary 3, l(v′′)+ is reachable from l(v)+ by a positive path P ′ in G. Then, by P and P ′, a positive cycle exists in G. As every offline justification is a safe offline e-graph due to Definition 17, we reach a contradiction.\n(i) By Condition (ii) in Definition 3, we know that the root of 〈V ′, E′〉 is a vertex v with l(v) = p. Then, if we show that for every vertex v′ ∈ V ′, outE′(v′) is a subset of ET , then we can conclude that 〈V ′, E′〉 is a subtree of 〈VT , ET 〉. Now, pick a vertex v′ ∈ V ′. We consider two cases: Case 1. Assume that v′ is an atom vertex. Take an out-going edge (v′, v′′) of v′ in E′. To show that (v′, v′′) ∈ ET , we need to show that l(v′′) ∈ ΠX,ancT ′ (v′′)(l(v′)), due to Condition (ii) in Definition 2. For that, we should show that H(l(v′′)) = l(v′), B+(l(v′′)) ⊆ X\\ancT ′(v′′), B−(l(v′′)) ∩ X = ∅ and X |= Bcard(l(v′′)), due to (8) in Section 4. As Π is a ground normal ASP program, it does not contain cardinality expressions in its body. Thus, X |= Bcard(l(v′′)) trivially. In Algorithm 7, outgoing edges of atom vertices are formed at Line 15. Then, due to Lines 13 and 14, H(l(v′′)) = l(v′) and B(l(v′′)) = support(l(v′)+, G). Since G is an offline justification, G is an offline e-graph by Definition 17. Then, by Definition 13, G is an (X,U)based e-graph. So, by Definition 12, support(l(v′)+, G) is an LCE of l(v′)+ with respect to (X,U), so does B(l(v′′)). According to Definition 11, as B(l(v′′)) 6= {assume}, B+(l(v′′)) ⊆ X and B−(l(v′′)) ∩ X = ∅. To complete this part, it remains to show that B+(l(v′′)) ⊆ X\\ancT ′(v′′). Since B+(l(v′′)) ⊆ X , it is enough to show that B+(l(v′′)) ∩ ancT ′(v′′) = ∅. For that, assume B+(l(v′′)) ∩ ancT ′(v′′) 6= ∅. Let a ∈ B+(l(v′′)) ∩ ancT ′(v′′). Since a ∈ B+(l(v′′)) and B(l(v′′)) = support(l(v′)+, G), (l(v′)+, a+,+) ∈ E holds. As a ∈ ancT ′(v′′), there exists a vertex u ∈ V ′ where l(u) = a such that a path P = 〈v1 = u, . . . , vn = v′〉 in T ′ exists. Then, due to Corollary 3, l(v′)+ is reachable from a+ by a positive path in G. But, as (l(v′)+, a+,+) ∈ E, (a+, a+) ∈ E∗,+\n22\nholds, i.e., there is a positive cycle in the offline justification, which is a contradiction, due to Definition 17. Case 2. Assume that v′ is a rule vertex. Take an out-going edge (v′, v′′) of v′ in E′. To show that (v′, v′′) ∈ ET , we need to show that l(v′′) ∈ B+(l(v′)), due to Condition (iii) in Definition 2. Out-going edges of v′ are formed at Line 10 which is reached only by satisfying the condition at Line 8. Then, due to Line 9, l(v′′) ∈ B+(l(v′)).\n(iii) Observe that an element is added into Q once. Thus, we dequeue each atom vertex only once. Then, due to Lines 12–16, every atom vertex v′ ∈ V ′ has exactly one out-going edge, i.e., degE′(v ′) = 1.\n(iv) Take a rule vertex v′ ∈ V ′. Its edges are formed at Line 10. Then, due to the condition at Line 8 and the statement at Line 9, for every a ∈ B+(l(v′)), there exists a vertex v′′ such that l(v′′) = a. Then, the condition holds.\nAlso, we can show that the and-or explanation tree exists for every atom in an answer set.\nProposition 1 Let Π be a ground ASP program and X be an answer set for Π. For every p be in X , the and-or explanation tree for p with respect to Π and X is not empty."
    }, {
      "heading" : "Proof of Proposition 1",
      "text" : "By Proposition 9, we know that there exists an offline justification of p+ with respect to X and X−\\WF−Π . Then, by Proposition 10, there is an explanation tree in the and-or explanation tree for p with respect to Π and X . That is, the and-or explanation tree for p with respect to Π and X is not empty.\nA.3.2 Proof of Proposition 11 – Soundness of Algorithm 8\nBefore proving Proposition 11, we provide the necessary lemmas.\nLemma 20 Let Π be a ground normal ASP program, X be an answer set for Π, p be an atom in X , T = 〈V ′, E′, l,Π, X〉 be an explanation tree in the and-or explanation tree for p with respect to Π and X such that for every v, v′ ∈ V ′, l(v) = l(v′) if and only if v = v′, (V,E) be the output of Algorithm 8 called with inputs Π, X, p and T , and 〈v1, v2, v3〉 be a path in T such that l(v1)+ ∈ V . Then, (l(v1)+, l(v3)+,+) ∈ E and l(v3)+ ∈ V ."
    }, {
      "heading" : "Proof of Lemma 20",
      "text" : "All of the nodes, except the one with label >, are added to V at Line 5 of Algorithm 8. As l(v1)\n+ ∈ V , v1 is extracted from the queue Q at Line 4. Then, since 〈v1, v2, v3〉 is a path in T and every atom vertex in V ′ has exactly one child due to Condition (iii) in Definition 3, v2 is obtained at Line 6. By the condition at Line 9, every child of v2 is considered in the loop. Accordingly, at Line 10, the edge (l(v1)+, l(v3)+,+) is added into E. Also, v3 is\n23\nadded into Q at Line 11. Then, due to the condition at Line 3 and the statements at Lines 4 and 5, l(v3)+ ∈ V .\nCorollary 4 Let Π be a ground normal ASP program, X be an answer set for Π, p be an atom in X , T = 〈V ′, E′, l,Π, X〉 be an explanation tree in the and-or explanation tree for p with respect to Π and X such that for every v, v′ ∈ V ′, l(v) = l(v′) if and only if v = v′, (V,E) be the output of Algorithm 8 called with inputs Π, X, p and T , and 〈v1, v2, . . . , vn〉 be a path in T such that l(v1)+ ∈ V . Then, 〈l(v1)+, l(v3)+, l(v5)+, . . . , l(vn)+〉 is a path in (V,E)."
    }, {
      "heading" : "Proof of Corollary 4",
      "text" : "Since 〈v1, v2, v3〉 is a path in T and l(v1)+ ∈ V , by Lemma 20, (l(v1)+, l(v3)+,+) ∈ E and l(v3)+ ∈ V . Similarly, (l(v3)+, l(v5)+,+) ∈ E and l(v5)+ ∈ V . Then, this incremental application of Lemma 20 leads that 〈l(v1)+, l(v3)+, l(v5)+, . . . , l(vn)+〉 is a path in (V,E).\nWe now prove Proposition 11 which shows that Algorithm 8 creates an offline justification of the given atom in the reduct of the given ASP program with respect to the given answer set, provided that labels of the vertices of the given explanation tree are unique labels, i.e., no two different vertices labels the same entity.\nProposition 11 Given a ground normal ASP program Π , an answer set X for Π, an atom p in X , and an explanation tree 〈V ′, E′, l,Π, X〉 in the and-or explanation tree for p with respect to Π and X such that for every v, v′ ∈ V ′, l(v) = l(v′) if and only if v = v′, Algorithm 8 returns an offline justification of p+ in ΠX with respect to X and ∅."
    }, {
      "heading" : "Proof of Proposition 11",
      "text" : "To show that the output (V,E) of Algorithm 8 at Line 13 is an offline justification of p+ in ΠX with respect to X and ∅, one needs to show that the following conditions hold.\n(1) ∅ ∈ Assumptions(ΠX , X); (2) (V,E) is an e-graph for ΠX ; (3) (V,E) is a (X, ∅)-based e-graph of p+; (4) (V,E) is an offline e-graph of p+ with respect to X and ∅.\nCondition (1) We show that ∅ ∈ Assumptions(ΠX , X). As ΠX is a positive program, i.e., it does not contain any negative atoms, by Definition 14, T AΠX (X) = ∅. Also, due to Definition 15, NR(ΠX , X) = ΠX . Then, by Definition 16, ∅ ∈ Assumptions(ΠX , X).\nCondition (2) We show that (V,E) is an e-graph for ΠX . For that, (V,E) should satisfy Conditions (i)− (iv) in Definition 9.\n(i) Consider two cases.\n24\nCase 1. Take a node b+ ∈ V \\{>}. It is added to V at Line 5. Then, there exists an atom vertex v ∈ V ′ such that l(v) = b. By Condition (iii) in Definition 3, v has exactly one child v′ in 〈V ′, E′〉, which is a rule vertex. Then, depending on whether l(v′) is a fact or not, an out-going edge of b+ in E is formed at Line 8 or 10. So, b+ is not a sink. Case 2. Let l be >. Then, it is added to V at Line 12. The edges in E are formed at Lines 8 and 10. Accordingly, l has no out-going edge, i.e., it is a sink. Therefore, (V,E) is an e-graph for ΠX . (ii) Due to Lines 8 and 10, clearly, for every b ∈ V there is no edges in the form of (b, assume,−) and (b,⊥,−) in E.\n(iii) Similar to (ii), for every b ∈ V there is no edges in the form of (b, assume,+) and (b,>,+) in E. (iv) Let b+ ∈ V such that (b+,>,+) ∈ E. As out-going edges are created at Lines 8 and 10, (b,>,+) must be formed at Line 8. Then, there exists an atom vertex v ∈ V ′ such that l(v) = b and the label of the child v′ of v is a fact (Line 7). Then, since the condition at Line 9 is not satisfied, it is not possible that b+ has another out-going edge.\nCondition (3) We show that (V,E) is an (X, ∅)-based e-graph of p+. By Condition (1) above, we know that (V,E) is an e-graph. To show that (V,E) is an (X, ∅)-based e-graph of p+, we need to show that Conditions (i) and (ii) in Definition 12 hold.\n(i) Take a node c+ ∈ V . It is added to V at Line 5. Then, there exists an atom vertex v′ ∈ V ′ such that l(v′) = c. By Condition (ii) in Definition 3, we know that the root of 〈V ′, E′〉 is a vertex v where l(v) = p. So, v′ is reachable from v by a path 〈v1 = v, v2, v3, . . . , vn = v′〉 in 〈V ′, E′〉. Also, as v is added into Q at Line 2, we know that l(v)+ ∈ V by Line 5. Then, by Corollary 4, 〈l(v)+, l(v3)+, . . . , l(v′)+〉 is a path in (V,E). That is, c+ is reachable from p+.\n(ii) Let G = (V,E). Take a node c+ ∈ V \\{>}. Then, support(c+, G) = {a | (c+, a+,+) ∈ E} or support(c+, G) = {>}. Assume that support(c+, G) = {a | (c+, a+,+) ∈ E}. As c+ ∈ V \\{>}, there exists an atom vertex v ∈ V ′ such that l(v) = c. By Condition (iii) in Definition 3, there exists exactly one child v′ of v in 〈V ′, E′〉. Then, due to the condition at Line 9, for each a ∈ support(c+, G), (v′, v′′) ∈ E′ where v′′ ∈ V ′ with l(v′′) = a. Thus, B+(l(v′)) = support(c+, G). By Condition (ii) in Definition 2, H(l(v′)) = c and B+(l(v′)) ⊆ X . Hence, support(c+G) is an LCE of (X, ∅).\nCondition (4) We show that (V,E) is an offline e-graph of p+ with respect to X and ∅. By Condition (3) above, we know that (V,E) is an (X, ∅)-based e-graph of p+. Then, to show that (V,E) is an offline e-graph of p+ with respect to X and ∅, we need to show that (V,E) satisfies Conditions (i) and (ii) in Definition 13. As edges in E are formed at Lines 8 and 10, for every b ∈ V there are no edges in the form of (b, assume,+) and (b, assume,−) in E. Then, conditions are trivially satisfied."
    } ],
    "references" : [ {
      "title" : "Logic programming and negation: A survey",
      "author" : [ "APT K.R.", "BOL R.N." ],
      "venue" : "J. Log. Program. 19/20, 9–71.",
      "citeRegEx" : "R. and N.,? 1994",
      "shortCiteRegEx" : "R. and N.",
      "year" : 1994
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. BARAL" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "BARAL,? 2003",
      "shortCiteRegEx" : "BARAL",
      "year" : 2003
    }, {
      "title" : "A preliminary report on answering complex queries related to drug discovery using answer set programming",
      "author" : [ "O. BODENREIDER", "Z.H. COBAN", "M.C. DOGANAY", "E. ERDEM", "H. KOSUCU" ],
      "venue" : "Proc. of ALPSWS.",
      "citeRegEx" : "BODENREIDER et al\\.,? 2008",
      "shortCiteRegEx" : "BODENREIDER et al\\.",
      "year" : 2008
    }, {
      "title" : "Debugging logic programs under the answer set semantics",
      "author" : [ "M. BRAIN", "M.D. VOS" ],
      "venue" : "Proc. of ASP.",
      "citeRegEx" : "BRAIN and VOS,? 2005",
      "shortCiteRegEx" : "BRAIN and VOS",
      "year" : 2005
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. BREWKA", "T. EITER", "M. TRUSZCZYNSKI" ],
      "venue" : "Commun. ACM 54, 12, 92–103.",
      "citeRegEx" : "BREWKA et al\\.,? 2011",
      "shortCiteRegEx" : "BREWKA et al\\.",
      "year" : 2011
    }, {
      "title" : "New uses for old drugs",
      "author" : [ "C.R. CHONG", "D.J. SULLIVAN" ],
      "venue" : "Nature 448, 645–646.",
      "citeRegEx" : "CHONG and SULLIVAN,? 2007",
      "shortCiteRegEx" : "CHONG and SULLIVAN",
      "year" : 2007
    }, {
      "title" : "The Comparative Toxicogenomics Database: update 2011",
      "author" : [ "A.P. DAVIS", "B.L. KING", "S. MOCKUS", "C.G. MURPHY", "C. SARACENI-RICHARDS", "M. ROSENSTEIN", "T. WIEGERS", "C.J. MATTINGLY" ],
      "venue" : "Nucleic Acids Research 39, Database issue, D1067–D1072.",
      "citeRegEx" : "DAVIS et al\\.,? 2011",
      "shortCiteRegEx" : "DAVIS et al\\.",
      "year" : 2011
    }, {
      "title" : "Effective integration of declarative rules with external evaluations for Semantic-Web reasoning",
      "author" : [ "T. EITER", "G.IANNI", "R.SCHINDLAUER", "H.TOMPITS." ],
      "venue" : "Proc. of ESWC.",
      "citeRegEx" : "EITER et al\\.,? 2006",
      "shortCiteRegEx" : "EITER et al\\.",
      "year" : 2006
    }, {
      "title" : "Finding answers and generating explanations for complex biomedical queries",
      "author" : [ "E. ERDEM", "Y. ERDEM", "H. ERDOGAN", "U. OZTOK" ],
      "venue" : "Proc. of AAAI.",
      "citeRegEx" : "ERDEM et al\\.,? 2011",
      "shortCiteRegEx" : "ERDEM et al\\.",
      "year" : 2011
    }, {
      "title" : "BIOQUERY-ASP: Querying biomedical ontologies using answer set programming",
      "author" : [ "E. ERDEM", "H. ERDOGAN", "U. OZTOK" ],
      "venue" : "Proc. of RuleML2011@BRF Challenge.",
      "citeRegEx" : "ERDEM et al\\.,? 2011",
      "shortCiteRegEx" : "ERDEM et al\\.",
      "year" : 2011
    }, {
      "title" : "Transforming controlled natural language biomedical queries into answer set programs",
      "author" : [ "E. ERDEM", "R. YENITERZI" ],
      "venue" : "Proc. of the Workshop on BioNLP. 117–124.",
      "citeRegEx" : "ERDEM and YENITERZI,? 2009",
      "shortCiteRegEx" : "ERDEM and YENITERZI",
      "year" : 2009
    }, {
      "title" : "Weight constraints as nested expressions",
      "author" : [ "P. FERRARIS", "V. LIFSCHITZ" ],
      "venue" : "Theory and Practice of Logic Programming 5, 45–74.",
      "citeRegEx" : "FERRARIS and LIFSCHITZ,? 2005",
      "shortCiteRegEx" : "FERRARIS and LIFSCHITZ",
      "year" : 2005
    }, {
      "title" : "Advances in gringo series 3",
      "author" : [ "M. GEBSER", "R. KAMINSKI", "A. KOENIG", "T. SCHAUB" ],
      "venue" : "Proc of. LPNMR. Vol. 6645. 345–351.",
      "citeRegEx" : "GEBSER et al\\.,? 2011",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2011
    }, {
      "title" : "clasp: A conflict-driven answer set solver",
      "author" : [ "M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB" ],
      "venue" : "Proc. of LPNMR. 260–265.",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "A meta-programming technique for debugging answer-set programs",
      "author" : [ "M. GEBSER", "J. PUEHRER", "T. SCHAUB", "H. TOMPITS" ],
      "venue" : "Proc. of AAAI.",
      "citeRegEx" : "GEBSER et al\\.,? 2008",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2008
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A.V. GELDER", "K.A. ROSS", "J.S. SCHLIPF" ],
      "venue" : "J. ACM 38, 3, 620–650.",
      "citeRegEx" : "GELDER et al\\.,? 1991",
      "shortCiteRegEx" : "GELDER et al\\.",
      "year" : 1991
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proc. of ICLP. MIT Press, 1070–1080.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "New Generation Computing 9, 365–385.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1991",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1991
    }, {
      "title" : "Born again",
      "author" : [ "T. GOWER" ],
      "venue" : "Proto Magazine Summer, 14–19.",
      "citeRegEx" : "GOWER,? 2009",
      "shortCiteRegEx" : "GOWER",
      "year" : 2009
    }, {
      "title" : "A side effect resource to capture phenotypic effects of drugs",
      "author" : [ "M. KUHN", "M. CAMPILLOS", "I. LETUNIC", "L.J. JENSEN", "P. BORK" ],
      "venue" : "Molecular Systems Biology 6, 343.",
      "citeRegEx" : "KUHN et al\\.,? 2010",
      "shortCiteRegEx" : "KUHN et al\\.",
      "year" : 2010
    }, {
      "title" : "Answer set programming and plan generation",
      "author" : [ "V. LIFSCHITZ" ],
      "venue" : "Artificial Intelligence 138, 39–54.",
      "citeRegEx" : "LIFSCHITZ,? 2002",
      "shortCiteRegEx" : "LIFSCHITZ",
      "year" : 2002
    }, {
      "title" : "What is answer set programming? In Proc",
      "author" : [ "V. LIFSCHITZ" ],
      "venue" : "of AAAI. MIT Press, 1594–1597.",
      "citeRegEx" : "LIFSCHITZ,? 2008",
      "shortCiteRegEx" : "LIFSCHITZ",
      "year" : 2008
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. MAREK", "M. TRUSZCZYŃSKI" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375– 398.",
      "citeRegEx" : "MAREK and TRUSZCZYŃSKI,? 1999",
      "shortCiteRegEx" : "MAREK and TRUSZCZYŃSKI",
      "year" : 1999
    }, {
      "title" : "From pharmacogenomic knowledge acquisition to clinical applications: the PharmGKB as a clinical pharmacogenomic biomarker resource",
      "author" : [ "E.M. MCDONAGH", "M. WHIRL-CARRILLO", "Y. GARTEN", "R.B. ALTMAN", "T.E. KLEIN" ],
      "venue" : "Biomarkers in Medicine 5, 6, 795–806.",
      "citeRegEx" : "MCDONAGH et al\\.,? 2011",
      "shortCiteRegEx" : "MCDONAGH et al\\.",
      "year" : 2011
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. NIEMELÄ" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 241–273.",
      "citeRegEx" : "NIEMELÄ,? 1999",
      "shortCiteRegEx" : "NIEMELÄ",
      "year" : 1999
    }, {
      "title" : "An A-Prolog decision support system for the space shuttle",
      "author" : [ "M. NOGUEIRA", "M. BALDUCCINI", "M. GELFOND", "R. WATSON", "M. BARRY" ],
      "venue" : "Proc. of PADL. Springer, 169–183.",
      "citeRegEx" : "NOGUEIRA et al\\.,? 2001",
      "shortCiteRegEx" : "NOGUEIRA et al\\.",
      "year" : 2001
    }, {
      "title" : "Catching the ouroboros: On debugging nonground answer-set programs",
      "author" : [ "J. OETSCH", "J. PUEHRER", "H. TOMPITS" ],
      "venue" : "TPLP 10, 4-6, 513–529.",
      "citeRegEx" : "OETSCH et al\\.,? 2010",
      "shortCiteRegEx" : "OETSCH et al\\.",
      "year" : 2010
    }, {
      "title" : "Stepping through an answer-set program",
      "author" : [ "J. OETSCH", "J. PUEHRER", "H. TOMPITS" ],
      "venue" : "LPNMR. 134–147.",
      "citeRegEx" : "OETSCH et al\\.,? 2011",
      "shortCiteRegEx" : "OETSCH et al\\.",
      "year" : 2011
    }, {
      "title" : "Generating explanations for complex biomedical queries",
      "author" : [ "U. OZTOK" ],
      "venue" : null,
      "citeRegEx" : "OZTOK,? \\Q2012\\E",
      "shortCiteRegEx" : "OZTOK",
      "year" : 2012
    }, {
      "title" : "Justifications for logic programs under answer set semantics",
      "author" : [ "E. PONTELLI", "T.C. SON", "O. EL-KHATIB" ],
      "venue" : "Theory and Practice of Logic Programming, 1–56.",
      "citeRegEx" : "PONTELLI et al\\.,? 2009",
      "shortCiteRegEx" : "PONTELLI et al\\.",
      "year" : 2009
    }, {
      "title" : "Team-building with answer set programming in the Gioia-Tauro seaport",
      "author" : [ "F. RICCA", "G. GRASSO", "M. ALVIANO", "M. MANNA", "V. LIO", "S. IIRITANO", "N. LEONE" ],
      "venue" : "Theory and Practice of Logic Programming 12.",
      "citeRegEx" : "RICCA et al\\.,? 2012",
      "shortCiteRegEx" : "RICCA et al\\.",
      "year" : 2012
    }, {
      "title" : "Disease Ontology: a backbone for disease semantic integration",
      "author" : [ "L.M. SCHRIML", "C. ARZE", "S. NADENDLA", "CHANG", "Y.-W.W.", "M. MAZAITIS", "V. FELIX", "G. FENG", "W.A. KIBBE" ],
      "venue" : "Nucleic Acids Research 40, Database issue, D940–D946.",
      "citeRegEx" : "SCHRIML et al\\.,? 2012",
      "shortCiteRegEx" : "SCHRIML et al\\.",
      "year" : 2012
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. SIMONS", "I. NIEMELÄ", "T. SOININEN" ],
      "venue" : "Artificial Intelligence 138, 181–234.",
      "citeRegEx" : "SIMONS et al\\.,? 2002",
      "shortCiteRegEx" : "SIMONS et al\\.",
      "year" : 2002
    }, {
      "title" : "BioGRID: a general repository for interaction datasets",
      "author" : [ "C. STARK", "BREITKREUTZ", "B.-J.", "T. REGULY", "L. BOUCHER", "A. BREITKREUTZ", "M. TYERS" ],
      "venue" : "Nucleic Acids Research 34, Database issue, D535–D539.",
      "citeRegEx" : "STARK et al\\.,? 2006",
      "shortCiteRegEx" : "STARK et al\\.",
      "year" : 2006
    }, {
      "title" : "Debugging inconsistent answer set programs",
      "author" : [ "T. SYRJANEN" ],
      "venue" : "Proc. of NMR.",
      "citeRegEx" : "SYRJANEN,? 2006",
      "shortCiteRegEx" : "SYRJANEN",
      "year" : 2006
    }, {
      "title" : "A practical tool for mass-customising configurable products",
      "author" : [ "J. TIIHONEN", "T. SOININEN", "R. SULONEN" ],
      "venue" : "Proc. of the International Conference on Engineering Design. 1290– 1299.",
      "citeRegEx" : "TIIHONEN et al\\.,? 2003",
      "shortCiteRegEx" : "TIIHONEN et al\\.",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : ", representing complex queries in natural language and finding answers to queries efficiently), novel methods and a software system, called BIOQUERY-ASP (Erdem et al. 2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al.",
      "startOffset" : 153,
      "endOffset" : 172
    }, {
      "referenceID" : 20,
      "context" : "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):",
      "startOffset" : 73,
      "endOffset" : 180
    }, {
      "referenceID" : 1,
      "context" : "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):",
      "startOffset" : 73,
      "endOffset" : 180
    }, {
      "referenceID" : 21,
      "context" : "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):",
      "startOffset" : 73,
      "endOffset" : 180
    }, {
      "referenceID" : 4,
      "context" : "2011) (Figure 1), have been developed using Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011):",
      "startOffset" : 73,
      "endOffset" : 180
    }, {
      "referenceID" : 10,
      "context" : "• Erdem and Yeniterzi (Erdem and Yeniterzi 2009) developed a controlled natural language, BIOQUERY-CNL, for expressing biomedical queries related to drug discovery.",
      "startOffset" : 22,
      "endOffset" : 48
    }, {
      "referenceID" : 2,
      "context" : "(Bodenreider et al. 2008) introduced methods to extract biomedical information from various knowledge resources and integrate them by a rule layer.",
      "startOffset" : 0,
      "endOffset" : 25
    }, {
      "referenceID" : 8,
      "context" : "(Erdem et al. 2011) have introduced an algorithm for query answering by identifying the relevant parts of the rule layer and the knowledge resources with respect to a given query.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 23,
      "context" : "Next, Section 7 illustrates the usefulness of these algorithms on some complex queries over the biomedical knowledge resources PHARMGKB (McDonagh et al. 2011), DRUGBANK (Knox et al.",
      "startOffset" : 136,
      "endOffset" : 158
    }, {
      "referenceID" : 33,
      "context" : "BIOGRID (Stark et al. 2006), CTD (Davis et al.",
      "startOffset" : 8,
      "endOffset" : 27
    }, {
      "referenceID" : 6,
      "context" : "2006), CTD (Davis et al. 2011), SIDER (Kuhn et al.",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 19,
      "context" : "2011), SIDER (Kuhn et al. 2010), DISEASE ONTOLOGY (Schriml et al.",
      "startOffset" : 13,
      "endOffset" : 31
    }, {
      "referenceID" : 31,
      "context" : "2010), DISEASE ONTOLOGY (Schriml et al. 2012) and ORPHADATA.",
      "startOffset" : 24,
      "endOffset" : 45
    }, {
      "referenceID" : 29,
      "context" : "In Section 10, we provide a detailed analysis of the related work on “justifications” (Pontelli et al. 2009) in comparison to explanations; and in Section 11, we briefly discuss other related work.",
      "startOffset" : 86,
      "endOffset" : 108
    }, {
      "referenceID" : 20,
      "context" : "Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.",
      "startOffset" : 29,
      "endOffset" : 136
    }, {
      "referenceID" : 1,
      "context" : "Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.",
      "startOffset" : 29,
      "endOffset" : 136
    }, {
      "referenceID" : 21,
      "context" : "Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.",
      "startOffset" : 29,
      "endOffset" : 136
    }, {
      "referenceID" : 4,
      "context" : "Answer Set Programming (ASP) (Marek and Truszczyński 1999; Niemelä 1999; Lifschitz 2002; Baral 2003; Lifschitz 2008; Brewka et al. 2011) is a form of declarative programming paradigm oriented towards solving combinatorial search problems as well as knowledge-intensive problems.",
      "startOffset" : 29,
      "endOffset" : 136
    }, {
      "referenceID" : 16,
      "context" : "The idea is to represent a problem as a “program” whose models (called “answer sets” (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions.",
      "startOffset" : 85,
      "endOffset" : 141
    }, {
      "referenceID" : 17,
      "context" : "The idea is to represent a problem as a “program” whose models (called “answer sets” (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991)) correspond to the solutions.",
      "startOffset" : 85,
      "endOffset" : 141
    }, {
      "referenceID" : 13,
      "context" : "ASP also provides efficient solvers, such as CLASP (Gebser et al. 2007).",
      "startOffset" : 51,
      "endOffset" : 71
    }, {
      "referenceID" : 25,
      "context" : "Here are, for instance, three applications of ASP used in industry: • Decision Support Systems: An ASP-based system was developed to help flight controllers of space shuttle solve some planning and diagnostic tasks (Nogueira et al. 2001) (used by United Space Alliance).",
      "startOffset" : 215,
      "endOffset" : 237
    }, {
      "referenceID" : 35,
      "context" : "• Automated Product Configuration: A web-based commercial system uses an ASPbased product configuration technology (Tiihonen et al. 2003) (used by Variantum Oy).",
      "startOffset" : 115,
      "endOffset" : 137
    }, {
      "referenceID" : 30,
      "context" : ", skills, fairness, regulations (Ricca et al. 2012) (used by Gioia Tauro seaport).",
      "startOffset" : 32,
      "endOffset" : 51
    }, {
      "referenceID" : 21,
      "context" : "The idea of ASP (Lifschitz 2008) is to represent a computational problem as a program whose answer sets correspond to the solutions of the problem, and to find the answer sets for that program using an answer set solver.",
      "startOffset" : 16,
      "endOffset" : 32
    }, {
      "referenceID" : 32,
      "context" : "(called cardinality expressions) where each Ai is an atom and l and u are nonnegative integers denoting the “lower bound” and the “upper bound” (Simons et al. 2002).",
      "startOffset" : 144,
      "endOffset" : 164
    }, {
      "referenceID" : 11,
      "context" : "Programs using these constructs can be viewed as abbreviations for normal nested programs defined in (Ferraris and Lifschitz 2005).",
      "startOffset" : 101,
      "endOffset" : 130
    }, {
      "referenceID" : 12,
      "context" : "For CLASP, we use the “grounder” GRINGO (Gebser et al. 2011).",
      "startOffset" : 40,
      "endOffset" : 60
    }, {
      "referenceID" : 8,
      "context" : "We have earlier developed the software system BIOQUERY-ASP (Erdem et al. 2011) (see Figure 1) to answer complex queries that require appropriate integration of relevant knowledge from different knowledge resources and auxiliary definitions such as chains of drugdrug interactions, cliques of genes based on gene-gene relations, or similar/diverse genes.",
      "startOffset" : 59,
      "endOffset" : 78
    }, {
      "referenceID" : 7,
      "context" : "If the biomedical ontology is in RDF(S)/OWL then we can extract such knowledge using the ASP solver DLVHEX (Eiter et al. 2006) by making use of external predicates.",
      "startOffset" : 107,
      "endOffset" : 126
    }, {
      "referenceID" : 5,
      "context" : "This type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer’s Viagra (Gower 2009).",
      "startOffset" : 69,
      "endOffset" : 94
    }, {
      "referenceID" : 18,
      "context" : "This type of queries might be important in terms of drug repurposing (Chong and Sullivan 2007) which has achieved a number of successes in drug development, including the famous example of Pfizer’s Viagra (Gower 2009).",
      "startOffset" : 205,
      "endOffset" : 217
    }, {
      "referenceID" : 8,
      "context" : "Once the query and the rule layer are in ASP, the parts of the rule layer that are relevant to the given query are identified by an algorithm (Erdem et al. 2011).",
      "startOffset" : 142,
      "endOffset" : 161
    }, {
      "referenceID" : 29,
      "context" : "The most similar work to ours is (Pontelli et al. 2009) that study the question “why is an atom p in an answer set X for an ASP program Π”.",
      "startOffset" : 33,
      "endOffset" : 55
    }, {
      "referenceID" : 29,
      "context" : "As an answer to this question, the authors of (Pontelli et al. 2009) finds a “justification”, which is a labeled graph that provides an explanation for the truth values of atoms with respect to an answer set.",
      "startOffset" : 46,
      "endOffset" : 68
    }, {
      "referenceID" : 29,
      "context" : "To relate offline justifications and explanations, we need to introduce the following definitions and notations about justifications defined in (Pontelli et al. 2009).",
      "startOffset" : 144,
      "endOffset" : 166
    }, {
      "referenceID" : 29,
      "context" : "First, let us introduce notations related to ASP programs used in (Pontelli et al. 2009).",
      "startOffset" : 66,
      "endOffset" : 88
    }, {
      "referenceID" : 15,
      "context" : "Apart from the answer set semantics, there is another important semantics of logic programs, called the well-founded semantics (Gelder et al. 1991).",
      "startOffset" : 127,
      "endOffset" : 147
    }, {
      "referenceID" : 15,
      "context" : "We consider the definition proposed in (Apt and Bol 1994), instead of the original definition proposed in (Gelder et al. 1991), as the authors of (Pontelli et al.",
      "startOffset" : 106,
      "endOffset" : 126
    }, {
      "referenceID" : 29,
      "context" : "1991), as the authors of (Pontelli et al. 2009) considered.",
      "startOffset" : 25,
      "endOffset" : 47
    }, {
      "referenceID" : 29,
      "context" : "In (Pontelli et al. 2009), the authors prove the following proposition which shows that for every atom in the program, there exists an offline justification.",
      "startOffset" : 3,
      "endOffset" : 25
    }, {
      "referenceID" : 34,
      "context" : "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al.",
      "startOffset" : 13,
      "endOffset" : 28
    }, {
      "referenceID" : 14,
      "context" : "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set.",
      "startOffset" : 84,
      "endOffset" : 124
    }, {
      "referenceID" : 26,
      "context" : "Among those, (Syrjanen 2006) studies why a program does not have an answer set, and (Gebser et al. 2008; Oetsch et al. 2010) studies why a set of atoms is not an answer set.",
      "startOffset" : 84,
      "endOffset" : 124
    }, {
      "referenceID" : 3,
      "context" : "In (Brain and Vos 2005), similar to our work, the question “why is an atom p in an answer set X for an ASP program Π” is studied.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 3,
      "context" : "As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in Π that supports X with respect to Π; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules).",
      "startOffset" : 46,
      "endOffset" : 66
    }, {
      "referenceID" : 27,
      "context" : "In (Oetsch et al. 2011), a framework where the users can construct interpretations through an interactive stepping process is introduced.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 29,
      "context" : "As a result, (Pontelli et al. 2009) and (Oetsch et al.",
      "startOffset" : 13,
      "endOffset" : 35
    }, {
      "referenceID" : 27,
      "context" : "2009) and (Oetsch et al. 2011) can be used together to provide the users with justifications of the truth values of atoms during the construction of interpretations interactively through stepping.",
      "startOffset" : 10,
      "endOffset" : 30
    }, {
      "referenceID" : 3,
      "context" : "In (Brain and Vos 2005), similar to our work, the question “why is an atom p in an answer set X for an ASP program Π” is studied. As an answer to this question, the authors of (Brain and Vos 2005) provide the rule in Π that supports X with respect to Π; whereas we compute shortest or k different explanations (as a tree whose vertices are labeled by rules). Pontelli et al. (2009) also introduce the notion of an online justification that aims to justify the truth values of atoms during the computation of an answer set.",
      "startOffset" : 4,
      "endOffset" : 382
    } ],
    "year" : 2013,
    "abstractText" : "We introduce novel mathematical models and algorithms to generate (shortest or k different) explanations for biomedical queries, using answer set programming. We implement these algorithms and integrate them in BIOQUERY-ASP. We illustrate the usefulness of these methods with some complex biomedical queries related to drug discovery, over the biomedical knowledge resources PHARMGKB, DRUGBANK, BIOGRID, CTD, SIDER, DISEASE ONTOLOGY and ORPHADATA.",
    "creator" : "LaTeX with hyperref package"
  }
}