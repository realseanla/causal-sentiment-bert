{
  "name" : "1606.07516.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Epistemic Protocols for Distributed Gossiping",
    "authors" : [ "Krzysztof R. Apt", "Davide Grossi", "Wiebe van der Hoek" ],
    "emails" : [ "k.r.apt@cwi.nl", "d.grossi@liv.ac.uk", "wiebe@liv.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "R. Ramanujam (Ed.): TARK 2015 EPTCS 215, 2016, pp. 51–66, doi:10.4204/EPTCS.215.5\nc© K. Apt, D. Grossi & W. van der Hoek This work is licensed under the Creative Commons Attribution License.\nEpistemic Protocols for Distributed Gossiping\nKrzysztof R. Apt Centrum Wiskunde Informatica\nAmsterdam, The Netherlands\nk.r.apt@cwi.nl\nDavide Grossi Wiebe van der Hoek University of Liverpool\nLiverpool, UK\nd.grossi@liv.ac.uk wiebe@liv.ac.uk\nGossip protocols aim at arriving, by means of point-to-point or group communications, at a situation in which all the agents know each other’s secrets. We consider distributed gossip protocols which are expressed by means of epistemic logic. We provide an operational semantics of such protocols and set up an appropriate framework to argue about their correctness. Then we analyze specific protocols for complete graphs and for directed rings."
    }, {
      "heading" : "1 Introduction",
      "text" : "In the gossip problem ([18, 4], see also [10] for an overview) a number n of agents, each one knowing a piece of information (a secret) unknown to the others, communicate by one-to-one interactions (e.g., telephone calls). The result of each call is that the two agents involved in it learn all secrets the other agent knows at the time of the call. The problem consists in finding a sequence of calls which disseminates all the secrets among the agents in the group. It sparked a large literature in the 70s and 80s [18, 4, 9, 5, 17] typically focusing on establishing—in the above and other variants of the problem—the minimum number of calls to achieve dissemination of all the secrets. This number has been proven to be 2n− 4, where n, the number of agents, is at least 4.\nThe above literature assumes a centralized perspective on the gossip problem: a planner schedules agents’ calls. In this paper we pursue a line of research first put forth in [3] by developing a decentralized theory of the gossip problem, where agents perform calls not according to a centralized schedule, but following individual epistemic protocols they run in a distributed fashion. These protocols tell the agents which calls to execute depending on what they know, or do not know, about the information state of the agents in the group. We call the resulting distributed programs (epistemic) gossip protocols.\nContribution of the paper and outline The paper introduces a formal framework for specifying epistemic gossip protocols and for studying their computations in terms of correctness, termination, and fair termination (Section 2). It then defines and studies two natural protocols in which the interactions are unconstrained (Section 3) and four example gossip protocols in which agents are positioned on a directed ring and calls can happen only between neighbours (Section 4). Proofs are collected in the appendix.\nFrom a methodological point of view, the paper integrates concepts and techniques from the distributed computing, see, e.g., [1, Chapter 11] and the epistemic logic literature [8, 15] in the tradition of [16, 14, 7]."
    }, {
      "heading" : "2 Gossip protocols",
      "text" : "We introduce first the syntax and semantics of gossip protocols."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "We loosely use the syntax of the language CSP (Communicating Sequential Processes) of [11] that extends the guarded command language of [6] by disjoint parallel composition and commands for synchronous communication. CSP was realized in the distributed programming language OCCAM (see INMOS [12]).\nThe main difference is that we use as guards epistemic formulas and as communication primitives calls that do not require synchronization. Also, the syntax of our distributed programs is very limited. In order to define gossip protocols we introduce in turn calls and epistemic guards.\nThroughout the paper we assume a fixed finite set A of at least three agents. We assume that each agent holds exactly one secret and that there exists a bijection between the set of agents and the set of secrets. We denote by P the set of all secrets (for propositions). Furthermore, it is assumed that each secret carries information identifying the agent to whom that secret belongs."
    }, {
      "heading" : "2.1.1 Calls",
      "text" : "Each call concerns two agents, the caller (a below) and the agent called (b). We distinguish three modes of communication of a call:\npush-pull, written as ab or (a,b). During this call the caller and the called agent learn each other’s secrets,\npush, written as a⊲b. After this call the called agent learns all the secrets held by the caller,\npull, written as a⊳b. After this call the caller learns all the secrets held by the called agent.\nVariables for calls are denoted by c, d. Abusing notation we write a ∈ c to denote that agent a is one of the two agents involved in the call c (e.g., for c := ab we have a ∈ c and b ∈ c). Calls in which agent a is involved are denoted by ca."
    }, {
      "heading" : "2.1.2 Epistemic guards",
      "text" : "Epistemic guards are defined as formulas in a simple modal language with the following grammar:\nφ ::= Fa p | ¬φ | φ ∧φ | Kaφ ,\nwhere p ∈ P and a ∈ A. Each secret is viewed as a distinct symbol. We denote the secret of agent a by A, the secret of agent b by B and so on. We denote the set of so defined formulas by L and we refer to its members as epistemic formulas or epistemic guards. We read Fa p as ‘agent a is familiar with the secret p’ (or ‘p belongs to the set of secrets a knows about’) and Kaφ as ‘agent a knows that formula φ is true’. So this language is an epistemic language where atoms consist of ‘knowing whether’ statements about propositional atoms, if we view secrets as Boolean variables.\nAtomic expressions in L concern only who knows what secrets. As a consequence the language cannot express formally the truth of a secret p. This level of abstraction suffices for the purposes of the current paper. However, expressions Fa p could be given a more explicit epistemic reading in terms of ‘knowing whether’. That is, ‘a is familiar with p’ can be interpreted (on a suitable Kripke model) as ‘a knows whether the secret p is true or not’. This link is established in [3]."
    }, {
      "heading" : "2.1.3 Gossip protocols",
      "text" : "Before specifying what a program for agent a is, let us first define the language La with the following grammar:\nψ ::= Kaφ | ¬ψ | ψ ∧ψ\nwith φ ∈ L .1 By a component program, in short a program, for an agent a we mean a statement of the form\n∗[[]mj=1 ψ j → c j],\nwhere m > 0 and each ψ j → c j is such that ψ j ∈ La and a is the caller in c j. Given an epistemic formula ψ ∈ La and a call c, we call the construct ψ → c a rule and refer in this context to ψ as a guard. We denote the set of rules {ψ1 → c1, . . .,ψk → ck} as [[]kj=1 ψ j → c j] and abbreviate a set of rules {ψ1 → c, . . .,ψk → c} with the same call to a single rule ∨k\ni=1 ψi → c. Intuitively, ∗ denotes a repeated execution of the rules, one at a time, where each time a rule is selected whose guard is true. Finally, by a distributed epistemic gossip protocol, in short a gossip protocol, we mean a parallel composition of component programs, one for each agent. In order not to complicate matters we assume that each gossip protocol uses only one mode of communication.\nOf special interest for this paper are gossip protocols that are symmetric. By this we mean that the protocol is a composition of the component programs that are identical modulo the names of the agents. Formally, consider a statement π(x), where x is a variable ranging over the set A of agents and such that for each agent a ∈ A, π(a) is a component program for agent a. Then the parallel composition of the π(a) programs, where a ∈ A, is called a symmetric gossip protocol.\nGossip protocols are syntactically extremely simple. Therefore it would seem that little can be expressed using them. However, this is not the case. In Sections 3 and 4 we consider gossip protocols that can exhibit complex behaviour."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "We now move on to provide a formal semantics of epistemic guards, and then describe the computations of gossip protocols."
    }, {
      "heading" : "2.2.1 Gossip situations and calls",
      "text" : "A gossip situation is a sequence s = (Qa)a∈A, where Qa ⊆P for each agent a. Intuitively, Qa is the set of secrets a is familiar with in situation s. The initial gossip situation is the one in which each Qa equals {A} and is denoted by root. The set of all gossip situations is denoted by S. We say that an agent a is an expert in a gossip situation s if he is familiar in s with all the secrets, i.e., if Qa = P. The initial gossip situation reflects the fact that initially each agent is familiar only with his own secret, although it is not assumed this is common knowledge among the agents. In fact, in the introduced language we have no means to express the concept of common knowledge.\n1Alternatively, La could be defined as the fragment of L consisting of the formulae of form Kaψ . In logic S5, it is easy to prove that each ψ ∈ La is logically equivalent to a formula Kaφ ∈ L .\nWe will use the following concise notation for gossip situations. Sets of secrets will be written down as lists. e.g., the set {A,B,C} will be written as ABC. Gossip situations will be written down as lists of lists of secrets separated by dots. E.g., if there are three agents, root = A.B.C and the situation ({A,B},{A,B},{C}) will be written as AB.AB.C.\nEach call transforms the current gossip situation by modifying the set of secrets the agents involved in the call are familiar with. More precisely, the application of a call to a situation is defined as follows.\nDefinition 2.1 (Effects of calls) A call is a function c : S−→ S, so defined, for s := (Qa)a∈A:\nc= ab c(s) = (Q′a)a∈A, where Q ′ a = Q ′ b = Qa ∪Qb, Q ′ c = Qc, for c 6= a,b;\nc= a⊲b c(s) = (Q′a)a∈A, where Q ′ b = Qa ∪Qb, Q ′ a = Qa, Q ′ c = Qc, for c 6= a,b;\nc= a⊳b c(s) = (Q′a)a∈A, where Q ′ a = Qa ∪Qb, Q ′ b = Qb, Q ′ c = Qc, for c 6= a,b.\nThe definition formalizes the modes of communications we introduced earlier. Depending on the mode, secrets are either shared between caller and callee (ab), they are pushed from the caller to the callee (a⊲b), or they are retrieved by the caller from the callee (a⊳b)."
    }, {
      "heading" : "2.2.2 Call sequences",
      "text" : "A call sequence is a (possibly infinite) sequence of calls, in symbols (c1,c2, . . . ,cn, . . .), all being of the same communication mode. The empty sequence is denoted by ε . We use c to denote a call sequence and C to denote the set of all call sequences. The set of all finite call sequences is denoted C<ω . Given a finite call sequence c and a call c we denote by c.c the prepending of c with c, and by c.c the postpending of c with c.\nThe result of applying a call sequence to a situation s is defined by induction using Definition 2.1, as follows: [Base] ε(s) := s, [Step] (c.c)(s) := c(c(s)).\nExample 2.2 Let the set of agents be {a,b,c}.\nab ca ab\nA.B.C AB.AB.C ABC.AB.ABC ABC.ABC.ABC\nThe top row lists the call sequence (ab,ca,ab), while the bottom row lists the successive gossip situations obtained from the initial situation A.B.C by applying the calls in the sequence: first ab, then ca and finally ab. ✷\nBy applying an infinite call sequence c = (c1,c2, . . . ,cn, . . .) to a gossip situation s one obtains therefore an infinite sequence c0(s),c1(s), . . . ,cn(s), . . . of gossip situations, where each ck is sequence c1,c2, . . . ,ck. A call sequence c is said to converge if for all input gossip situations s the generated sequence of gossip situations reaches a limit, that is, there exists n < ω such that for all m ≥ n cm(s) = cm+1(s). Since the set of secrets is finite and calls never make agents forget secrets they are familiar with, it is easy to see the following.\nFact 2.3 All infinite call sequences converge.\nHowever, as we shall see, this does not imply that all gossip protocols terminate. In the remainder of the paper, unless stated otherwise, we will assume the push-pull mode of communication. The reader can easily adapt our presentation to the other modes."
    }, {
      "heading" : "2.2.3 Gossip models",
      "text" : "The set S of all gossip situations is the set of all possible combinations of secret distributions among the agents. As calls progress in sequence from the initial situation, agents may be uncertain about which one of such secrets distributions is the actual one. This uncertainty is precisely the object of the epistemic language for guards we introduced earlier.\nDefinition 2.4 A gossip model (for a given set A) is a tuple M = (C<ω ,{∼a}a∈A), where each ∼a⊆ C<ω ×C<ω is the smallest relation satisfying the following inductive conditions (assume the mode of communication is push-pull):\n[Base] ε ∼a ε; [Step] Suppose c ∼a d.\n(i) If a 6∈ c, then c.c∼a d and c ∼a d.c. (ii) If there exists b ∈ A and c,d ∈ {ab,ba} such that c.c(root)a = d.d(root)a, then c.c∼a d.d.\nA gossip model with a designated finite call sequence is called a pointed gossip model. For the push, respectively pull, modes of communication clause (ii) needs to be modified by requiring that for some b ∈ A, c= d= a⊲b or c= d= a⊳b, respectively.\nFor instance, by (i) we have ab,bc∼a ab,bd. But we do not have bc,ab∼a bd,ab since (bc,ab)(root)a = ABC 6= ABD = (bd,ab)(root)a.\nLet us flesh out the intuitions behind the above definition. Gossip models are needed in order to interpret the epistemic guards of gossip protocols. Since such guards are relevant only after finite sequences of calls, the domain of a gossip model is taken to consist only of finite sequences. Intuitively, those are the finite sequences that can be generated by a gossip protocol. Let us turn now to the ∼a relation. This is defined with the following intuitions in mind. First of all, no agent can distinguish the empty call sequence from itself—this is the base of the induction. Next, if two call sequences are indistinguishable for a, then the same is the case if (i) we extend one of these sequences by a call in which a is not involved or if (ii) we extend each of these sequences by a call of a with the same agent (agent a may be the caller or the callee), provided a is familiar with exactly the same secrets after each of the new sequences has taken place—this is the induction step.2\nThe above intuitions are based on the following assumptions on the form of communication we presuppose: (i) At the initial situation, as communication starts, each agent knows only her own secret but considers it possible that the others may be familiar with all other secrets. In other words there is no such thing as common knowledge of the fact that ‘everybody knows exactly her own secret’. (ii) In general, each agent always considers it possible that call sequences (of any length) take place that do not involve her. These assumptions are weaker than the ones analyzed in [3].\nWe state without proof the following simple fact. Fact 2.5\n(i) Each ∼a is an equivalence relation;\n(ii) For all c,d ∈ C if c ∼a d, then c(root)a = d(root)a, but not vice versa. This prompts us to note also that according to Definition 2.4 sequences which make a learn the same set of secrets may well be distinguishable for a, such as, for instance, ab,bc,ab and ab,bc,ac. In the first one a comes to know that b knows a is familiar with all secrets, while in the second one, she comes to know that c knows a is familiar with all secrets. Relation ∼a is so defined as to capture this sort of ‘higher-order’ knowledge.\n2Notice that the definition requires a designated initial situation, which we assume to be root."
    }, {
      "heading" : "2.2.4 Truth conditions for epistemic guards",
      "text" : "Everything is now in place to define the truth of the considered formulas.\nDefinition 2.6 Let (M ,c) be a pointed gossip model with M = (C<ω ,(∼a)a∈A) and c∈C<ω . We define the satisfaction relation |= inductively as follows (clauses for Boolean connectives are omitted):\n(M ,c) |= Fa p iff p ∈ c(root)a,\n(M ,c) |= Kaφ iff ∀d s.t. c ∼a d, (M ,d) |= φ .\nSo formula Fa p is true (in a pointed gossip model) whenever secret p belongs to the set of secrets agent a is familiar with in the situation generated by the designated call sequence c applied to the initial situation root. The knowledge operator is interpreted as customary in epistemic logic using the equivalence relations ∼a."
    }, {
      "heading" : "2.2.5 Computations",
      "text" : "Assume a gossip protocol P that is a parallel composition of the component programs ∗[[]maj=1 ψaj → caj ], one for each agent a ∈ A.\nGiven the gossip model M = (C<ω ,{∼a}a∈A) we define the computation tree C P ⊆ C<ω of P as\nthe smallest set of sequences satisfying the following inductive conditions:\n[Base] ε ∈ CP;\n[Step] If c ∈ CP and (M ,c) |= ψaj then c.caj ∈ CP. In this case we say that a transition has taken place between c and c.caj , in symbols, c → c.c a j .\nSo CP is a (possibly infinite) set of finite call sequences that is iteratively obtained by performing a ‘legal’ call (according to protocol P) from a ‘legal’ (according to protocol P) call sequence.\nA path in the computation tree of P is a (possibly infinite) sequence of elements of CP, denoted by ξ = (c0,c1, . . . ,cn, . . .), where c0 = ε and each ci+1 = ci.c for some call c and i ≥ 0. A computation of P is a maximal rooted path in the computation tree of P.3\nThe above definition implies that a call sequence c is a leaf of the computation tree if and only if\n(M ,c) |= ∧\na∈A\nma∧\nj=1\n¬ψaj .\nWe call the formula ∧\na∈A\nma∧\nj=1\n¬ψaj\nthe exit condition of the gossip protocol P.\nObviously computation trees can be infinite, though they are always finitely branching. Further, note that this semantics for gossip protocols abstracts away from some implementation details of the calls. More specifically, we assume that the caller always succeeds in his call and does not require to synchronize with the called agent. In reality, the called agent might be busy, being engaged in another\n3Note that while the sequences that are elements of the computation tree of a protocol are always finite (although possibly infinite in number), computations can be infinite sequences (of finite call sequences).\ncall. To take care of this one could modify each call by replacing it by a ‘call protocol’ that implements the actual call using some lower level primitives. We do not elaborate further on this topic.\nLet us fix some more terminology. For c ∈ CP, an agent a is enabled in c if (M ,c) |= ∨ma\nj=1 ψ a j and\nis disabled otherwise. So an agent is enabled if it can perform a call. An agent a is selected in c if it is the caller in the call that for some c′ determines the transition c → c′ in ξ . Finally, a computation ξ is called a fair computation if it is finite or each agent that is enabled in infinitely many sequences in ξ is selected in infinitely many sequences in ξ .\nWe note in passing that various alternative definitions of fairness are possible; we just focus on one of them. An interested reader may consult [2], where several fairness definitions (for instance one focusing on actions and not on agents) for distributed programs were considered and compared.\nWe conclude this section by observing the following. Our definition of computation tree for protocol P presupposes that guards ψaj are interpreted over the gossip model M = (C<ω ,{∼a}a∈A). This means that when evaluating guards, agents consider as possible call sequences that cannot be generated by P. In other words, agents do not know the protocol. To model common knowledge of the considered protocol in the gossip model one should take as the domain of the gossip model M the underlying computation tree. However, the computation tree is defined by means of the underlying gossip model. To handle such a circularity an appropriate fixpoint definition is needed. We leave this topic for future work."
    }, {
      "heading" : "2.3 Correctness",
      "text" : "We are interested in proving the correctness of gossip protocols. Assume a gossip protocol P that is a parallel composition of the component programs ∗[[]maj=1 ψaj → caj ].\nWe say that P is partially correct, in short correct, if in all situations sequences c that are leaves of the computation tree of P, for each agent a\n(M ,c) |= ∧\nb∈A\nFaB,\ni.e., if for all situations sequences c that are leaves of the computation tree of P, each agent is an expert in the gossip situation c(root).\nWe say furthermore that P terminates if all its computations are finite and that P fairly terminates if all its fair computations are finite.\nIn the next section we provide examples showing that partial correctness and termination of the considered protocols can depend on the assumed mode of communication and on the number of agents. In what follows we study various gossip protocols and their correctness. We begin with the following obvious observation.\nFact 2.7 For each protocol P the following implications (⇒) hold, where TP(x) stands for its termination and FTP(x) for its fair termination in a communication mode x:\nTP(x)⇒ FTP(x).\nProtocol R3 given in Section 4 shows that none of these implications can be reversed. Moreover, it is not the case either that for each protocol P:\nTP(⊲)⇒ TP(push-pull),\nTP(⊳)⇒ TP(push-pull).\nExample 2.8 Let A= {a,b,c} and define the following expression:\nA ⊂ C := ∧\nI∈{A,B,C}\n(FaI → FcI)∧ ∨\nI∈{A,B,C}\n(FcI∧¬FaI)\nExpression B ⊂ C is defined analogously. Note that we denote by I the secret of agent i. Intuitively, A ⊂ C means that agent c is familiar with all the secrets that agent a is familiar with, but not vice versa. So c is familiar with a strict superset of the secrets a is familiar with. Further, let Exp j stand for∧\nI∈{A,B,C} FjI. Consider now the following component programs:\n• for agent a: ∗[¬Ka(A ⊂ C )∧¬KaExpa → a⊲ c],\n• for agent b: ∗[¬Kb(B ⊂ C )∧¬KbExpb → b⊲ c],\n• for agent c: ∗[¬KcExpa ∧KcExpc → c⊲a []¬KcExpb ∧KcExpc → c⊲b].\nThis protocol is correct. Indeed, initially no agent is an expert, hence both guards of c are false. On the other hand, we have (M ,ε) |=¬(A ⊂C ) and (M ,ε) |=¬(B ⊂C ), so both (M ,ε) |=¬Ka(A ⊂C ) and (M ,ε) |= ¬Kb(B ⊂ C ). Consequently, initially both a and b are enabled. If the first call is granted to a, this agent will call c yielding the gossip situation A.B.AC. Now the guard of a is false (since a is still familiar only with his own secret A, while c is familiar with at least A and C and a knows this). The guard of c is still false. So now only b is enabled. After his call of c this yields the gossip situation A.B.ABC. At this stage, only agent c is enabled and after he calls both a and b all guards become false. Moreover, this protocol terminates. Indeed, the only computations are the ones in which first the calls a⊲c and b⊲c take place, in any order, followed by the calls c⊲a and c⊲b, also performed in any order.\nHowever, if we use the push-pull direction type instead of push, then the situation changes. Indeed, after an arbitrary number of calls ac the formula ¬(A ⊂ C ) is still true and hence ¬Ka(A ⊂ C ) is true, as well. Consequently, this call can be indefinitely repeated, so the protocol does not terminate. ✷"
    }, {
      "heading" : "3 Two symmetric protocols",
      "text" : "In this section we consider protocols for the case when the agents form a complete graph. We study two protocols. We present them first for the communication mode push-pull. (Partial) correctness of the considered protocols does not depend on the assumed mode of communication.\nLearn new secrets protocol (LNS) Consider the following program for agent i:\n∗[[] j∈A¬FiJ → (i, j)].\nInformally, agent i calls agent j if i is not familiar with j’s secret. Note that the guards of this protocol do not use the epistemic operator Ki, but they are equivalent to the ones that do, as ¬FiJ is equivalent to Ki¬FiJ.\nThis protocol was introduced in [3] and studied with respect to the push-pull mode, assuming asynchronous communication. As noted there this protocol is clearly correct. Also, it always terminates since after each call (i, j) the size of {(i, j) ∈ A×A | ¬FiJ} decreases. The same argument shows termination if the communication mode is pull.\nHowever, if the communication mode is push, the protocol may fail to terminate, even fairly. To see it fix an agent a and consider a sequence of calls in which each agent calls a. At the end of this sequence a\nbecomes an expert but nobody is familiar with his secret. So any extension of this sequence is an infinite computation.\nLet us consider now the possible call sequences generated by the computations of this protocol. Assume that there are n ≥ 4 agents. By the result mentioned in the introduction in each terminating computation at least 2n−4 calls are made.\nThe LNS protocol can generate such shortest sequences (among others). Indeed, let A = {a,b,c,d, i1, . . ., in−4} be the set of agents. Then the following sequence of 2n−4 calls\n(a, i1),(a, i2), . . .,(a, in−4), (a,b),(c,d),(a,c),(b,d), (i1,b),(i2,b), . . .,(in−4,b)\n(1)\ncorresponds to a terminating computation. The guards used in this protocol entail that after a call (i, j) neither the call ( j, i) nor another call (i, j) can take place, that is between each pair of agents at most one call can take place. Consequently, the longest possible sequence contains at most n(n−1)2 calls. Such a worst case can be generated by means of the following sequence of calls:\n[2], [3], [4], . . ., [n],\nwhere for a natural number k, [k] stands for the sequence (1,k), (2,k), . . ., (k−1,k).4\nHear my secret protocol (HMS) Next, we consider a protocol with the following program for agent i:\n∗[[] j∈A¬KiFjI → (i, j)].\nInformally, agent i calls agent j if he (agent i) does not know whether j is familiar with his secret. To prove correctness of this protocol it suffices to note that its exit condition\n∧\ni, j∈A\nKiFjI\nimplies ∧\ni, j∈A FjI. To prove termination it suffices to note that after each call (i, j) the size of the set {(i, j) | ¬KiFjI} decreases.\nIf the communication mode is push, then the termination argument remains valid, since after the call i⊲ j agent j still learns all the secrets agent i is familiar with.\nHowever, if the communication mode is pull, then the protocol may fail to terminate, even fairly. To see it fix an agent j and consider the calls i⊳ j, where i ranges over A\\{ j}, arbitrarily ordered. Denote this sequence by c. Consider now an infinite sequence of calls resulting from repeating c indefinitely. It is straightforward to check that such a sequence corresponds to a possible computation. Indeed, in this sequence agent j never calls and hence never learns any new secret. So for each i 6= j the formula ¬KiFjI remains true and hence each agent i 6= j remains enabled. Moreover, after the calls from c took place agent j is not anymore enabled. Hence the resulting infinite computation is fair.\n4Other longest sequences are obviously possible, for instance: 12,13, ...,1n,23,24, ...,2n,34,35, ..,3n, ...,(n−1)n."
    }, {
      "heading" : "4 Protocols over directed rings",
      "text" : "In this section we consider the case when the agents are arranged in a directed ring, where n ≥ 3. For convenience we take the set of agents to be {1,2, . . .,n}. For i ∈ {1, . . .,n}, let i⊕ 1 and i⊖ 1 denote respectively the successor and predecessor of agent i. That is, for i ∈ {1, . . .,n−1}, i⊕1 = i+1, n⊕1 = 1, for i ∈ {2, . . .,n}, i⊖1 = i−1, and 1⊖1 = n. For k > 1 we define i⊕ k and i⊖ k by induction in the expected way. Again, when reasoning about the protocols we denote the secret of agent i ∈ {1, . . .,n} by I. We consider four different protocols and study them with respect to their correctness and (fair) termination.\nIn this set up, a call sequence over a directed ring is a (possibly infinite) sequence of calls, all being of the same communication mode, and all involving an agent i and i⊕1. As before, we use c to denote such a call sequence and CDR to denote the set of all call sequences over a directed ring. In this section, unless stated otherwise, by a call sequence we mean a sequence over a directed ring. The set of all such finite call sequences is denoted C<ωDR . A gossip model for a directed ring is a tuple MDR = (C <ω DR ,{∼a}a∈A), where each ∼a⊆ C<ωDR ×C <ω DR is as in Definition 2.4. The truth definition is as before, and the notion of a computation tree for directed rings CPDR ⊆ C <ω DR of a ring protocol P is analogous to the notion defined before. Note that by restricting the domain in MDR to C<ωDR , the ring network—and hence who is the successor of whom—becomes common knowledge.\nWhen presenting the protocols we use the fact that FiJ is equivalent to KiFiJ.\nRing protocol R1 Consider first a gossip protocol with the following program for i:\n∗[ n∨\nj=1\n(FiJ ∧Ki¬Fi⊕1J)→ i✸i⊕1],\nwhere ✸ denotes the mode of communication, so ⊲, ⊳ or push-pull. Informally, agent i calls his successor, agent i⊕1, if i is familiar with some secret and he knows that his successor is not familiar with it.\nProposition 4.1 Let ✸= ⊲. Protocol R1 terminates and is correct.\nTermination and correctness do not both hold for the other communication modes. Consider first the pull communication mode, i.e., ✸ = ⊳. Then the protocol does not always terminate. Indeed, each call i⊳ i⊕1 can be repeated. Next, consider the push-pull communication mode. We show that then the protocol is not correct. Indeed, take\nc = (1,2), (2,3), . . .,(n−1,n).\nWe claim that after the sequence of calls c the exit condition of the protocol is true. To this end we consider each agent in turn.\nAfter c each agent i, where i 6= n is familiar the secrets of the agents 1,2, . . ., i+1. Moreover, because of the call (i, i+1) agent i knows that agent i+1 is familiar with these secrets. So the exit condition of agent i is true.\nTo deal with agent n note that c ∼n c.(n−2,n−1).(n−3,n−2).. . .(2,3).(1,2). After the latter call sequence agent 1 becomes an expert. So after c agent n cannot know that agent 1 is not familiar with some secret. Consequently, after c the exit condition of agent n is true, as well. However, after c agent 1 is not an expert, so the protocol is indeed not correct.\nIn what follows we initially present the protocols assuming the push-pull mode of communication.\nRing protocol R2 Consider now a gossip protocol with the following program for agent i:\n∗[¬KiFi⊕1I ⊖1 → (i, i⊕1)],\nwhere (recall) I ⊖ 1 denotes the secret of agent i⊖ 1. Informally, agent i calls his successor, which is agent i⊕1, if i does not know that his successor is familiar with the secret of i’s predecessor, i.e., agent i⊖1.\nProposition 4.2 If |A| ∈ {3,4} then protocol R2 is correct.\nHowever, this protocol is not correct for five or more agents. To see it consider the sequence of calls\n(1,2), (2,3), . . .,(n−1,n), (n,1), (1,2)\nwhere n ≥ 5. After it the exit condition of the protocol is true. However, agent 3 is not familiar with the secret of agent 5.\nNote that the same argument shows that the protocol in which we use ¬KiFi⊕1I∨¬KiFi⊕1I⊖1 instead of ¬KiFi⊕1I ⊖1 is incorrect, as well.\nMoreover, this protocol does not always terminate. Indeed, one possible computation consists of an agent i repeatedly calling his successor i⊕1.\nRing protocol R3 Next, consider the following modification of protocol R2 in which we use the following program for agent i:\n∗[(¬ n∧\nj=1\nFiJ)∨¬KiFi⊕1I ⊖1 → (i, i⊕1)].\nInformally, agent i calls his successor, agent i⊕ 1, if i is not familiar with all the secrets or i does not know that his successor is familiar with the secret of his predecessor, agent i⊖1.\nThis gossip protocol is obviously correct thanks to the fact that ∧n i=1 ∧n\nj=1 FiJ is part of the exit condition. However, it does not always terminate for the same reason as the previous one.\nOn the other hand, the following holds.\nProposition 4.3 Protocol R3 fairly terminates.\nThe same conclusions concerning non termination and fair termination can be drawn for the push and the pull modes of communication. Indeed, for push it suffices to consider the sequence of calls i ⊲ i⊕ 1, i⊕ 1⊲ i⊕ 2, . . ., i⊖ 1⊲ i after which agent i⊖ 1 becomes disabled, and for pull the sequence of calls i⊳ i⊕1, i⊖1⊳ i, . . ., i⊕2⊳ i⊕3 after which agent i⊕2 becomes disabled.\nRing protocol R4 Finally, we consider a protocol that is both correct and terminates for the push-pull mode. Consider the following program for i:\n∗[ n∨\nj=1\n(FiJ ∧¬KiFi⊕1J)→ (i, i⊕1)].\nInformally, agent i calls his successor, agent i⊕1, if i is familiar with some secret and he does not know whether his successor is familiar with it. Note the similarity with protocol R1.\nProposition 4.4 Protocol R4 terminates and is correct.\nIf the communication mode is push, then the termination argument remains valid, since after the call i ⊲ i⊕ 1 agent i⊕ 1 still learns all the secrets that agent i is familiar with and hence the above set {(i, j) | ¬KiFi⊕1J} decreases.\nIf the communication mode is pull, then the protocol may fail to terminate, because after the first call i ⊳ i⊕ 1 agent i⊕ 1 does not learn the secret of agent i and consequently the call can be repeated. However, the situation changes when fairness is assumed.\nProposition 4.5 For the pull communication mode protocol R4 fairly terminates.\nTable 1 summarizes the termination properties of the protocols considered in the paper."
    }, {
      "heading" : "5 Conclusions",
      "text" : "The aim of this paper was to introduce distributed gossip protocols, to set up a formal framework to reason about them, and to illustrate it by means of an analysis of selected protocols.\nOur results open up several avenues for further research. First, our correctness arguments were given in plain English with occasional references to epistemic tautologies, such as Kiφ → φ , but it should be possible to formalize them in a customized epistemic logic. Such a logic should have a protocol independent component that would consist of the customary S5 axioms and a protocol dependent component that would provide axioms that depend on the mode of communication and the protocol in question. An example of such an axiom is the formula KiFi⊕1I ⊖ 1 → FiI ⊕ 1 that we used when reasoning about protocol R2. To prove the validity of the latter axioms one would need to develop a proof system that allows us to compute the effect of the calls, much like the computation of the strongest postconditions in Hoare logics. Once such a logic is provided the next step will be to study formally its properties, including decidability. Then we could clarify whether the provided correctness proofs could be carried out automatically.\nSecond, generalizing further the ideas we introduced by considering directed rings, gossip protocols could be studied in interface with network theory (see [13] for a textbook presentation). Calls can be assumed to be constrained by a network, much like in the literature on ‘centralized’ gossip (cf. [10]) or even have probabilistic results (i.e., secrets are passed with given probabilities). More complex properties of gossip protocols could then be studied involving higher-order knowledge or forms of group knowledge among neighbors (e.g., “it is common knowledge among a and her neighbors that they are all experts”), or their stochastic behavior (e.g., “at some point in the future all agents are experts with probability p”).\nThird, it will be interesting to analyze the protocols for the types of calls considered in [3]. They presuppose some form of knowledge that a call took place (for instance that given a call between a and b each agent c 6= a,b noted the call but did not learn its content). Another option is to consider multicasting (calling several agents at the same time).\nFinally, many assumptions of the current setup could be lifted. Different initial and final situations could be considered, for instance common knowledge of protocols could be assumed, or common knowledge of the familiarity of all agents with all the secrets upon termination could be required. Finally, to make the protocols more efficient passing of tokens could be allowed instead of just the transmission of secrets by means of calls."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to thank Hans van Ditmarsch and the referees for helpful comments and Rahim Ramezanian for useful comments about Example 2.8. This work resulted from a research visit by Krzysztof Apt to Davide Grossi and Wiebe van der Hoek, sponsored by the 2014 Visiting Fellowship Scheme of the Department of Computer Science of the University of Liverpool. The first author is also a Visiting Professor at the University of Warsaw. He was partially supported by the NCN grant nr 2014/13/B/ST6/01807."
    } ],
    "references" : [ {
      "title" : "F",
      "author" : [ "K.R. Apt" ],
      "venue" : "R. de Boer & E. R. Olderog ",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "N",
      "author" : [ "K.R. Apt" ],
      "venue" : "Francez & S. Katz ",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "H",
      "author" : [ "M. Attamah" ],
      "venue" : "van Ditmarsch, D. Grossi & W. Van der Hoek ",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Gossips and Telephones",
      "author" : [ "B. Baker", "R. Shostak" ],
      "venue" : "Discrete Mathematics",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1972
    }, {
      "title" : "A Problem with Telephones",
      "author" : [ "R. Bumby" ],
      "venue" : "SIAM Journal of Algorithms and Discrete Methods",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1981
    }, {
      "title" : "Guarded commands, nondeterminacy and formal derivation of programs",
      "author" : [ "E.W. Dijkstra" ],
      "venue" : "Communications of the ACM",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1975
    }, {
      "title" : "Y",
      "author" : [ "R. Fagin", "J. Halpern" ],
      "venue" : "Moses & M. Vardi ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Reasoning about knowledge",
      "author" : [ "Ronald Fagin", "Joseph Y. Halpern", "Yoram Moses", "Moshe Y. Vardi" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1995
    }, {
      "title" : "E",
      "author" : [ "A. Hajnal" ],
      "venue" : "C. Milner & E. Szemeredi ",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1972
    }, {
      "title" : "S",
      "author" : [ "S.M. Hedetniemi" ],
      "venue" : "T. Hedetniemi & A. L. Liestman ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Social and Economic Networks",
      "author" : [ "M.O. Jackson" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Towards programming with Knowledge Expressions",
      "author" : [ "R. Kurki-Suonio" ],
      "venue" : "Proceedings of POPL’86,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1986
    }, {
      "title" : "Meyer & W",
      "author" : [ "J.-J. Ch" ],
      "venue" : "van der Hoek ",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Distributed Processing and the Logic of Knowledge",
      "author" : [ "R. Parikh", "R. Ramanujam" ],
      "venue" : "Logic of Programs,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1985
    }, {
      "title" : "Quick Gossiping without Duplicate Transmissions",
      "author" : [ "Á Seress" ],
      "venue" : "Graphs and Combinatorics",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1986
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "In the gossip problem ([18, 4], see also [10] for an overview) a number n of agents, each one knowing a piece of information (a secret) unknown to the others, communicate by one-to-one interactions (e.",
      "startOffset" : 23,
      "endOffset" : 30
    }, {
      "referenceID" : 9,
      "context" : "In the gossip problem ([18, 4], see also [10] for an overview) a number n of agents, each one knowing a piece of information (a secret) unknown to the others, communicate by one-to-one interactions (e.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 3,
      "context" : "It sparked a large literature in the 70s and 80s [18, 4, 9, 5, 17] typically focusing on establishing—in the above and other variants of the problem—the minimum number of calls to achieve dissemination of all the secrets.",
      "startOffset" : 49,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "It sparked a large literature in the 70s and 80s [18, 4, 9, 5, 17] typically focusing on establishing—in the above and other variants of the problem—the minimum number of calls to achieve dissemination of all the secrets.",
      "startOffset" : 49,
      "endOffset" : 66
    }, {
      "referenceID" : 4,
      "context" : "It sparked a large literature in the 70s and 80s [18, 4, 9, 5, 17] typically focusing on establishing—in the above and other variants of the problem—the minimum number of calls to achieve dissemination of all the secrets.",
      "startOffset" : 49,
      "endOffset" : 66
    }, {
      "referenceID" : 14,
      "context" : "It sparked a large literature in the 70s and 80s [18, 4, 9, 5, 17] typically focusing on establishing—in the above and other variants of the problem—the minimum number of calls to achieve dissemination of all the secrets.",
      "startOffset" : 49,
      "endOffset" : 66
    }, {
      "referenceID" : 2,
      "context" : "In this paper we pursue a line of research first put forth in [3] by developing a decentralized theory of the gossip problem, where agents perform calls not according to a centralized schedule, but following individual epistemic protocols they run in a distributed fashion.",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 7,
      "context" : ", [1, Chapter 11] and the epistemic logic literature [8, 15] in the tradition of [16, 14, 7].",
      "startOffset" : 53,
      "endOffset" : 60
    }, {
      "referenceID" : 12,
      "context" : ", [1, Chapter 11] and the epistemic logic literature [8, 15] in the tradition of [16, 14, 7].",
      "startOffset" : 53,
      "endOffset" : 60
    }, {
      "referenceID" : 13,
      "context" : ", [1, Chapter 11] and the epistemic logic literature [8, 15] in the tradition of [16, 14, 7].",
      "startOffset" : 81,
      "endOffset" : 92
    }, {
      "referenceID" : 11,
      "context" : ", [1, Chapter 11] and the epistemic logic literature [8, 15] in the tradition of [16, 14, 7].",
      "startOffset" : 81,
      "endOffset" : 92
    }, {
      "referenceID" : 6,
      "context" : ", [1, Chapter 11] and the epistemic logic literature [8, 15] in the tradition of [16, 14, 7].",
      "startOffset" : 81,
      "endOffset" : 92
    }, {
      "referenceID" : 5,
      "context" : "We loosely use the syntax of the language CSP (Communicating Sequential Processes) of [11] that extends the guarded command language of [6] by disjoint parallel composition and commands for synchronous communication.",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 2,
      "context" : "This link is established in [3].",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 2,
      "context" : "These assumptions are weaker than the ones analyzed in [3].",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "An interested reader may consult [2], where several fairness definitions (for instance one focusing on actions and not on agents) for distributed programs were considered and compared.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 2,
      "context" : "This protocol was introduced in [3] and studied with respect to the push-pull mode, assuming asynchronous communication.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 1,
      "context" : "Such a worst case can be generated by means of the following sequence of calls: [2], [3], [4], .",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "Such a worst case can be generated by means of the following sequence of calls: [2], [3], [4], .",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 3,
      "context" : "Such a worst case can be generated by means of the following sequence of calls: [2], [3], [4], .",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 10,
      "context" : "Second, generalizing further the ideas we introduced by considering directed rings, gossip protocols could be studied in interface with network theory (see [13] for a textbook presentation).",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 9,
      "context" : "[10]) or even have probabilistic results (i.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "Third, it will be interesting to analyze the protocols for the types of calls considered in [3].",
      "startOffset" : 92,
      "endOffset" : 95
    } ],
    "year" : 2016,
    "abstractText" : "Gossip protocols aim at arriving, by means of point-to-point or group communications, at a situation in which all the agents know each other’s secrets. We consider distributed gossip protocols which are expressed by means of epistemic logic. We provide an operational semantics of such protocols and set up an appropriate framework to argue about their correctness. Then we analyze specific protocols for complete graphs and for directed rings.",
    "creator" : "LaTeX with hyperref package"
  }
}