{
  "name" : "1406.7443.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Efficient Learning in Large-Scale Combinatorial Semi-Bandits",
    "authors" : [ "Zheng Wen", "Branislav Kveton", "Azin Ashkan" ],
    "emails" : [ "ZHENGWEN@YAHOO-INC.COM", "KVETON@ADOBE.COM", "AZIN.ASHKAN@TECHNICOLOR.COM" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Combinatorial optimization is a mature field (Papadimitriou & Steiglitz, 1998), which has countless practical applications. One of the most studied problems in combinatorial optimization is maximization of a modular function\nsubject to combinatorial constraints. Many important problems, such as minimum spanning tree (MST), shortest path, and maximum-weight bipartite matching, can be viewed as instances of this problem.\nIn practice, the optimized modular function is often unknown and needs to be learned while repeatedly solving the problem. This class of learning problems was recently formulated as a combinatorial bandit/semi-bandit, depending on the feedback model (Audibert et al., 2014). Since then, many combinatorial bandit/semi-bandit algorithms have been proposed: for the stochastic setting (Gai et al., 2012; Chen et al., 2013; Russo & Van Roy, 2014; Kveton et al., 2015b); for the adversarial setting (Cesa-Bianchi & Lugosi, 2012; Audibert et al., 2014; Neu & Bartók, 2013); and for subclasses of combinatorial problems, matroid and polymatroid bandits (Kveton et al., 2014a;b), submodular maximization (Wen et al., 2013; Gabillon et al., 2013), and cascading bandits (Kveton et al., 2015a). Many regret bounds have been established for the combinatorial semibandit algorithms. To achieve an O( √ n) dependence on time n, all of the regret bounds are Ω( √ L), where L is the number of items. The dependence on L is intrinsic because the algorithms estimate the weight of each item separately, and matching lower bounds have been established (Section 3.2).\nHowever, in many real-world problems, the number of items L is intractably large. For instance, online advertising in a mainstream commercial website can be viewed as a bipartite matching problem with millions of users and products; routing in the Internet can be formulated as a shortest path problem with billions of edges. Thus, learning algorithms with Ω( √ L) regret are impractical in such problems. On the other hand, in many problems, items have features and their weights are similar when the features are similar. In movie recommendation, for instance, the expected ratings of movies that are close in the latent space are also similar. In this work, we show how to leverage this struc-\nar X\niv :1\n40 6.\n74 43\nv4 [\ncs .L\nG ]\n3 1\nJa n\nture to learn to make good decisions more efficiently. More specifically, we assume a linear generalization across the items: conditioned on the features of an item, the expected weight of that item can be estimated using a linear model. Our goal is to develop more efficient learning algorithms for combinatorial semi-bandits with linear generalization.\nIt is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al. (2008); AbbasiYadkori et al. (2011)) , to combinatorial semi-bandits with linear generalization. In this paper, we propose two learning algorithms, Combinatorial Linear Thompson Sampling (CombLinTS) and Combinatorial Linear UCB (CombLinUCB), based on Thompson sampling and LinUCB. Both CombLinTS and CombLinUCB are computationally efficient, as long as the offline version of the combinatorial problem can be solved efficiently. The first major contribution of the paper is that we establish a Bayes regret bound on CombLinTS and a regret bound on CombLinUCB, under reasonable assumptions. Both bounds are L-independent, and sublinear in time. The second major contribution of the paper is that we evaluate CombLinTS on a variety of problems with thousands of items, and two of these problems are based on real-world datasets. We only evaluate CombLinTS since recent literature (Chapelle & Li, 2011) suggests that Thompson sampling algorithms usually outperform UCB-like algorithms in practice. Our experimental results demonstrate that CombLinTS is scalable, robust to the choice of algorithm parameters, and significantly outperforms the best of our baselines. It is worth mentioning that our derived L-independent regret bounds also hold in cases with L = ∞. Moreover, as we will discuss in Section 7, our proposed algorithms and their analyses can be easily extended to the contextual combinatorial semibandits.\nFinally, we briefly review some relevant papers. Gabillon et al. (2014) and Yue & Guestrin (2011) focus on submodular maximization with linear generalization. Our paper differs from these two papers in the following two aspects: (1) our paper allows general combinatorial constraints while they do not; (2) our paper focuses on maximization of modular functions while they focus on submodular maximization."
    }, {
      "heading" : "2. Combinatorial Optimization",
      "text" : "We focus on a class of combinatorial optimization problems that aim to find a maximum-weight set from a given family of sets. Specifically, one such combinatorial optimization problem can be represented as a triple (E,A,w), where (1) E = {1, . . . , L} is a set of L items, called the ground set, (2) A ⊆ {A ⊆ E : |A| ≤ K} is a family of\nsubsets of E with up to K items, where K ≤ L, and (3) w : E → R is a weight function that assigns each item e in the ground set E a real number. The total weight of all items in a set A ⊆ E is defined as:\nf(A,w) = ∑ e∈Aw(e), (1)\nwhich is a linear functional of w and a modular function in A. A set Aopt is a maximum-weight set in A if:\nAopt ∈ arg max A∈A f(A,w) = arg max A∈A\n∑ e∈Aw(e). (2)\nMany classical combinatorial optimization problems, such as finding an MST, bipartite matching, the shortest path problem and the traveling salesman problem (TSP), have form (2). Though some of these problems can be solved efficiently (e.g. bipartite matching), others (e.g. TSP) are known to be NP-hard. However, for many such NPhard problems, there exist computationally efficient approximation algorithms and/or randomized algorithms that achieve near-optimal solutions with high probability. Similarly to Chen et al. (2013), in this paper, we allow the agent to use any approximation / randomized algorithm ORACLE to solve (2), and denote its solution as A∗ = ORACLE(E,A,w). To distinguish from a learning algorithm, we refer to a combinatorial optimization algorithm as an oracle in this paper."
    }, {
      "heading" : "3. Combinatorial Semi-Bandits with Linear Generalization",
      "text" : "Many real-world problems are combinatorial in nature. In recommender systems, for instance, the user is typically recommendedK items out of L. The value of an item, such as the expected rating of a movie, is never known perfectly and has to be refined while repeatedly recommending to the pool of the users. Recommender problems are known to be highly structured. In particular, it is well known that the user-item matrix is typically low-rank (Koren et al., 2009) and that the value of an item can be written as a linear combination of its position in the latent space. In this work, we propose a learning algorithm for combinatorial optimization that leverages this structure. In particular, we assume that the weight of each item is a linear function of its features and then we learn the parameters of this model, jointly for all items."
    }, {
      "heading" : "3.1. Combinatorial Semi-Bandits",
      "text" : "We formalize our learning problem as a combinatorial semi-bandit. A combinatorial semi-bandit is a triple (E,A, P ), where E and A are defined in Section 2 and P is a probability distribution over the weights w ∈ RL of the items in the ground set E. We assume that the weights w are drawn i.i.d. from P . The mean weight is denoted by\nw̄ = E[w]. Each item e is associated with an arm and we assume that multiple arms can be pulled. A subset of arms A ⊆ E can be pulled if and only if A ∈ A. The return of pulling arms A is f(A,w) (Equation (1)), the sum of the weights of all items in A. After the arms A are pulled, we observe the individual return of each arm, {w(e) : e ∈ A}. This feedback model is known as semi-bandit (Audibert et al., 2014).\nWe assume that the combinatorial structure (E,A) is known and the distribution P is unknown. We would like to stress that we do not make any structural assumptions on P . The optimal solution to our problem is a maximumweight set in expectation:\nAopt ∈ arg max A∈A Ew[f(A,w)] = arg max A∈A ∑ e∈A w̄(e). (3)\nThis objective is equivalent to the one in Equation (2).\nOur learning problem is episodic. In each episode t, the learning agent adaptively chooses At ∈ A based on its observations of the weights up to episode t, gains f(At,wt), and observes the weights of all chosen items in episode t, {(e,wt(e)) : e ∈ At}. The learning agent interacts with the combinatorial semi-bandit for n times and its goal is to maximize the expected cumulative return in n-episodes E[ ∑n t=1 f(A\nt,wt)], where the expectation is over (1) the random weights wt’s, (2) possible randomization in the learning algorithm, and (3) w̄ if it is randomly generated. Notice that the choice ofAt impacts both the return and observations in episode t. So we need to trade off exploration and exploitation, similarly to other bandit problems."
    }, {
      "heading" : "3.2. Linear Generalization",
      "text" : "As we have discussed in Section 1, many provably efficient algorithms have been developed for various combinatorial semi-bandits of form (3) (Chen et al., 2013; Gai et al., 2012; Kveton et al., 2014a; Russo & Van Roy, 2014). However, since there areL parameters to learn and these algorithms do not consider generalization across items, the derived upper bounds on the expected cumulative regret and/or the Bayes cumulative regret of these algorithms are at least O( √ L). Furthermore, Audibert et al. (2014) has derived an Ω( √ LKn) lower bound on adversarial combinatorial semi-bandits, while Kveton et al. (2014a) has derived an asymptotic Ω(L log(n)/∆) gap-dependent lower bound on stochastic combinatorial semi-bandits, where ∆ is the “gap”.\nHowever, in many modern combinatorial semi-bandit problems, L tends to be enormous. Thus, an O( √ L) regret is unacceptably large in these problems. On the other hand, in many practical problems, there exists a generalization model based on which the weight of one item can be (approximately) inferred based on the weights of\nother items. By exploiting such generalization models, an o( √ L) or even an L-independent cumulative regret might be achieved.\nIn this paper, we assume that there is a (possibly imperfect) linear generalization model across the items. Specifically, we assume that the agent knows a generalization matrix Φ ∈ RL×d s.t. w̄ either lies in or is “close” to the subspace span [Φ]. We use φe to denote the transpose of the e-th row of Φ, and refer to it as the feature vector of item e. Without loss of generality, we assume that rank [Φ] = d.\nSimilar to Wen & Van Roy (2013), we distinguish between the coherent learning cases, in which w̄ ∈ span [Φ], and the agnostic learning cases, in which w̄ /∈ span [Φ]. Like existing literature on linear bandits (Dani et al., 2008; Abbasi-Yadkori et al., 2011), the analysis in this paper focuses on coherent learning cases. However, we would like to emphasize that both of our proposed algorithms, CombLinTS and CombLinUCB, are also applicable to the agnostic learning cases. As is demonstrated in Section 6, CombLinTS performs well in the agnostic learning cases.\nFinally, we define θ∗ = arg min θ ‖w̄ − Φθ‖2. Since rank [Φ] = d, θ∗ is uniquely defined. Moreover, in coherent learning cases, we have w̄ = Φθ∗."
    }, {
      "heading" : "3.3. Performance Metrics",
      "text" : "Let A∗ = ORACLE(E,A, w̄). In this paper, we measure the performance loss of a learning algorithm with respect to A∗. Recall that the learning algorithm chooses At in episode t, we define Rt = f(A∗,wt) − f(At,wt) as the realized regret in episode t. If the expected weight w̄ is fixed but unknown, we define the expected cumulative regret of the learning algorithm in n episodes as\nR(n) = ∑n t=1 E [Rt|w̄] , (4)\nwhere the expectation is over random weights and possible randomization in the learning algorithm. If necessary, we denote R(n) as R(n; w̄) to emphasize the dependence on w̄. On the other hand, if w̄ is randomly generated or the agent has a prior belief in w̄, then from Russo & Van Roy (2013), the Bayes cumulative regret of the learning algorithm in n episodes is defined as\nRBayes(n) = Ew̄[R(n; w̄)] = ∑n t=1 E [Rt] , (5)\nwhere the expectation is also over w̄. That is, RBayes(n) is a weighted average of R(n; w̄) under the prior on w̄."
    }, {
      "heading" : "4. Learning Algorithms",
      "text" : "In this section, we propose two learning algorithms for combinatorial semi-bandits: Combinatorial Linear Thompson Sampling (CombLinTS) and Combinatorial Linear\nAlgorithm 2 Combinatorial Linear Thompson Sampling Input: Combinatorial structure (E,A), generalization matrix Φ ∈ RL×d, algorithm parameters λ, σ > 0, oracle ORACLE\nInitialize Σ1 ← λ2I ∈ Rd×d and θ̄1 = 0 ∈ Rd for all t = 1, 2, . . . , n do\nSample θt ∼ N ( θ̄t,Σt ) Compute At ← ORACLE(E,A,Φθt) Choose set At, and observe wt(e), ∀e ∈ At Compute θ̄t+1 and Σt+1 based on Algorithm 1\nend for\nUCB (CombLinUCB), which are respectively motivated by Thompson sampling and LinUCB. Both algorithms maintain a mean vector θ̄t and a covariance matrix Σt, and use Kalman filtering to update θ̄t and Σt. They differ in how to choose At (i.e. how to explore) in each episode t: CombLinTS chooses At based on a randomly sampled coefficient vector θt, while CombLinUCB choosesAt based on the optimism in the face of uncertainty (OFU) principle."
    }, {
      "heading" : "4.1. Combinatorial Linear Thompson Sampling",
      "text" : "The psuedocode of CombLinTS is given in Algorithm 2, where (E,A) is the combinatorial structure, Φ is the generalization matrix, ORACLE is a combinatorial optimization algorithm, and λ and σ are two algorithm parameters controlling the learning rate. Specifically, λ is an inverseregularization parameter and smaller λ makes the covariance matrix Σt closer to 0. Thus, a too small λ will lead to insufficient exploration and significantly reduce the performance of CombLinTS. On the other hand, σ controls the decrease rate of the covariance matrix Σt. In particular, a large σ will lead to slow learning, while a too small σ will make the algorithm quickly converge to some sub-optimal coefficient vector.\nIn each episode t, Algorithm 2 consists of three steps. First, it randomly samples a coefficient vector θt from a Gaussian distribution. Second, it computes At based on θt and the pre-specified oracle. Finally, it updates the mean vector θ̄t+1 and the covariance matrix Σt+1 based on Kalman filtering (Algorithm 1).\nIt is worth pointing our that if (1) w̄ = Φθ∗, (2) the prior on θ∗ is N(0, λ2I), and (3) ∀(t, e), the noise ηt(e) = wt(e) − w̄(e) is independently sampled from N(0, σ2), then in each episode t, the CombLinTS algorithm samples θt from the posterior distribution of θ∗. We henceforth refer to a case satisfying condition (1)-(3) as a coherent Gaussian case. Obviously, the CombLinTS algorithm can be applied to more general cases, even to cases with no prior and/or agnostic learning cases.\nAlgorithm 3 Combinatorial Linear UCB Input: Combinatorial structure (E,A), generalization matrix Φ ∈ RL×d, algorithm parameters λ, σ, c > 0, oracle ORACLE\nInitialize Σ1 ← λ2I ∈ Rd×d and θ̄1 = 0 ∈ Rd for all t = 1, 2, . . . , n do\nDefine the UCB weight vector ŵt as\nŵt(e) = 〈 φe, θ̄t 〉 + c √ φTe Σtφe ∀e ∈ E\nCompute At ← ORACLE(E,A, ŵt) Choose set At, and observe wt(e), ∀e ∈ At Compute θ̄t+1 and Σt+1 based on Algorithm 1\nend for"
    }, {
      "heading" : "4.2. Combinatorial Linear UCB",
      "text" : "The pseudocode of CombLinUCB is given in Algorithm 3, where E, A, Φ and ORACLE are defined the same as in Algorithm 2, and λ, σ, and c are three algorithm parameters. Similarly, λ is an inverse-regularization parameter, σ controls the decrease rate of the covariance matrix, and c controls the degree of optimism (exploration). Specifically, if c is too small, the algorithm might converge to some suboptimal coefficient vector due to insufficient exploration; on the other hand, too large c will lead to excessive exploration and slow learning.\nIn each episode t, Algorithm 3 also consists of three steps. First, for each e ∈ E, it computes an upper confidence bound (UCB) ŵt(e). Second, it computes At based on ŵt and the pre-specified oracle. Finally, it updates θ̄t+1 and Σt+1 based on Kalman filtering (Algorithm 1)."
    }, {
      "heading" : "5. Regret Bounds",
      "text" : "In this section, we present a Bayes regret bound on CombLinTS, and a regret bound on CombLinUCB. We will also briefly discuss how these bounds are derived, as well as their tightness. The detailed proofs are left to the appendices. Without loss of generality, throughout this section, we assume that ‖φe‖2 ≤ 1, ∀e ∈ E.\n5.1. Bayes Regret Bound on CombLinTS\nWe have the following upper bound on RBayes(n) when CombLinTS is applied to a coherent Gaussian case with the right parameter.\nTheorem 1. If (1) w̄ = Φθ∗, (2) the prior on θ∗ is N(0, λ2I), (3) the noises are i.i.d. sampled from N(0, σ2), and (4) λ ≥ σ, then under CombLinTS algorithm with pa-\nAlgorithm 1 Compute θ̄t+1 and Σt+1 based on Kalman Filtering Input: θ̄t, Σt, σ, and feature-observation pairs {(φe,wt(e)) : e ∈ At} Initialize θ̄t+1 ← θ̄t and Σt+1 ← Σt for k = 1, . . . , |At| do\nUpdate θ̄t+1 and Σt+1 as follows, where atk is the kth element in A t\nθ̄t+1 ← [ I − Σt+1φatkφ T atk\nφT atk Σt+1φatk + σ 2\n] θ̄t+1 + [ Σt+1φatk\nφT atk Σt+1φatk + σ 2\n] wt ( atk )\nΣt+1 ←Σt+1 − Σt+1φatkφ T atk Σt+1\nφT atk Σt+1φatk + σ 2 , (6)\nend for Output: θ̄t+1 and Σt+1\nrameter (Φ, λ, σ), we have RBayes(n) ≤ Õ ( Kλ √ dnmin {ln(L), d} ) . (7)\nNotice that condition (1)-(3) ensure it is a coherent Gaussian case, and condition (4) almost always holds1. The Õ notation hides the logarithm factors. We also note that Equation (7) is a minimum of two bounds. The first bound is L-dependent, but it is only O( √ ln(L)); on the other\nhand, the second bound is L-independent, but is Õ(d) instead of Õ( √ d).\nWe now outline the proof of Theorem 1, which is motivated by Russo & Van Roy (2013) and Dani et al. (2008). LetHt denote the “history” (i.e. all the available information) by the start of episode t. Note that from the Bayesian perspective, conditioning on Ht, θ∗ and θt are i.i.d. drawn from N(θ̄t,Σt) (Russo & Van Roy, 2013). This is because that conditioning on Ht, the posterior belief in θ∗ is N(θ̄t,Σt) and based on Algorithm 2, θt is independently sampled from N(θ̄t,Σt). Since ORACLE is a fixed combinatorial optimization algorithm (even though it can be independently randomized), and E,A,Φ are all fixed, then conditioning on Ht, A∗ and At are also i.i.d., furthermore, A∗ is conditionally independent of θt, and At is conditionally independent of θ∗.\nTo simplify the exposition, ∀θ ∈ Rd and ∀A ⊆ E, we define\ng(A, θ) = ∑ e∈A 〈φe, θ〉 ,\nwhere 〈·, ·〉 is an alternative notation for inner product. Thus we have E[Rt|Ht] = E[g(A∗, θ∗)− g(At, θ∗)|Ht]. We also define a UCB function Ut : 2E → R as\nUt(A) = ∑ e∈A [〈 φe, θ̄t 〉 + c √ φTe Σtφe ] ,\n1Condition (4) is not essential, please refer to Theorem 3 in Appendix A for a Bayes regret bound without condition (4).\nwhere c > 0 is a constant to be specified. Notice that conditioning on Ht, Ut is a deterministic function and A∗, At are i.i.d., then E[Ut(At)− Ut(A∗)|Ht] = 0 and\nE[Rt|Ht] =E[g(A∗, θ∗)− Ut(A∗)|Ht] +E [ Ut(A t)− g(At, θ∗) ∣∣Ht] . (8)\nTheorem 1 follows by respectively bounding the two terms on the righthand side of Equation (8). Two key observations are (1) if c = Õ (√ min {ln(L), d} ) , then\nE[g(A∗, θ∗)− Ut(A∗)|Ht] = O(1),\nand (2) E [ Ut(A t)− g(At, θ∗) ∣∣Ht] = cE[∑e∈At√φTe Σtφe∣∣∣Ht] ,\nand we have a worst-case bound (see Lemma 4 in Appendix A) on ∑n t=1 ∑ e∈At √ φTe Σtφe. Please refer to Appendix A for the detailed proof for Theorem 1.\nFinally, we briefly discuss the tightness of our bound. Without loss of generality, we assume that λ = 1. For the special case when Φ = I (i.e. no generalization), Russo & Van Roy (2014) provides an O( √ LK log(L/K)n) upper bound on RBayes(n) when Thompson sampling is applied, and Audibert et al. (2014) provides an Ω( √ LKn) lower bound2. Since L = d when Φ = I , the above results indicate that for general Φ, the best upper bound one can hope is O( √ Kdn). Hence, our bound is at most\nÕ( √ K min{ln(L), d}) larger. It is well-known that the O( √ d) factor is due to linear generalization (Dani et al., 2008; Abbasi-Yadkori et al., 2011), and as is discussed in the appendix (see Remark 1), the extra O( √ K) factor is\n2Audibert et al. (2014) focuses on the adversarial setting but the lower bound is stochastic. So it is a reasonable lower bound to compare with.\nalso due to linear generalization. They might be intrinsic, but we leave the final word and tightness analysis to future work.\n5.2. Regret Bound on CombLinUCB\nUnder the assumptions that (1) the support of P is a subset of [0, 1]L, (2) the stochastic item weights {w(e)}e∈E are statistically independent under P , and (3) the oracle ORACLE exactly solves the offline optimization problem3, we have the following upper bound on R(n) when CombLinUCB is applied to coherent learning cases: Theorem 2. For any λ, σ > 0, any δ ∈ (0, 1), and any c satisfying\nc ≥ 1 σ\n√ d ln ( 1 + nKλ2\ndσ2\n) + 2 ln ( 1\nδ ) + ‖θ∗‖2 λ , (9)\nif w̄ = Φθ∗ and the above three assumptions hold, then under CombLinUCB algorithm with parameter (Φ, λ, σ, c), we have\nR(n) ≤ 2cKλ\n√ dn ln ( 1 + nKλ 2\ndσ2 ) ln ( 1 + λ 2\nσ2 ) + nKδ. Generally speaking, the proof for Theorem 2 proceeds as follows. We first construct a confidence set G of θ∗ based on the “self normalized bound” developed in Abbasi-Yadkori et al. (2011). Then we decompose the regret over the high-probability “good” event G and the low-probability “bad” event Ḡ, where Ḡ is the complement of G. Finally, we bound the term associated with the event G based on the same worst-case bound on ∑n t=1 ∑ e∈At √ φTe Σtφe used in the analysis for CombLinTS (see Lemma 4 in Appendix A), and bound the term associated with the event Ḡ based on a naive bound. Please refer to Appendix B for the detailed proof of Theorem 2.\nNotice that if we choose λ = σ = 1, δ = 1/(nK), and c as the lower bound specified in Inequality (9), then the regret bound derived in Theorem 2 is also Õ(Kd √ n). Compared with the lower bound derived in Audibert et al. (2014), this bound is at most Õ( √ Kd) larger. Similarly, the extra O( √ K) and O( √ d) factors are also due to linear generalization.\nFinally, we would like to clarify that the assumption that the support of P is bounded is not essential. By slightly modifying the analysis, we can achieve a similar highprobability bound on the realized cumulative regret as long as P is sub-Gaussian. We also want to point out that the Lindependent bounds derived in both Theorem 1 and 2 will still hold even if L =∞.\n3 If ORACLE is an approximation algorithm, a variant of Theorem 2 can be proved (see Appendix D)."
    }, {
      "heading" : "6. Experiments",
      "text" : "In this section, we evaluate CombLinTS on three problems. The first problem is synthetic, but the last two problems are constructed based on real-world datasets. As we have discussed in Section 1, we only evaluate CombLinTS since in practice Thompson sampling algorithms usually outperform the UCB-like algorithms. Our experiment results in the synthetic problem demonstrate that CombLinTS is both scalable and robust to the choice of algorithm parameters. They also suggest the Bayes regret bound derived in Theorem 1 is likely to be tight. On the other hand, our experiment results in the last two problems show the value of linear generalization in real-world settings: with domainspecific but imperfect linear generalization (i.e. agnostic learning), CombLinTS can significantly outperform stateof-the-art learning algorithms that do not exploit linear generalization, which serve as baselines in these two problems.\nIn all three problems, the oracle ORACLE exactly solves the offline combinatorial optimization problem. Moreover, in the two real-world problems, we demonstrate the experiment results using a new performance metric, the expected per-step return in n episodes, which is defined as\n1 n Ew1,...,wn [\n∑n t=1 f(A t,wt)|w̄] . (10)\nObviously, it is the expected cumulative return in n episodes divided by n. We demonstrate experiment results using expected cumulative return rather than R(n) since it is more illustrative."
    }, {
      "heading" : "6.1. Longest Path",
      "text" : "We first evaluate CombLinTS on a synthetic problem. Specifically, we experiment with a stochastic longest path problem on an (m+1)×(m+1) square grid4. The items in the ground set E are the edges in the grid, L = 2m(m+ 1) in total. The feasible set A are all paths in the grid from the upper left corner to the bottom right corner that follow the directions of the edges. The length of these paths is K = 2m. In this problem, we focus on coherent Gaussian cases and randomly sample the linear generalization matrix Φ ∈ RL×d to weaken the dependence on a particular choice of Φ.\nOur experiments are parameterized by a sextuple (m, d, λtrue, σtrue, λ, σ), where m, d, λ, and σ are defined before and λtrue and σtrue are respectively the true standard deviations of θ∗ and the observation noises. In each round of simulation, we first construct a problem instance as follows: (1) generate Φ by sampling each component of Φ i.i.d. from N(0, 1); (2) sample θ∗ inde-\n4That is, each side has m edges and m + 1 nodes. Notice that the longest path problem and the shortest path problem are mathematically equivalent.\npendently from N(0, λ2trueI) and set w̄ = Φθ ∗; and (3) ∀(t, e), the observation noise ηt(e) = wt(e)−w̄(e) is i.i.d. sampled from N(0, σ2true). Then we apply CombLinTS with parameter (λ, σ) to the constructed instance for n episodes. Notice that in general (λ, σ) 6= (λtrue, σtrue). We average the experiment results over 200 simulations to estimate the Bayes cumulative regret RBayes(n).\nWe start with a “default case” with m = 30, d = 200, λtrue = λ = 10 and σtrue = σ = 1. Notice in this case L = 1860 and |A| ≈ 1.18 × 1017. We choose n = 150 since in the default case, the Bayes per-episode regret of CombLinTS vanishes far before period 150. In the default case RBayes(150) ≈ 1.56 × 104. In the experiments, we vary only one and only one parameter while keeping all the other parameters fixed to their “default values” specified above to demonstrate the scalability and robustness of CombLinTS.\nFirst, we study how the Bayes cumulative regret of CombLinTS scales with the size of the problem by varying m = 10, 20, . . . , 100, and show the result in Figure 1(a). The experiment results show that RBayes(150) roughly increases linearly withm, which indicates that CombLinTS is scalable with respect to the problem size m. We also experiment with m = 250, in this case we have L ≈ 125k, |A| ≈ 1.17×10149, andRBayes(150) ≈ 6.56×104, which is only 4.2 times of RBayes(150) in the default case. It is worth mentioning that this result also suggests that the Bayes regret bound derived in Theorem 1 is (almost) tight in this problem5. To see it, notice that K = 2m and\n5Recall that Theorem 1 requires maxe∈E ‖φe‖2 ≤ 1. It can\nL = O(m2), and hence the Bayes regret bound derived in Theorem 1 is Õ(m).\nSecond, we study how the Bayes cumulative regret of CombLinTS scales with d, the dimension of the feature vectors, by varying d = 10, 60, 110, . . . , 510, and demonstrate the result in Figure 1(b). The experiment results indicate that RBayes(150) also roughly increases linearly with d, and hence CombLinTS is also scalable with the feature dimension d. This result also suggests that the Õ( √ d) bound in Theorem 1 is (almost) tight5.\nFinally, we study the robustness of CombLinTS with respect to the algorithm parameters σ and λ. In Figure 1(c), we vary σ = 10−7, 10−6, . . . , 104 and in Figure 1(d), we vary λ = 10−2, 10−1, . . . , 105. We would like to emphasize again that we only vary the algorithm parameters and fix σtrue = 1 and λtrue = 10. The experiment results show that CombLinTS is robust to the choice of algorithm parameters and performs well for a wide range of σ and λ. However, too small or too large σ, or too small λ, can significantly reduce the performance of CombLinTS, as we have discussed in Section 4.1."
    }, {
      "heading" : "6.2. Online Advertising",
      "text" : "In the second experiment, we evaluate CombLinTS on an advertising problem. Our objective is to identify 100 people that are most likely to accept an advertisement offer, subject to the targeting constraint that exactly half of them are females. Specifically, the ground set E includes 33k representative people from Adult dataset (Asuncion & Newman, 2007), which was collected in the 1994 US census. A feasible solution A is any subset of E with |A| = 100 and satisfying the targeting constraint mentioned above. We assume that person e accepts an advertisement offer with probability\nw̄(e) = { 0.15 income is at least 50k 0.05 otherwise,\nand people accept offers independently of each other. The features in the generalization matrix Φ are the age, which is binned into 7 groups; gender; whether the person works more than 40 hours per week; and the length of education in years. All these features can be constructed based on the Adult dataset.\nCombLinTS is compared to three baselines. The first baseline is the optimal solution Aopt. The second baseline is\nbe easily extended to cases with maxe∈E ‖φe‖2 ≤M by scaling the Bayes regret bound by M . However, in this problem φe is not bounded since it is sampled from a Gaussian distribution. We believe that Theorem 1 can be extended to this case by exploiting the properties of Gaussian distribution. Roughly speaking, in this problem, with high probability, ‖φe‖2 = O( √ d).\nCombUCB1 (Kveton et al., 2015b). This algorithm estimates the probability that person e accepts the offer w̄(e) independently of the other probabilities. The third baseline is CombLinTS without linear generalization, which we simply refer to as CombTS. As in CombUCB1, this algorithm estimates the probability that person e accepts the offer w̄(e) independently of the other probabilities. The posterior of w̄(e) is modeled as a beta distribution.\nOur experiment results are reported in Figure 2. We observe two major trends. First, CombLinTS learns extremely quickly. In particular, its per-step return at episode 100 is 70% of the optimum, and its per-step return at episode 1k is 80% of the optimum. These results are remarkable since the linear generalization is imperfect in this problem. Second, both CombUCB1 and CombTS perform poorly due to insufficient observations with respect to the model complexity. Specifically, in 1k episodes, the people in E are observed 100k times, which implies that each person is observed only 3 times on average. This is not enough to discriminate the people who are likely to accept the advertisement offer from those that are not."
    }, {
      "heading" : "6.3. Artist Recommendation",
      "text" : "In the last experiment, we evaluate CombLinTS on a problem of recommending K = 10 music artists that are most likely to be chosen by an average user of a music recommendation website. Specifically, the ground set E include artists from the Last.fm music recommendation dataset (Cantador et al., 2011). The dataset contains tagging and music artist listening information from a set of 2k users from Last.fm online music system6. The tagging part includes the tag assignments of all artists provided by the users. For each user, the artists to whom she listened and the number of listening events are also available in the dataset.\n6http://www.lastfm.com\nWe choose E as the set of artists that were listened by at least two users and had at least one tag assignment among the top 20 most popular tags, and |E| ≈ 6k. For each artist e, we construct its feature vector φe ∈ [0, 1]20 by setting its jth component as the fraction of users who assigned tag j to this artist. We assume that each artist e is chosen by an average user with probability w̄(e) = 1|Ue| ∑ u∈Ue wu(e), where Ue is the set of users that listened to artist e, and w̄u(e) is the probability that user u likes artist e. We estimate w̄u(e) based on a Naı̈ve Bayes classifier with respect to the number of person/artist listening events.\nLike Section 6.2, we also compare CombLinTS to three baselines: the optimal solution Aopt, the CombUCB1 algorithm and the CombTS algorithm. Our experiment results are reported in Figure 3. Similarly as Figure 2, the expected per-step return of CombLinTS approaches that of Aopt much faster than CombUCB1 and CombTS. Moreover, both CombUCB1 and CombTS perform poorly due to the insufficient observations with respect to the model complexity: In 1k episodes, each artist is observed less than 2 times on average, which is not enough to discriminate most popular artists from less popular artists."
    }, {
      "heading" : "7. Conclusion",
      "text" : "We have proposed two learning algorithms, CombLinTS and CombLinUCB, for stochastic combinatorial semibandits with linear generalization. The main contribution of this work is two-fold: First, we have established Lindependent regret bounds for these two algorithms under reasonable assumptions, where L is the number of items. Second, we have also evaluated CombLinTS on a variety of problems. The experiment results in the first problem show that CombLinTS is scalable and robust, and the experiment results in the other two problems demonstrate the value of exploiting linear generalization in real-world settings.\nIt is worth mentioning that our results can be easily ex-\ntended to the contextual combinatorial semi-bandits with linear generalization. In a contextual combinatorial semibandit, the probability distribution P (and hence the expected weight w̄) also depends on a context x, which either follows an exogenous stochastic process or is adaptively chosen by an adversary. Assume that each state-item pair (x, e) is associated with a feature vector φx,e, then similar to Agrawal & Goyal (2013), both CombLinTS and CombLinUCB, as well as their analyses, can be generalized to the contextual combinatorial semi-bandits.\nWe leave open several questions of interest. One interesting open question is how to derive regret bounds for CombLinTS and CombLinUCB in the agnostic learning cases. Another interesting open question is how to extend the results to combinatorial semi-bandits with nonlinear generalization. We believe that our results can be extended to combinatorial semi-bandits with generalized linear generalization7, but leave it to future work."
    }, {
      "heading" : "A. Proof for Theorem 1",
      "text" : "To prove Theorem 1, we first prove the following theorem:\nTheorem 3. If (1) w̄ = Φθ∗, (2) the prior on θ∗ is N(0, λ2I), and (3) the noises are i.i.d. sampled from N(0, σ2), then under CombLinTS algorithm with parameter (Φ, λ, σ), then we have\nRBayes(n) ≤ 1 +Kλmin {√ ln ( λLn√\n2π\n) , √ d ln ( 2dKnλ√\n2π\n)}√ 2dn ln ( 1 + nKλ 2\nd ) ln ( 1 + λ 2\nσ2 ) . (11) Notice that Theorem 1 follows immediately from Theorem 3. Specifically, if λ ≥ σ, then we have\nBBayes(n) ≤ 1 +Kλmin {√ ln ( λLn√\n2π\n) , √ d ln ( 2dKnλ√\n2π\n)}√ 2dn log2 ( 1 + nKλ2\nd ) = Õ ( Kλ √ dnmin {ln(L), d} ) . (12)\nWe now outline the proof of Theorem 3, which is based on (Russo & Van Roy, 2013; Dani et al., 2008). LetHt denote the “history” (i.e. all the available information) by the start of episode t. Note that from the Bayesian perspective, conditioning on Ht, θ∗ and θt are i.i.d. drawn from N(θ̄t,Σt) (see (Russo & Van Roy, 2013)). This is because that conditioning on Ht, the posterior belief in θ∗ is N(θ̄t,Σt) and based on Algorithm 2, θt is independently sampled from N(θ̄t,Σt). Since ORACLE is a fixed combinatorial optimization algorithm (even though it can be independently randomized), and E,A,Φ are all fixed, then conditioning onHt, A∗ and At are also i.i.d., furthermore, A∗ is conditionally independent of θt, and At is conditionally independent of θ∗.\nTo simplify the exposition, ∀θ ∈ Rd and ∀A ⊆ E, we define\ng(A, θ) = ∑ e∈A 〈φe, θ〉 , (13)\nthen we have E[f(A∗,wt)|Ht, θ∗, θt, A∗, At] = g(A∗, θ∗) and E[f(At,wt)|Ht, θ∗, θt, A∗, At] = g(At, θ∗), hence we have E[Rt|Ht] = E[g(A∗, θ∗)− g(At, θ∗)|Ht]. We also define the upper confidence bound (UCB) function Ut : 2E → R as\nUt(A) = ∑ e∈A [〈 φe, θ̄t 〉 + c √ φTe Σtφe ] , (14)\nwhere c > 0 is a constant to be specified. Notice that conditioning on Ht, Ut is a deterministic function and A∗, At are i.i.d., then E[Ut(At)− Ut(A∗)|Ht] = 0 and\nE[Rt|Ht] = E[g(A∗, θ∗)− Ut(A∗)|Ht] + E [ Ut(A t)− g(At, θ∗) ∣∣Ht] . (15)\nOne key observation is that\nE [ Ut(A t)− g(At, θ∗) ∣∣Ht] (a)= ∑ e∈E E [ 1 { e ∈ At } [〈 φe, θ̄t − θ∗ 〉 + c √ φTe Σtφe ]∣∣∣∣Ht] (b) = ∑ e∈E E [ 1 { e ∈ At }∣∣Ht]E[〈φe, θ̄t − θ∗〉∣∣Ht]+ cE[∑ e∈At √ φTe Σtφe ∣∣∣∣∣Ht ]\n(c) = cE [∑ e∈At √ φTe Σtφe ∣∣∣∣∣Ht ] , (16)\nwhere (b) follows from the fact that At and θ∗ are conditionally independent, and (c) follows from E[θ∗|Ht] = θ̄t. Hence BBayes(n) = ∑n t=1 E[g(A∗, θ∗)− Ut(A∗)] + c ∑n t=1 E [∑ e∈At √ φTe Σtφe ] . We can show that (1)\nEfficient Learning in Large-Scale Combinatorial Semi-Bandits∑n t=1 E[g(A∗, θ∗)− Ut(A∗)] ≤ 1 if we choose\nc ≥ min {√ ln ( λLn√\n2π\n) , √ d ln ( 2dKnλ√\n2π\n)} , (17)\nand (2) ∑n t=1 E [∑ e∈At √ φTe Σtφe ] ≤ Kλ √ 2dn ln ( 1 + nKλ 2 d ) / ln ( 1 + λ 2 σ2 ) . Thus, the bound in Theorem 3 holds. Please refer to the remainder of this section for the full proof. A.1. Bound on ∑n t=1 E[g(A∗, θ∗)− Ut(A∗)]\nWe first prove that if we choose\nc ≥ min {√ ln ( λLn√\n2π\n) , √ d ln ( 2dKnλ√\n2π\n)} , (18)\nthen ∑n t=1 E[g(A∗, θ∗)− Ut(A∗)] ≤ 1. To prove this result, we use the following inequality for truncated Gaussian distribution.\nLemma 1. If X ∼ N(µ, s2), then we have\nE[X1{X ≥ 0}] = µ [ 1− ΦG ( −µ s )] + s√ 2π exp ( − µ 2 2s2 ) ,\nwhere ΦG is the cumulative distribution function (CDF) of the standard Gaussian distribution N(0, 1). Furthermore, if µ ≤ 0, we have E[X1{X ≥ 0}] ≤ s√ 2π exp ( − µ 2 2s2 ) .\nBased on Lemma 1, we can prove the following lemmas: Lemma 2. If c ≥ √ ln ( λLn√\n2π\n) , then we have ∑n t=1 E[g(A∗, θ∗)− Ut(A∗)] ≤ 1.\nProof. We have the following naive bound:\ng(A∗, θ∗)− Ut(A∗) = ∑ e∈A∗ [〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ] ≤ ∑ e∈A∗ [〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ] 1 {〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ≥ 0\n} ≤ ∑ e∈E [〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ] 1 {〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ≥ 0 } .\nNotice that conditioning on Ht, 〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe is a Gaussian random variable with mean −c √ φTe Σtφe and variance φTe Σtφe. Thus, from Lemma 1, we have\nEθ∗,A∗ [g(A∗, θ∗)− Ut(A∗)|Ht] (a) ≤ ∑ e∈E Eθ∗ [[〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ] 1 {〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ≥ 0 }∣∣∣∣Ht] (b)\n≤ ∑ e∈E\n√ φTe Σtφe\n2π exp\n( −c 2\n2 ) (c)\n≤ exp ( −c 2\n2 )∑ e∈E λ‖φe‖√ 2π ≤ exp ( −c 2 2 ) λL√ 2π , (19)\nwhere the last two inequalities follow from the fact that φTe Σtφe ≤ φTe Σ1φe ≤ λ2‖φe‖2 ≤ λ2, since ‖φe‖ ≤ 1 by assumption8. Thus we have\nE [ n∑ t=1 [g(A∗, θ∗)− Ut(A∗)] ] ≤ exp ( −c 2 2 ) nλL√ 2π . (20)\nIf we choose c ≥ √ 2 ln ( λLn√\n2π\n) , then we have E[ ∑n t=1 [g(A ∗, θ∗)− Ut(A∗)]] ≤ 1.\nLemma 3. If c ≥ √ d ln ( 2dKnλ√\n2π\n) , then we also have ∑n t=1 E[g(A∗, θ∗)− Ut(A∗)] ≤ 1.\nProof. We use v1, . . . , vd to denote a fixed set of d orthonormal eigenvectors of Σt, and Λ21, . . . ,Λ 2 d to denote the associated eigenvalues. Notice that for i 6= j, we have vTi Σtvj = Λ2i vTi vj = 0. ∀i = 1, . . . , d, we define vi+d = −vi and Λi+d = Λi, which allows us to define the following conic decomposition:\nφe = 2d∑ i=1 αeivi, ∀e ∈ E,\nsubject to the constraints that αei ≥ 0, ∀(e, i). Notice that αei’s are uniquely determined. Furthermore, for i and j s.t. |i− j| = d, by definition of conic decomposition, we have αeiαej = 0. In other words, αe is a d-sparse vector.\nSince we assume that ‖φe‖ ≤ 1, we have that ∑2d i=1 α 2 ei ≤ 1, ∀e ∈ E. Thus, for any e, we have that 〈 φe, θ ∗ − θ̄t 〉\n=∑2d i=1 αei 〈 vi, θ ∗ − θ̄t 〉 and\nφTe Σtφe = ( 2d∑ i=1 αeiv T i ) Σt  2d∑ j=1 αeivj  =\n2d∑ i=1 2d∑ j=1 αeiαejv T i Σtvj . (21)\nNotice that for i 6= j, if |i − j| 6= d, then vTi Σtvj = 0; on the other hand, if |i − j| = d, αeiαej = 0. Thus, if i 6= j, we have αeiαejv T i Σtvj = 0. Consequently,\nφTe Σtφe = 2d∑ i=1 α2eiv T i Σtvi = 2d∑ i=1 α2eiΛ 2 i .\nThus we have\n√ φTe Σtφe = √√√√ 2d∑ i=1 α2eiΛ 2 i ≥ 1√ d 2d∑ i=1 αeiΛi, (22)\nwhere the inequality follows from Cauchy-Schwartz inequality, specifically, define si = 1 if αeiΛi 6= 0, and si = 0 if αeiΛi = 0, then we have\n2d∑ i=1 αeiΛi = 2d∑ i=1 αeiΛisi ≤ √√√√ 2d∑ i=1 s2i √√√√ 2d∑ i=1 α2eiΛ 2 i ≤ √ d √√√√ 2d∑ i=1 α2eiΛ 2 i ,\n8Notice that in the derivation of Inequality (19), we implicitly assume that φTe Σtφe > 0, ∀e ∈ E. It is worth pointing out that the case with φTe Σtφe = 0 is a trivial case and this inequality still holds in this case.\nwhere the last inequality follows from the fact that αe is d-sparse. Thus, for any e, we have that\n〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ≤ 2d∑ i=1 αei 〈 vi, θ ∗ − θ̄t 〉 − c√ d 2d∑ i=1 αeiΛi. (23)\nConsequently, we have\n∑ e∈A∗ [〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ] ≤ 2d∑ i=1 (〈 vi, θ ∗ − θ̄t 〉 − cΛi√ d )(∑ e∈A∗ αei ) . (24)\nDefine Xi = 〈 vi, θ ∗ − θ̄t 〉 − cΛi√\nd , notice that conditioning onHt, we have Xi|Ht ∼ N\n( − cΛi√\nd ,Λ2i\n) . Hence we have\n∑ e∈A∗ 〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe (a) ≤ 2d∑ i=1 Xi [∑ e∈A∗ αei ] (b)\n≤ 2d∑ i=1 Xi1{Xi ≥ 0} [∑ e∈A∗ αei ] ,\nwhere the inequality (b) follows from the fact that Xi ≤ Xi1{Xi ≥ 0} and [∑ e∈A∗ αei ] ≥ 0. On the other hand, notice that |A∗| ≤ K\n∑ e∈A∗ αei ≤ √ |A∗| √∑ e∈A∗ α2ei ≤ √ |A∗| √√√√∑ e∈A∗ d∑ j=1 α2ej ≤ √ |A∗| √∑ e∈A∗ 1 = |A∗| ≤ K.\nSince Xi1{Xi ≥ 0} ≥ 0, we have\n∑ e∈A∗ 〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ≤ K 2d∑ i=1 Xi1{Xi ≥ 0} ,\nnotice that the RHS does not include A∗. Hence we have Eθ∗ [g(A∗, θ∗)− Ut(A∗)|Ht] = Eθ∗ [∑ e∈A∗ 〈 φe, θ ∗ − θ̄t 〉 − c √ φTe Σtφe ∣∣∣∣∣Ht ]\n≤ K 2d∑ i=1 Eθ∗ [Xi1{Xi ≥ 0}|Ht]\n≤ K 2d∑ i=1 Λi√ 2π exp ( − c 2 2d ) ≤ 2dKλ√ 2π exp ( − c 2 2d ) ,\nwhere the last inequality follows from the fact that Λi ≤ λ. Hence we have n∑ t=1 E[g(A∗, θ∗)− Ut(A∗)] ≤ 2dKnλ√ 2π exp ( − c 2 2d ) ,\nif we choose c ≥ √ 2d ln (\n2dKnλ√ 2π\n) , then we have ∑n t=1 E[f(A∗, θ∗)− Ut(A∗)] ≤ 1.\nCombining the results from Lemma 2 and 3, we have proved that if\nc ≥ min {√ ln ( λLn√\n2π\n) , √ d ln ( 2dKnλ√\n2π\n)} ,\nthen ∑n t=1 E[g(A∗, θ∗)− Ut(A∗)] ≤ 1.\nA.2. Bound on ∑n t=1 E [∑ e∈At √ φTe Σtφe ] In this subsection, we derive a bound on ∑n t=1 E [∑ e∈At √ φTe Σtφe ] . Our analysis is motivated by the analysis in (Dani\net al., 2008). Specifically, we provide a worst-case bound on ∑n t=1 ∑ e∈At √ φTe Σtφe, for any realization of random variable wt’s, θt’s, At’s, A∗, and θ∗. Lemma 4. ∑n t=1 ∑ e∈At √ φTe Σtφe ≤ Kλ √ dn log ( 1+nKλ 2 dσ2 ) log ( 1+λ 2\nσ2\n) .\nProof. To simplify the exposition, we define\nzt,k = √ φT atk Σtφatk . (25)\nFirst, notice that Σ−1t is the Gramian matrix and satisfies\nΣ−1t+1 = Σ −1 t +\n1\nσ2 |At|∑ k=1 φatkφ T atk . (26)\nHence for any t, k, we have that\ndet [ Σ−1t+1 ] ≥ det [ Σ−1t + 1\nσ2 φatkφ T atk\n] = det [ Σ − 12 t ( I + 1\nσ2 Σ\n1 2 t φatkφ T atk Σ 1 2 t ) Σ − 12 t ] = det [ Σ−1t ] det [ I + 1\nσ2 Σ\n1 2 t φatkφ T atk Σ 1 2 t\n] = det [ Σ−1t ]( 1 + 1\nσ2 φTatk Σtφatk ) = det [ Σ−1t ]( 1 + z2t,k σ2 ) . (27)\nHence we have that\n( det [ Σ−1t+1 ])|At| ≥ (det [Σ−1t ])|At| |A t|∏\nk=1\n( 1 +\nz2t,k σ2\n) . (28)\nRemark 1. This is where the extraO( √ K) factor arises. Notice that this extra factor is purely due to linear generalization. Specifically, if Φ = I , then Σt’s and Σ−1t ’s will be diagonal, and we have\ndet [ Σ−1t+1 ] = det [ Σ−1t ] |At|∏ k=1\n( 1 +\nz2t,k σ2\n) . (29)\nNotice that Equation 28 further implies that\n( det [ Σ−1t+1 ])K ≥ (det [Σ−1t ])K |A t|∏\nk=1\n( 1 +\nz2t,k σ2\n) , (30)\nsince det [ Σ−1t+1 ] ≥ det [ Σ−1t ] and |At| ≤ K. Recall that det [ Σ−11 ] = ( 1 λ2 )d , we have that\n( det [ Σ−1n+1 ])K ≥ (det [Σ−11 ])K n∏ t=1 |At|∏ k=1\n( 1 +\nz2t,k σ2\n) = 1\nλ2dK n∏ t=1 |At|∏ k=1\n( 1 +\nz2t,k σ2\n) . (31)\nOn the other hand, we have\ntrace [ Σ−1n+1 ] = trace  1 λ2 I + 1 σ2 n∑ t=1 |At|∑ k=1 φatkφ T atk  = d λ2 + 1 σ2 n∑ t=1 |At|∑ k=1 ‖φatk‖ 2 ≤ d λ2 + nK σ2 , (32)\nwhere the last inequality follows from the assumption that ‖φe‖ ≤ 1, ∀e ∈ E and |At| ≤ K. From the trace-determinant inequality, we have\n1 d trace\n[ Σ−1n+1 ] ≥ ( det [ Σ−1n+1 ]) 1 d ,\nwhich implies that\n( 1\nλ2 + nK dσ2\n)dK ≥ ( 1\nd trace\n[ Σ−1n+1 ])dK ≥ ( det [ Σ−1n+1 ])K ≥ 1 λ2dK n∏ t=1 |At|∏ k=1 ( 1 + z2t,k σ2 ) .\nTaking the logarithm, we have\ndK log ( 1 + nKλ2\ndσ2\n) ≥ n∑ t=1 |At|∑ k=1 log ( 1 + z2t,k σ2 ) . (33)\nNotice that z2t,k = φ T atk Σtφatk , hence we have that 0 ≤ z 2 t,k ≤ φTatkΣ1φatk ≤ λ 2‖φatk‖ 2 ≤ λ2. We have the following technical lemma:\nLemma 5. For any real number x ∈ [0, λ2], we have x ≤ λ 2 log ( 1+λ 2\nσ2 ) log (1 + xσ2 ). Proof. Define h(x) = λ 2\nlog ( 1+λ 2\nσ2 ) log (1 + xσ2 )−x, thus we only need to prove h(x) ≥ 0 for x ∈ [0, λ2]. Notice that h(x) is a strictly concave function for x ≥ 0, and h(0) = 0, h(λ2) = 0. From Jensen’s inequality, for any x ∈ (0, λ2), we have h(x) > 0.\nHence we have that\nn∑ t=1 |At|∑ k=1 z2t,k ≤ λ2 log ( 1 + λ 2 σ2 ) n∑ t=1 |At|∑ k=1 log\n( 1 +\nz2t,k σ2\n) ≤ dKλ2 log ( 1 + nKλ 2 dσ2 ) log ( 1 + λ 2\nσ2 ) (34) Finally, we have that\nn∑ t=1 |At|∑ k=1 zt,k ≤ √ nK √√√√ n∑ t=1 |At|∑ k=1 z2t,k ≤ Kλ √ dn log ( 1 + nKλ 2 dσ2 ) log ( 1 + λ 2 σ2 ) . (35)\nRecall that the above bound holds for any realization of random variables, thus, we have\nE [ n∑ t=1 [ Ut(A t)− g(At, θ∗) ]] = cE  n∑ t=1 |At|∑ k=1 zt,k  ≤ cKλ√dn log (1 + nKλ2d ) log ( 1 + λ 2 σ2\n) . With\nc = min {√ ln ( λLn√\n2π\n) , √ d ln ( 2dKnλ√\n2π\n)} , (36)\nand combining the results in the previous subsection, we have proved Theorem 3."
    }, {
      "heading" : "B. Proof for Theorem 2",
      "text" : "We start by writing an alternative formula for Σt and θ̄t. Notice that based on Algorithm 1, we have:\nΣ−1t = 1\nλ2 I +\n1\nσ2 t−1∑ τ=1 |Aτ |∑ k=1 φaτkφ T aτk\nΣ−1t θ̄t = 1\nσ2 t−1∑ τ=1 |Aτ |∑ k=1 φaτkwτ (a τ k) (37)\nInterested readers might refer to Appendix C for the derivation of Equation (37). The proof proceeds as follows. We first construct a confidence set of θ∗ based on the “self normalized bound” developed in (Abbasi-Yadkori et al., 2011). Then we derive a regret bound based on Lemma 4 derived above.\nB.1. Confidence Set\nOur construction of confidence set is motivated by the analysis in (Agrawal & Goyal, 2013). We start by defining some useful notation. Specifically, for any t = 1, 2, . . . , n, any k = 1, 2, . . . , |At|, we define\nηt,k = wt ( atk ) − w̄ ( atk ) .\nOne key observation is that ηt,k’s form a Martingale difference sequence (MDS)9 since w(e)’s are statistically independent under P . Moreover, since wt (atk) is bounded in interval [0, 1], ηt,k’s are sub-Gaussian with constant R = 1. We further define\nVt = σ2\nλ2 I + t−1∑ τ=1 |Aτ |∑ k=1 φaτkφ T aτk\nξt = t−1∑ τ=1 |Aτ |∑ k=1 φaτkητ,k\nAs we will see later, we define Vt and ξt to use the “self normalized bound” developed in (Abbasi-Yadkori et al., 2011) (see Theorem 1 of (Abbasi-Yadkori et al., 2011)). Notice that based on the above definition, we have Σ−1t = 1 σ2Vt, and\nθ̄t − θ∗ = Σt ( 1\nσ2 ξt −\n1 λ2 θ∗ ) .\nTo see why the second equality holds, notice that\nΣ−1t θ̄t = 1\nσ2 t−1∑ τ=1 |Aτ |∑ k=1 φaτk ( φTaτkθ ∗ + ητ,k ) = ( Σ−1t − 1\nλ2 I\n) θ∗ + 1\nσ2 ξt.\nHence, for any e ∈ E, we have\n∣∣〈φe, θ̄t − θ∗〉∣∣ = ∣∣∣∣φTe Σt( 1σ2 ξt − 1λ2 θ∗ )∣∣∣∣\n≤ ‖φe‖Σt ∥∥∥∥ 1σ2 ξt − 1λ2 θ∗ ∥∥∥∥\nΣt\n≤ ‖φe‖Σt\n[ 1\nσ2 ‖ξt‖Σt +\n1\nλ2 ‖θ∗‖Σt\n] ,\n9Note that the notion of “time” is indexed by a pair (t, k), and follows the lexicographical order.\nwhere the first inequality follows from the Cauchy-Schwarz inequality, and the second inequality follows from the triangular inequality. Notice that\n‖θ∗‖Σt ≤ ‖θ ∗‖Σ1 = λ ‖θ ∗‖2 , hence we have ∣∣〈φe, θ̄t − θ∗〉∣∣ ≤ ‖φe‖Σt [ 1σ2 ‖ξt‖Σt + 1λ ‖θ∗‖2 ] .\nMoreover, we have\n1\nσ2 ‖ξt‖Σt =\n1\nσ2 ‖ξt‖σ2V −1t =\n1 σ ‖ξt‖V −1t .\nSo we have ∣∣〈φe, θ̄t − θ∗〉∣∣ ≤ ‖φe‖Σt [ 1σ ‖ξt‖V −1t + 1λ ‖θ∗‖2 ] . (38)\nThe above inequality always holds. We now provide a high probability bound on ‖ξt‖V −1t , based on the “self normalized bound” proposed in (Abbasi-Yadkori et al., 2011). From Theorem 1 of (Abbasi-Yadkori et al., 2011), we know for any δ ∈ (0, 1), with probability at least 1− δ,\n‖ξt‖V −1t ≤\n√ 2 log ( det(Vt)1/2 det(V1)−1/2\nδ\n) ∀t = 1, 2, . . . .\nObviously, det (V1) = [ σ2\nλ2\n]d , on the other hand, we have\n[det(Vt)] 1/d ≤ trace(Vt) d = σ2 λ2 + 1 d t−1∑ τ=1 |Aτ |∑ k=1 ‖φaτk‖ 2 ≤ σ 2 λ2 + (t− 1)K d ,\nwhere the last inequality follows from the assumption that ‖φe‖ ≤ 1. Hence, for t ≤ n, we have\n[det(Vt)] 1/d ≤σ\n2\nλ2 + nK d .\nThus, with probability at least 1− δ, we have\n‖ξt‖V −1t ≤\n√ d log ( 1 + nKλ2\ndσ2\n) + 2 log ( 1\nδ\n) ∀t = 1, 2, . . . , n.\nThus, we have the following lemma:\nLemma 6. For any λ, σ > 0 and any δ ∈ (0, 1), with probability at least 1− δ, we have ∣∣〈φe, θ̄t − θ∗〉∣∣ ≤ ‖φe‖Σt [ 1\nσ\n√ d log ( 1 + nKλ2\ndσ2\n) + 2 log ( 1\nδ ) + ‖θ∗‖2 λ ] , (39)\nfor all t = 1, 2, . . . , n, and for all e ∈ E. Notice that ‖φe‖Σt = √ φTe Σtφe, thus, the above lemma immediately implies the following lemma:\nLemma 7. For any λ, σ > 0, any δ ∈ (0, 1), and any\nc ≥ 1 σ\n√ d log ( 1 + nKλ2\ndσ2\n) + 2 log ( 1\nδ ) + ‖θ∗‖2 λ ,\nwith probability at least 1− δ, we have〈 φe, θ̄t 〉 − c √ φTe Σtφe ≤ 〈φe, θ∗〉 ≤ 〈 φe, θ̄t 〉 + c √ φTe Σtφe,\nfor all e ∈ E and t = 1, 2, . . . n.\nNotice that\n〈φe, θ∗〉 ≤ 〈 φe, θ̄t 〉 + c √ φTe Σtφe\nis exactly w̄(e) ≤ ŵt(e).\nB.2. Regret Analysis\nWe define event G as\nG = {〈 φe, θ̄t 〉 − c √ φTe Σtφe ≤ 〈φe, θ∗〉 ≤ 〈 φe, θ̄t 〉 + c √ φTe Σtφe ∀e ∈ E, ∀t = 1, . . . , n } , (40)\nand use Ḡ to denote the complement of event G. Recall that Lemma 7 states that if\nc ≥ 1 σ\n√ d log ( 1 + nKλ2\ndσ2\n) + 2 log ( 1\nδ\n) + 1\nλ ‖θ∗‖2 , (41)\nthen P(G) ≥ 1− δ. Moreover, by definition, under event G, we have w̄(e) ≤ ŵt(e), for all t = 1, . . . , n and any e ∈ E.\nNotice that\nR(n) = n∑ t=1 E [∑ e∈A∗ wt(e)− ∑ e∈At wt(e) ]\n= n∑ t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ]\n=P (G) n∑ t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ∣∣∣∣∣G ] + P ( Ḡ ) n∑ t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ∣∣∣∣∣Ḡ ]\n≤ n∑ t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ∣∣∣∣∣G ] + P ( Ḡ ) nK,\nwhere the last inequality follows from the naive bound on the realized regret. If c satisfies inequality (41), we have P ( Ḡ ) ≤ δ, hence we have\nR(n) ≤ n∑ t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ∣∣∣∣∣G ] + nKδ.\nFinally, we bound ∑n t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ∣∣G] using a worst-case bound conditioning onG (worst-case over all the possible random realizations), notice that conditioning on G, we have∑\ne∈A∗ w̄(e) ≤ ∑ e∈A∗ ŵt(e) ≤ ∑ e∈At ŵt(e),\nwhere the first inequality follows from the definition of eventG, and the second inequality follows from thatAt is the exact solution of the combinatorial optimization problem (E,A, ŵt). Thus we have∑\ne∈A∗ w̄(e)− ∑ e∈At w̄(e) ≤ ∑ e∈At ŵt(e)− ∑ e∈At w̄(e)\n= ∑ e∈At [〈 φe, θ̄t − θ∗ 〉 + c √ φTe Σtφe ] ≤ 2c\n∑ e∈At √ φTe Σtφe,\nwhere the last inequality follows from the definition of G. Recall that from Lemma 4, we have\nn∑ t=1 ∑ e∈At √ φTe Σtφe ≤ Kλ\n√ dn log ( 1 + nKλ 2\ndσ2 ) log ( 1 + λ 2\nσ2 ) . Thus we have\nn∑ t=1 E [∑ e∈A∗ w̄(e)− ∑ e∈At w̄(e) ∣∣∣∣∣G ] ≤ 2cE [ n∑ t=1 ∑ e∈At √ φTe Σtφe ] ≤ 2cKλ √ dn log ( 1 + nKλ 2 dσ2 ) log ( 1 + λ 2 σ2\n) , which implies\nR(n) ≤ 2cKλ\n√ dn log ( 1 + nKλ 2\ndσ2 ) log ( 1 + λ 2\nσ2 ) + nKδ."
    }, {
      "heading" : "C. Technical Lemma",
      "text" : "In this section, we derive Equation (37). We first prove the following technical lemma:\nLemma 8. For any φ, θ̄ ∈ Rd, any positive definite Σ ∈ Rd×d, any σ > 0, and any w ∈ R, if we define\nΣnew = Σ− ΣφφTΣ\nφTΣφ+ σ2\nθ̄new =\n[ I − Σφφ T\nφTΣφ+ σ2\n] θ̄ + [ Σφ\nφTΣφ+ σ2\n] w,\nthen we have\nΣ−1new = Σ −1 +\n1\nσ2 φφT (42)\nΣ−1newθ̄new = Σ −1θ̄ +\n1\nσ2 φw. (43)\nProof. Notice that Equation (42) follows directly from the Woodbury matrix identity (matrix inversion lemma). We now prove Equation (43). Notice that we have\nθ̄new =\n[ I − Σφφ T\nφTΣφ+ σ2\n] θ̄ + [ Σφ\nφTΣφ+ σ2\n] w\n= [ Σ− Σφφ TΣ\nφTΣφ+ σ2\n] Σ−1θ̄ + [ Σφ\nφTΣφ+ σ2\n] w\n= ΣnewΣ −1θ̄ +\n[ Σφ\nφTΣφ+ σ2\n] w,\nthat is,\nΣ−1newθ̄new = Σ −1θ̄ +\n[ Σ−1newΣφ\nφTΣφ+ σ2\n] w. (44)\nNotice that\nΣ−1newΣφ =\n[ Σ−1 + 1\nσ2 φφT\n] Σφ = φ+ φTΣφ\nσ2 φ =\nσ2 + φTΣφ\nσ2 φ. (45)\nPlug Equation (45) into Equation (44), we have Equation (43).\nBased on Lemma 8, by mathematical induction, we have\nΣ−1t = Σ −1 1 +\n1\nσ2 t−1∑ τ=1 |Aτ |∑ k=1 φaτkφ T aτk\nΣ−1t θ̄t = Σ −1 1 θ̄1\n1\nσ2 t−1∑ τ=1 |Aτ |∑ k=1 φaτkwτ (a τ k) ,\nfurther noting that Σ1 = λ2I and θ̄1 = 0, we can derive Equation (37)."
    }, {
      "heading" : "D. A Variant of Theorem 2 for Approximation Algorithms",
      "text" : "By suitably redefining the realized regret, we can prove a variant of Theorem 2 in which ORACLE can be an approximation algorithm. Specifically, for a (possibly approximation) algorithm ORACLE, let A∗(w) be the solution of ORACLE to the optimization problem (E,A,w), we say γ ∈ [0, 1) is a sub-optimality gap of ORACLE if\nf(A∗(w),w) ≥ (1− γ) max A∈A f(A,w), ∀w. (46)\nThen we define the (scaled) realized regret Rγt as\nRγt = f ( Aopt,wt ) − f (A t,wt)\n1− γ , (47)\nwhere Aopt is the exact solution to the optimization problem (E,A, w̄). The (scaled) cumulative regret Rγ(n) is defined as\nRγ(n) = n∑ t=1 E [Rγt |w̄] .\nUnder the assumptions that (1) the support of P is a subset of [0, 1]L (i.e. wt(e) ∈ [0, 1] ∀t and ∀e ∈ E), (2) the item weight w(e)’s are statistically independent under P , and (3) the oracle ORACLE has sub-optimality gap γ ∈ [0, 1), we have the following variant of Theorem 2 when CombLinUCB is applied to coherent learning cases:\nTheorem 4. For any λ, σ > 0, any δ ∈ (0, 1), and any c satisfying\nc ≥ 1 σ\n√ d ln ( 1 + nKλ2\ndσ2\n) + 2 ln ( 1\nδ ) + ‖θ∗‖2 λ , (48)\nif w̄ = Φθ∗ and the above two assumptions hold, then under CombLinUCB algorithm with parameter (Φ, λ, σ, c), we have\nRγ(n) ≤ 2cKλ 1− γ\n√ dn ln ( 1 + nKλ 2\ndσ2 ) ln ( 1 + λ 2\nσ2 ) + nKδ. Proof. Notice that Lemma 7 in Section B.1 still holds. With G defined in Equation (40), we have\nRγ(n) = n∑ t=1 E [ ∑ e∈Aopt wt(e)− 1 1− γ ∑ e∈At wt(e) ]\n= n∑ t=1 E [ ∑ e∈Aopt w̄(e)− 1 1− γ ∑ e∈At w̄(e) ]\n=P (G) n∑ t=1 E [ ∑ e∈Aopt w̄(e)− 1 1− γ ∑ e∈At w̄(e) ∣∣∣∣∣G ] + P ( Ḡ ) n∑ t=1 E [ ∑ e∈Aopt w̄(e)− 1 1− γ ∑ e∈At w̄(e) ∣∣∣∣∣Ḡ ]\n≤ n∑ t=1 E [ ∑ e∈Aopt w̄(e)− 1 1− γ ∑ e∈At w̄(e) ∣∣∣∣∣G ] + P ( Ḡ ) nK,\nwhere the last inequality follows from the naive bound on Rγt . If c satisfies inequality (41), we have P ( Ḡ ) ≤ δ, hence we have\nRγ(n) ≤ n∑ t=1 E [ ∑ e∈Aopt w̄(e)− 1 1− γ ∑ e∈At w̄(e) ∣∣∣∣∣G ] + nKδ.\nFinally, we bound ∑n t=1 E [∑ e∈Aopt w̄(e)− 1 1−γ ∑ e∈At w̄(e) ∣∣∣G] using a worst-case bound conditioning on G (worstcase over all the possible random realizations), notice that conditioning on G, we have∑\ne∈Aopt w̄(e) ≤ ∑ e∈Aopt ŵt(e) ≤ max A∈A ∑ e∈A ŵt(e) ≤ 1 1− γ ∑ e∈At ŵt(e),\nwhere\n• The first inequality follows from the definition of event G. Specifically, under event G, w̄(e) ≤ ŵt(e) for all t = 1, . . . , n and all e ∈ E.\n• The second inequality follows from Aopt ∈ A.\n• The last inequality follows from At ← ORACLE(E,A, ŵt) and ORACLE has sub-optimality gap γ (see Equation (46)).\nThus we have\n∑ e∈Aopt w̄(e)− 1 1− γ ∑ e∈At w̄(e) ≤ 1 1− γ [∑ e∈At ŵt(e)− ∑ e∈At w̄(e) ]\n= 1 1− γ ∑ e∈At [〈 φe, θ̄t − θ∗ 〉 + c √ φTe Σtφe ] ≤ 2c\n1− γ ∑ e∈At √ φTe Σtφe,\nwhere the last inequality follows from the definition of G. Recall that from Lemma 4, we also have\nn∑ t=1 ∑ e∈At √ φTe Σtφe ≤ Kλ\n√ dn log ( 1 + nKλ 2\ndσ2 ) log ( 1 + λ 2\nσ2 ) . Putting the above inequalities together, we have proved the theorem."
    } ],
    "references" : [ {
      "title" : "Improved algorithms for linear stochastic bandits",
      "author" : [ "Abbasi-Yadkori", "Yasin", "Pál", "Dávid", "Szepesvári", "Csaba" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Abbasi.Yadkori et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Abbasi.Yadkori et al\\.",
      "year" : 2011
    }, {
      "title" : "Analysis of thompson sampling for the multi-armed bandit problem",
      "author" : [ "Agrawal", "Shipra", "Goyal", "Navin" ],
      "venue" : "In COLT 2012 - The 25th Annual Conference on Learning Theory, June",
      "citeRegEx" : "Agrawal et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Agrawal et al\\.",
      "year" : 2012
    }, {
      "title" : "Thompson sampling for contextual bandits with linear payoffs",
      "author" : [ "Agrawal", "Shipra", "Goyal", "Navin" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning,",
      "citeRegEx" : "Agrawal et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Agrawal et al\\.",
      "year" : 2013
    }, {
      "title" : "Regret in online combinatorial optimization",
      "author" : [ "Audibert", "Jean-Yves", "Bubeck", "Sebastien", "Lugosi", "Gabor" ],
      "venue" : "Mathematics of Operations Research,",
      "citeRegEx" : "Audibert et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Audibert et al\\.",
      "year" : 2014
    }, {
      "title" : "Using confidence bounds for exploitationexploration trade-offs",
      "author" : [ "Auer", "Peter" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Auer and Peter.,? \\Q2002\\E",
      "shortCiteRegEx" : "Auer and Peter.",
      "year" : 2002
    }, {
      "title" : "Second workshop on information heterogeneity and fusion in recommender systems (hetrec",
      "author" : [ "Cantador", "Iván", "Brusilovsky", "Peter", "Kuflik", "Tsvi" ],
      "venue" : "In Proceedings That is,",
      "citeRegEx" : "Cantador et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Cantador et al\\.",
      "year" : 2011
    }, {
      "title" : "Combinatorial bandits",
      "author" : [ "Cesa-Bianchi", "Nicolò", "Lugosi", "Gábor" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Cesa.Bianchi et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Cesa.Bianchi et al\\.",
      "year" : 2012
    }, {
      "title" : "An empirical evaluation of Thompson sampling",
      "author" : [ "Chapelle", "Olivier", "Li", "Lihong" ],
      "venue" : "In Neural Information Processing Systems,",
      "citeRegEx" : "Chapelle et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Chapelle et al\\.",
      "year" : 2011
    }, {
      "title" : "Combinatorial multi-armed bandit: General framework and applications",
      "author" : [ "Chen", "Wei", "Wang", "Yajun", "Yuan", "Yang" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning,",
      "citeRegEx" : "Chen et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2013
    }, {
      "title" : "Stochastic linear optimization under bandit feedback",
      "author" : [ "Dani", "Varsha", "Hayes", "Thomas", "Kakade", "Sham" ],
      "venue" : "In Proceedings of the 21st Annual Conference on Learning Theory, pp",
      "citeRegEx" : "Dani et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Dani et al\\.",
      "year" : 2008
    }, {
      "title" : "Adaptive submodular maximization in bandit setting",
      "author" : [ "Gabillon", "Victor", "Kveton", "Branislav", "Wen", "Zheng", "Eriksson", "Brian", "S. Muthukrishnan" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Gabillon et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Gabillon et al\\.",
      "year" : 2013
    }, {
      "title" : "Large-scale optimistic adaptive submodularity",
      "author" : [ "Gabillon", "Victor", "Kveton", "Branislav", "Wen", "Zheng", "Eriksson", "Brian", "S. Muthukrishnan" ],
      "venue" : "In Proceedings of the 28th AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Gabillon et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Gabillon et al\\.",
      "year" : 2014
    }, {
      "title" : "Combinatorial network optimization with unknown variables: Multi-armed bandits with linear rewards and individual observations",
      "author" : [ "Gai", "Yi", "Krishnamachari", "Bhaskar", "Jain", "Rahul" ],
      "venue" : "IEEE/ACM Transactions on Networking,",
      "citeRegEx" : "Gai et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Gai et al\\.",
      "year" : 2012
    }, {
      "title" : "Matrix factorization techniques for recommender systems",
      "author" : [ "Koren", "Yehuda", "Bell", "Robert", "Volinsky", "Chris" ],
      "venue" : "IEEE Computer,",
      "citeRegEx" : "Koren et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Koren et al\\.",
      "year" : 2009
    }, {
      "title" : "Matroid bandits: Fast combinatorial optimization with learning",
      "author" : [ "Kveton", "Branislav", "Wen", "Zheng", "Ashkan", "Azin", "Eydgahi", "Hoda", "Eriksson", "Brian" ],
      "venue" : "In Proceedings of the 30th Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Kveton et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kveton et al\\.",
      "year" : 2014
    }, {
      "title" : "Learning to act greedily: Polymatroid semi-bandits",
      "author" : [ "Kveton", "Branislav", "Wen", "Zheng", "Ashkan", "Azin", "Eydgahi", "Hoda", "Valko", "Michal" ],
      "venue" : "CoRR, abs/1405.7752,",
      "citeRegEx" : "Kveton et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kveton et al\\.",
      "year" : 2014
    }, {
      "title" : "Combinatorial Optimization",
      "author" : [ "Papadimitriou", "Christos", "Steiglitz", "Kenneth" ],
      "venue" : "Dover Publications, Mineola, NY,",
      "citeRegEx" : "Papadimitriou et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Papadimitriou et al\\.",
      "year" : 1998
    }, {
      "title" : "Learning to optimize via posterior sampling",
      "author" : [ "Russo", "Daniel", "Van Roy", "Benjamin" ],
      "venue" : "CoRR, abs/1301.2609,",
      "citeRegEx" : "Russo et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Russo et al\\.",
      "year" : 2013
    }, {
      "title" : "An informationtheoretic analysis of thompson",
      "author" : [ "Russo", "Daniel", "Van Roy", "Benjamin" ],
      "venue" : "sampling. CoRR,",
      "citeRegEx" : "Russo et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Russo et al\\.",
      "year" : 2014
    }, {
      "title" : "On the likelihood that one unknown probability exceeds another in view of the evidence of two samples",
      "author" : [ "W.R. Thompson" ],
      "venue" : null,
      "citeRegEx" : "Thompson,? \\Q1933\\E",
      "shortCiteRegEx" : "Thompson",
      "year" : 1933
    }, {
      "title" : "Efficient exploration and value function generalization in deterministic systems",
      "author" : [ "Wen", "Zheng", "Van Roy", "Benjamin" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Wen et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Wen et al\\.",
      "year" : 2013
    }, {
      "title" : "Sequential Bayesian search",
      "author" : [ "Wen", "Zheng", "Kveton", "Branislav", "Eriksson", "Brian", "Bhamidipati", "Sandilya" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning,",
      "citeRegEx" : "Wen et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Wen et al\\.",
      "year" : 2013
    }, {
      "title" : "Linear submodular bandits and their application to diversified retrieval",
      "author" : [ "Yue", "Yisong", "Guestrin", "Carlos" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Yue et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Yue et al\\.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "This class of learning problems was recently formulated as a combinatorial bandit/semi-bandit, depending on the feedback model (Audibert et al., 2014).",
      "startOffset" : 127,
      "endOffset" : 150
    }, {
      "referenceID" : 12,
      "context" : "Since then, many combinatorial bandit/semi-bandit algorithms have been proposed: for the stochastic setting (Gai et al., 2012; Chen et al., 2013; Russo & Van Roy, 2014; Kveton et al., 2015b); for the adversarial setting (Cesa-Bianchi & Lugosi, 2012; Audibert et al.",
      "startOffset" : 108,
      "endOffset" : 190
    }, {
      "referenceID" : 8,
      "context" : "Since then, many combinatorial bandit/semi-bandit algorithms have been proposed: for the stochastic setting (Gai et al., 2012; Chen et al., 2013; Russo & Van Roy, 2014; Kveton et al., 2015b); for the adversarial setting (Cesa-Bianchi & Lugosi, 2012; Audibert et al.",
      "startOffset" : 108,
      "endOffset" : 190
    }, {
      "referenceID" : 3,
      "context" : ", 2015b); for the adversarial setting (Cesa-Bianchi & Lugosi, 2012; Audibert et al., 2014; Neu & Bartók, 2013); and for subclasses of combinatorial problems, matroid and polymatroid bandits (Kveton et al.",
      "startOffset" : 38,
      "endOffset" : 110
    }, {
      "referenceID" : 20,
      "context" : ", 2014a;b), submodular maximization (Wen et al., 2013; Gabillon et al., 2013), and cascading bandits (Kveton et al.",
      "startOffset" : 36,
      "endOffset" : 77
    }, {
      "referenceID" : 10,
      "context" : ", 2014a;b), submodular maximization (Wen et al., 2013; Gabillon et al., 2013), and cascading bandits (Kveton et al.",
      "startOffset" : 36,
      "endOffset" : 77
    }, {
      "referenceID" : 19,
      "context" : "It is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al.",
      "startOffset" : 89,
      "endOffset" : 151
    }, {
      "referenceID" : 16,
      "context" : "It is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al.",
      "startOffset" : 71,
      "endOffset" : 192
    }, {
      "referenceID" : 9,
      "context" : "It is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al. (2008); AbbasiYadkori et al.",
      "startOffset" : 193,
      "endOffset" : 212
    }, {
      "referenceID" : 9,
      "context" : "It is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al. (2008); AbbasiYadkori et al. (2011)) , to combinatorial semi-bandits with linear generalization.",
      "startOffset" : 193,
      "endOffset" : 241
    }, {
      "referenceID" : 9,
      "context" : "It is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al. (2008); AbbasiYadkori et al. (2011)) , to combinatorial semi-bandits with linear generalization. In this paper, we propose two learning algorithms, Combinatorial Linear Thompson Sampling (CombLinTS) and Combinatorial Linear UCB (CombLinUCB), based on Thompson sampling and LinUCB. Both CombLinTS and CombLinUCB are computationally efficient, as long as the offline version of the combinatorial problem can be solved efficiently. The first major contribution of the paper is that we establish a Bayes regret bound on CombLinTS and a regret bound on CombLinUCB, under reasonable assumptions. Both bounds are L-independent, and sublinear in time. The second major contribution of the paper is that we evaluate CombLinTS on a variety of problems with thousands of items, and two of these problems are based on real-world datasets. We only evaluate CombLinTS since recent literature (Chapelle & Li, 2011) suggests that Thompson sampling algorithms usually outperform UCB-like algorithms in practice. Our experimental results demonstrate that CombLinTS is scalable, robust to the choice of algorithm parameters, and significantly outperforms the best of our baselines. It is worth mentioning that our derived L-independent regret bounds also hold in cases with L = ∞. Moreover, as we will discuss in Section 7, our proposed algorithms and their analyses can be easily extended to the contextual combinatorial semibandits. Finally, we briefly review some relevant papers. Gabillon et al. (2014) and Yue & Guestrin (2011) focus on submodular maximization with linear generalization.",
      "startOffset" : 193,
      "endOffset" : 1693
    }, {
      "referenceID" : 9,
      "context" : "It is relatively easy to extend many linear bandit algorithms, such as Thompson sampling (Thompson, 1933; Agrawal & Goyal, 2012; Russo & Van Roy, 2013) and Linear UCB (LinUCB, see Auer (2002); Dani et al. (2008); AbbasiYadkori et al. (2011)) , to combinatorial semi-bandits with linear generalization. In this paper, we propose two learning algorithms, Combinatorial Linear Thompson Sampling (CombLinTS) and Combinatorial Linear UCB (CombLinUCB), based on Thompson sampling and LinUCB. Both CombLinTS and CombLinUCB are computationally efficient, as long as the offline version of the combinatorial problem can be solved efficiently. The first major contribution of the paper is that we establish a Bayes regret bound on CombLinTS and a regret bound on CombLinUCB, under reasonable assumptions. Both bounds are L-independent, and sublinear in time. The second major contribution of the paper is that we evaluate CombLinTS on a variety of problems with thousands of items, and two of these problems are based on real-world datasets. We only evaluate CombLinTS since recent literature (Chapelle & Li, 2011) suggests that Thompson sampling algorithms usually outperform UCB-like algorithms in practice. Our experimental results demonstrate that CombLinTS is scalable, robust to the choice of algorithm parameters, and significantly outperforms the best of our baselines. It is worth mentioning that our derived L-independent regret bounds also hold in cases with L = ∞. Moreover, as we will discuss in Section 7, our proposed algorithms and their analyses can be easily extended to the contextual combinatorial semibandits. Finally, we briefly review some relevant papers. Gabillon et al. (2014) and Yue & Guestrin (2011) focus on submodular maximization with linear generalization.",
      "startOffset" : 193,
      "endOffset" : 1719
    }, {
      "referenceID" : 8,
      "context" : "Similarly to Chen et al. (2013), in this paper, we allow the agent to use any approximation / randomized algorithm ORACLE to solve (2), and denote its solution as A∗ = ORACLE(E,A,w).",
      "startOffset" : 13,
      "endOffset" : 32
    }, {
      "referenceID" : 13,
      "context" : "In particular, it is well known that the user-item matrix is typically low-rank (Koren et al., 2009) and that the value of an item can be written as a linear combination of its position in the latent space.",
      "startOffset" : 80,
      "endOffset" : 100
    }, {
      "referenceID" : 3,
      "context" : "This feedback model is known as semi-bandit (Audibert et al., 2014).",
      "startOffset" : 44,
      "endOffset" : 67
    }, {
      "referenceID" : 8,
      "context" : "Linear Generalization As we have discussed in Section 1, many provably efficient algorithms have been developed for various combinatorial semi-bandits of form (3) (Chen et al., 2013; Gai et al., 2012; Kveton et al., 2014a; Russo & Van Roy, 2014).",
      "startOffset" : 163,
      "endOffset" : 245
    }, {
      "referenceID" : 12,
      "context" : "Linear Generalization As we have discussed in Section 1, many provably efficient algorithms have been developed for various combinatorial semi-bandits of form (3) (Chen et al., 2013; Gai et al., 2012; Kveton et al., 2014a; Russo & Van Roy, 2014).",
      "startOffset" : 163,
      "endOffset" : 245
    }, {
      "referenceID" : 9,
      "context" : "Like existing literature on linear bandits (Dani et al., 2008; Abbasi-Yadkori et al., 2011), the analysis in this paper focuses on coherent learning cases.",
      "startOffset" : 43,
      "endOffset" : 91
    }, {
      "referenceID" : 0,
      "context" : "Like existing literature on linear bandits (Dani et al., 2008; Abbasi-Yadkori et al., 2011), the analysis in this paper focuses on coherent learning cases.",
      "startOffset" : 43,
      "endOffset" : 91
    }, {
      "referenceID" : 2,
      "context" : "Furthermore, Audibert et al. (2014) has derived an Ω( √ LKn) lower bound on adversarial combinatorial semi-bandits, while Kveton et al.",
      "startOffset" : 13,
      "endOffset" : 36
    }, {
      "referenceID" : 2,
      "context" : "Furthermore, Audibert et al. (2014) has derived an Ω( √ LKn) lower bound on adversarial combinatorial semi-bandits, while Kveton et al. (2014a) has derived an asymptotic Ω(L log(n)/∆) gap-dependent lower bound on stochastic combinatorial semi-bandits, where ∆ is the “gap”.",
      "startOffset" : 13,
      "endOffset" : 144
    }, {
      "referenceID" : 2,
      "context" : "Furthermore, Audibert et al. (2014) has derived an Ω( √ LKn) lower bound on adversarial combinatorial semi-bandits, while Kveton et al. (2014a) has derived an asymptotic Ω(L log(n)/∆) gap-dependent lower bound on stochastic combinatorial semi-bandits, where ∆ is the “gap”. However, in many modern combinatorial semi-bandit problems, L tends to be enormous. Thus, an O( √ L) regret is unacceptably large in these problems. On the other hand, in many practical problems, there exists a generalization model based on which the weight of one item can be (approximately) inferred based on the weights of other items. By exploiting such generalization models, an o( √ L) or even an L-independent cumulative regret might be achieved. In this paper, we assume that there is a (possibly imperfect) linear generalization model across the items. Specifically, we assume that the agent knows a generalization matrix Φ ∈ RL×d s.t. w̄ either lies in or is “close” to the subspace span [Φ]. We use φe to denote the transpose of the e-th row of Φ, and refer to it as the feature vector of item e. Without loss of generality, we assume that rank [Φ] = d. Similar to Wen & Van Roy (2013), we distinguish between the coherent learning cases, in which w̄ ∈ span [Φ], and the agnostic learning cases, in which w̄ / ∈ span [Φ].",
      "startOffset" : 13,
      "endOffset" : 1171
    }, {
      "referenceID" : 9,
      "context" : "We now outline the proof of Theorem 1, which is motivated by Russo & Van Roy (2013) and Dani et al. (2008). LetHt denote the “history” (i.",
      "startOffset" : 88,
      "endOffset" : 107
    }, {
      "referenceID" : 9,
      "context" : "It is well-known that the O( √ d) factor is due to linear generalization (Dani et al., 2008; Abbasi-Yadkori et al., 2011), and as is discussed in the appendix (see Remark 1), the extra O( √ K) factor is Audibert et al.",
      "startOffset" : 73,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "It is well-known that the O( √ d) factor is due to linear generalization (Dani et al., 2008; Abbasi-Yadkori et al., 2011), and as is discussed in the appendix (see Remark 1), the extra O( √ K) factor is Audibert et al.",
      "startOffset" : 73,
      "endOffset" : 121
    }, {
      "referenceID" : 2,
      "context" : "no generalization), Russo & Van Roy (2014) provides an O( √ LK log(L/K)n) upper bound on RBayes(n) when Thompson sampling is applied, and Audibert et al. (2014) provides an Ω( √ LKn) lower bound2.",
      "startOffset" : 138,
      "endOffset" : 161
    }, {
      "referenceID" : 0,
      "context" : ", 2008; Abbasi-Yadkori et al., 2011), and as is discussed in the appendix (see Remark 1), the extra O( √ K) factor is Audibert et al. (2014) focuses on the adversarial setting but the lower bound is stochastic.",
      "startOffset" : 8,
      "endOffset" : 141
    }, {
      "referenceID" : 0,
      "context" : "We first construct a confidence set G of θ∗ based on the “self normalized bound” developed in Abbasi-Yadkori et al. (2011). Then we decompose the regret over the high-probability “good” event G and the low-probability “bad” event Ḡ, where Ḡ is the complement of G.",
      "startOffset" : 94,
      "endOffset" : 123
    }, {
      "referenceID" : 0,
      "context" : "We first construct a confidence set G of θ∗ based on the “self normalized bound” developed in Abbasi-Yadkori et al. (2011). Then we decompose the regret over the high-probability “good” event G and the low-probability “bad” event Ḡ, where Ḡ is the complement of G. Finally, we bound the term associated with the event G based on the same worst-case bound on ∑n t=1 ∑ e∈At √ φe Σtφe used in the analysis for CombLinTS (see Lemma 4 in Appendix A), and bound the term associated with the event Ḡ based on a naive bound. Please refer to Appendix B for the detailed proof of Theorem 2. Notice that if we choose λ = σ = 1, δ = 1/(nK), and c as the lower bound specified in Inequality (9), then the regret bound derived in Theorem 2 is also Õ(Kd √ n). Compared with the lower bound derived in Audibert et al. (2014), this bound is at most Õ( √ Kd) larger.",
      "startOffset" : 94,
      "endOffset" : 809
    }, {
      "referenceID" : 5,
      "context" : "fm music recommendation dataset (Cantador et al., 2011).",
      "startOffset" : 32,
      "endOffset" : 55
    }, {
      "referenceID" : 9,
      "context" : "We now outline the proof of Theorem 3, which is based on (Russo & Van Roy, 2013; Dani et al., 2008).",
      "startOffset" : 57,
      "endOffset" : 99
    }, {
      "referenceID" : 9,
      "context" : "Our analysis is motivated by the analysis in (Dani et al., 2008).",
      "startOffset" : 45,
      "endOffset" : 64
    }, {
      "referenceID" : 0,
      "context" : "We first construct a confidence set of θ∗ based on the “self normalized bound” developed in (Abbasi-Yadkori et al., 2011).",
      "startOffset" : 92,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "As we will see later, we define Vt and ξt to use the “self normalized bound” developed in (Abbasi-Yadkori et al., 2011) (see Theorem 1 of (Abbasi-Yadkori et al.",
      "startOffset" : 90,
      "endOffset" : 119
    }, {
      "referenceID" : 0,
      "context" : ", 2011) (see Theorem 1 of (Abbasi-Yadkori et al., 2011)).",
      "startOffset" : 26,
      "endOffset" : 55
    }, {
      "referenceID" : 0,
      "context" : "We now provide a high probability bound on ‖ξt‖V −1 t , based on the “self normalized bound” proposed in (Abbasi-Yadkori et al., 2011).",
      "startOffset" : 105,
      "endOffset" : 134
    }, {
      "referenceID" : 0,
      "context" : "From Theorem 1 of (Abbasi-Yadkori et al., 2011), we know for any δ ∈ (0, 1), with probability at least 1− δ,",
      "startOffset" : 18,
      "endOffset" : 47
    } ],
    "year" : 2017,
    "abstractText" : "A stochastic combinatorial semi-bandit is an online learning problem where at each step a learning agent chooses a subset of ground items subject to combinatorial constraints, and then observes stochastic weights of these items and receives their sum as a payoff. In this paper, we consider efficient learning in large-scale combinatorial semi-bandits with linear generalization, and as a solution, propose two learning algorithms called Combinatorial Linear Thompson Sampling (CombLinTS) and Combinatorial Linear UCB (CombLinUCB). Both algorithms are computationally efficient as long as the offline version of the combinatorial problem can be solved efficiently. We establish that CombLinTS and CombLinUCB are also provably statistically efficient under reasonable assumptions, by developing regret bounds that are independent of the problem scale (number of items) and sublinear in time. We also evaluate CombLinTS on a variety of problems with thousands of items. Our experiment results demonstrate that CombLinTS is scalable, robust to the choice of algorithm parameters, and significantly outperforms the best of our baselines.",
    "creator" : "LaTeX with hyperref package"
  }
}