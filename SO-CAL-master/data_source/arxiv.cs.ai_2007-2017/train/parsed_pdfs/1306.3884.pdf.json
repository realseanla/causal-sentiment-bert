{
  "name" : "1306.3884.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "JOÃO LEITE" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "More recently, AGM revision has been successfully applied to a significantly more expressive semantic characterisation of logic programs based on SE-models. This is an important step, as it changes the focus from the evolution of a syntactic representation of a rule base to the evolution of its semantic content.\nIn this paper, we borrow results from the area of belief update to tackle the problem of updating (instead of revising) answer-set programs. We prove a representation theorem which makes it possible to constructively define any operator satisfying a set of postulates derived from Katsuno and Mendelzon’s postulates for belief update. We define a specific operator based on this theorem, examine its computational complexity and compare the behaviour of this operator with syntactic rule update semantics from the literature. Perhaps surprisingly, we uncover a serious drawback of all rule update operators based on Katsuno and Mendelzon’s approach to update and on SE-models.\nKEYWORDS: belief update, answer-set programs, rule update, SE-models, support, literal inertia"
    }, {
      "heading" : "1 Introduction",
      "text" : "Answer-Set Programming (ASP) (Gelfond and Lifschitz 1988; Baral 2003) is now widely recognised as a valuable approach to knowledge representation and reasoning, mostly due to its simple and well-understood declarative semantics, its rich expressive power, and the existence of efficient implementations.\nHowever, the dynamic character of many applications that can benefit from ASP calls for the development of ways to deal with the evolution of answer-set programs and the inconsistencies that may arise.\n∗ This is an extended version of (Slota and Leite 2010).\nar X\niv :1\n30 6.\n38 84\nv1 [\ncs .A\nI] 1\n7 Ju\nThe problems associated with knowledge evolution have been extensively studied, over the years, by different research communities, namely in the context of Classical Logic, and in the context of Logic Programming.\nThe former have been inspired, to a large extent, by the seminal work of Alchourrón, Gärdenfors and Makinson (AGM) who proposed a set of desirable properties of belief change operators, now called AGM postulates (Alchourrón et al. 1985). Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991). While revision deals with incorporating new information about a static world, update takes place when changes occurring in a dynamic world are recorded. Katsuno and Mendelzon formulated a separate set of postulates for update, now known as KM postulates.\nBoth AGM and KM postulates were later studied in the context of Logic Programming, only to find that their formulations based on a non-monotonic semantics, such as the answer sets, are inappropriate (Eiter et al. 2002). Like many belief change operators, earlier methods used to tackle rule updates were based on literal inertia (Alferes and Pereira 1996) but proved not sufficiently expressive. This led to the development of rule update semantics based on different intuitions, principles and constructions, when compared to their classical counterparts. For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour. Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al. 2007), or dependencies on default assumptions (Šefránek 2006; Krümpelmann and KernIsberner 2010; Šefránek 2011).\nThough useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour. For example, except for the semantics proposed in (Alferes et al. 2005; Šefránek 2011), a tautological update may influence the result under all of these semantics, a behaviour that is highly undesirable when considering knowledge updates. Other kinds of irrelevant updates are even more problematic and subject of ongoing research (Šefránek 2006; Šefránek 2011). But more important, the common feature of all of these semantics is that they make heavy use of the syntactic structure of programs and rules, making any analysis of their semantic properties a daunting task.\nRecently, AGM revision was reformulated in the context of Logic Programming in a manner analogous to belief revision in classical propositional logic, and specific revision operators for logic programs were investigated (Delgrande et al. 2008; Osorio and Cuevas 2007). Central to this novel approach are SE-models (Turner 2003) which provide a monotonic semantic characterisation of logic programs that is strictly more expressive than the answer-set semantics. Furthermore, two programs have the same set of SE-models if and only if they are strongly equivalent (Lifschitz et al. 2001), which means that programs P,Q with the same set of SE-models can be modularly replaced by one another, even in the presence of additional rules, without affecting the resulting answer sets.\nIndeed, these results constitute an important breakthrough in the research of answer-set\nprogram evolution. They change the focus from the syntactic representation of a program, where not all rules and literal occurrences are necessarily relevant to the meaning of the program as a whole, to its semantic content, i.e. to the information that the program is intended to represent.\nIn this paper, we follow a similar path, but to tackle the problem of answer-set program updates, instead of revision as in (Delgrande et al. 2008).\nUsing SE-models, we adapt the KM postulates to answer-set program updates and prove a representation theorem that provides a constructive characterisation of rule update operators satisfying the postulates, making it possible to define and evaluate any operator satisfying the postulates using an intuitive construction. We show how this constructive characterisation can be used by defining a concrete answer-set program update operator that can be seen as a counterpart of Winslett’s belief update operator (Winslett 1990) which satisfies the KM postulates and is commonly used in the literature.\nHowever, while investigating the operator’s properties, we uncover a serious drawback which, as it turns out, extends to all answer-set program update operators based on SE-models and Katsuno and Mendelzon’s approach to updates. This finding is very important as it guides the research on updates of answer-set programs away from the purely semantic approach materialised in AGM and KM postulates or, alternatively, to the development of semantic characterisations of answer-set programs, richer than SE-models, that are appropriate for describing their dynamic behaviour.\nThe remainder of this paper is structured as follows: In Section 2 we introduce the formal concepts that are necessary throughout the rest of the paper. Section 3 contains the reformulation of KM postulates for logic program updates and the representation theorem that establishes a general constructive characterisation of rule update operators obeying the postulates. We also show how this theorem can be used by defining a specific rule update operator that satisfies the postulates and we examine the computational complexity of query answering for this operator. In Section 4 we further analyse the previously defined operator and establish that all semantic rule update operators based on SE-models exhibit an undesired behaviour. We summarise our findings in Section 5."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We consider a propositional language over a finite set of propositional variables A and the usual set of propositional connectives to form propositional formulae. An objective literal is either an atom p or its negation ¬p. A Horn clause is a disjunction of at most one atom and zero or more negated atoms; a Horn formula is a conjunction of Horn clauses.\nA (propositional) interpretation is any subset of A and the set of all interpretations is I = 2A. We use the standard semantics for propositional formulae and denote the set of models of a formula φ by JφK. We also write J |= φ if J ∈ JφK. We say that a formula φ is complete if JφK is a singleton set. For formulae φ, ψ we say that φ is equivalent to ψ, denoted by φ ≡ ψ, if JφK = Jψ K, and that φ entails ψ, denoted by φ |= ψ, if JφK ⊆ Jψ K. As we are dealing with the finite case, every knowledge base can be expressed by a single formula."
    }, {
      "heading" : "2.1 Belief Update",
      "text" : "Update is a belief change operation that brings a knowledge base up to date when the world described by it changes (Keller and Winslett 1985; Katsuno and Mendelzon 1991). Formally, a belief update operator is a function that takes two formulae, representing the original knowledge base and its update, as arguments and returns a formula representing the updated knowledge base. To further specify the desired properties of update operators, the following eight postulates for a belief update operator and formulae φ, ψ, µ, ν were proposed in (Katsuno and Mendelzon 1991):\n(B1) φ µ |= µ. (B2) If φ |= µ, then φ µ ≡ φ. (B3) If JφK 6= ∅ and JµK 6= ∅, then Jφ µK 6= ∅. (B4) If φ ≡ ψ and µ ≡ ν, then φ µ ≡ ψ ν. (B5) (φ µ) ∧ ν |= φ (µ ∧ ν). (B6) If φ µ |= ν and φ ν |= µ, then φ µ ≡ φ ν. (B7) If φ is complete, then (φ µ) ∧ (φ ν) |= φ (µ ∨ ν). (B8) (φ ∨ ψ) µ ≡ (φ µ) ∨ (ψ µ).\nKatsuno and Mendelzon also proved an important representation theorem that makes it possible to define and evaluate any operator satisfying these postulates using an intuitive construction. It is based on treating the models of a knowledge base as possible real states of the modelled world. An update of an original knowledge base φ is performed by modifying each of its models as little as possible to make it consistent with new information in the update µ, obtaining a new set of interpretations – the models of the updated knowledge base. More formally,\nJφ µK = ⋃\nI∈JφK incorporate(JµK, I) ,\nwhere incorporate(M, I) returns the members ofM closer to I . A natural way of defining incorporate(M, I) is by assigning an order ≤I over I to each interpretation I and taking the minima ofM w.r.t. ≤I , i.e. incorporate(M, I) = min(M,≤I). In the following we first formally establish the concept of an order assignment; thereafter we define when an update operator is characterised by such an assignment.\nGiven a set S, a preorder over S is a reflexive and transitive binary relation over S; a strict preorder over S is an irreflexive and transitive binary relation over S; a partial order over S is a preorder over S that is antisymmetric. Given a preorder ≤ over S, we denote by < the strict preorder induced by ≤, i.e. s < t if and only if s ≤ t and not t ≤ s. For any subset T of S, the set of minimal elements of T w.r.t. ≤ is\nmin(T ,≤) = { s ∈ T | ¬∃t ∈ T : t < s } .\nDefinition 1 (Order assignment) Let S be a set. A preorder assignment over S is any function ω that assigns a preorder ≤sω over S to each s ∈ S. A partial order assignment over S is any preorder assignment ω over S such that ≤sω is a partial order over S for every s ∈ S.\nDefinition 2 (Belief update operator characterised by an order assignment) Let be a belief update operator and ω a preorder assignment over I. We say that is characterised by ω if for all formulae φ, µ,\nJφ µK = ⋃\nI∈JφK min\n( JµK,≤Iω ) . (1)\nA natural condition to impose on the assigned orders is that every interpretation be the closest to itself. This is captured by the notion of a faithful order assignment:\nDefinition 3 (Faithful order assignment (Katsuno and Mendelzon 1991)) A preorder assignment ω over I is faithful if for every interpretation I the following condition is satisfied:\nFor every J ∈ I with J 6= I it holds that I <Iω J .\nThe representation theorem of (Katsuno and Mendelzon 1991) states that operators characterised by faithful order assignments are exactly those that satisfy the KM postulates.\nTheorem 4 (Representation theorem for belief updates (Katsuno and Mendelzon 1991)) Let be a belief update operator. Then the following conditions are equivalent:\na) The operator satisfies conditions (B1) – (B8). b) The operator is characterised by a faithful preorder assignment. c) The operator is characterised by a faithful partial order assignment.\nKatsuno and Mendelzon’s results provide a framework for belief update operators, each specified on the semantic level by a faithful partial order assignment over I. The most influential instance of this framework is the Possible Models Approach (Keller and Winslett 1985; Winslett 1990), also referred to as Winslett’s belief update semantics, based on minimising the set of atoms whose truth value changes when an interpretation is updated. Formally, Winslett’s partial order assignment W is defined for all interpretations I , J , K by"
    }, {
      "heading" : "J ≤IW K if and only if (J ÷ I) ⊆ (K ÷ I) ,",
      "text" : "where ÷ denotes set-theoretic symmetric difference. It is not difficult to verify that W is a faithful partial order assignment, so it follows from Theorem 4 that any belief update operator characterised by W satisfies postulates (B1) – (B8). Note that there is a whole class of operators characterised by W that differ in the syntactic representation of updated belief bases. Insofar as we are interested in the semantic properties of Winslett’s updates, it follows from (B4) that it does not matter which operator from this class we pick. This is illustrated in the following example:\nExample 5 (Winslett’s belief update semantics) Consider the knowledge base φ = (p∧ (q ≡ r)) and the update µ = (q ∨ r) over the set of atoms A = { p, q, r }. Their sets of models are as follows:\nJφK = { { p } , { p, q, r } } , JµK = { { q } , { r } , { q, r } , { p, q } , { p, r } , { p, q, r } } .\nWhen performing an update of φ by µ under Winslett’s update semantics, equation (1) applies as follows:\nJφ µK = ⋃\nI∈JφK min\n( JµK,≤IW ) = min ( JµK,≤{ p }W ) ∪min ( JµK,≤{ p,q,r }W ) .\nThe models of µ that “differ least” from { p }, in the sense of the order assignment W, are { p, q } and { p, r }. Furthermore, since W is faithful, the unique model of µ that is minimally distant from { p, q, r } is { p, q, r } itself. Consequently,\nJφ µK = { { p, q } , { p, r } , { p, q, r } } .\nNote that from the syntactic viewpoint, φ µ can be any formula with the above set of models. Thus, it may for example be the case that φ µ = (p ∧ (q ∨ r)) while for another operator ′, also characterised by W, φ ′ µ = ((p ∧ q) ∨ (p ∧ r))."
    }, {
      "heading" : "2.2 Computational Complexity of Winslett’s Update Semantics",
      "text" : "Computationally, query answering for Winlett’s operator, i.e. the problem of deciding whether φ µ |= ψ, where is characterised by W, belongs to the second level of the polynomial hierarchy (Eiter and Gottlob 1992). We formulate this result formally as it later facilitates the study of computational complexity of a newly introduced rule update operator.\nAssuming that the reader is familiar with the classes NP and co-NP, we briefly introduce the polynomial hierarchy (Meyer and Stockmeyer 1972; Stockmeyer 1976). Its definition relies on the notion of an oracle: An oracle for a class of decision problems C can decide any problem in C in just one step of computation. We denote by NPC the class of decision problems solvable in polynomial time by a non-deterministic Turing machine that can make calls to an oracle for C. The classes ΣPi and Π P i of the polynomial hierarchy are defined inductively as follows: ΣP0 = Π P 0 = P and for all i ≥ 0,\nΣPi+1 = NP ΣPi and ΠPi+1 = co-Σ P i+1 .\nIn the general case, query answering for Winslett’s updates is ΠP2 -complete.\nTheorem 6 (Part of Theorem 6.4 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W. Deciding whether φ µ |= ψ for formulae φ, µ, ψ is ΠP2 -complete. Hardness holds even if φ is a conjunction of atoms and ψ is one of the atoms in that conjunction.\nHowever, when dealing only with Horn formulae, the problem drops to the first level of the polynomial hierarchy:\nTheorem 7 (Part of Theorem 7.2 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W. Deciding whether φ µ |= ψ for Horn formulae φ, µ, ψ is co-NP-complete. Hardness holds even if φ is a conjunction of objective literals and ψ is one of the literals in that conjunction."
    }, {
      "heading" : "2.3 Logic Programming",
      "text" : "We define the syntax and semantics of logic programs, borrowing some of the notation used in (Delgrande et al. 2008).\nAn atom is any p ∈ A. A literal is an atom p or its default negation ∼p. Given a set of literals S, we introduce the following notation:\nS+ = { p ∈ A | p ∈ S } , S− = { p ∈ A | ∼p ∈ S } , ∼S = { ∼p | p ∈ S ∩A } , ¬S = { ¬p | p ∈ S ∩A } .\nA rule is a pair of sets of literals π = (H(π), B(π)). We say that H(π) is the head of π and B(π) is the body of π. Usually, for convenience, we write π as\nH(π)+;∼H(π)− ← B(π)+,∼B(π)−. (2)\nOperators ‘;’ and ‘,’ express disjunctive and conjunctive connectives, respectively. A rule is called a fact if its head contains exactly one literal and its body is empty. A fact is positive if the literal in its head is an atom. A rule is non-disjunctive if its head contains at most one literal; definite if it is non-disjunctive and its head and body contain only atoms. A program is a set of rules. A program is non-disjunctive if all rules inside it are non-disjunctive; definite if all rules inside it are definite.\nTurning to the semantics, we need to define answer sets and SE-models of a logic program. We start by defining the more basic notion of a (classical) model of a logic program. For every rule π of the form (2) we denote by κ(π) the propositional formula∧\n(B(π)+ ∪ ¬B(π)−) ⊃ ∨ (H(π)+ ∪ ¬H(π)−) .\nFor a program P, κ(P) = ∧ π∈P κ(π). An interpretation J is a model of a program P, denoted by J |= P, if J |= κ(P). We say that P is consistent if it has some classical model.\nAn interpretation J is an answer set of a program P if it is a subset-minimal model of the reduct of P relative to J :\nPJ = { H(π)+ ← B(π)+. ∣∣ π ∈ P ∧H(π)− ⊆ J ∧B(π)− ∩ J = ∅ } . SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets. We use SE-models in the following sections to reformulate the KM postulates for belief update in the context of rule updates.\nIntuitively, each SE-interpretation assigns one of three truth values to every atom. Technically it consists of a pair of propositional interpretations, the first containing atoms that are true and the second containing atoms that are not false. Formally:\nDefinition 8 (SE-interpretation (Turner 2003)) An SE-interpretation is a pair of interpretations (I, J) such that I ⊆ J . The set of all SE-interpretations is denoted by X.\nSE-models themselves are defined by referring to the program reduct used to define answer sets above.\nDefinition 9 (SE-model (Turner 2003)) Let P be a program. An SE-interpretation (I, J) is an SE-model of P if J |= P and I |= PJ . The set of all SE-models of P is denoted by JP KSE and we write (I, J) |= P if (I, J) ∈ JP KSE.\nNote that J |= P if and only if (J, J) ∈ JP KSE, so SE-models capture the classical models of a program. And just like classical models, the set of SE-models of a program is monotonic, i.e. larger programs have smaller sets of SE-models. This is one of the important differences between SE-models and the non-monotonic answer sets.\nNevertheless, a program’s answer sets, just like its classical models, can be extracted from its set of SE-models: An interpretation J is an answer set of P if and only if (J, J) ∈ JP KSE and no (I, J) ∈ JP KSE with I ( J exists. This implies that programs with the same set of SE-models also have the same answer sets. Moreover, when such programs are augmented with the same set of rules, the resulting programs still have the same answer sets. In many situations such a property is desirable as it allows one program to be modularly replaced by another one, even in the presence of additional rules, without affecting the resulting answer sets. It is typically referred to as strong equivalence (Lifschitz et al. 2001) and the relationship between SE-models and strong equivalence is formally captured as follows:\nProposition 10 (SE-models and strong equivalence (Turner 2003)) Let P,Q be programs. It holds that JP KSE = JQKSE if and only if for every programR, the answer sets of P ∪R and Q∪R are the same.\nIn other words, SE-models exactly capture the concept of strong equivalence. This also explains the origin of the name SE-models – “SE” stands for strong equivalence. Based on this result, we define strong equivalence and entailment as follows:\nDefinition 11 (Strong equivalence and strong entailment) Let P, Q be programs. We say that P is strongly equivalent to Q, denoted by P ≡SE Q, if JP KSE = JQKSE, and that P strongly entails Q, denoted by P |=SE Q, if JP KSE ⊆ JQKSE.\nAn important distinguishing property of SE-models that we will need to carefully consider in the following sections is that whenever a program P has the SE-model (I, J), it also has the SE-model (J, J). More generally, any set of SE-interpretations with this property is referred to as well-defined (Delgrande et al. 2008).\nDefinition 12 (Well-defined set of SE-interpretations (Delgrande et al. 2008)) For every SE-interpretation X = (I, J) we denote by X∗ the SE-interpretation (J, J). A set of SE-interpretationsM is well-defined if for every SE-interpretation X , X ∈ M implies X∗ ∈M.\nIn fact, as pinpointed in the following result, not only is the set of SE-models of a program well-defined, but every well-defined set of SE-interpretations is also the set of SE-models of some program.\nProposition 13 (Delgrande et al. 2008) A set of SE-interpretationsM is well-defined if and only ifM = JP KSE for some program P.\nAs a consequence, whenever I ( J , there is no program that has the single SE-model X = (I, J), though there is a program that has the pair of SE-models X , X∗. The following notion of a basic program is thus analogous to the concept of a complete formula that is used in the formulation of belief update postulate (B7).\nDefinition 14 (Basic program) We say that a program P is basic if JP KSE = {X,X∗ } for some SE-interpretation X .\nNote that a program is basic if either it has a unique SE-model (J, J), or a pair of SE-models (I, J) and (J, J). In the former case, the program exactly determines the truth values of all atoms – the atoms in J are true and the remaining atoms are false. In the latter case, the program makes atoms in I true, the atoms in J \\ I may either be undefined or true, as long as they all have the same truth value, and the remaining atoms are false.\n3 Semantic Rule Updates Based on SE-Models\nWith the necessary concepts defined, we are ready to step forward and tailor the belief update postulates and operators to the context of logic programs viewed through their sets of SE-models. Since SE-models provide a monotonic characterisation of logic programs, the analysis provided in (Eiter et al. 2002), which showed KM postulates not appropriate for use with non-monotonic semantics, no longer applies. In the following we reformulate the belief update postulates as well as a constructive characterisation of semantic rule update operators, and finally show a counterpart of the representation theorem for belief updates. The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).\nSimilarly as in the case of belief updates, we liberally define a rule update operator as any function that takes two inputs, the original program and its update, and returns the updated program.\nDefinition 15 (Rule update operator) A rule update operator is a binary function on the set of all programs.\nIn order to reformulate postulates (B1) – (B8) for logic programs under the SE-model semantics, we first need to specify what a conjunction and disjunction of logic programs is. To this end, we introduce program conjunction and disjunction operators. These are required to assign, to each pair of programs, a program whose set of SE-models is the intersection and union, respectively, of the sets of SE-models of argument programs.\nDefinition 16 (Program conjunction and disjunction) A binary operator ∧̇ on the set of all programs is a program conjunction operator if for all programs P, Q,\nJP ∧̇ QKSE = JP KSE ∩ JQKSE .\nA binary operator ∨̇ on the set of all programs is a program disjunction operator if for all programs P, Q,\nJP ∨̇ QKSE = JP KSE ∪ JQKSE .\nIn the following we assume that some program conjunction and disjunction operators ∧̇, ∨̇ are given. Note that the program conjunction operator may simply return the union of argument programs; it is the same as the expansion operator defined in (Delgrande et al. 2008). A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).\nThe final obstacle before we can proceed with introducing the new postulates is the following: We need to substitute the notion of a complete formula used in (B7) with a suitable class of logic programs. It turns out that the notion of a basic program, as introduced in Definition 14, is a natural candidate for this purpose. While a complete formula is defined as having a unique model, a program is basic if it has either a unique SE-model (J, J), or a pair of SE-models (I, J) and (J, J). The latter case needs to be allowed in order to make the new postulate applicable to SE-interpretations (I, J) with I ( J because no program has the single SE-model (I, J) (c.f. Proposition 13).\nThe following are the reformulated postulates for a rule update operator⊕ and programs P, Q, U , V:\n(P1)SE P ⊕ U |=SE U . (P2)SE If P |=SE U , then P ⊕ U ≡SE P. (P3)SE If JP KSE 6= ∅ and JU KSE 6= ∅, then JP ⊕ U KSE 6= ∅. (P4)SE If P ≡SE Q and U ≡SE V , then P ⊕ U ≡SE Q⊕ V . (P5)SE (P ⊕ U) ∧̇ V |=SE P ⊕ (U ∧̇ V). (P6)SE If P ⊕ U |=SE V and P ⊕ V |=SE U , then P ⊕ U ≡SE P ⊕ V . (P7)SE If P is basic, then (P ⊕ U) ∧̇ (P ⊕ V) |=SE P ⊕ (U ∨̇ V). (P8)SE (P ∨̇ Q)⊕ U ≡SE (P ⊕ U) ∨̇ (Q⊕ U).\nNow we turn to a constructive characterisation of rule update operators satisfying conditions (P1)SE – (P8)SE. Analogically to belief updates, it is based on an order assignment, but this time over the set of all SE-interpretations X. Since the set of SE-models of a program must be well-defined, not every order assignment characterises a rule update operator. We thus additionally define well-defined order assignments as those that do.\nDefinition 17 (Rule update operator characterised by an order assignment) Let ⊕ be a rule update operator and ω a preorder assignment over X. We say that ⊕ is characterised by ω if for all programs P, U ,\nJP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤Xω ) .\nWe say that a preorder assignment over X is well-defined if some rule update operator is characterised by it.\nSimilarly as with belief update, we require the order assignment to be faithful, i.e. to consider each SE-interpretation the closest to itself.\nDefinition 18 (Faithful order assignment) A preorder assignment ω over X is faithful if for every SE-interpretation X the following condition is satisfied:\nFor every Y ∈ X with Y 6= X it holds that X <Xω Y .\nInterestingly, faithful assignments characterise the same class of operators as the larger class of semi-faithful assignments, defined as follows:\nDefinition 19 (Semi-faithful order assignment) A preorder assignment ω over X is semi-faithful if for every SE-interpretation X the following conditions are satisfied:\n1. For every Y ∈ X with Y 6= X and Y 6= X∗, either X <Xω Y or X∗ <Xω Y . 2. If X∗ ≤Xω X , then X ≤Xω X∗.\nFinally, we require the preorder assignment to satisfy one further condition, related to the well-definedness of sets of SE-models of every program. It can be seen as the natural semantic counterpart of (P7)SE.\nDefinition 20 (Organised order assignment) A preorder assignment ω is organised if for all SE-interpretations X , Y and all welldefined sets of SE-interpretationsM,N the following condition is satisfied:\nIf Y ∈ min(M,≤Xω ) ∪min(M,≤X ∗ ω ) and Y ∈ min(N ,≤Xω ) ∪min(N ,≤X ∗ ω ), then Y ∈ min(M∪N ,≤Xω ) ∪min(M∪N ,≤X ∗ ω ).\nNow we are ready to formulate the main result of this section:\nTheorem 21 (Representation theorem for rule updates) Let ⊕ be a rule update operator. The following conditions are equivalent:\na) The operator ⊕ satisfies conditions (P1)SE – (P8)SE. b) The operator ⊕ is characterised by a semi-faithful and organised preorder assignment. c) The operator ⊕ is characterised by a faithful and organised partial order assignment."
    }, {
      "heading" : "Proof",
      "text" : "See Appendix A, page 25.\nThis theorem provides a constructive characterisation of rule update operators satisfying the defined postulates. It facilitates the analysis of their properties, both semantic as well as computational. Note also that it implies that the larger class of semi-faithful and organised preorder assignments is equivalent to the smaller class of faithful and organised partial order assignments. Furthermore, it offers a strategy for defining operators satisfying the postulates that can be directly applied whenever an order assignment is known or can be approximated. This strategy is also complete in the sense that, up to strong equivalence, all operators satisfying the postulates can be characterised and distinguished by applying this strategy.\nIn what follows, we define a specific update operator based on the ideas underlying Winslett’s update semantics (Keller and Winslett 1985; Winslett 1990) defined Section 2. Similarly as was argued in (Delgrande et al. 2008), since we are working with well-defined sets of SE-interpretations, preference needs to be given to their second component. Thus, we extend the assignment W to all SE-interpretations X = (I, J), Y = (K1, L1), Z = (K2, L2) as follows: Y ≤XW Z if and only if the following conditions are satisfied:\n1. (L1 ÷ J) ⊆ (L2 ÷ J); 2. If (L1 ÷ J) = (L2 ÷ J), then (K1 ÷ I) \\∆ ⊆ (K2 ÷ I) \\∆ where ∆ = L1 ÷ J .\nIntuitively, first we compare the differences between the second components of Y and Z w.r.t. X . If they are equal, we compare the differences between the first components of Y and Z w.r.t. X , but now ignoring the differences between the second components. A concrete illustration of these comparisons is presented next:\nExample 22 (Assignment W for SE-interpretations) Let the SE-interpretations X , Y , Z1, Z2, Z3 be as follows:1\nX = (I, J) = (p, pq) , Y = (K,L) = (p, pr) ,\nZ1 = (K1, L1) = (p, prs) , Z2 = (K2, L2) = (∅, pr) , Z3 = (K3, L3) = (pr, pr) .\nWe can see that (L ÷ J) = { q, r } ( { q, r, s } = (L1 ÷ J), so it follows that Y ≤XW Z1 holds and it is not the case that Z1 ≤XW Y . Thus, Y <XW Z1.\nOn the other hand, (L÷ J) = (L2 ÷ J) = (L3 ÷ J) = ∆ = { q, r }, so Y and Z2 can only be distinguished based on the second condition. Furthermore, we have (K÷I)\\∆ = ∅ ( { p } = (K2 ÷ I) \\∆. Similarly as before, we obtain Y <XW Z2.\nA slightly different case occurs with Z3 because (K3÷ I) \\∆ = { r } \\ { q, r } = ∅ and it follows that both Y ≤XW Z3 and Z3 ≤XW Y hold, despite the fact that Y 6= Z3.\nOur following result shows that W indeed satisfies the necessary conditions to characterise rule update operators satisfying the reformulated postulates.\nProposition 23 The assignment W is a well-defined, faithful and organised preorder assignment."
    }, {
      "heading" : "Proof",
      "text" : "See Appendix A, page 29.\nFurthermore, as a consequence of Theorem 21 and Proposition 23:\nCorollary 24 Every rule update operator characterised by W satisfies conditions (P1)SE – (P8)SE.\nAs regards the computational complexity of query answering for rule update operators characterised by W, it follows the same pattern as query answering for Winslett’s belief update operator (c.f. Theorems 6 and 7). In the general case, it resides in the second level of the polynomial hierarchy while for definite programs it drops to the first level. Formally:\n1 For the sake of readability, we omit the usual set notation when listing SE-interpretations. For example, instead of ({ p } , { p, q }) we simply write (p, pq).\nTheorem 25 (Computational complexity of rule updates characterised by W) Let ⊕ be a rule update operator characterised by W. Deciding whether P ⊕ U |=SE Q for programs P, U , Q is ΠP2 -complete. Hardness holds even if P is a set of positive facts, U is a non-disjunctive program and Q contains a single fact from P."
    }, {
      "heading" : "Proof",
      "text" : "See Appendix A, page 34.\nTheorem 26 (Computational complexity of definite rule updates characterised by W) Let ⊕ be a rule update operator characterised by W. Deciding whether P ⊕ U |=SE Q for definite programs P, U , Q is co-NP-complete. Hardness holds even if P is a set of facts and Q contains a single fact from P."
    }, {
      "heading" : "Proof",
      "text" : "See Appendix A, page 35."
    }, {
      "heading" : "4 Support in Semantic Rule Updates",
      "text" : "In this section we take a closer look at the behaviour of semantic rule update operators. One of the benefits of dealing with rule updates on the semantic level is that semantic properties that are rather difficult to show for syntax-based update operators are much easier to analyse and prove. For example, one of the most widespread and counterintuitive side effects of syntactic updates is that they are sensitive to tautological updates. In case of semantic update operators, such a behaviour is easily shown to be impossible given that the operator satisfies (P2)SE.\nHowever, semantic update operators do not always behave the way we expect. Consider first an example using some update operator ⊕ characterised by the order assignment W defined in the previous section:2\nExample 27 Let the programs P, Q and U be as follows:\nP : p. Q : p← q. U : ∼q. q. q.\nIt can be easily verified that:\nJP ⊕ U K SE = JQ⊕ U K SE = { (p, p) } .\nHence, both P⊕U andQ⊕U have the single answer set J = { p }. In case of P⊕U this is indeed the expected result. But in case ofQ⊕U we can see that p is true in J even though there is no rule in Q ∪ U justifying it, i.e. there is no rule with p in its head and its body\n2 It has been shown that Winslett’s update semantics has some drawbacks, just as other update operators previously proposed in the context of Classical Logic do (see (Herzig and Rifi 1999) for a survey). Nevertheless, we decided to choose Winslett’s update operator as the basis to define a rule update operator and illustrate its properties because it is one of the most extensively studied and understood update operators, and because the undesired behaviour illustrated in this example is shared by all update operators based on KM postulates and SE-models – as we shall see – and not a specific problem due to our choice of Winslett’s operator.\nsatisfied in J . This means that the behaviour of ⊕ is in discord with intuitions underlying most Logic Programming semantics.\nIn the following we show that such counterintuitive behaviour is not specific to ⊕, but extends to all semantic update operators for answer-set programs based on the wellestablished notions of SE-models and KM postulates. This is especially interesting from the point of view of comparison with syntax-based approaches to rule updates that, as we formally pinpoint in what follows, do not suffer from such drawbacks.\nThe property of support (Apt et al. 1988; Dix 1995b) is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy. In the static case, this property can be formulated as follows:\nDefinition 28 (Static support) Let P be a program, p an atom and J an interpretation. We say that P supports p in J if there is some rule π ∈ P such that p ∈ H(π) and J |= B(π).\nA Logic Programming semantics S is supported if for each model J of a program P under S the following condition is satisfied: Every atom p ∈ J is supported by P in J .\nA supported semantics thus requires all atoms in an assigned model to be in the head of some rule with a satisfied body, ensuring that no atom is true without at least some justification. Note that the widely accepted Logic Programming semantics, such as the answer-set and well-founded semantics, are supported (see (Dix 1995a; Dix 1995b) for more on properties of Logic Programming semantics).\nIt is only natural to require that rule update operators do not neglect this essential property which also gives rise to much of the intuitive appeal of Logic Programming systems. As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:\nDefinition 29 (Dynamic support) We say that a rule update operator⊕ respects support if the following condition is satisfied for all programs P, U and all answer sets J of P ⊕ U : Every atom p ∈ J is supported by P ∪ U in J .\nSo an update operator respects support if it returns only programs whose answer sets are supported by rules from either the original program or from its update. Similarly as in the case of static support, this amounts to the requirement that an atom may be true only if at least some justification can be found for it.\nAnother basic expectation from an update operator is the usual intuition regarding how facts should be updated by newer facts. It enforces the principle of literal inertia, but only for the case when both the initial program and its update are consistent sets of facts. Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:\nDefinition 30 (Fact update) We say that a rule update operator ⊕ respects fact update if for all consistent sets of facts P, U , the unique answer set of P ⊕ U is the interpretation\n{ p | (p.) ∈ P ∪ U ∧ (∼p.) /∈ U } .\nThus, a rule update operator respects fact update if it is well-behaved w.r.t. consistent sets of facts: it provides the answer set that contains exactly those atoms that are asserted as true in either the original program or its update, and are not asserted as false in the update. This behaviour is widely accepted – it stems from the intuitions regarding database updates and is uncontroversial in both the belief change and rule change communities.\nWe conjecture that any reasonable update operator for answer-set programs should satisfy support and fact update since these two properties place basic constraints on its behaviour and are based on fundamental and widely accepted intuitions. They are by no means exhaustive or sufficient – it is not difficult to define rule update operators that satisfy both of them but are sensitive to tautological updates or quickly end up in an inconsistent state without a possibility of recovery – but they both seem necessary, even elementary, properties of a well-behaved rule update operator. However, it turns out that every rule update operator based on SE-models, even if it satisfies only the basic postulate that enforces syntax independence, fails to comply with at least one of these two basic expectations.\nTheorem 31 A rule update operator that satisfies (P4)SE either does not respect support or it does not respect fact update."
    }, {
      "heading" : "Proof",
      "text" : "Let ⊕ be a rule update operator that satisfies (P4)SE and consider again the programs P, Q and U from Example 27. Since P is strongly equivalent to Q, by (P4)SE we obtain that P ⊕ U is strongly equivalent to Q⊕ U . Consequently, P ⊕ U has the same answer sets as Q⊕U . It only remains to observe that if⊕ respects fact update, then P⊕U has the unique answer set { p }. But then { p } is an answer set of Q ⊕ U in which p is unsupported by Q∪ U . Hence ⊕ does not respect support.\nSo any answer-set program update operator based on SE-models and the KM approach to belief update, as materialised in the fundamental principle (P4)SE, cannot respect two basic and desirable properties: support and fact update. We believe that this is a major drawback of such operators, severely diminishing their applicability.\nMoreover, the principle (P4)SE is also adopted for revision of answer-set programs based on SE-models in (Delgrande et al. 2008).3 This means that Theorem 31 extends to semantic program revision operators, such as those defined in (Delgrande et al. 2008): Whenever\n3 Note that the belief update postulate (B4), from which (P4)SE originates, is also one of the reformulated AGM postulates for belief revision (Katsuno and Mendelzon 1992). The original AGM framework (Alchourrón et al. 1985) assumes that the initial knowledge base B is closed w.r.t. logical consequence and the first AGM postulate requires that the result of revision also be a closed set. Under these assumptions, different knowledge bases cannot be equivalent and, as a consequence, the original AGM postulate corresponding to (B4) is ?5: If Cn(µ) = Cn(ν), then B ? µ = B ? ν (where Cn is the logical consequence operator and ? the revision operator.)\nsupport and fact update are expected to be satisfied by a rule revision operator, it cannot be defined by purely manipulating the sets of SE-models of the underlying programs.\nOne question that suggests itself is whether a weaker version of the principle (P4)SE can be combined with properties such as support and fact update. Its two immediate weakenings, analogous to the weakenings of (B4) in (Herzig and Rifi 1999), are as follows:\n(P4.1)SE If P ≡SE Q, then P ⊕ U ≡SE Q⊕ U . (P4.2)SE If U ≡SE V , then P ⊕ U ≡SE P ⊕ V .\nIn case of (P4.1)SE, it is easy to see that the proof of Theorem 31 applies in the same way as with (P4)SE, so (P4.1)SE is likewise incompatible with support and fact update.\nOn the other hand, principle (P4.2)SE, also referred to as Weak Independence of Syntax (WIS) (Osorio and Cuevas 2007), does not suffer from such severe limitations. It is, nevertheless, violated by syntax-based rule update semantics that assign a special meaning to occurrences of default literals in heads of rules, as illustrated in the following example:\nExample 32 Let the programs P, U and V be as follows:\nP : p. U : ∼p← q. V : ∼q ← p. q.\nSince U is strongly equivalent to V , (P4.2)SE requires that P ⊕ U be strongly equivalent to P⊕V . This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal ∼p in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true. A consequence of this is that an update of P by U results in the single answer set { q } while an update by V leads to the single answer set { p }.\nThus, when considering the principle (P4.2)SE, benefits of the declarativeness that it brings with it need to be weighed against the loss of control over the results of updates by rules with default literals in their heads.\nThe problems we identified might be mitigated if a richer semantic characterisation of logic programs was used instead of SE-models. Such a characterisation would have to be able to distinguish between programs such as P = { p., q. } and Q = { p← q., q. } because they are expected to behave differently when subject to evolution.\nAnother alternative is to use one of the syntactic approaches to rule updates, e.g. (Alferes et al. 2005), that have matured over the years."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper we revisited the problem of updates of answer-set programs, in an attempt to change the focus from the syntactic representation of a program to its semantic content and to facilitate the analysis of semantic properties of defined update operators. We did so by applying the established approach to updates following Katsuno and Mendelzon’s postulates in the context of logic programs. Whereas until recently this was not possible since these postulates were simply not applicable (nor adaptable) when considering\nnon-monotonic Logic Programming semantics, as shown in (Eiter et al. 2002), the introduction of SE-models (Turner 2003), which provide a monotonic characterisation of logic programs that is strictly more expressive than the answer-set semantics, provided a new opportunity to cast KM postulates into Logic Programming.\nWe adapted the KM postulates to be used for answer-set program updates and showed a representation theorem which provides a constructive characterisation of rule update operators satisfying the postulates. This characterisation not only facilitates the investigation of these operators’ properties, both semantic as well as computational, but it also provides an intuitive strategy for constructively defining these operators. This is one of the major contributions of the paper since it brings, for the first time, updates of answer-set programs in line with KM postulates. We illustrated this result with a definition of a specific rule update operator which is a counterpart of Winslett’s belief update operator.\nThe second important contribution of this paper is the uncovering of a serious drawback that extends to all answer-set program update operators based on SE-models and AGMstyle approach to program revision and update. All such operators violate at least one of two basic and very desirable properties. The first one consists of respecting support, a property that is enjoyed, in the static case, by all widely accepted Logic Programming semantics. The second property, fact update, is concerned with the answer set assigned to a consistent set of facts after it is updated by another consistent set of facts. This contribution is very important as it should guide further research on updates of answer-set programs\na) away from the purely semantic approach materialised in AGM and KM postulates, or b) to the development of semantic characterisations of answer-set programs that are richer than SE-models and appropriately capture their dynamic behaviour, such as in (Slota and Leite 2012), or even c) turning back to the more syntactic approaches, such as (Alferes et al. 2005), and see whether they indeed offer a viable alternative.\nEither way, updating answer-set programs is a very important theoretical and practical problem that is still waiting for a definite solution. Also, despite the issues with the syntax independence postulate (P4)SE, other principles based on SE-models play an important role with regards to the classification and evaluation of different approaches to rule change. For instance, the reformulations of rule change principles from (Eiter et al. 2002) in terms of strong equivalence, considered already in (Delgrande et al. 2008), can be formulated as follows:\n(Initialisation)SE ∅ ⊕ U ≡SE U . (Idempotence)SE P ⊕ P ≡SE P.\n(Tautology)SE If U ≡SE ∅, then P ⊕ U ≡SE P. (Absorption)SE If U ≡SE V , then (P ⊕ U)⊕ V ≡SE P ⊕ V . (Augmentation)SE If V |=SE U , then (P ⊕ U)⊕ V ≡SE P ⊕ V .\nWe believe that all of these properties are indeed desirable and strengthen their original formulations in an interesting way. Investigation of operators with these properties, as well as a further analysis of the postulates (P1)SE – (P8)SE, remains an important research topic.\nThis paper contains, we believe, a relevant contribution to a better understanding of rule change that will help guide future research."
    }, {
      "heading" : "Acknowledgement",
      "text" : "We would like to thank the anonymous reviewers for their valuable comments. M. Slota was supported by FCT scholarship SFRH/BD/38214/2007. J. Leite was partially supported by FCT funded project ERRO (PTDC/EIA-CCO/121823/2010)."
    }, {
      "heading" : "Appendix A Proofs: Representation Theorem",
      "text" : "Definition 33 (Program corresponding to a set of SE-interpretations) LetM be a set of SE-interpretations. We denote by ‖M‖ some arbitrary but fixed program P such that JP KSE = {X,X∗ | X ∈M } . Instead of ‖ {X1, X2, . . . , Xn } ‖ we usually write ‖X1, X2, . . . , Xn‖.\nDefinition 34 (Order assignment generated by an update operator) Let ⊕ be a rule update operator and X an SE-interpretation. We define the binary relation ≺X⊕ for all SE-interpretations Y , Z as follows: Y ≺X⊕ Z if and only if the following conditions are satisfied:\nY ∈ J‖X‖ ⊕ ‖Y,Z‖KSE (A1) Z /∈ J‖X‖ ⊕ ‖Y,Z‖KSE (A2) If Y 6= Y ∗, then Z ∈ J‖X‖ ⊕ ‖Y ∗, Z‖KSE (A3)\nThe preorder assignment generated by⊕ assigns to every SE-interpretationX the reflexive and transitive closure≤X⊕ of≺X⊕ , i.e. Y ≤X⊕ Z if and only if Y = Z or there is some n ≥ 2 and SE-interpretations Y1, Y2, . . . , Yn such that Y = Y1 ≺X⊕ Y2 ≺X⊕ · · · ≺X⊕ Yn = Z.\nLemma 35 Let ⊕ be a rule update operator satisfying conditions (P1)SE – (P8)SE and X , Y , Z some SE-interpretations. If Y ≤X⊕ Z, then either Y = Z or Z /∈ J‖X‖ ⊕ ‖Y,Z‖KSE."
    }, {
      "heading" : "Proof",
      "text" : "Suppose that Y 6= Z. Then, by the definition of≤X⊕ , for some n ≤ 2 and SE-interpretations Y1, Y2, . . . , Yn it holds that Y = Y1 ≺X⊕ Y2 ≺X⊕ · · · ≺X⊕ Yn = Z. We will prove by induction on n that Yn /∈ J‖X‖ ⊕ ‖Y1, Yn‖KSE from which the desired result follows directly.\n1◦ For n = 2 this follows from Y1 ≺X⊕ Y2 by (A2). 2◦ We inductively assume that\nYn /∈ J‖X‖ ⊕ ‖Y1, Yn‖KSE (A4)\nand prove that Yn+1 /∈ J‖X‖ ⊕ ‖Y1, Yn+1‖KSE.\nWe know that Yn ≺X⊕ Yn+1, so by (A2) we obtain\nYn+1 /∈ J‖X‖ ⊕ ‖Yn, Yn+1‖KSE . (A5) Considering that the program ‖Y1, Yn, Yn+1‖∧̇‖Y1, Yn‖ is strongly equivalent to ‖Y1, Yn‖, by (P5)SE and (P4)SE we conclude that\n(‖X‖ ⊕ ‖Y1, Yn, Yn+1‖) ∧̇ ‖Y1, Yn‖ |=SE ‖X‖ ⊕ ‖Y1, Yn‖\nwhich, together with (A4), implies that\nYn /∈ J‖X‖ ⊕ ‖Y1, Yn, Yn+1‖KSE . (A6) Similarly, since the program ‖Y1, Yn, Yn+1‖ ∧̇ ‖Yn, Yn+1‖ is strongly equivalent to ‖Yn, Yn+1‖, by (P5)SE and (P4)SE we obtain that\n(‖X‖ ⊕ ‖Y1, Yn, Yn+1‖) ∧̇ ‖Yn, Yn+1‖ |=SE ‖X‖ ⊕ ‖Yn, Yn+1‖ ,\nand so due to (A5) it holds that\nYn+1 /∈ J‖X‖ ⊕ ‖Y1, Yn, Yn+1‖KSE . (A7) Now we consider two cases:\na) If Yn = Y ∗n , then (A6) and (P1)SE imply that\n‖X‖ ⊕ ‖Y1, Yn, Yn+1‖ |=SE ‖Y1, Yn+1‖ ; ‖X‖ ⊕ ‖Y1, Yn+1‖ |=SE ‖Y1, Yn, Yn+1‖ ,\nso by (P6)SE we can conclude that ‖X‖ ⊕ ‖Y1, Yn, Yn+1‖ is strongly equivalent to ‖X‖ ⊕ ‖Y1, Yn+1‖. But then the desired conclusion follows from (A7).\nb) If Yn 6= Y ∗n , then from (A3) we infer that\nYn+1 ∈ J‖X‖ ⊕ ‖Y ∗n , Yn+1‖KSE . (A8) Furthermore, from (A6) and (P1)SE we obtain\n‖X‖ ⊕ ‖Y1, Yn, Yn+1‖ |=SE ‖Y1, Y ∗n , Yn+1‖ ; ‖X‖ ⊕ ‖Y1, Y ∗n , Yn+1‖ |=SE ‖Y1, Yn, Yn+1‖ ,\nso by (P6)SE we can conclude that ‖X‖ ⊕ ‖Y1, Yn, Yn+1‖ is strongly equivalent to ‖X‖ ⊕ ‖Y1, Y ∗n , Yn+1‖ and, due to (A7), Yn+1 /∈ J‖X‖ ⊕ ‖Y1, Y ∗n , Yn+1‖KSE . Since ‖Y1, Y ∗n , Yn+1‖ is strongly equivalent to ‖Y1, Yn+1‖ ∨̇ ‖Y ∗n , Yn+1‖, it follows from (P4)SE and (P7)SE that either Yn+1 /∈ J‖X‖ ⊕ ‖Y1, Yn+1‖KSE or Yn+1 /∈ J‖X‖ ⊕ ‖Y ∗n , Yn+1‖KSE. The latter is impossible due to (A8).\nLemma 36 Let ⊕ be a rule update operator satisfying conditions (P1)SE – (P8)SE and X , Y , Z, some SE-interpretations. If Y ≮X⊕ Z, then the following conditions are satisfied: (1) If Y = Z∗, then Z ∈ J‖X‖ ⊕ ‖Y, Z‖KSE. (2) If Y = Y ∗ and Z ∈ J‖X‖ ⊕ ‖Z‖KSE, then Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE. (3) If Y 6= Y ∗ and Z ∈ J‖X‖ ⊕ ‖Y ∗, Z‖KSE, then Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE."
    }, {
      "heading" : "Proof",
      "text" : "First we show the following auxiliary statement: If Y = Z or Y /∈ J‖X‖ ⊕ ‖Y,Z‖KSE, then all three conditions are satisfied.\nFirst suppose that Y = Z. If Y = Z∗, then Y = Y ∗ = Z = Z∗, so it follows from (P1)SE and (P3)SE that J‖X‖⊕‖Y,Z‖KSE = J‖X‖⊕‖Z∗‖KSE = {Z∗ }, verifying condition (1). Furthermore, conditions (2) and (3) are satisfied because ‖Z‖ = ‖Y ∗, Z‖ = ‖Y,Z‖.\nNow suppose that Y /∈ J‖X‖ ⊕ ‖Y,Z‖KSE. If Y = Z∗, then it follows from (P1)SE and (P3)SE that Z ∈ J‖X‖ ⊕ ‖Y, Z‖KSE. If Y = Y ∗, then it follows from (P1)SE that\n‖X‖ ⊕ ‖Y,Z‖ |=SE ‖Z‖ and ‖X‖ ⊕ ‖Z‖ |=SE ‖Y, Z‖ ,\nso by (P6)SE we obtain that ‖X‖ ⊕ ‖Y,Z‖ ≡SE ‖X‖ ⊕ ‖Z‖. Hence, it follows from Z ∈ J‖X‖⊕‖Z‖KSE that Z ∈ J‖X‖⊕‖Y,Z‖KSE. On the other hand, if Y 6= Y ∗, then it follows from (P1)SE that\n‖X‖ ⊕ ‖Y, Z‖ |=SE ‖Y ∗, Z‖ and ‖X‖ ⊕ ‖Y ∗, Z‖ |=SE ‖Y, Z‖ ,\nso by (P6)SE we obtain that ‖X‖ ⊕ ‖Y,Z‖ ≡SE ‖X‖ ⊕ ‖Y ∗, Z‖. Hence it follows from Z ∈ J‖X‖ ⊕ ‖Y ∗, Z‖KSE that Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE.\nTurning to the proof of the lemma, note that since Y ≮X⊕ Z, either Y X⊕ Z orZ ≤X⊕ Y . In the former case, Y ⊀X⊕ Z, so, by the definition of ≺X⊕ , either Y /∈ J‖X‖ ⊕ ‖Y, Z‖KSE, so we can apply our auxiliary statement, or Z ∈ J‖X‖⊕ ‖Y,Z‖KSE as desired, or Y 6= Y ∗ and Z /∈ J‖X‖ ⊕ ‖Y ∗, Z‖KSE, in which case all three conditions are trivially satisfied. In the latter case it follows from Lemma 35 that either Y = Z or Y /∈ J‖X‖ ⊕ ‖Y,Z‖KSE, so the rest follows once again from the auxiliary statement.\nProposition 37 Let ⊕ be a rule update operator satisfying conditions (P1)SE – (P8)SE, X an SE-interpretation and U a program. Then,\nJ‖X‖ ⊕ U KSE = min ( JU KSE,≤X⊕ ) ."
    }, {
      "heading" : "Proof",
      "text" : "First take some Z ∈ J‖X‖ ⊕ U KSE. By (P1)SE, Z ∈ JU KSE. Suppose that Z is not minimal in JU KSE w.r.t. ≤X⊕ . Then there is some Y ∈ JU KSE such that Y <X⊕ Z. Thus, Y 6= Z, and by Lemma 35 we conclude that Z /∈ J‖X‖ ⊕ ‖Y,Z‖KSE. Considering that U ∧̇ ‖Y,Z‖ is strongly equivalent to ‖Y,Z‖, it follows from (P4)SE and (P5)SE that (‖X‖⊕U) ∧̇ ‖Y,Z‖ |=SE ‖X‖⊕‖Y, Z‖. Consequently, Z /∈ J‖X‖⊕U KSE, contrary to our assumption. Therefore, J‖X‖ ⊕ U KSE is a subset of min(JU KSE,≤X⊕ ).\nTo prove the converse inclusion, assume that Z is minimal in JU KSE w.r.t. ≤X⊕ and take some Y ∈ JU KSE. Note that Y ≮X⊕ Z, so we can use Lemma 36. We will show that Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE. We consider three cases:\na) If Y = Z∗, then Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE follows immediately from condition (1) of Lemma 36. b) If Y = Y ∗, then the previous case together with the fact that JU KSE is well-defined entails that Z ∈ J‖X‖ ⊕ ‖Z‖KSE and by condition (2) of Lemma 36 it follows that Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE.\nc) If Y 6= Y ∗, then the previous case together with the fact that JU KSE is well-defined entails that Z ∈ J‖X‖ ⊕ ‖Y ∗, Z‖KSE and by condition (3) of Lemma 36 it follows that Z ∈ J‖X‖ ⊕ ‖Y,Z‖KSE.\nThe choice of Y was arbitrary, so we have proven that Z ∈ J‖X‖ ⊕ ‖Y, Z‖KSE for all Y ∈ JU KSE. This means that by repeated application of (P7)SE, Z is an SE-model of the program\n‖X‖ ⊕ ∨̇\nY ∈JU KSE\n‖Y,Z‖\nand since U is strongly equivalent to the program ∨̇ Y ∈JU KSE ‖Y, Z‖, it follows from (P4)SE that Z ∈ J‖X‖ ⊕ U KSE.\nProposition 38 If a rule update operator⊕ satisfies conditions (P1)SE – (P8)SE, then the preorder assignment generated by ⊕ is semi-faithful and organised and it characterises ⊕."
    }, {
      "heading" : "Proof",
      "text" : "First we show that the assignment generated by ⊕ characterises ⊕. We know that P is strongly equivalent to the program ∨̇ X∈JP KSE ‖X‖, so by (P4)SE and repeated application of (P8)SE we obtain that P ⊕ U is strongly equivalent to the program∨̇ X∈JP KSE (‖X‖ ⊕ U) .\nFurthermore, Proposition 37 implies that J‖X‖ ⊕ U KSE = min ( JU KSE,≤X⊕ ) , so indeed\nJP ⊕ U KSE = ⋃\nX∈JP KSE\nJ‖X‖ ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤X⊕ ) . (A9)\nTo see that the assignment generated by ⊕ is semi-faithful, first take some SE-interpretations X , Y such that Y 6= X and Y 6= X∗. We need to show that either X <X⊕ Y or X∗ <X⊕ Y . The equation (A9) together with (P2)SE imply that\nJ‖X‖ ⊕ ‖Y ∗, X‖KSE = min ( {Y ∗, X,X∗ } ,≤X⊕ ) ∪min ( {Y ∗, X,X∗ } ,≤X ∗ ⊕ ) = {X,X∗ } ,\nJ‖X‖ ⊕ ‖Y,X‖KSE = min ( {Y, Y ∗, X,X∗ } ,≤X⊕ ) ∪min ( {Y, Y ∗, X,X∗ } ,≤X ∗ ⊕ ) = {X,X∗ } .\nThus, Y ∗ is not minimal within {Y ∗, X,X∗ } and Y is not minimal within {Y, Y ∗, X,X∗ } w.r.t. ≤X⊕ . In other words:\neither X <X⊕ Y ∗ or X∗ <X⊕ Y ∗ and (A10) either X <X⊕ Y or X ∗ <X⊕ Y or Y ∗ <X⊕ Y . (A11)\nIn case of the first two alternatives of (A11), we have already achieved our goal. The third alternative together with (A10) and transitivity of <X⊕ also concludes the proof of the first condition of semi-faithfulness. To see that the second condition holds as well, consider that\nby (P2)SE, J‖X∗‖ ⊕ ‖X‖KSE = {X∗ } and J‖X‖ ⊕ ‖X‖KSE = {X,X∗ }, so it follows from (A9) that\nX /∈ min({X,X∗ } ,≤X ∗ ⊕ ) and X ∈ min({X,X∗ } ,≤X⊕ ) ∪min({X,X∗ } ,≤X ∗ ⊕ ) .\nHence, X ∈ min({X,X∗ } ,≤X⊕ ). In other words, if X∗ ≤X⊕ X , then it must also be the case that X ≤X⊕ X∗. Consequently, the order assignment generated by ⊕ is semi-faithful.\nTo show that it is also organised, consider well-defined sets of SE-interpretations M, N , and SE-interpretations X , Y such that\nY ∈ min ( M,≤X⊕ ) ∪min ( M,≤X ∗ ⊕ ) and Y ∈ min ( N ,≤X⊕ ) ∪min ( N ,≤X ∗ ⊕ ) .\nBy (A9) we obtain that Y ∈ J‖X‖ ⊕ ‖M‖KSE and Y ∈ J‖X‖ ⊕ ‖N‖KSE. Applying (P7)SE and (P4)SE yields that Y ∈ J‖X‖ ⊕ ‖M ∪ N‖KSE. Consequently, by (A9), either Y ∈ min ( M∪N ,≤X⊕ ) or Y ∈ min ( M∪N ,≤X∗⊕ ) , so the order assignment generated by ⊕ is organised.\nLemma 39 Let ω be a semi-faithful preorder assignment and X an SE-interpretation. Then there is no SE-interpretation Y such that Y <Xω X ."
    }, {
      "heading" : "Proof",
      "text" : "We prove by contradiction. Suppose that Y <Xω X for some SE-interpretation Y . Clearly, Y 6= X due to irreflexivity of <Xω and Y 6= X∗ due to the second condition of semifaithfulness. Hence, Y 6= X and Y 6= X∗, so by the first condition of semi-faithfulness, either X <Xω Y or X ∗ <Xω Y . The former is in conflict with the irreflexivity of < X ω and in the latter case it follows by transitivity of <Xω that X ∗ <Xω X , contrary to the second condition of semi-faithfulness.\nProposition 40 Let ⊕ be a rule update operator. If ⊕ is characterised by a semi-faithful and organised preorder assignment, then it is also characterised by a faithful and organised partial order assignment."
    }, {
      "heading" : "Proof",
      "text" : "Let ⊕ be characterised by a semi-faithful and organised preorder assignment ω. We define the assignment ω′ over X as follows:"
    }, {
      "heading" : "Y ≤Xω′ Z if and only if Y = X ∨ Y = Z ∨ Y <Xω Z .",
      "text" : "We need to show that ≤Xω′ is a partial order for all X ∈ X, that ω′ is faithful and organised and that for all programs P, U ,\nJP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤Xω′ ) .\nNote that due to Lemma 39, the following holds for all SE-interpretations X , Y :\nIf Y ≤Xω′ X , then Y = X. (A12)\nOtherwise we would obtain that Y <Xω X which is in conflict with Lemma 39. Turning back to the main proof, reflexivity of ≤Xω′ follows directly by its definition. To show that≤Xω′ is antisymmetric, take some SE-interpretations Y1, Y2 such that Y1 ≤Xω′ Y2 and Y2 ≤Xω′ Y1. If Y1 = X , then Y2 ≤Xω′ X and it follows from (A12) that Y2 = X = Y1. The case when Y2 = X is symmetric. If Y1 6= X and Y2 6= X , then, by the definition of ≤Xω′ , either Y1 = Y2 as desired, or Y1 <Xω Y2 and Y2 <Xω Y1, which is in conflict with the transitivity and irreflexivity of <Xω .\nTurning to transitivity of ≤Xω′ , suppose that Y1 ≤Xω′ Y2 and Y2 ≤Xω′ Y3. We need to show that Y1 ≤Xω′ Y3. We consider three cases:\na) If Y1 = X , then Y1 ≤Xω′ Y3 by the definition of ≤Xω′ . b) If Y2 = X , then Y1 ≤Xω′ X , so Y1 = X due to (A12) and the previous case applies. c) If Y1 6= X and Y2 6= X , then the desired conclusion follows from the transitivity of\nequality and of <Xω .\nAs for faithfulness of ω′, suppose that Y 6= X . We have X ≤Xω′ Y by definition and Y Xω′ X follows from (A12).\nTo show that ω′ is organised, we prove the following property: For any well-defined set of SE-interpretationsM and any SE-interpretation X ,\nmin ( M,≤Xω′ ) ∪min ( M,≤X ∗ ω′ ) = min ( M,≤Xω ) ∪min ( M,≤X ∗ ω ) . (A13)\nFrom (A13) it follows that since ω is organised, ω′ must also be. Before we prove (A13), we need to note that Y <Xω′ Z holds if and only if Y ≤Xω′ Z and Z Xω′ Y , so according to the definition of ≤Xω′ ,"
    }, {
      "heading" : "Y <Xω′ Z if and only if (Y = X∨Y = Z∨Y <Xω Z)∧(Z 6= X∧Z 6= Y ∧Z 6<Xω Y ) .",
      "text" : "Due to Lemma 39 and the transitivity and irreflexivity of <Xω , this can be simplified to\nY <Xω′ Z if and only if (Y = X ∧ Y 6= Z) ∨ Y <Xω Z . (A14)\nComing back to the proof of (A13), we need to consider three cases:\na) If X /∈M and X∗ /∈M, then for all Y,Z ∈M, Y 6= X and Y 6= X∗, so by (A14),\nY <Xω′ Z if and only if Y < X ω Z and Y <\nX∗ ω′ Z if and only if Y < X∗ ω Z ,\nfrom which the desired conclusion follows directly. b) If X /∈M and X∗ ∈M, then for all Y,Z ∈M, Y 6= X , so by (A14),\nY <Xω′ Z if and only if Y < X ω Z .\nConsequently, min(M,≤Xω′) = min(M,≤Xω ), and by (A14) and semi-faithfulness of ω we obtain min(M,≤X∗ω′ ) = {X∗ } = min(M,≤X ∗\nω ). c) If X ∈M, then X∗ ∈M, and by (A14) and semi-faithfulness of ω,\n{X } ⊆ min ( M,≤Xω ) ⊆ {X,X∗ } , min ( M,≤X ∗ ω ) = {X∗ } ,\nmin ( M,≤Xω′ ) = {X } , min ( M,≤X ∗ ω′ ) = {X∗ } ,\nfrom which the desired conclusion follows straightforwardly.\nFinally, it follows from the assumption that ω characterises ⊕ and from (A13) that JP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤Xω ) =\n⋃ X∈JP KSE ( min ( JU KSE,≤Xω ) ∪min ( JU KSE,≤X ∗ ω )) =\n⋃ X∈JP KSE ( min ( JU KSE,≤Xω′ ) ∪min ( JU KSE,≤X ∗ ω′ )) =\n⋃ X∈JP KSE min ( JU KSE,≤Xω′ ) .\nProposition 41 Let ⊕ be a rule update operator. If ⊕ is characterised by a faithful and organised partial order assignment, then ⊕ satisfies conditions (P1)SE – (P8)SE."
    }, {
      "heading" : "Proof",
      "text" : "Let⊕ be characterised by a faithful and organised partial order assignment ω. We consider each condition separately:\n(P1)SE Since ω characterises ⊕, for all programs P, U , JP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤Xω ) ,\nso all elements of JP ⊕ U KSE belong to JU KSE. Equivalently, P ⊕ U |=SE U . (P2)SE Suppose that P |=SE U and take some X ∈ JP KSE ⊆ JU KSE. Since the preorder\nassignment is faithful, for all Y ∈ JU KSE with Y 6= X we have X <Xω Y . Consequently, min(JU KSE,≤Xω ) = {X } and so\nJP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤Xω ) = ⋃ X∈JP KSE {X } = JP KSE .\n(P3)SE Suppose that both JP KSE 6= ∅ and JU KSE 6= ∅. Then there is some X0 ∈ JP KSE and also some Y ∈ min(JU KSE,≤X0ω ), so we obtain\nY ∈ min ( JU KSE,≤X0ω ) ⊆ ⋃ X∈JP KSE min ( JU KSE,≤Xω ) = JP ⊕ U KSE .\nHence, JP ⊕ U KSE 6= ∅. (P4)SE If P ≡SE Q and U ≡SE V , then\nJP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤Xω ) = ⋃ X∈JQKSE min ( JV KSE,≤Xω ) = JQ⊕ V KSE .\nTherefore, P ⊕ U ≡SE Q⊕ V . (P5)SE Suppose that Y is an SE-model of (P⊕U) ∧̇ V . Then Y ∈ JV KSE and there is some\nSE-model X of P such that Y belongs to min(JU KSE,≤Xω ). Consequently, Y also belongs to min(JU KSE ∩ JV KSE,≤Xω ), so Y is an SE-model of P ⊕ (U ∧̇ V).\n(P6)SE Assume that P ⊕ U |=SE V and P ⊕ V |=SE U . We will prove by contradiction that P ⊕ U |=SE P ⊕ V . The other half can be proved similarly. So suppose that Y is an SE-model of P ⊕ U but not of P ⊕ V . Then there is some SE-model X of P such that\nY ∈ min(JU KSE,≤Xω ) . (A15)\nAt the same time, there must be some SE-model Z of V such that Z <Xω Y . Let Z0 be minimal w.r.t. ≤Xω among all such Z. Then by transitivity of <Xω we obtain that Z0 ∈ min(JV KSE,≤Xω ) and, consequently, Z0 is an SE-model of P⊕V . By the assumption we now obtain that Z0 is an SE-model of U . But since Z0 <Xω Y , this is in conflict with (A15).\n(P7)SE Suppose that P is strongly equivalent to ‖X‖ for some SE-interpretation X and Y is an SE-model of both P ⊕ U and P ⊕ V . We will show that Y is an SE-model of P ⊕ (U ∨̇ V). LetM = JU KSE and N = JV KSE. It follows that\nY ∈ min(M,≤Xω ) ∪min(M,≤X ∗ ω ) and Y ∈ min(N ,≤Xω ) ∪min(N ,≤X ∗ ω ) ,\nso since ω is organised, Y ∈ min(M∪ N ,≤Xω ) ∪ min(M∪ N ,≤X ∗\nω ). Consequently, Y is an SE-model of P ⊕ (U ∨̇ V).\n(P8)SE The following sequence of equations establishes the property: J(P ∨̇ Q)⊕ U KSE = ⋃\nX∈JP∨̇QKSE\nmin ( JU KSE,≤Xω ) =\n⋃ X∈JP KSE min ( JU KSE,≤Xω ) ∪ ⋃ X∈JQKSE min ( JU KSE,≤Xω ) = JP ⊕ U KSE ∪ JQ⊕ U KSE = J(P ⊕ U) ∨̇ (Q⊕ U)KSE\nTheorem 21. Let ⊕ be a rule update operator. The following conditions are equivalent:\na) The operator ⊕ satisfies conditions (P1)SE – (P8)SE. b) The operator ⊕ is characterised by a semi-faithful and organised preorder assignment. c) The operator ⊕ is characterised by a faithful and organised partial order assignment."
    }, {
      "heading" : "Proof of Theorem 21",
      "text" : "Follows from Propositions 38, 40 and 41."
    }, {
      "heading" : "Appendix B Proofs: Properties of the Assignment W",
      "text" : "Proposition 42 The assignment W is a preorder assignment."
    }, {
      "heading" : "Proof",
      "text" : "Recall that the assignment W is defined for all SE-interpretations X = (I, J), Y = (K1, L1), Z = (K2, L2) as follows: Y ≤XW Z if and only if\n1. (L1 ÷ J) ⊆ (L2 ÷ J); 2. If (L1 ÷ J) = (L2 ÷ J), then (K1 ÷ I) \\∆ ⊆ (K2 ÷ I) \\∆ where ∆ = L1 ÷ J .\nIn order to show that W is a preorder assignment, we need to prove that given an arbitrary SE-interpretation X = (I, J), ≤XW is a preorder over X. This holds if and only if ≤XW is reflexive and transitive. First we show reflexivity. Take some SE-interpretation Y = (K,L). By definition, Y ≤XW Y holds if and only if\n1. (L÷ J) ⊆ (L÷ J); 2. If (L÷ J) = (L÷ J), then (K ÷ I) \\∆ ⊆ (K ÷ I) \\∆ where ∆ = L÷ J .\nIt is not difficult to check that both conditions hold. To show transitivity, take some SE-interpretations Y1 = (K1, L1), Y2 = (K2, L2), Y3 = (K3, L3) such that Y1 ≤XW Y2 and Y2 ≤XW Y3. We need to show that Y1 ≤XW Y3. According to the definition of ≤XW we obtain\n1. (L1 ÷ J) ⊆ (L2 ÷ J); 2. If (L1 ÷ J) = (L2 ÷ J), then (K1 ÷ I) \\∆ ⊆ (K2 ÷ I) \\∆ where ∆ = L1 ÷ J ;\nand also\n1’ (L2 ÷ J) ⊆ (L3 ÷ J); 2’ If (L2 ÷ J) = (L3 ÷ J), then (K2 ÷ I) \\∆ ⊆ (K3 ÷ I) \\∆ where ∆ = L2 ÷ J .\nWe need to show the following two conditions:\n1∗ (L1 ÷ J) ⊆ (L3 ÷ J); 2∗ If (L1 ÷ J) = (L3 ÷ J), then (K1 ÷ I) \\∆ ⊆ (K3 ÷ I) \\∆ where ∆ = L1 ÷ J .\nIt can be seen that 1∗ follows from 1. and 1’ by transitivity of the subset relation. To show that 2∗ holds as well, suppose that (L1 ÷ J) = (L3 ÷ J). Then by 1. and 1’ we obtain that (L1 ÷ J) = (L2 ÷ J) = (L3 ÷ J) = ∆ and so by 2. and 2’ it holds that\n(K1 ÷ I) \\∆ ⊆ (K2 ÷ I) \\∆ ⊆ (K3 ÷ I) \\∆ .\nConsequently, 2∗ is also satisfied and the proof is finished.\nLemma 43 Let X = (I, J), Y = (K1, L1), Z = (K2, L2) be SE-interpretations. Then Y <XW Z holds if and only if one of the following conditions is satisfied:\na) (L1 ÷ J) ( (L2 ÷ J), or b) (L1 ÷ J) = (L2 ÷ J) and (K1 ÷ I) \\∆ ( (K2 ÷ I) \\∆ where ∆ = L1 ÷ J ."
    }, {
      "heading" : "Proof",
      "text" : "By definition, Y <XW Z holds if and only if Y ≤XW Z and it is not the case that Z ≤XW Y . This in turn holds if and only if the following two conditions hold\n1. (L1 ÷ J) ⊆ (L2 ÷ J); 2. If (L1 ÷ J) = (L2 ÷ J), then (K1 ÷ I) \\∆ ⊆ (K2 ÷ I) \\∆ where ∆ = L1 ÷ J .\nand one of the following conditions also holds:\ni) (L2 ÷ J) * (L1 ÷ J), or ii) (L2 ÷ J) = (L1 ÷ J) and (K2 ÷ I) \\∆ * (K1 ÷ I) \\∆ where ∆ = L2 ÷ J .\nIt is not difficult to verify that conditions 1., 2. and i) are together equivalent to a) and that conditions 1., 2. and ii) are together equivalent to b). This concludes our proof.\nProposition 44 The assignment W is well-defined."
    }, {
      "heading" : "Proof",
      "text" : "By definition we need to show that there is a rule update operator ⊕ such that for all programs P, U ,\nJP ⊕ U KSE = ⋃\nX∈JP KSE\nmin ( JU KSE,≤XW ) .\nThis holds if and only if for every well-defined set of SE-interpretations M and every SE-interpretation X , the set of SE-interpretations\nmin ( M,≤XW ) ∪min ( M,≤X ∗ W ) (B1)\nis well-defined. Suppose that Y belongs to (B1). We need to demonstrate that Y ∗ also belongs to (B1). We consider two cases:\n(a) Suppose that Y ∈ min(M,≤XW ). If Y ∗ belongs to min(M,≤X ∗\nW ), then we are finished. On the other hand, if Y ∗ does not belong to min(M,≤X∗W ), then there must be some Z ∈ M such that Z <X∗W Y ∗. Let Y = (K1, L1), Z = (K2, L2) and X = (I, J). By Lemma 43 we know that Z <X ∗\nW Y ∗ holds if and only if one of the\nfollowing conditions is satisfied:\na) (L2 ÷ J) ( (L1 ÷ J), or b) (L2 ÷ J) = (L1 ÷ J) and (K2 ÷ J) \\∆ ( (L1 ÷ J) \\∆ where ∆ = L2 ÷ J .\nIf a) is satisfied, then Lemma 43 implies that Z <XW Y which is in conflict with the assumption that Y ∈ min(M,≤XW ). So b) must hold. But in that case we infer that (K2 ÷ J) \\∆ is a proper subset of\n(L1 ÷ J) \\∆ = (L1 ÷ J) \\ (L1 ÷ J) = ∅ ,\nwhich is impossible. (b) Suppose that Y ∈ min(M,≤X∗W ) and let X = (I, J), Y = (K,L). First we show that\nY ∗ ≤X∗W Y holds – for this, the following conditions need to be satisfied:\n1. (L÷ J) ⊆ (L÷ J); 2. If (L÷ J) = (L÷ J), then (L÷ J) \\∆ ⊆ (K ÷ J) \\∆ where ∆ = L÷ J .\nIt is not difficult to verify that both conditions hold. Thus, since Y ∗ ≤X∗W Y , there can be no Z ∈ M with Z <X ∗ W Y ∗ because by transitivity we would obtain Z <X ∗\nW Y which would be in conflict with the assumption that Y ∈ min(M,≤X∗W ). So Y ∗ ∈ min(M,≤X ∗ W ) and our proof is finished.\nProposition 45 The assignment W is faithful."
    }, {
      "heading" : "Proof",
      "text" : "Take some SE-interpretations X = (I, J), Y = (K,L) such that Y 6= X . We need to show thatX <XW Y . By Lemma 43 this holds if and only if one of the following conditions is satisfied:\na) (J ÷ J) ( (L÷ J), or b) (J ÷ J) = (L÷ J) and (I ÷ I) \\∆ ( (K ÷ I) \\∆ where ∆ = J ÷ J .\nWe consider two cases:\ni) If L÷ J = ∅, then L = J and since Y 6= X , we conclude that K 6= I . Consequently, the second condition is satisfied because I ÷ I = J ÷J = ∅ and K ÷ I is non-empty.\nii) If L÷ J 6= ∅, then a) holds since J ÷ J = ∅.\nProposition 46 The assignment W is organised."
    }, {
      "heading" : "Proof",
      "text" : "Recall that by definition W is organised if for all SE-interpretations X , Y and all welldefined sets of SE-interpretationsM,N the following condition is satisfied:\nIf Y ∈ min(M,≤XW ) ∪min(M,≤X ∗ W ) and Y ∈ min(N ,≤XW ) ∪min(N ,≤X ∗ W ), then Y ∈ min(M∪N ,≤XW ) ∪min(M∪N ,≤X ∗ W ).\nSuppose that Y /∈ min(M∪N ,≤XW )∪min(M∪N ,≤X ∗\nW ). We need to show that at least one of the following holds:\ni) Y /∈ min(M,≤XW ) ∪min(M,≤X ∗\nW ); ii) Y /∈ min(N ,≤XW ) ∪min(N ,≤X ∗ W ).\nIf Y /∈M, then i) is trivially satisfied. Similarly, if Y /∈ N , then ii) is trivially satisfied. So we can assume that Y ∈M∩N . It follows from the assumption that there must be some Z1, Z2 ∈ M ∪ N such that Z1 <XW Y and Z2 <X ∗\nW Y . If Z1 and Z2 both belong toM, then i) is satisfied; if they both belong to N , then ii) is satisfied. So let’s assume, without loss of generality, that Z1 ∈ M and Z2 ∈ N . Furthermore, let X = (I, J), Y = (K,L), Z1 = (K1, L1) and Z2 = (K2, L2). It follows from Z2 <X ∗\nW Y and Lemma 43 that we need to consider two cases:\na) If (L2 ÷ J) ( (L÷ J), then by Lemma 43 we also have Z2 <XW Y and, consequently, ii) is satisfied. b) If (L2 ÷ J) = (L÷ J) and (K2 ÷ J) \\∆ ( (K ÷ J) \\∆ where ∆ = L2 ÷ J , then it follows that (K ÷ J) \\∆ 6= ∅ and by using ∆ = L2 ÷ J = L÷ J we obtain\n(K ÷ J) \\ (L÷ J) 6= ∅ . (B2)\nFurthermore, from Z1 <XW Y we know that one of the following cases occurs:\na’) (L1 ÷ J) ( (L÷ J), or b’) (L1 ÷ J) = (L÷ J) and (K1 ÷ I) \\∆ ( (K ÷ I) \\∆, where ∆ = L1 ÷ J .\nWe will show that Z∗1 < X∗\nW Y . By Lemma 43 this holds if and only if one of the following conditions is satisfied:\na∗) (L1 ÷ J) ( (L÷ J), or b∗) (L1 ÷ J) = (L÷ J) and (L1 ÷ J) \\∆ ( (K ÷ J) \\∆, where ∆ = L1 ÷ J .\nWe see that a’) implies a∗) and b’) together with (B2) implies b∗). Also, since M is well-defined, we have Z∗1 ∈M, so i) is satisfied.\nProposition 23. The assignment W is a well-defined, faithful and organised preorder assignment."
    }, {
      "heading" : "Proof of Proposition 23",
      "text" : "Follows by Propositions 42, 44, 45 and 46."
    }, {
      "heading" : "Appendix C Proofs: Computational Complexity of Operators Characterised by W",
      "text" : "Definition 47 (Truth value assigned by SE-interpretation) Let X be an SE-interpretation and p an atom. We define the truth value assigned by X to p as follows:\nX(p) =  T if p ∈ I ; U if p ∈ J \\ I ; F if p ∈ A \\ J .\nDefinition 48 (Set of relevant atoms) Let φ be a propositional formula. We inductively define the set of atoms relevant to φ, denoted by at(φ), as follows:\n• If φ is > or ⊥, then at(φ) = ∅; • If φ is an atom p, then at(φ) = { p }; • If φ is of the form ¬ψ, then at(φ) = at(ψ); • If φ is of the form ψ1∧ψ2, ψ1∨ψ2, ψ1 ⊃ ψ2 or ψ1 ≡ ψ2, then at(φ) = at(ψ1)∪at(ψ2).\nFor a logic program P, at(P) = at(κ(P)).\nLemma 49 Let P, U be programs and ⊕ a rule update operator characterised by W. If Z belongs to min(JU KSE,≤XW ) for some X ∈ JP KSE, then X(p) = Z(p) for all p ∈ A \\ at(U)."
    }, {
      "heading" : "Proof",
      "text" : "We prove by contradiction. Suppose that our assumptions are satisfied and X(p) 6= Z(p) for some p ∈ A \\ at(U). Let the SE-interpretation Y be defined as follows:\nY (q) =\n{ X(q) q = p ;\nZ(q) q 6= p .\nFirst note that since Z is an SE-model of U and Y differs from Z only in the truth value assigned to p, where p /∈ at(U), it follows that Y is also an SE-model of U .\nPut X = (I, J), Y = (K1, L1) and Z = (K2, L2). By assumption, X(p) 6= Z(p), so, by the definition of Y , Y (p) 6= Z(p). Thus, one of the following cases occurs:\na) If L1 ÷ L2 = { p }, then we immediately obtain that (L1 ÷ J) ÷ (L2 ÷ J) = { p }. Since Y (p) = X(p), we conclude that p /∈ L1 ÷ J and it follows that\n(L1 ÷ J) \\ (L2 ÷ J) = ∅ and (L2 ÷ J) \\ (L1 ÷ J) = { p } .\nConsequently, L1 ÷ J ( L2 ÷ J , so Y <XW Z, contrary to the assumption that Z belongs to min(JU KSE,≤XW ). b) If K1 ÷K2 = { p }, then we obtain that (K1 ÷ I)÷ (K2 ÷ I) = { p }. Since Y (p) = X(p), we conclude that p /∈ K1 ÷ I and it follows that\n(K1 ÷ I) \\ (K2 ÷ I) = ∅ and (K2 ÷ I) \\ (K1 ÷ I) = { p } .\nFurthermore, assuming that the previous case does not occur, it follows that L1 = L2, so for ∆ = L1÷J = L2÷J it holds that p /∈ ∆ because X(p) = Z(p). Consequently, (K1 ÷ I) \\∆ ( (K2 ÷ I) \\∆, so Y <XW Z, contrary to the assumption that Z belongs to min(JU KSE,≤XW ).\nDefinition 50 (Truth value substitution) Let X = (I, J) be an SE-interpretation and p an atom. We define the SE-interpretations X [p:=T], X [p:=U] and X [p:=F] as follows:\nX [p:=T] = (I ∪ { p } , J ∪ { p }) ,\nX [p:=U] = (I \\ { p } , J ∪ { p }) ,\nX [p:=F] = (I \\ { p } , J \\ { p }) .\nLemma 51 Let X , Y , Z be SE-interpretations, p an atom such that X(p) = Z(p) and V a truth value. Then,\nY <XW Z implies Y [p:=V] <X\n[p:=V]\nW Z [p:=V] ."
    }, {
      "heading" : "Proof",
      "text" : "Put X = (I, J), Y = (K1, L1) and Z = (K2, L2). The assumption that X(p) = Z(p) implies that\np /∈ L2 ÷ J and p /∈ K2 ÷ I . (C1)\nFurthermore, if Y <XW Z, then, by Lemma 43, one of the following two cases occurs:\na) If (L1 ÷ J) ( (L2 ÷ J), then it follows from (C1) that p /∈ L1 ÷ J and we obtain the following:\n(L1 ∪ { p })÷ (J ∪ { p }) = L1 ÷ J ( L2 ÷ J = (L2 ∪ { p })÷ (J ∪ { p }) , (C2) (L1 \\ { p })÷ (J \\ { p }) = L1 ÷ J ( L2 ÷ J = (L2 \\ { p })÷ (J \\ { p }) . (C3)\nFinally, we need to consider two cases depending on V:\n(i) If V = T or V = U, then the second components of the SE-interpretations X [p:=V], Y [p:=V] and Z [p:=V] are J ∪{ p }, L1∪{ p } and L2∪{ p }, respectively. Hence, the desired conclusion follows from (C2) by Lemma 43.\n(ii) If V = F, then the second components of the SE-interpretations X [p:=V], Y [p:=V]\nand Z [p:=V] are J \\{ p }, L1 \\{ p } and L2 \\{ p }, respectively. Hence, the desired conclusion follows from (C3) by Lemma 43.\nb) If (L1 ÷ J) = (L2 ÷ J) and (K1 ÷ I) \\∆ ( (K2 ÷ I) \\∆ where ∆ = L1 ÷ J , then L1 = L2 and it follows from (C1) that p /∈ ∆ as well as p /∈ K1 ÷ I , so we obtain the following:\n(L1 ∪ { p })÷ (J ∪ { p }) = (L2 ∪ { p })÷ (J ∪ { p }) = ∆ , (C4)\n(L1 \\ { p })÷ (J \\ { p }) = (L2 \\ { p })÷ (J \\ { p }) = ∆ , (C5)\n[(K1 ∪ { p })÷ (I ∪ { p })] \\∆ = (K1 ÷ I) \\∆ ( (K2 ÷ I) \\∆ = [(K2 ∪ { p })÷ (I ∪ { p })] \\∆ ,\n(C6)\n[(K1 \\ { p })÷ (I \\ { p })] \\∆ = (K1 ÷ I) \\∆ ( (K2 ÷ I) \\∆ = [(K2 \\ { p })÷ (I \\ { p })] \\∆ .\n(C7)\nFinally, we need to use Lemma 43, considering three cases depending on V:\n(i) If V = T, then the desired conclusion follows from (C4) and (C6). (ii) If V = U, then the desired conclusion follows from (C4) and (C7).\n(iii) If V = F, then the desired conclusion follows from (C5) and (C7).\nLemma 52 Let P, U be programs, p an atom with p /∈ at(P) ∪ at(U), ⊕ a rule update operator characterised by W and Z, Z ′ be SE-interpretations such that Z = Z ′[p:=V] for some truth value V. Then,\nZ ∈ JP ⊕ U KSE if and only if Z ′ ∈ JP ⊕ U KSE ."
    }, {
      "heading" : "Proof",
      "text" : "We prove the direct implication, the converse one follows by the symmetry of the claim.\nSuppose that Z ∈ JP⊕U KSE but Z ′ /∈ JP⊕U KSE. Then there is some SE-interpretation X ∈ JP KSE such that Z belongs to min(JU KSE,≤XW ). It follows from Lemma 49 that\nX(p) = Z(p) = V .\nPut Z ′(p) = V′ and let X ′ = X [p:=V ′]. Since X ′ differs from X only in the truth value\nassigned to p and p /∈ at(P), it follows that X ′ ∈ JP KSE. Thus, there exists some SE-interpretation Y ′ such that Y ′ <X ′\nW Z ′ and by Lemma 51 we conclude that\nY ′[p:=V] <X ′[p:=V] W Z ′[p:=V] .\nIt remains to observe that X ′[p:=V] = X and Z ′[p:=V] = Z, so for Y = Y ′[p:=V] we have\nY <XW Z .\nSince Y differs from Y ′ only in the truth value assigned to p and p /∈ at(U), it follows that Y ∈ JU KSE – a conflict with the assumption that Z belongs to min(JU KSE,≤XW ).\nCorollary 53 Let P, U be programs, ⊕ a rule update operator characterised by W and Z, Z ′ be SE-interpretations such that Z(p) = Z ′(p) for all p ∈ at(P) ∪ at(U). Then,\nZ ∈ JP ⊕ U KSE if and only if Z ′ ∈ JP ⊕ U KSE ."
    }, {
      "heading" : "Proof",
      "text" : "Suppose that\nA \\ (at(P) ∪ at(U)) = { p1, p2, . . . , pn } and construct a sequence of SE-interpretations Z0, Z1, . . . , Zn as follows: Z0 = Z and Zi+1 = Z [pi:=Z ′(pi)]\ni for all i with 0 ≤ i < n. Clearly, Zn = Z ′ and Lemma 52 can be used n times, for each pair (Zi, Zi+1), to infer the desired result.\nLemma 54 Let P be a set of facts, U a program such that at(U) ⊆ at(P), ⊕ a rule update operator characterised by W and Z an SE-interpretation from JP ⊕ U KSE. Then for every atom p with (p.) ∈ P it holds that Z(p) 6= U."
    }, {
      "heading" : "Proof",
      "text" : "Suppose that Z belongs to JP ⊕ U KSE, put Z = (K,L) and let\nY = (K ∩ at(P), L ∩ at(P)) .\nIt follows by Corollary 53 that Y belongs to JP ⊕ U KSE. Thus, there exists some SE-interpretation X ∈ JP KSE such that Y belongs to min(JU KSE,≤XW ). Also, using Lemma 49 we conclude that X assigns truth values as follows:\nX(q) =  T (q.) ∈ P ; F (∼q.) ∈ P ; F q ∈ A \\ at(P) .\nIn other words, X is of the form (J, J) where J = { q ∈ A | (q.) ∈ P }. Furthermore, since Y belongs to JU KSE, Y ∗ = (L ∩ at(P), L ∩ at(P)) also belongs there.\nWe proceed by contradiction: Suppose that Z(p) = U for some atom p with (p.) ∈ P.\nThen p ∈ L \\K, p ∈ at(P) and p ∈ J and we reach a conflict because Y ∗ <XW Y follows by Lemma 43 from the fact that\n[(L ∩ at(P))÷ J ] \\ [(L ∩ at(P))÷ J ] = ∅ ( { p } ⊆ [(K ∩ at(P))÷ J ] \\ [(L ∩ at(P))÷ J ] .\nLemma 55 Let P, U be programs, ⊕ a rule update operator characterised by W, a belief update operator characterised by W and L an interpretation. Then,\n(L,L) ∈ JP ⊕ U KSE if and only if L ∈ Jκ(P) κ(U)K ."
    }, {
      "heading" : "Proof",
      "text" : "Suppose that (L,L) ∈ JP ⊕ U KSE. Then (L,L) belongs to min(JU KSE,≤XW ) for some X = (I, J) ∈ JP KSE. Since JP KSE is a well-defined set of SE-interpretations, we conclude that (J, J) ∈ JP KSE and, consequently, J |= P. We will prove that L ∈ min(Jκ(U)K,≤JW). Suppose that this is not the case, i.e. there is some L′ ∈ Jκ(U)K such that L′ <JW L. In other words, L′ ÷ J ( L ÷ J . It follows that (L′, L′) is an SE-model of U and by Lemma 43 we conclude that (L′, L′) <XW (L,L), contrary to the assumption that (L,L) belongs to min(JU KSE,≤XW ).\nTo prove the converse implication, assume that L ∈ Jκ(P) κ(U)K. Then there is some interpretation J with J |= P such that L ∈ min(Jκ(U)K,≤JW). It follows that X = (J, J) ∈ JP KSE and Z = (L,L) ∈ JU KSE. Our goal is to prove that Z ∈ min(JU KSE,≤XW ). Suppose that this is not the case, i.e. there is some Z ′ = (K ′, L′) ∈ JU KSE such that Z ′ <XW Z. Note that since JU KSE is a well-defined set of SE-interpretations, it follows that (L′, L′) ∈ JU KSE and thus L′ |= U . By Lemma 43, one of the following conditions is then satisfied:\na) If L′÷ J ( L÷ J , then we obtain L′ <JW L, contrary to the assumption that L belongs to min(Jκ(U)K,≤JW). b) The case when L′ ÷ J = L÷ J and (K ′ ÷ J) \\∆ ( (L÷ J) \\∆, where ∆ = L÷ J , is impossible because the set (L÷ J) \\∆ is empty.\nProposition 56 Let P be a set of facts, Q and U be programs such that Q ⊆ P and at(U) ⊆ at(P), ⊕ a rule update operator characterised by W and a belief update operator characterised by W. Then,\nP ⊕ U |=SE Q if and only if κ(P) κ(U) |= κ(Q) ."
    }, {
      "heading" : "Proof",
      "text" : "First suppose that P⊕U |=SE Q and take some L ∈ Jκ(P) κ(U)K. We need to prove that L |= Q. It follows from Lemma 55 that (L,L) ∈ JP ⊕ U KSE and our assumption implies that (L,L) |= Q. This means that L |= Q, so we reached the desired conclusion.\nFor the converse implication, suppose that κ(P) κ(U) |= κ(Q) and take some (K,L) ∈ JP ⊕ U KSE. Our goal is to prove that (K,L) |= Q. Since the set of SE-interpretations JP ⊕ U KSE is well-defined, we obtain that (L,L) ∈ JP ⊕ U KSE and by Lemma 55 it\nfollows that L ∈ Jκ(P) κ(U)K. By our assumption we infer that L |= Q. Thus, for every positive fact (p.) from Q it holds that p ∈ L and due to Lemma 54 also p ∈ K. Therefore, (K,L) |= (p.). Similarly, for every negative fact (∼p.) from Q it holds that p /∈ L and, hence, (K,L) |= (∼p.). Consequently, (K,L) |= Q as desired.\nTheorem 25 (Computational complexity of rule updates characterised by W). Let ⊕ be a rule update operator characterised by W. Deciding whether P ⊕ U |=SE Q for programs P, U , Q is ΠP2 -complete. Hardness holds even if P is a set of positive facts, U is a non-disjunctive program and Q contains a single fact from P."
    }, {
      "heading" : "Proof of Theorem 25",
      "text" : "Hardness can be shown by reducing the problem of query answering for Winslett’s belief update semantics to the problem of query answering for ⊕. To do this, we rely on some specifics of the proof of Theorem 6 as it is presented in (Eiter and Gottlob 1992). More specifically, Lemma 6.2 (c.f. page 250 of (Eiter and Gottlob 1992)) shows ΠP2 -hardness of Winslett’s belief update semantics by taking an instance\nF = ∀x1, . . . , xm∃y1, . . . , yn : ν\nof QBF2,∀ and constructing propositional formulae φ, µ and ψ such that\nF is valid if and only if φ µ |= ψ . (C8)\nIn the following we reproduce the definition of φ, µ and ψ in order to pinpoint their syntactic structure. Then we show how they can be encoded as logic programs P, U and Q such that\nφ µ |= ψ if and only if P ⊕ U |=SE Q . (C9)\nHowever, we omit the proof of the equivalence (C8) and refer the interested reader to (Eiter and Gottlob 1992) for further details.\nFormulae φ, µ and ψ can be defined as follows:\nφ = x1 ∧ · · · ∧ xm ∧ z1 ∧ · · · ∧ zm ∧ y1 ∧ · · · ∧ yn ∧ r , µ = (x1 ≡ ¬z1) ∧ · · · ∧ (xm ≡ ¬zm) ∧ (r ⊃ ν) ∧ ((y1 ∨ · · · ∨ yn) ⊃ r) , ψ = r ,\nwhere z1, . . . , zm and r are fresh propositional variables. Moreover, we can assume without loss of generality that ν is in conjunctive normal form, i.e.\nν = s∧ i=1 (pi,1 ∨ · · · ∨ pi,ti ∨ ¬qi,1 ∨ · · · ∨ ¬qi,ui)\nwhere pi,j and qi,k belong to {x1, . . . , xm, y1, . . . , yn } for all i, j, k. We construct pro-\ngrams P, U and Q as follows:\nP = { (xi.) | 1 ≤ i ≤ m } ∪ { (zi.) | 1 ≤ i ≤ m } ∪ { (yi.) | 1 ≤ i ≤ n } ∪ { (r.) } , U = { (xi ← ∼zi.), (∼zi ← xi.) | 1 ≤ i ≤ m }\n∪ { (⊥ ← ∼pi,1, . . . ,∼pi,ti , qi,1, . . . , qi,ui , r.) | 1 ≤ i ≤ s } ∪ { (r ← yi.) | 1 ≤ i ≤ n } ,\nQ = { (r.) } .\nIt is not difficult to verify that κ(P) ≡ φ, κ(U) ≡ µ and κ(Q) ≡ ψ, so it follows from postulate (B4) and Proposition 56 that (C9) is satisfied. Together with (C8) this implies that query answering for rule update operators characterised by W is ΠP2 -hard.\nTo verify membership to ΠP2 , consider the following non-deterministic polynomial algorithm with an NP oracle, analogous to the one for Winslett’s belief update semantics (c.f. proof of Theorem 6.4 on page 252 in (Eiter and Gottlob 1992)): To prove that P ⊕ U 6|=SE Q, consider only atoms from at(P) ∪ at(U) ∪ at(Q) (this can be done due to Corollary 53), guess some SE-interpretations X and Y , check in polynomial time that X ∈ JP KSE, Y ∈ JU KSE and Y /∈ JQKSE and invoke the NP oracle to check that there is no Z ∈ JU KSE such that Z <XW Y .\nLemma 57 Let U be a definite program. Then for all interpretations I , J it holds that,\n(I, J) ∈ JU KSE if and only if I ⊆ J ∧ I |= κ(U) ∧ J |= κ(U) ."
    }, {
      "heading" : "Proof",
      "text" : "Follows from the fact that since U is definite, UK = U for any interpretation K.\nTheorem 26 (Computational complexity of definite rule updates characterised by W). Let ⊕ be a rule update operator characterised by W. Deciding whether P ⊕ U |=SE Q for definite programs P, U , Q is co-NP-complete. Hardness holds even if P is a set of facts and Q contains a single fact from P."
    }, {
      "heading" : "Proof of Theorem 26",
      "text" : "Hardness follows by reducing the co-NP-complete problem of query answering for Horn formulae under Winslett’s belief update semantics. More specifically, Theorem 7 shows that deciding whether φ µ |= ψ, where is a belief update operator characterised by W, is co-NP-hard even when φ is a conjunction of objective literals, µ is a Horn formula and ψ is one of the literals in φ. It is straightforward to construct a set of facts P, a definite program U and a program Q containing a single fact from P such that κ(P) ≡ φ, κ(U) ≡ µ and κ(Q) ≡ ψ. Finally, it follows from postulate (B4) and Proposition 56 that\nP ⊕ U |=SE Q if and only if φ⊕ µ |= ψ ,\nwhich concludes the proof of co-NP-hardness of query answering for ⊕. To verify membership to co-NP, consider the following non-deterministic polynomial algorithm, analogous to the one for Winslett’s belief update semantics for Horn formulae (c.f. proof of Theorem 7.2 on page 259 in (Eiter and Gottlob 1992)): To prove that P ⊕\nU 6|=SE Q, consider only atoms from A′ = at(P) ∪ at(U) ∪ at(Q) (this can be done due to Corollary 53), guess some SE-interpretations X = (I, J) and Y = (K,L) and check in polynomial time that X ∈ JP KSE, Y ∈ JU KSE and Y /∈ JQKSE. It remains to check that there is no SE-interpretation Z ∈ JU KSE such that Z <XW Y . This can be performed in polynomial time by using Lemma 57 as follows: Put ∆ = L ÷ J and ∆′ = (K ÷ I) \\∆ and let for every atom p,\nt(p) = { p J |= p ; ¬p J 6|= p ;\ns(p) = { p I |= p ; ¬p I 6|= p .\nIt follows from Lemma 57 and from the definition of ≤XW that it suffices to verify that for every p ∈ ∆ and every q ∈ ∆′, both of the Horn formulae\nκ(U) ∧ t(p) ∧ ∧\nr∈A′\\∆\nt(r) and κ(U) ∧ s(q) ∧ ∧\nr∈A′\\∆′ s(r)\nare not satisfiable."
    }, {
      "heading" : "ALFERES, J. J., LEITE, J. A., PEREIRA, L. M., PRZYMUSINSKA, H., AND PRZYMUSINSKI, T. C.",
      "text" : "2000. Dynamic updates of non-monotonic knowledge bases. The Journal of Logic Programming 45, 1-3 (September/October), 43–70. 2, 9, 14, 16\nALFERES, J. J. AND PEREIRA, L. M. 1996. Update-programs can update programs. In NonMonotonic Extensions of Logic Programming (NMELP ’96), Selected Papers, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 110–131. 2\nAPT, K. R., BLAIR, H. A., AND WALKER, A. 1988. Towards a theory of declarative knowledge. In Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, 89–148. 14\nBARAL, C. 2003. Knowledge Representation, Reasoning, and Declarative Problem Solving. Cambridge University Press. 1\nCABALAR, P. AND FERRARIS, P. 2007. Propositional theories are strongly equivalent to logic programs. Theory and Practice of Logic Programming (TPLP) 7, 6, 745–759. 10\nDELGRANDE, J. P. 2010. A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics. Theory and Practice of Logic Programming, 26th Int’l. Conference on Logic Programming (ICLP’10) Special Issue 10, 4-6 (July), 565–580. 14\nDELGRANDE, J. P., SCHAUB, T., AND TOMPITS, H. 2007. A preference-based framework for updating logic programs. In Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2007), C. Baral, G. Brewka, and J. S. Schlipf, Eds. Lecture Notes in Computer Science, vol. 4483. Springer, Tempe, AZ, USA, 71–83. 2, 9, 14\nDELGRANDE, J. P., SCHAUB, T., TOMPITS, H., AND WOLTRAN, S. 2008. Belief revision of logic programs under answer set semantics. In Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008), G. Brewka and J. Lang, Eds. AAAI Press, Sydney, Australia, 411–421. 2, 3, 7, 8, 9, 10, 12, 15, 17 DIX, J. 1995a. A classification theory of semantics of normal logic programs: I. Strong properties. Fundamenta Informaticae 22, 3, 227–255. 14 DIX, J. 1995b. A classification theory of semantics of normal logic programs: II. Weak properties. Fundamenta Informaticae 22, 3, 257–288. 14 EITER, T., FINK, M., SABBATINI, G., AND TOMPITS, H. 2002. On properties of update sequences based on causal rejection. Theory and Practice of Logic Programming (TPLP) 2, 6, 721–777. 2, 9, 14, 17 EITER, T. AND GOTTLOB, G. 1992. On the complexity of propositional knowledge base revision, updates, and counterfactuals. In Proceedings of the 11th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS 1992). ACM Press, San Diego, California, USA, 261–273. 6, 34, 35 GELFOND, M. AND LIFSCHITZ, V. 1988. The stable model semantics for logic programming. In Proceedings of the 5th International Conference and Symposium on Logic Programming (ICLP/SLP 1988), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Seattle, Washington, 1070– 1080. 1 HERZIG, A. AND RIFI, O. 1999. Propositional belief base update and minimal change. Artificial Intelligence 115, 1, 107–138. 13, 16 HEYTING, A. 1930. Die formalen Regeln der intuitionistischen Logik. Sitzungsberichte der Preussischen Akademie der Wissenschaften, 42–56. Reprint in Logik-Texte: Kommentierte Auswahl zur Geschichte der Modernen Logik, Akademie-Verlag, 1986. 7, 10 ILIC, M., LEITE, J., AND SLOTA, M. 2008. Explicit dynamic user profiles for a collaborative filtering recommender system. In Proceedings of the 11th Ibero-American Conference on Artificial Intelligence (IBERAMIA’08), H. Geffner, R. Prada, I. M. Alexandre, and N. David, Eds. Vol. LNAI 5290. Springer-Verlag, 352–361. 2 KATSUNO, H. AND MENDELZON, A. O. 1991. On the difference between updating a knowledge base and revising it. In Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR’91), J. F. Allen, R. Fikes, and E. Sandewall, Eds. Morgan Kaufmann Publishers, Cambridge, MA, USA, 387–394. 2, 4, 5 KATSUNO, H. AND MENDELZON, A. O. 1992. Propositional knowledge base revision and minimal change. Artificial Intelligence 52, 3, 263–294. 15 KELLER, A. M. AND WINSLETT, M. 1985. On the use of an extended relational model to handle changing incomplete information. IEEE Transactions on Software Engineering 11, 7, 620–633. 2, 4, 5, 12 KRÜMPELMANN, P. AND KERN-ISBERNER, G. 2010. On belief dynamics of dependency relations for extended logic programs. In Proceedings of the 13th International Workshop on NonMonotonic Reasoning. Toronto, Canada. 2 LEITE, J. A. 2003. Evolving Knowledge Bases. Frontiers of Artificial Intelligence and Applications, xviii + 307 p. Hardcover, vol. 81. IOS Press. 2 LEITE, J. A. AND PEREIRA, L. M. 1998. Generalizing updates: From models to programs. In Proceedings of the 3rd International Workshop on Logic Programming and Knowledge Representation (LPKR ’97), October 17, 1997, Port Jefferson, New York, USA, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1471. Springer, 224–246. 2, 9, 14, 16 LIFSCHITZ, V., PEARCE, D., AND VALVERDE, A. 2001. Strongly equivalent logic programs. ACM Transactions on Computational Logic (TOCL) 2, 4, 526–541. 2, 8 ŁUKASIEWICZ, J. 1941. Die Logik und das Grundlagenproblem. In Les Entretiens de Zürich sue les Fondements et la méthode des sciences mathématiques 1938. Zürich, 82–100. 7, 10\nMEYER, A. R. AND STOCKMEYER, L. J. 1972. The equivalence problem for regular expressions with squaring requires exponential space. In Proceedings of the 13th Annual Symposium on Switching and Automata Theory (SWAT) (October 25-27). IEEE Computer Society, College Park, Maryland, USA, 125–129. 6\nOSORIO, M. AND CUEVAS, V. 2007. Updates in answer set programming: An approach based on basic structural properties. Theory and Practice of Logic Programming 7, 4, 451–479. 2, 16\nPEARCE, D. 1997. A new logical characterisation of stable models and answer sets. In Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming (NMELP ’96), J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 57–70. 7, 10\nSAIAS, J. AND QUARESMA, P. 2004. A methodology to create legal ontologies in a logic programming based web information retrieval system. Artificial Intelligence and Law 12, 4, 397–417. 2\nSAKAMA, C. AND INOUE, K. 2003. An abductive framework for computing knowledge base updates. Theory and Practice of Logic Programming (TPLP) 3, 6, 671–713. 2, 9, 14\nŠEFRÁNEK, J. 2006. Irrelevant updates and nonmonotonic assumptions. In Proceedings of the 10th European Conference on Logics in Artificial Intelligence (JELIA 2006), M. Fisher, W. van der Hoek, B. Konev, and A. Lisitsa, Eds. Lecture Notes in Computer Science, vol. 4160. Springer, Liverpool, UK, 426–438. 2\nŠEFRÁNEK, J. 2011. Static and dynamic semantics: Preliminary report. Mexican International Conference on Artificial Intelligence, 36–42. 2, 9\nSISKA, J. 2006. Dynamic logic programming and world state evaluation in computer games. In Proceedings of the 20th Workshop on Logic Programming, M. Fink, H. Tompits, and S. Woltran, Eds. INFSYS Research Report, vol. 1843-06-02. Technische Universität Wien, Austria, Vienna, Austria, 64–70. 2\nSLOTA, M. AND LEITE, J. 2010. On semantic update operators for answer-set programs. In Proceedings of the 19th European Conference on Artificial Intelligence (ECAI 2010), H. Coelho, R. Studer, and M. Wooldridge, Eds. Frontiers in Artificial Intelligence and Applications, vol. 215. IOS Press, Lisbon, Portugal, 957–962. 1\nSLOTA, M. AND LEITE, J. 2012. Robust equivalence models for semantic updates of answer-set programs. In Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR 2012), G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press, Rome, Italy, 158–168. 17\nSLOTA, M., LEITE, J., AND SWIFT, T. 2011. Splitting and updating hybrid knowledge bases. Theory and Practice of Logic Programming, 27th Int’l. Conference on Logic Programming (ICLP’11) Special Issue 11, 4-5, 801–819. 2\nSTOCKMEYER, L. J. 1976. The polynomial-time hierarchy. Theoretical Computer Science 3, 1, 1–22. 6\nTURNER, H. 2003. Strong equivalence made easy: nested expressions and weight constraints. Theory and Practice of Logic Programming (TPLP) 3, 4-5, 609–622. 2, 7, 8, 17\nWINSLETT, M. 1990. Updating Logical Databases. Cambridge University Press, New York, USA. 2, 3, 5, 12\nZHANG, Y. 2006. Logic program-based updates. ACM Transactions on Computational Logic 7, 3, 421–472. 2, 9, 14\nZHANG, Y. AND FOO, N. Y. 2005. A unified framework for representing logic program updates. In Proceedings of the 20th National Conference on Artificial Intelligence (AAAI 2005), M. M. Veloso and S. Kambhampati, Eds. AAAI Press / The MIT Press, Pittsburgh, Pennsylvania, USA, 707–713. 2, 9"
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "C.E. ALCHOURRÓN", "P. GÄRDENFORS", "D. MAKINSON" ],
      "venue" : "Journal of Symbolic Logic 50, 2, 510–530. 2, 15",
      "citeRegEx" : "ALCHOURRÓN et al\\.,? 1985",
      "shortCiteRegEx" : "ALCHOURRÓN et al\\.",
      "year" : 1985
    }, {
      "title" : "The refined extension principle for semantics of dynamic logic programming",
      "author" : [ "J.J. ALFERES", "F. BANTI", "A. BROGI", "J.A. LEITE" ],
      "venue" : "Studia Logica 79, 1, 7–32. 2, 9, 14, 16, 17",
      "citeRegEx" : "ALFERES et al\\.,? 2005",
      "shortCiteRegEx" : "ALFERES et al\\.",
      "year" : 2005
    }, {
      "title" : "An evolvable rule-based email agent",
      "author" : [ "J.J. ALFERES", "A. BROGI", "J.A. LEITE", "L.M. PEREIRA" ],
      "venue" : "Proceedings of the 11th Portuguese Conference Artificial Intelligence (EPIA 2003), F. Moura-Pires and S. Abreu, Eds. Lecture Notes in Computer Science, vol. 2902. Springer, Beja, Portugal, 394–408. 2",
      "citeRegEx" : "ALFERES et al\\.,? 2003",
      "shortCiteRegEx" : "ALFERES et al\\.",
      "year" : 2003
    }, {
      "title" : "Dynamic updates of non-monotonic knowledge bases",
      "author" : [ "J.J. ALFERES", "J.A. LEITE", "L.M. PEREIRA", "H. PRZYMUSINSKA", "T.C. PRZYMUSINSKI" ],
      "venue" : "The Journal of Logic Programming 45, 1-3 (September/October), 43–70. 2, 9, 14, 16",
      "citeRegEx" : "ALFERES et al\\.,? 2000",
      "shortCiteRegEx" : "ALFERES et al\\.",
      "year" : 2000
    }, {
      "title" : "Update-programs can update programs",
      "author" : [ "J.J. ALFERES", "L.M. PEREIRA" ],
      "venue" : "NonMonotonic Extensions of Logic Programming (NMELP ’96), Selected Papers, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 110–131. 2",
      "citeRegEx" : "ALFERES and PEREIRA,? 1996",
      "shortCiteRegEx" : "ALFERES and PEREIRA",
      "year" : 1996
    }, {
      "title" : "Towards a theory of declarative knowledge",
      "author" : [ "K.R. APT", "H.A. BLAIR", "A. WALKER" ],
      "venue" : "Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, 89–148. 14",
      "citeRegEx" : "APT et al\\.,? 1988",
      "shortCiteRegEx" : "APT et al\\.",
      "year" : 1988
    }, {
      "title" : "Knowledge Representation, Reasoning, and Declarative Problem Solving",
      "author" : [ "C. BARAL" ],
      "venue" : "Cambridge University Press. 1",
      "citeRegEx" : "BARAL,? 2003",
      "shortCiteRegEx" : "BARAL",
      "year" : 2003
    }, {
      "title" : "Propositional theories are strongly equivalent to logic programs",
      "author" : [ "P. CABALAR", "P. FERRARIS" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP) 7, 6, 745–759. 10",
      "citeRegEx" : "CABALAR and FERRARIS,? 2007",
      "shortCiteRegEx" : "CABALAR and FERRARIS",
      "year" : 2007
    }, {
      "title" : "A Program-Level Approach to Revising Logic Programs under the Answer Set Semantics",
      "author" : [ "J.P. DELGRANDE" ],
      "venue" : "Theory and Practice of Logic Programming, 26th Int’l. Conference on Logic Programming (ICLP’10) Special Issue 10, 4-6 (July), 565–580. 14",
      "citeRegEx" : "DELGRANDE,? 2010",
      "shortCiteRegEx" : "DELGRANDE",
      "year" : 2010
    }, {
      "title" : "A preference-based framework for updating logic programs",
      "author" : [ "J.P. DELGRANDE", "T. SCHAUB", "H. TOMPITS" ],
      "venue" : "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2007), C. Baral, G. Brewka, and J. S. Schlipf, Eds. Lecture Notes in Computer Science, vol. 4483. Springer, Tempe, AZ, USA, 71–83. 2, 9, 14",
      "citeRegEx" : "DELGRANDE et al\\.,? 2007",
      "shortCiteRegEx" : "DELGRANDE et al\\.",
      "year" : 2007
    }, {
      "title" : "Belief revision of logic programs under answer set semantics",
      "author" : [ "J.P. DELGRANDE", "T. SCHAUB", "H. TOMPITS", "S. WOLTRAN" ],
      "venue" : "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR 2008), G. Brewka and J. Lang, Eds. AAAI Press, Sydney, Australia, 411–421. 2, 3, 7, 8, 9, 10, 12, 15, 17",
      "citeRegEx" : "DELGRANDE et al\\.,? 2008",
      "shortCiteRegEx" : "DELGRANDE et al\\.",
      "year" : 2008
    }, {
      "title" : "A classification theory of semantics of normal logic programs: I",
      "author" : [ "DIX J." ],
      "venue" : "Strong properties. Fundamenta Informaticae 22, 3, 227–255. 14",
      "citeRegEx" : "J.,? 1995a",
      "shortCiteRegEx" : "J.",
      "year" : 1995
    }, {
      "title" : "A classification theory of semantics of normal logic programs: II",
      "author" : [ "DIX J." ],
      "venue" : "Weak properties. Fundamenta Informaticae 22, 3, 257–288. 14",
      "citeRegEx" : "J.,? 1995b",
      "shortCiteRegEx" : "J.",
      "year" : 1995
    }, {
      "title" : "On properties of update sequences based on causal rejection",
      "author" : [ "T. EITER", "M. FINK", "G. SABBATINI", "H. TOMPITS" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP) 2, 6, 721–777. 2, 9, 14, 17",
      "citeRegEx" : "EITER et al\\.,? 2002",
      "shortCiteRegEx" : "EITER et al\\.",
      "year" : 2002
    }, {
      "title" : "On the complexity of propositional knowledge base revision, updates, and counterfactuals",
      "author" : [ "T. EITER", "G. GOTTLOB" ],
      "venue" : "Proceedings of the 11th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (PODS 1992). ACM Press, San Diego, California, USA, 261–273. 6, 34, 35",
      "citeRegEx" : "EITER and GOTTLOB,? 1992",
      "shortCiteRegEx" : "EITER and GOTTLOB",
      "year" : 1992
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Proceedings of the 5th International Conference and Symposium on Logic Programming (ICLP/SLP 1988), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Seattle, Washington, 1070– 1080. 1",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1988",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1988
    }, {
      "title" : "Propositional belief base update and minimal change",
      "author" : [ "A. HERZIG", "O. RIFI" ],
      "venue" : "Artificial Intelligence 115, 1, 107–138. 13, 16",
      "citeRegEx" : "HERZIG and RIFI,? 1999",
      "shortCiteRegEx" : "HERZIG and RIFI",
      "year" : 1999
    }, {
      "title" : "Die formalen Regeln der intuitionistischen Logik",
      "author" : [ "A. HEYTING" ],
      "venue" : "Sitzungsberichte der Preussischen Akademie der Wissenschaften, 42–56. Reprint in Logik-Texte: Kommentierte Auswahl zur Geschichte der Modernen Logik, Akademie-Verlag, 1986. 7, 10",
      "citeRegEx" : "HEYTING,? 1930",
      "shortCiteRegEx" : "HEYTING",
      "year" : 1930
    }, {
      "title" : "Explicit dynamic user profiles for a collaborative filtering recommender system",
      "author" : [ "M. ILIC", "J. LEITE", "M. SLOTA" ],
      "venue" : "Proceedings of the 11th Ibero-American Conference on Artificial Intelligence (IBERAMIA’08), H. Geffner, R. Prada, I. M. Alexandre, and N. David, Eds. Vol. LNAI 5290. Springer-Verlag, 352–361. 2",
      "citeRegEx" : "ILIC et al\\.,? 2008",
      "shortCiteRegEx" : "ILIC et al\\.",
      "year" : 2008
    }, {
      "title" : "On the difference between updating a knowledge base and revising it",
      "author" : [ "H. KATSUNO", "A.O. MENDELZON" ],
      "venue" : "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR’91), J. F. Allen, R. Fikes, and E. Sandewall, Eds. Morgan Kaufmann Publishers, Cambridge, MA, USA, 387–394. 2, 4, 5",
      "citeRegEx" : "KATSUNO and MENDELZON,? 1991",
      "shortCiteRegEx" : "KATSUNO and MENDELZON",
      "year" : 1991
    }, {
      "title" : "Propositional knowledge base revision and minimal change",
      "author" : [ "H. KATSUNO", "A.O. MENDELZON" ],
      "venue" : "Artificial Intelligence 52, 3, 263–294. 15",
      "citeRegEx" : "KATSUNO and MENDELZON,? 1992",
      "shortCiteRegEx" : "KATSUNO and MENDELZON",
      "year" : 1992
    }, {
      "title" : "On the use of an extended relational model to handle changing incomplete information",
      "author" : [ "A.M. KELLER", "M. WINSLETT" ],
      "venue" : "IEEE Transactions on Software Engineering 11, 7, 620–633. 2, 4, 5, 12",
      "citeRegEx" : "KELLER and WINSLETT,? 1985",
      "shortCiteRegEx" : "KELLER and WINSLETT",
      "year" : 1985
    }, {
      "title" : "On belief dynamics of dependency relations for extended logic programs",
      "author" : [ "P. KRÜMPELMANN", "G. KERN-ISBERNER" ],
      "venue" : "Proceedings of the 13th International Workshop on NonMonotonic Reasoning. Toronto, Canada. 2",
      "citeRegEx" : "KRÜMPELMANN and KERN.ISBERNER,? 2010",
      "shortCiteRegEx" : "KRÜMPELMANN and KERN.ISBERNER",
      "year" : 2010
    }, {
      "title" : "Evolving Knowledge Bases",
      "author" : [ "J.A. LEITE" ],
      "venue" : "Frontiers of Artificial Intelligence and Applications, xviii + 307 p. Hardcover, vol. 81. IOS Press. 2",
      "citeRegEx" : "LEITE,? 2003",
      "shortCiteRegEx" : "LEITE",
      "year" : 2003
    }, {
      "title" : "Generalizing updates: From models to programs",
      "author" : [ "J.A. LEITE", "L.M. PEREIRA" ],
      "venue" : "Proceedings of the 3rd International Workshop on Logic Programming and Knowledge Representation (LPKR ’97), October 17, 1997, Port Jefferson, New York, USA, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1471. Springer, 224–246. 2, 9, 14, 16",
      "citeRegEx" : "LEITE and PEREIRA,? 1998",
      "shortCiteRegEx" : "LEITE and PEREIRA",
      "year" : 1998
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "V. LIFSCHITZ", "D. PEARCE", "A. VALVERDE" ],
      "venue" : "ACM Transactions on Computational Logic (TOCL) 2, 4, 526–541. 2, 8",
      "citeRegEx" : "LIFSCHITZ et al\\.,? 2001",
      "shortCiteRegEx" : "LIFSCHITZ et al\\.",
      "year" : 2001
    }, {
      "title" : "Die Logik und das Grundlagenproblem",
      "author" : [ "J. ŁUKASIEWICZ" ],
      "venue" : "Les Entretiens de Zürich sue les Fondements et la méthode des sciences mathématiques 1938. Zürich, 82–100. 7, 10",
      "citeRegEx" : "ŁUKASIEWICZ,? 1941",
      "shortCiteRegEx" : "ŁUKASIEWICZ",
      "year" : 1941
    }, {
      "title" : "The equivalence problem for regular expressions with squaring requires exponential space",
      "author" : [ "A.R. MEYER", "L.J. STOCKMEYER" ],
      "venue" : "Proceedings of the 13th Annual Symposium on Switching and Automata Theory (SWAT) (October 25-27). IEEE Computer Society, College Park, Maryland, USA, 125–129. 6",
      "citeRegEx" : "MEYER and STOCKMEYER,? 1972",
      "shortCiteRegEx" : "MEYER and STOCKMEYER",
      "year" : 1972
    }, {
      "title" : "Updates in answer set programming: An approach based on basic structural properties",
      "author" : [ "M. OSORIO", "V. CUEVAS" ],
      "venue" : "Theory and Practice of Logic Programming 7, 4, 451–479. 2, 16",
      "citeRegEx" : "OSORIO and CUEVAS,? 2007",
      "shortCiteRegEx" : "OSORIO and CUEVAS",
      "year" : 2007
    }, {
      "title" : "A new logical characterisation of stable models and answer sets",
      "author" : [ "D. PEARCE" ],
      "venue" : "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming (NMELP ’96), J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol. 1216. Springer, Bad Honnef, Germany, 57–70. 7, 10",
      "citeRegEx" : "PEARCE,? 1997",
      "shortCiteRegEx" : "PEARCE",
      "year" : 1997
    }, {
      "title" : "A methodology to create legal ontologies in a logic programming based web information retrieval system",
      "author" : [ "J. SAIAS", "P. QUARESMA" ],
      "venue" : "Artificial Intelligence and Law 12, 4, 397–417. 2",
      "citeRegEx" : "SAIAS and QUARESMA,? 2004",
      "shortCiteRegEx" : "SAIAS and QUARESMA",
      "year" : 2004
    }, {
      "title" : "An abductive framework for computing knowledge base updates",
      "author" : [ "C. SAKAMA", "K. INOUE" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP) 3, 6, 671–713. 2, 9, 14",
      "citeRegEx" : "SAKAMA and INOUE,? 2003",
      "shortCiteRegEx" : "SAKAMA and INOUE",
      "year" : 2003
    }, {
      "title" : "Irrelevant updates and nonmonotonic assumptions",
      "author" : [ "J. ŠEFRÁNEK" ],
      "venue" : "Proceedings of the 10th European Conference on Logics in Artificial Intelligence (JELIA 2006), M. Fisher, W. van der Hoek, B. Konev, and A. Lisitsa, Eds. Lecture Notes in Computer Science, vol. 4160. Springer, Liverpool, UK, 426–438. 2",
      "citeRegEx" : "ŠEFRÁNEK,? 2006",
      "shortCiteRegEx" : "ŠEFRÁNEK",
      "year" : 2006
    }, {
      "title" : "Static and dynamic semantics: Preliminary report",
      "author" : [ "J. ŠEFRÁNEK" ],
      "venue" : "Mexican International Conference on Artificial Intelligence, 36–42. 2, 9",
      "citeRegEx" : "ŠEFRÁNEK,? 2011",
      "shortCiteRegEx" : "ŠEFRÁNEK",
      "year" : 2011
    }, {
      "title" : "Dynamic logic programming and world state evaluation in computer games",
      "author" : [ "J. SISKA" ],
      "venue" : "Proceedings of the 20th Workshop on Logic Programming, M. Fink, H. Tompits, and S. Woltran, Eds. INFSYS Research Report, vol. 1843-06-02. Technische Universität Wien, Austria, Vienna, Austria, 64–70. 2",
      "citeRegEx" : "SISKA,? 2006",
      "shortCiteRegEx" : "SISKA",
      "year" : 2006
    }, {
      "title" : "On semantic update operators for answer-set programs",
      "author" : [ "M. SLOTA", "J. LEITE" ],
      "venue" : "Proceedings of the 19th European Conference on Artificial Intelligence (ECAI 2010), H. Coelho, R. Studer, and M. Wooldridge, Eds. Frontiers in Artificial Intelligence and Applications, vol. 215. IOS Press, Lisbon, Portugal, 957–962. 1",
      "citeRegEx" : "SLOTA and LEITE,? 2010",
      "shortCiteRegEx" : "SLOTA and LEITE",
      "year" : 2010
    }, {
      "title" : "Robust equivalence models for semantic updates of answer-set programs",
      "author" : [ "M. SLOTA", "J. LEITE" ],
      "venue" : "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR 2012), G. Brewka, T. Eiter, and S. A. McIlraith, Eds. AAAI Press, Rome, Italy, 158–168. 17",
      "citeRegEx" : "SLOTA and LEITE,? 2012",
      "shortCiteRegEx" : "SLOTA and LEITE",
      "year" : 2012
    }, {
      "title" : "Splitting and updating hybrid knowledge bases",
      "author" : [ "M. SLOTA", "J. LEITE", "T. SWIFT" ],
      "venue" : "Theory and Practice of Logic Programming, 27th Int’l. Conference on Logic Programming (ICLP’11) Special Issue 11, 4-5, 801–819. 2",
      "citeRegEx" : "SLOTA et al\\.,? 2011",
      "shortCiteRegEx" : "SLOTA et al\\.",
      "year" : 2011
    }, {
      "title" : "The polynomial-time hierarchy",
      "author" : [ "L.J. STOCKMEYER" ],
      "venue" : "Theoretical Computer Science 3, 1, 1–22. 6",
      "citeRegEx" : "STOCKMEYER,? 1976",
      "shortCiteRegEx" : "STOCKMEYER",
      "year" : 1976
    }, {
      "title" : "Strong equivalence made easy: nested expressions and weight constraints",
      "author" : [ "H. TURNER" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP) 3, 4-5, 609–622. 2, 7, 8, 17",
      "citeRegEx" : "TURNER,? 2003",
      "shortCiteRegEx" : "TURNER",
      "year" : 2003
    }, {
      "title" : "Updating Logical Databases",
      "author" : [ "M. WINSLETT" ],
      "venue" : "Cambridge University Press, New York, USA. 2, 3, 5, 12",
      "citeRegEx" : "WINSLETT,? 1990",
      "shortCiteRegEx" : "WINSLETT",
      "year" : 1990
    }, {
      "title" : "Logic program-based updates",
      "author" : [ "Y. ZHANG" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3, 421–472. 2, 9, 14",
      "citeRegEx" : "ZHANG,? 2006",
      "shortCiteRegEx" : "ZHANG",
      "year" : 2006
    }, {
      "title" : "A unified framework for representing logic program updates",
      "author" : [ "Y. ZHANG", "N.Y. FOO" ],
      "venue" : "Proceedings of the 20th National Conference on Artificial Intelligence (AAAI 2005), M. M. Veloso and S. Kambhampati, Eds. AAAI Press / The MIT Press, Pittsburgh, Pennsylvania, USA, 707–713. 2, 9",
      "citeRegEx" : "ZHANG and FOO,? 2005",
      "shortCiteRegEx" : "ZHANG and FOO",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "Answer-Set Programming (ASP) (Gelfond and Lifschitz 1988; Baral 2003) is now widely recognised as a valuable approach to knowledge representation and reasoning, mostly due to its simple and well-understood declarative semantics, its rich expressive power, and the existence of efficient implementations.",
      "startOffset" : 29,
      "endOffset" : 69
    }, {
      "referenceID" : 6,
      "context" : "Answer-Set Programming (ASP) (Gelfond and Lifschitz 1988; Baral 2003) is now widely recognised as a valuable approach to knowledge representation and reasoning, mostly due to its simple and well-understood declarative semantics, its rich expressive power, and the existence of efficient implementations.",
      "startOffset" : 29,
      "endOffset" : 69
    }, {
      "referenceID" : 35,
      "context" : "∗ This is an extended version of (Slota and Leite 2010).",
      "startOffset" : 33,
      "endOffset" : 55
    }, {
      "referenceID" : 21,
      "context" : "Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991).",
      "startOffset" : 128,
      "endOffset" : 197
    }, {
      "referenceID" : 40,
      "context" : "Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991).",
      "startOffset" : 128,
      "endOffset" : 197
    }, {
      "referenceID" : 19,
      "context" : "Subsequently, update and revision have been distinguished as two very related but ultimately different belief change operations (Keller and Winslett 1985; Winslett 1990; Katsuno and Mendelzon 1991).",
      "startOffset" : 128,
      "endOffset" : 197
    }, {
      "referenceID" : 13,
      "context" : "Both AGM and KM postulates were later studied in the context of Logic Programming, only to find that their formulations based on a non-monotonic semantics, such as the answer sets, are inappropriate (Eiter et al. 2002).",
      "startOffset" : 199,
      "endOffset" : 218
    }, {
      "referenceID" : 4,
      "context" : "Like many belief change operators, earlier methods used to tackle rule updates were based on literal inertia (Alferes and Pereira 1996) but proved not sufficiently expressive.",
      "startOffset" : 109,
      "endOffset" : 135
    }, {
      "referenceID" : 24,
      "context" : "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al.",
      "startOffset" : 64,
      "endOffset" : 88
    }, {
      "referenceID" : 3,
      "context" : "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.",
      "startOffset" : 147,
      "endOffset" : 244
    }, {
      "referenceID" : 13,
      "context" : "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.",
      "startOffset" : 147,
      "endOffset" : 244
    }, {
      "referenceID" : 23,
      "context" : "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.",
      "startOffset" : 147,
      "endOffset" : 244
    }, {
      "referenceID" : 1,
      "context" : "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.",
      "startOffset" : 147,
      "endOffset" : 244
    }, {
      "referenceID" : 28,
      "context" : "For example, the introduction of the causal rejection principle (Leite and Pereira 1998) motivated a line of work on several rule update semantics (Alferes et al. 2000; Eiter et al. 2002; Leite 2003; Alferes et al. 2005; Osorio and Cuevas 2007), all of them with a strong syntactic flavour.",
      "startOffset" : 147,
      "endOffset" : 244
    }, {
      "referenceID" : 31,
      "context" : "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al.",
      "startOffset" : 113,
      "endOffset" : 136
    }, {
      "referenceID" : 42,
      "context" : "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al.",
      "startOffset" : 149,
      "endOffset" : 169
    }, {
      "referenceID" : 41,
      "context" : "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al.",
      "startOffset" : 186,
      "endOffset" : 198
    }, {
      "referenceID" : 9,
      "context" : "Other approaches tackle rule updates by employing syntactic transformations and other methods, such as abduction (Sakama and Inoue 2003), forgetting (Zhang and Foo 2005), prioritisation (Zhang 2006), preferences (Delgrande et al. 2007), or dependencies on default assumptions (Šefránek 2006; Krümpelmann and KernIsberner 2010; Šefránek 2011).",
      "startOffset" : 212,
      "endOffset" : 235
    }, {
      "referenceID" : 2,
      "context" : "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.",
      "startOffset" : 49,
      "endOffset" : 144
    }, {
      "referenceID" : 30,
      "context" : "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.",
      "startOffset" : 49,
      "endOffset" : 144
    }, {
      "referenceID" : 34,
      "context" : "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.",
      "startOffset" : 49,
      "endOffset" : 144
    }, {
      "referenceID" : 18,
      "context" : "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.",
      "startOffset" : 49,
      "endOffset" : 144
    }, {
      "referenceID" : 37,
      "context" : "Though useful in a number of practical scenarios (Alferes et al. 2003; Saias and Quaresma 2004; Siska 2006; Ilic et al. 2008; Slota et al. 2011), it turned out that most of these semantics exhibit undesirable behaviour.",
      "startOffset" : 49,
      "endOffset" : 144
    }, {
      "referenceID" : 1,
      "context" : "For example, except for the semantics proposed in (Alferes et al. 2005; Šefránek 2011), a tautological update may influence the result under all of these semantics, a behaviour that is highly undesirable when considering knowledge updates.",
      "startOffset" : 50,
      "endOffset" : 86
    }, {
      "referenceID" : 10,
      "context" : "Recently, AGM revision was reformulated in the context of Logic Programming in a manner analogous to belief revision in classical propositional logic, and specific revision operators for logic programs were investigated (Delgrande et al. 2008; Osorio and Cuevas 2007).",
      "startOffset" : 220,
      "endOffset" : 267
    }, {
      "referenceID" : 28,
      "context" : "Recently, AGM revision was reformulated in the context of Logic Programming in a manner analogous to belief revision in classical propositional logic, and specific revision operators for logic programs were investigated (Delgrande et al. 2008; Osorio and Cuevas 2007).",
      "startOffset" : 220,
      "endOffset" : 267
    }, {
      "referenceID" : 39,
      "context" : "Central to this novel approach are SE-models (Turner 2003) which provide a monotonic semantic characterisation of logic programs that is strictly more expressive than the answer-set semantics.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 25,
      "context" : "Furthermore, two programs have the same set of SE-models if and only if they are strongly equivalent (Lifschitz et al. 2001), which means that programs P,Q with the same set of SE-models can be modularly replaced by one another, even in the presence of additional rules, without affecting the resulting answer sets.",
      "startOffset" : 101,
      "endOffset" : 124
    }, {
      "referenceID" : 10,
      "context" : "In this paper, we follow a similar path, but to tackle the problem of answer-set program updates, instead of revision as in (Delgrande et al. 2008).",
      "startOffset" : 124,
      "endOffset" : 147
    }, {
      "referenceID" : 40,
      "context" : "We show how this constructive characterisation can be used by defining a concrete answer-set program update operator that can be seen as a counterpart of Winslett’s belief update operator (Winslett 1990) which satisfies the KM postulates and is commonly used in the literature.",
      "startOffset" : 188,
      "endOffset" : 203
    }, {
      "referenceID" : 21,
      "context" : "Update is a belief change operation that brings a knowledge base up to date when the world described by it changes (Keller and Winslett 1985; Katsuno and Mendelzon 1991).",
      "startOffset" : 115,
      "endOffset" : 169
    }, {
      "referenceID" : 19,
      "context" : "Update is a belief change operation that brings a knowledge base up to date when the world described by it changes (Keller and Winslett 1985; Katsuno and Mendelzon 1991).",
      "startOffset" : 115,
      "endOffset" : 169
    }, {
      "referenceID" : 19,
      "context" : "To further specify the desired properties of update operators, the following eight postulates for a belief update operator and formulae φ, ψ, μ, ν were proposed in (Katsuno and Mendelzon 1991): (B1) φ μ |= μ.",
      "startOffset" : 164,
      "endOffset" : 192
    }, {
      "referenceID" : 19,
      "context" : "Definition 3 (Faithful order assignment (Katsuno and Mendelzon 1991)) A preorder assignment ω over I is faithful if for every interpretation I the following condition is satisfied:",
      "startOffset" : 40,
      "endOffset" : 68
    }, {
      "referenceID" : 19,
      "context" : "The representation theorem of (Katsuno and Mendelzon 1991) states that operators characterised by faithful order assignments are exactly those that satisfy the KM postulates.",
      "startOffset" : 30,
      "endOffset" : 58
    }, {
      "referenceID" : 19,
      "context" : "Theorem 4 (Representation theorem for belief updates (Katsuno and Mendelzon 1991)) Let be a belief update operator.",
      "startOffset" : 53,
      "endOffset" : 81
    }, {
      "referenceID" : 21,
      "context" : "The most influential instance of this framework is the Possible Models Approach (Keller and Winslett 1985; Winslett 1990), also referred to as Winslett’s belief update semantics, based on minimising the set of atoms whose truth value changes when an interpretation is updated.",
      "startOffset" : 80,
      "endOffset" : 121
    }, {
      "referenceID" : 40,
      "context" : "The most influential instance of this framework is the Possible Models Approach (Keller and Winslett 1985; Winslett 1990), also referred to as Winslett’s belief update semantics, based on minimising the set of atoms whose truth value changes when an interpretation is updated.",
      "startOffset" : 80,
      "endOffset" : 121
    }, {
      "referenceID" : 14,
      "context" : "the problem of deciding whether φ μ |= ψ, where is characterised by W, belongs to the second level of the polynomial hierarchy (Eiter and Gottlob 1992).",
      "startOffset" : 127,
      "endOffset" : 151
    }, {
      "referenceID" : 27,
      "context" : "Assuming that the reader is familiar with the classes NP and co-NP, we briefly introduce the polynomial hierarchy (Meyer and Stockmeyer 1972; Stockmeyer 1976).",
      "startOffset" : 114,
      "endOffset" : 158
    }, {
      "referenceID" : 38,
      "context" : "Assuming that the reader is familiar with the classes NP and co-NP, we briefly introduce the polynomial hierarchy (Meyer and Stockmeyer 1972; Stockmeyer 1976).",
      "startOffset" : 114,
      "endOffset" : 158
    }, {
      "referenceID" : 14,
      "context" : "4 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W.",
      "startOffset" : 5,
      "endOffset" : 29
    }, {
      "referenceID" : 14,
      "context" : "2 in (Eiter and Gottlob 1992)) Let be a belief update operator characterised by W.",
      "startOffset" : 5,
      "endOffset" : 29
    }, {
      "referenceID" : 10,
      "context" : "We define the syntax and semantics of logic programs, borrowing some of the notation used in (Delgrande et al. 2008).",
      "startOffset" : 93,
      "endOffset" : 116
    }, {
      "referenceID" : 39,
      "context" : "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.",
      "startOffset" : 10,
      "endOffset" : 23
    }, {
      "referenceID" : 17,
      "context" : "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.",
      "startOffset" : 76,
      "endOffset" : 121
    }, {
      "referenceID" : 26,
      "context" : "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.",
      "startOffset" : 76,
      "endOffset" : 121
    }, {
      "referenceID" : 29,
      "context" : "SE-models (Turner 2003), based on the non-classical logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), provide a monotonic characterisation of logic programs that is expressive enough to capture both their classical models and answer sets.",
      "startOffset" : 76,
      "endOffset" : 121
    }, {
      "referenceID" : 39,
      "context" : "Definition 8 (SE-interpretation (Turner 2003)) An SE-interpretation is a pair of interpretations (I, J) such that I ⊆ J .",
      "startOffset" : 32,
      "endOffset" : 45
    }, {
      "referenceID" : 39,
      "context" : "Definition 9 (SE-model (Turner 2003)) Let P be a program.",
      "startOffset" : 23,
      "endOffset" : 36
    }, {
      "referenceID" : 25,
      "context" : "It is typically referred to as strong equivalence (Lifschitz et al. 2001) and the relationship between SE-models and strong equivalence is formally captured as follows:",
      "startOffset" : 50,
      "endOffset" : 73
    }, {
      "referenceID" : 39,
      "context" : "Proposition 10 (SE-models and strong equivalence (Turner 2003)) Let P,Q be programs.",
      "startOffset" : 49,
      "endOffset" : 62
    }, {
      "referenceID" : 10,
      "context" : "More generally, any set of SE-interpretations with this property is referred to as well-defined (Delgrande et al. 2008).",
      "startOffset" : 96,
      "endOffset" : 119
    }, {
      "referenceID" : 10,
      "context" : "Definition 12 (Well-defined set of SE-interpretations (Delgrande et al. 2008)) For every SE-interpretation X = (I, J) we denote by X∗ the SE-interpretation (J, J).",
      "startOffset" : 54,
      "endOffset" : 77
    }, {
      "referenceID" : 10,
      "context" : "Proposition 13 (Delgrande et al. 2008) A set of SE-interpretationsM is well-defined if and only ifM = JP KSE for some program P.",
      "startOffset" : 15,
      "endOffset" : 38
    }, {
      "referenceID" : 13,
      "context" : "Since SE-models provide a monotonic characterisation of logic programs, the analysis provided in (Eiter et al. 2002), which showed KM postulates not appropriate for use with non-monotonic semantics, no longer applies.",
      "startOffset" : 97,
      "endOffset" : 116
    }, {
      "referenceID" : 24,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 3,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 13,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 31,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 42,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 1,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 41,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 9,
      "context" : "The studied operators are semantic in their very nature and in line with KM postulates, in contrast with the traditional syntax-based approaches to rule updates (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang and Foo 2005; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Šefránek 2011).",
      "startOffset" : 161,
      "endOffset" : 339
    }, {
      "referenceID" : 10,
      "context" : "Note that the program conjunction operator may simply return the union of argument programs; it is the same as the expansion operator defined in (Delgrande et al. 2008).",
      "startOffset" : 145,
      "endOffset" : 168
    }, {
      "referenceID" : 17,
      "context" : "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).",
      "startOffset" : 116,
      "endOffset" : 161
    }, {
      "referenceID" : 26,
      "context" : "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).",
      "startOffset" : 116,
      "endOffset" : 161
    }, {
      "referenceID" : 29,
      "context" : "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).",
      "startOffset" : 116,
      "endOffset" : 161
    }, {
      "referenceID" : 7,
      "context" : "A program disjunction operator can be defined by translating the argument programs into the logic of Here-and-There (Heyting 1930; Łukasiewicz 1941; Pearce 1997), taking their disjunction and transforming the resulting formula back into a logic program (using results from (Cabalar and Ferraris 2007)).",
      "startOffset" : 273,
      "endOffset" : 300
    }, {
      "referenceID" : 21,
      "context" : "In what follows, we define a specific update operator based on the ideas underlying Winslett’s update semantics (Keller and Winslett 1985; Winslett 1990) defined Section 2.",
      "startOffset" : 112,
      "endOffset" : 153
    }, {
      "referenceID" : 40,
      "context" : "In what follows, we define a specific update operator based on the ideas underlying Winslett’s update semantics (Keller and Winslett 1985; Winslett 1990) defined Section 2.",
      "startOffset" : 112,
      "endOffset" : 153
    }, {
      "referenceID" : 10,
      "context" : "Similarly as was argued in (Delgrande et al. 2008), since we are working with well-defined sets of SE-interpretations, preference needs to be given to their second component.",
      "startOffset" : 27,
      "endOffset" : 50
    }, {
      "referenceID" : 16,
      "context" : "2 It has been shown that Winslett’s update semantics has some drawbacks, just as other update operators previously proposed in the context of Classical Logic do (see (Herzig and Rifi 1999) for a survey).",
      "startOffset" : 166,
      "endOffset" : 188
    }, {
      "referenceID" : 5,
      "context" : "The property of support (Apt et al. 1988; Dix 1995b) is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy.",
      "startOffset" : 24,
      "endOffset" : 52
    }, {
      "referenceID" : 24,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 3,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 13,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 31,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 1,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 41,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 9,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 8,
      "context" : "As it turns out, it is not difficult to verify that despite the substantial differences between various syntax-based approaches to rule updates and revision, all of the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010) respect support in the following sense:",
      "startOffset" : 193,
      "endOffset" : 352
    }, {
      "referenceID" : 24,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 3,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 13,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 31,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 1,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 41,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 9,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 8,
      "context" : "Similarly as with support, a variety of different syntax-based approaches to rule updates and revision, in particular the semantics introduced in (Leite and Pereira 1998; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Alferes et al. 2005; Zhang 2006; Delgrande et al. 2007; Delgrande 2010), satisfy fact update in the following sense:",
      "startOffset" : 146,
      "endOffset" : 305
    }, {
      "referenceID" : 10,
      "context" : "Moreover, the principle (P4)SE is also adopted for revision of answer-set programs based on SE-models in (Delgrande et al. 2008).",
      "startOffset" : 105,
      "endOffset" : 128
    }, {
      "referenceID" : 10,
      "context" : "This means that Theorem 31 extends to semantic program revision operators, such as those defined in (Delgrande et al. 2008): Whenever",
      "startOffset" : 100,
      "endOffset" : 123
    }, {
      "referenceID" : 20,
      "context" : "3 Note that the belief update postulate (B4), from which (P4)SE originates, is also one of the reformulated AGM postulates for belief revision (Katsuno and Mendelzon 1992).",
      "startOffset" : 143,
      "endOffset" : 171
    }, {
      "referenceID" : 16,
      "context" : "Its two immediate weakenings, analogous to the weakenings of (B4) in (Herzig and Rifi 1999), are as follows:",
      "startOffset" : 69,
      "endOffset" : 91
    }, {
      "referenceID" : 28,
      "context" : "2)SE, also referred to as Weak Independence of Syntax (WIS) (Osorio and Cuevas 2007), does not suffer from such severe limitations.",
      "startOffset" : 60,
      "endOffset" : 84
    }, {
      "referenceID" : 24,
      "context" : "This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal ∼p in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true.",
      "startOffset" : 54,
      "endOffset" : 120
    }, {
      "referenceID" : 3,
      "context" : "This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal ∼p in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true.",
      "startOffset" : 54,
      "endOffset" : 120
    }, {
      "referenceID" : 1,
      "context" : "This is in contrast with the rule update semantics of (Leite and Pereira 1998; Alferes et al. 2000; Alferes et al. 2005) where a default literal ∼p in the head of a rule indicates that whenever the body of the rule is satisfied, there is a reason for p to cease being true.",
      "startOffset" : 54,
      "endOffset" : 120
    }, {
      "referenceID" : 1,
      "context" : "(Alferes et al. 2005), that have matured over the years.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 13,
      "context" : "non-monotonic Logic Programming semantics, as shown in (Eiter et al. 2002), the introduction of SE-models (Turner 2003), which provide a monotonic characterisation of logic programs that is strictly more expressive than the answer-set semantics, provided a new opportunity to cast KM postulates into Logic Programming.",
      "startOffset" : 55,
      "endOffset" : 74
    }, {
      "referenceID" : 39,
      "context" : "2002), the introduction of SE-models (Turner 2003), which provide a monotonic characterisation of logic programs that is strictly more expressive than the answer-set semantics, provided a new opportunity to cast KM postulates into Logic Programming.",
      "startOffset" : 37,
      "endOffset" : 50
    }, {
      "referenceID" : 36,
      "context" : "a) away from the purely semantic approach materialised in AGM and KM postulates, or b) to the development of semantic characterisations of answer-set programs that are richer than SE-models and appropriately capture their dynamic behaviour, such as in (Slota and Leite 2012), or even c) turning back to the more syntactic approaches, such as (Alferes et al.",
      "startOffset" : 252,
      "endOffset" : 274
    }, {
      "referenceID" : 1,
      "context" : "a) away from the purely semantic approach materialised in AGM and KM postulates, or b) to the development of semantic characterisations of answer-set programs that are richer than SE-models and appropriately capture their dynamic behaviour, such as in (Slota and Leite 2012), or even c) turning back to the more syntactic approaches, such as (Alferes et al. 2005), and see whether they indeed offer a viable alternative.",
      "startOffset" : 342,
      "endOffset" : 363
    }, {
      "referenceID" : 13,
      "context" : "For instance, the reformulations of rule change principles from (Eiter et al. 2002) in terms of strong equivalence, considered already in (Delgrande et al.",
      "startOffset" : 64,
      "endOffset" : 83
    }, {
      "referenceID" : 10,
      "context" : "2002) in terms of strong equivalence, considered already in (Delgrande et al. 2008), can be formulated as follows:",
      "startOffset" : 60,
      "endOffset" : 83
    }, {
      "referenceID" : 14,
      "context" : "To do this, we rely on some specifics of the proof of Theorem 6 as it is presented in (Eiter and Gottlob 1992).",
      "startOffset" : 86,
      "endOffset" : 110
    }, {
      "referenceID" : 14,
      "context" : "page 250 of (Eiter and Gottlob 1992)) shows Π2 -hardness of Winslett’s belief update semantics by taking an instance",
      "startOffset" : 12,
      "endOffset" : 36
    }, {
      "referenceID" : 14,
      "context" : "However, we omit the proof of the equivalence (C8) and refer the interested reader to (Eiter and Gottlob 1992) for further details.",
      "startOffset" : 86,
      "endOffset" : 110
    }, {
      "referenceID" : 14,
      "context" : "4 on page 252 in (Eiter and Gottlob 1992)): To prove that P ⊕ U 6|=SE Q, consider only atoms from at(P) ∪ at(U) ∪ at(Q) (this can be done due to Corollary 53), guess some SE-interpretations X and Y , check in polynomial time that X ∈ JP KSE, Y ∈ JU KSE and Y / ∈ JQKSE and invoke the NP oracle to check that there is no Z ∈ JU KSE such that Z <W Y .",
      "startOffset" : 17,
      "endOffset" : 41
    }, {
      "referenceID" : 14,
      "context" : "2 on page 259 in (Eiter and Gottlob 1992)): To prove that P ⊕",
      "startOffset" : 17,
      "endOffset" : 41
    } ],
    "year" : 2017,
    "abstractText" : "Logic programs under the stable model semantics, or answer-set programs, provide an expressive rule-based knowledge representation framework, featuring a formal, declarative and well-understood semantics. However, handling the evolution of rule bases is still a largely open problem. The AGM framework for belief change was shown to give inappropriate results when directly applied to logic programs under a non-monotonic semantics such as the stable models. The approaches to address this issue, developed so far, proposed update semantics based on manipulating the syntactic structure of programs and rules. More recently, AGM revision has been successfully applied to a significantly more expressive semantic characterisation of logic programs based on SE-models. This is an important step, as it changes the focus from the evolution of a syntactic representation of a rule base to the evolution of its semantic content. In this paper, we borrow results from the area of belief update to tackle the problem of updating (instead of revising) answer-set programs. We prove a representation theorem which makes it possible to constructively define any operator satisfying a set of postulates derived from Katsuno and Mendelzon’s postulates for belief update. We define a specific operator based on this theorem, examine its computational complexity and compare the behaviour of this operator with syntactic rule update semantics from the literature. Perhaps surprisingly, we uncover a serious drawback of all rule update operators based on Katsuno and Mendelzon’s approach to update and on SE-models.",
    "creator" : "LaTeX with hyperref package"
  }
}