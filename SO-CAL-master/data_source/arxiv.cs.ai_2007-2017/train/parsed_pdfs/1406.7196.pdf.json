{
  "name" : "1406.7196.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Ricardo Soto" ],
    "emails" : [ "Frederic.Lardeux@univ-angers.fr", "Eric.Monfroy@univ-nantes.fr", "broderick.crawford@ucv.cl", "ricardo.soto@ucv.cl" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 6.\n71 96\nv2 [\ncs .A\nI] 3\n0 Ju\nn 20\nOur technique is simpler, more declarative, and less error-prone than direct and improved hand modeling. The SAT instances that we automatically generate contain less clauses than improved hand-written instances such as in [20], and with unit propagation they also contain less variables. Moreover, they are well-suited for SAT solvers and they are solved faster as shown when solving difficult instances of the Social Golfer Problem.\nKeywords Constraint Programming · CSP · Set Constraints · SAT Encoding · Social Golfer Problem\nF. Lardeux Université d’Angers, France E-mail: Frederic.Lardeux@univ-angers.fr\nE. Monfroy LINA, UMR CNRS 6241, Université de Nantes, France E-mail: Eric.Monfroy@univ-nantes.fr\nB. Crawford Pontificia Universidad Católica de Valparaiso, Valparaiso 2362807, Chile and Universidad Finis Terrae, Santiago 7500000, Chile E-mail: broderick.crawford@ucv.cl\nR. Soto Pontificia Universidad Católica de Valparaiso, Valparaiso 2362807, Chile and Universidad Autnoma de Chile, Santiago 7500000, Chile E-mail: ricardo.soto@ucv.cl"
    }, {
      "heading" : "1 Introduction",
      "text" : "Most of combinatorial problems can be formulated as Constraint Satisfaction Problems (CSP) [19]. A CSP is defined by some variables (generally over finite domains) and constraints between these variables. Solving a CSP consists in finding assignments of the variables that satisfy the constraints. One of the main strength of CSP is declarativity: variables can be of various types (finite domains, floating point numbers, intervals, sets, . . . ) and constraints as well (linear arithmetic constraints, set constraints, non linear constraints, Boolean constraints, symbolic constraints, . . . ). Moreover, the so-called global constraints not only improve solving efficiency but also declarativity: they propose new constructs and relations such as alldifferent (to enforce that all the variables of a list have different values), cumulative (to schedule tasks sharing resources), . . .\nOn the other hand, the propositional satisfiability problem (SAT) [12] is restricted (in terms of declarativity) to Boolean variables and propositional formulae. However, SAT solvers can now handle huge SAT instances (millions of variables). It is thus attractive to 1) encode CSPs into SAT (e.g., [3,5]) in order to benefit from the declarativity of CSP and the power of SAT, or 2) introduce more declarativity into SAT, for example with global constraints (e.g., alldifferent [17], cardinality [4]).\nIn this paper we are concerned with the transformation of set constraints into SAT instances: we often refer to this transformation as ”encoding”. Various systems of set constraints (either specialized systems [18], libraries for constraint programming systems such as [16], or the set constraint library of CHOCO [1]) have been designed for solving problems such as prototyping combinatorial problems, axiomatization of set theory, analysis of programs,. . . They have shown that some problems can easily be modeled with set constraints.\nCoding set constraints directly into SAT is a tedious tasks (see for example [20] or [13]). Moreover, when one wants to optimize its model in terms of variables and clauses this quickly leads to very complicated and unreadable models in which errors can easily appear. Thus, our approach is based on an automated encoding of set constraints into SAT instances. To this end, we define some encoding rules (⇔enc) that encode set constraints (such as intersection, union, membership, cardinal of sets) into the corresponding SAT clauses and variables. The advantage is that the modeling language (i.e., standard set constraints) is declarative, simple, and readable. We have tried this technique on various problems, and the SAT instances which are automatically generated have a complexity similar to the complexity of improved hand-written SAT formulations, and their solving with a SAT solver (in our case Minisat) is efficient.\nWe illustrate our approach with the Social Golfer Problem (problem number 10 of the CSPLib [15]). The problem is the following: q golfers play every weeks during w weeks split in g groups of p golfers (q = p.g). How to schedule\nthe play of these golfers such that no golfer plays in the same group as any other golfer more than once. An instance of the problem is then given by a triple g− p−w. Various instances of the Social Golfer Problem are still open, and the problem is attractive since it is related to problems such as encryption and covering problems. Compared to direct encodings (such as the one of [20]), the instances we generate are smaller (less clauses), and also contain less variables using unit propagation. The introduction of symmetry breaking is simplified with our technique and can be done by adding constraints to the initial model or by refining the initial model. Using Minisat [9], our automatically generated instances (with or without symmetry breaking) are solved faster than the ones of [20].\nWe can compare our work with works of different types, first of all with SAT encoding techniques such as [3] and [5]. These works make a relation between CSP solving and SAT solving in terms of properties such as consistencies for finite domain variables and constraints. In this article, we are concerned with a different type of constraints, i.e., set constraints.\nConcerning applications, i.e., the Social Golfer Problem, the closest work is [20] which is a revision and improvement of [13]. Whereas these works are hand-written modeling of the Social Golfer Problem directly in SAT, we are concerned with a higher-level model language which is automatically transformed into SAT instances. [20] also proposes various symmetry breaking techniques to improve the model; some of these symmetries naturally disappear using our set constraint model (for example, we do not have the permutations due to numbering of groups within a week). The remaining symmetry breakings can easily be introduced in our model, by adding constraints or by refining the initial model.\nIn [6], the Social Golfer Problem is modeled with a combination of set constraints and arithmetic constraints. However, this model is not directly used but it is transformed into CSP before being solved by mimetic algorithms.\nFinally, our approach is similar to [17] in which alldifferent global constraints and overlapping alldifferent constraints are handled declaratively before being encoded automatically in SAT using rewrite rules. Note also that we use the work of [4] about the cardinality global constraint in order to perform the encoding of set cardinality.\nIn the next section (Section 2), we present our set constraint language and the rule-based system for encoding set constraints into SAT; we consider standard set constraints. To get a comparison basis, we then (Section 3) give a direct SAT model of the Social Golfer Problem, and some variants of this model. We then present how to model the Social Golfer Problem with set constraints, and show the interest of our system in terms of declarativity. In Section 4, we show how to introduce symmetry breaking techniques ( that can be found in the literature) with our set constraint language: by adding new constraints or by refining the initial model. In Section 5, we compare various SAT instances, either hand-written our automatically generated with our encoding rule: this analysis is made with respect to instance structures\n(e.g., number of variables and clauses). In the next section, we compare the solving time of these instances. Section 7, discusses various points related to our technique: structure of instances, usefullness of unit propagation, difference with work about set constraints in constraint programming, . . .We finally conclude in Section 8."
    }, {
      "heading" : "2 Set Constraint Encoding",
      "text" : "We present here the encoding of usual (CSP) set constraints (such as ∈, ∪, ∩, . . . ) into SAT clauses. More constraints could be defined, but they can be deduced from these basic constraints.\n2.1 Universe and Supports\nWe consider two notions: universe and support. Unformally, the universe is the set of all elements that are considered in a model of a given problem while the support F of a set F appearing in this model is a set of possible elements of F (i.e., F is a superset of F ).\nDefinition 1 Let P be a problem, and M be a model of P in L, i.e., a description of P from the natural language to the language of constraints L.\n– The universe U of M is a finite set of constants. – The support of the set F of the model M is a subset of the universe U ;\nwe denote it by F . F represents the elements of U that can possibly be elements of F :\nF ⊆ F ⊆ U and F ∈ P(F)\nwhere P(F) = {A|A ⊆ F} is the power set of F . We say that F is over F .\nNote that each element of U \\ F cannot be element of F . In the following, we denote sets by uppercase letters (e.g., F ) and their supports by calligraphic uppercase letters (e.g., F). When there is no confusion of model, we shorten ”the set F of the model M” to ”the set F”.\nConsider a model M with a universe U , and a set F over F . For each element x of F , we consider a Boolean variable xF which is true if x ∈ F and false otherwise. We call the set of such variables the support variables for F in F .\nExample 1 Let U = {x, y, z, t} be the universe of a model M , and F = {x, y, t} be the support of a set F of M . Then, we have 3 Boolean variables xF , yF , and tF corresponding respectively to x, y, and z to represent F . By definition, z 6∈ F and there is no zF variable; and x, y, t can possibly be in F . Consider now that F = {x, y}. Then, xF = true, yF = true, and tF = false\nIn the following, we write xF for xF = true and ¬xF for xF = false.\n2.2 The ⇔enc Encoding Rule\nWe can now define the encoding of the various CSP set constraints into SAT. In the following, we consider three sets F , G, andH respectively defined on the supports F , G and H of the universe U , and for each x ∈ U the various Boolean variables xF , xG , and xH as defined before. |G| denotes the cardinality of the set G.\nNote that we do not force the supports to be minimal: for example, for the equality constraint F = G, the sets F \\ G and G \\ F can be non empty whereas F \\ G and G \\ F must be empty. We thus consider these cases in the ⇔enc encoding rule. Allowing the supports to be non minimal eases the modeling process: indeed, one does not have to compute the minimal support and can use a superset of it or the universe. This is practical when sets are built from many other sets using numerous set constraints. Note also that using the minimal supports reduces the size of the generated SAT instances.\nThe encoding rule is noted ⇔enc. The clauses that are generated by this rule are of the form ∀x ∈ F , φ(xF ) which denotes the |F| formulae φ(xF ) built for each element x of the support F of F (x refers to the element of the universe/support, and xF to the variable representing x for the set F ). For the membership constraint, the rule is not quantified; for multi-intersection and multi-union, an additional universal quantifier over i is used to denote a set of encoding rules, each rule being related to one of the sets Fi.\nIn the following, we propose several set constraint encodings with: first the set constraint, then its encoding in SAT, and finally, the number of clauses generated.\n2.3 Membership Constraint\nThis constraint enforces the membership of an element x to a set F :\n– if x ∈ F (x is in the support of F ), then the corresponding support variable must be true, i.e., xF . – if x 6∈ F (x is not in the support of F ), then the constraint x ∈ F must generate a failure since the problem does not have any solution.\nx ∈ F ⇔enc\n{\nx ∈ F , xF 1 unit clause x 6∈ F , false 1 empty clause\nThe constraint x 6∈ F can be similarly defined.\n2.4 Set Equality Constraint\nTwo sets G and F are equal if and only if:\n– for the elements of F ∩G: the support variables of G have the same values as the support variables of F ;\n– for the elements of F \\G: the support variables of F must be false. Indeed, an element of the universe which is not in the support of a set is not part of this set; thus, an element of F \\ G cannot be in F . – for the elements of G \\ F : the support variables of G must be false.\nF = G ⇔enc\n\n\n ∀x ∈ F ∩ G, xF ↔ xG 2.|F ∩ G| binary clauses ∀x ∈ F \\ G, ¬xF |F \\ G| unit clauses ∀x ∈ G \\ F , ¬xG |G \\ F| unit clauses\nThe constraint F 6= G can be similarly defined by considering the negation of the conjunction of formulae of the previous encoding.\n2.5 Intersection Constraint\nLet H be the intersection of two sets G and F :\n– for the elements of F ∩ G ∩ H: a support variable of H is true if and only if this variable is in F and G; – for the elements of (F ∩ G) \\ H: since such an element cannot be in H , it must not be in F and G; – for the elements of H\\ (F ∩G): a support variable of H which is not in the support of F and G cannot be true\nF ∩G = H ⇔enc\n\n  \n  \n∀x ∈ F ∩ G ∩H, xF ∧ xG ↔ xH |F ∩ G ∩ H| ternary clauses +2.|F ∩ G ∩ H| binary clauses ∀x ∈ (F ∩ G) \\ H, ¬xF ∨ ¬xG |(F ∩ G) \\ H| binary clauses ∀x ∈ H \\ (F ∩ G), ¬xH |H \\ (F ∩ G)| unit clauses\nNote that if H = ∅ (e.g., we want to force the intersection to be empty), then the encoding can be simplified into ∀x ∈ U,¬xF ∨¬xG, and thus, reduce its size to |U | clauses.\n2.6 Union Constraint\nMore cases are to be considered for this constraints:\n– for the elements of F ∩ G ∩ H: a support variable of H is true if and only if this variable is in F or in G; this is the trivial case; – for the elements of (F ∩H) \\G: this case is a reduction of the previous one but it is however equivalent; since such an element x is not in the support of G then xG does not exist, and x is in H if and only if it is in F ; note that the generated clauses are exactly the same removing xG ; – for the elements of (G ∩H) \\ F : this is the symmetrical case for G;\n– for the elements of H \\ (F ∪G): the support variables of H that are not in F or in G must be false; – for the elements of F \\H: elements of the support of F that are not in the support of H cannot be in F ; – for the elements of G \\ H: symmetrical case for G.\nF ∪G = H ⇔enc\n\n        \n        \n∀x ∈ F ∩ G ∩H, xF ∨ xG ↔ xH |F ∩ G ∩ H| ternary clauses +2.|F ∩ G ∩ H| binary clauses ∀x ∈ (F ∩H) \\ G, xF ↔ xH 2.|(F ∩H) \\ G| binary clauses ∀x ∈ (G ∩ H) \\ F , xG ↔ xH 2.|(G ∩ H) \\ F| binary clauses ∀x ∈ H \\ (F ∪ G), ¬xH |H \\ (F ∪ G)| unit clauses ∀x ∈ F \\ H, ¬xF |F \\ H| unit clauses ∀x ∈ G \\ H, ¬xG |G \\ H| unit clauses\n2.7 Inclusion Constraint\n– for the elements of F ∩ G: such an element is in G if it is in F , – for the elements of F \\G: since these elements cannot be in G, they cannot\nbe in F ;\nF ⊆ G ⇔enc\n{\n∀x ∈ F ∩ G, xF → xG |F ∩ G| binary clauses ∀x ∈ F \\ G, ¬xF |F \\ G| unit clauses\n2.8 Difference Constraint\n– for the elements of F ∩ G ∩ H: such elements are in H if and only if they are in F and not in G; – for the elements of F \\ (G ∪ H): such elements cannot be in F ; – for the elements of H \\ F : such elements cannot be in H ; – for the elements of (F ∩H) \\ G: such elements are in H if and only if they\nare in F ; – for the elements of (F ∩G)\\H: since such elements cannot be in H , if they\nare in F they also must be in G;\nH = F \\G ⇔enc\n\n      \n     \n∀x ∈ F ∩ G ∩ H, xF ∧ ¬xG ↔ xH |F ∩ G ∩ H| ternary clauses +2.|F ∩ G ∩ H| binary clauses ∀x ∈ F \\ (G ∪ H), ¬xF |F \\ (G ∪ H)| ternary clauses ∀x ∈ H \\ F , ¬xH |H \\ F| unit clauses ∀x ∈ (F ∩H) \\ G, xF ↔ xH 2.|(F ∩H) \\ G| binary clauses ∀x ∈ (F ∩ G) \\ H, xF → xG |(F ∩ G) \\ H| binary clauses\n2.9 Multi-union Constraint\nThe multi-union constraint H = ⋃n\ni=1 Fi is equivalent to the n constraints expressed as H = F1 ∪ (F2 ∪ (. . . (Fn−1 ∪ Fn) . . .). It is not only a shorthand, but it also significantly reduces the number of generated clauses. Indeed, elements of ⋂n\ni=1 Fi are considered once in the multi-union constraint whereas it is considered n times in the corresponding n union constraints. We do not detail the encoding since this is an extension of the union constraint. In the next formulae, the set {1, . . . , n} is noted N .\nH = ⋃n\ni=1 Fi ⇔enc\n\n    \n    \n∀I, J ∈ P(N), I 6= ∅, I ∪ J = N, ∀x ∈ H ∩ ( ⋂\ni∈I Fi) \\ ( ⋃ j∈J Fj), ∨ i∈I xFi ↔ xH (I)\n∀x ∈ H \\ ( ⋃n\ni=1 Fi), ¬xH (II) ∀i ∈ [1..n], ∀x ∈ Fi \\ H, ¬xFi (III)\n(I) generates ∑\nI,J∈P(N), I 6=∅,\nI∪J=N\n(\n|H ∩ ( ⋂ i∈I Fi) \\ ( ⋃ j∈J Fj)|.(|I|+ 1) ) binary clauses\nand ∑\nI,J∈P(N), I 6=∅,\nI∪J=N\n(\n|H ∩ ( ⋂ i∈I Fi) \\ ( ⋃ j∈J Fj)| ) (|I|+ 1)-ary clauses\n(II) generates |H \\ ( ⋃n\ni=1 Fi)| unit clauses (III) generates ∑n\ni=1 |(Fi \\ H| unit clauses\nNote also that in our implementation that generates SAT instances, the result of an union must be stored in a set: thus, H = ⋃n\ni=1 Fi is equivalent to H = F1∪H1, H1 = F2∪H2, . . .Hn−1 = Fn−1∪Fn. The multi-union constraint thus also significantly reduce the number of variables (variables necessary for the intermediate sets Hi).\n2.10 Multi-intersection Constraint\nSimilarly, we define the multi-intersection constraints. As for the multi-union, the advantage is the gain of clauses, and of variables in our implementation of the encoding.\nH = ⋂n\ni=1 Fi ⇔enc\n\n\n\n∀x ∈ H ∩ ( ⋂n i=1 Fi), ∧n\ni=1 xFi ↔ xH (I) ∀x ∈\n⋂n i=1 Fi \\ H, ∨n i=1(¬xFi) (II)\n∀x ∈ H \\ ( ⋂n\ni=1 Fi), ¬xH (III)\n(I) generates 2.|H ∩ ( ⋂n\ni=1 Fi)| (n+ 1)-ary clauses (II) generates |\n⋂n i=1 Fi \\ H| n-ary clauses\n(III) generates |H \\ ( ⋂n\ni=1 Fi)| unit clauses\n2.11 Cardinality Constraint\nThis constraint is interesting to enforce the size of a set, or to compute the size of a set. We denote by k = |G| the cardinality constraint linking the cardinal of G to the finite domain number (or variable) k. This constraint has been studied for the encoding of global constraints, see for example [4].\nThe very intuitive encoding of this constraint is quite simple. If we have a support G of size n and we want to obtain a set G of k elements (k ≤ n) we have to verify that:\n– All the sets of k + 1 variables have at least one false variable. – All the sets of n− k + 1 variables have at most one true variable.\n|G| = k ⇔enc\n∀{x1, ..., xk+1} ⊆ V , ∨\ni\n¬xi, ∀{x1, ..., xn−k+1} ⊆ V , ∨\ni\nxi\nThe weakness of this encoding is the number of generated clauses:\nn!\n(k + 1)! + (n− k − 1)! +\nn!\n(k − 1)! + (n− k + 1)!\nA more efficient encoding (but less intuitive) for this constraint is the use of the unary representation of integers (an integer k ∈ [0..n] is represented by 1 k times followed by 0 n − k times). This encoding is presented in [4] with two main components: the totalizer and the comparator. Note that we have chosen this encoding for the unit clauses it generates (see Section 3.3.2).\nThe totalizer corresponds to a balanced binary tree structure. It is used to associate an auxiliary variable (output variable) for each variable of the cardinality constraint (input variable) and to sort these new variables such that the true variables are placed before the false variables. Internal variables used to linked input and output variables are called linking variables. The main property of the binary tree is that each non-leaf node corresponds to the union of the two children. The leaves are the input variables and the seed is the set of the output variables. Each node N has two child nodes C1 and C2 that are sets of Boolean variables. We denote C1α the α-th variable of the set C1.\nThe totalizer is encoded by generating for each node the next clauses:\n∧\n0≤α≤|C1| 0≤β≤|C2| 0≤γ≤|N| α+β=γ\n(¬C1α ∨ ¬C 2 β ∨Nγ) ∧ (C 1 α+1 ∨C 2 β+1 ∨ ¬Nγ+1)\nwith\n– C10 = C 2 0 = N0 = 1 – C1|C1|+1 = C 2 |C2|+1 = N|N |+1 = 0\nThe comparator enforces the cardinal k of the set simply by assigning the true value to the first k output variables (noted si) of the totalizer. Its encoding is very simple:\n∧\n1≤i≤k\nsi ∧\nk+1≤j≤n\n¬sj\nIn total, if G is over the support G of size n, then the set constraint |G| = k generates:\n– n+ ∑n i=1 2u n i (⌊ uni 2 ⌋+ 1)(⌈ uni 2 ⌉+ 1)− ( uni 2 + 1) clauses – ∑n\ni=1 u n i variables.\nwith unn = 1,u n 1 = n and u n i = u n 2i−1 + 2u n 2i + u n 2i+1."
    }, {
      "heading" : "3 Models for the Social Golfer Problem",
      "text" : "In this section we describe various SAT related models for the Social Golfer Problem.\n3.1 Direct Encoding\nIn order to present (and then compare) a SAT model for the Social Golfer Problem which does not use set constraints, we give here a model, similar to the one of [20] (which was already a revision of [13]) without auxiliary variables.\nThe Boolean variables to be considered are denoted gq′,p′,g′,w′ meaning (when gq′,p′,g′,w′ is true) that player q\n′ is the p′-th player of the group number g′ of week w′ with:\n– p′ ranging from 1 to p, p being the number of players in each group; – g′ ranging from 1 to g, g being the number of groups each week; – q′ ranging from 1 to q, q = g.p being the total number of players; – and w ranging from 1 to w, w being the number of weeks considered.\nWith the q.p.g.w variables of type gq′,p′,g′,w′ , the constraints are:\n– each golfer plays once per week; – there is p players in each group; – two players never play twice in the same group.\nEach golfer plays at least once per week To enforce that each golfer plays at least once per week, we need the following g.p.w clauses:\nq ∧\nq′=1\nw ∧\nw′=1\np ∨\np′=1\ng ∨\ng′=1\ngq′,p′,g′,w′ (1)\nmeaning that for each week w′, each player q′ is at least the p′-th player in one group g′.\nEach players plays at most once per week Enforcing that each players plays at most once per week is done in two steps, first enforcing that each golfer plays at most once per group in each week: on week w′, group g′, the same player cannot play both on position p′ of g′ and position p′′ of g′:\nq ∧\nq′=1\nw ∧\nw′=1\np ∧\np′=1\ng ∧\ng′=1\np ∧\np′′=p′+1\n¬gq′,p′,g′,w′ ∨ ¬gq′,p′′,g′,w′ (2)\nFormula (2) consists in q.w.g.p.(p− 1)/2 clauses. Then, the following q.w.p.(p − 1).g.(g − 1)/4 clauses ensure than a player does not play in more than a group each week:\nq ∧\nq′=1\nw ∧\nw′=1\np ∧\np′=1\ng ∧\ng′=1\ng ∧\ng′′=g′+1\np ∧\np′′=p′+1\n¬gq′,p′,g′,w′ ∨ ¬gq′,p′′,g′′,w′ (3)\nGroups are correct The same has to be done for groups to ensure that they are correct: one and only one player per position in each group, each week. There is at least a golfer playing at position p′ in the group g′ on week w′; this gives w.p.g clauses:\nw ∧\nw′=1\np ∧\np′=1\ng ∧\ng′=1\nq ∨\nq′\ngq′,p′,g′,w′ (4)\nAnd at most one golfer plays at position p′ in the group g′ on week w′:\nw ∧\nw′=1\np ∧\np′=1\ng ∧\ng′=1\nq ∧\nq′\nq ∧\nq′′=q′+1\n¬gq′,p′,g′,w′ ∨ ¬gq′′,p′,g′,w′ (5)\nwhich results in q.(q − 1).w.p.g/2 clauses.\nThe socialization constraint The only remaining constraint (named the socialization constraint) states that two players cannot play twice in the same group, i.e., if a player q′ plays in the same group g′ on the same week w′ as player q′′, and that q′ plays in another group g′′ another week w′′, then q′′ cannot play on group g′′ on week w′′ at whatever position:\nw ∧\nw′=1\ng ∧\ng′=1\nw ∧\nw′′=w′+1\ng ∧\ng′′=1\nq ∧\nq′=1\np ∧\np1=1\np ∧\np′1=1\nq ∧\nq′′=q′+1\np ∧\np2=1\np ∧\np′2=1\ngq′,p1,g′,w′ ∧ gq′′,p2,g′,w′ ∧ gq′,p′1,g′′,w′′ → ¬gq′′,p′2,g′′,w′′ (6)\nFormula (6) is the hard point of the direct model with a complexity of w.(w− 1).g2.q.(q − 1).p4/4 clauses.\nComplexity of the direct encoding The complexity of the direct encoding DE which contains Formulae (1)–(6) is thus: O(w2.g4.p6) in terms of clauses with p2.g2.w variables.\n3.2 Variants of the Direct Encoding"
    }, {
      "heading" : "3.2.1 The Ladder matrix structure",
      "text" : "In [13] a ladder matrix is used: the ladder matrix, which was first presented in [14], introduces a set of auxiliary variables g′i,k,l ↔ ∨p p′=1 g ′ i,p′,k,l. Intuitively, these new variables abstract the positions of the players in the group. These new variables together with the characteristics of the ladder matrix are then used to model the socialization constraint. The resulting constraints are a bit less complex than the socialization constraint given above, but the ladder matrix introduces an ”intermediate level” in the model which is not so simple to handle and not declarative. Moreover, it also results from this model more variables and more clauses."
    }, {
      "heading" : "3.2.2 Intermediate variables",
      "text" : "In [20], q.g.w intermediate variables g′i,k,l are introduced:\n∀i ∈ [1..q], ∀k ∈ [1..g], ∀l ∈ [1..w], g′i,k,l ↔\np ∨\np′=1\ngi,p′,k,l (7)\nAs for the ladder matrix, these variables abstract the positions of players in the groups. These variables simplify the socialization constraint by abstracting positions as follows:\n∧w w′=1 ∧g g′=1 ∧w w′′=w′+1 ∧g g′′=1 ∧q q′ ∧q q′′=q′+1\n(¬g′q′,g′,w′ ∨ ¬g ′ q′′,g′,w′) ∨ (¬g ′ q′,g′′,w′′ ∨ ¬g ′ q′′,g′′,w′′)\n(8)\nThis introduces q.w.g new intermediate variables g′i,k,l and q.w.g.(p+1) clauses in g′i,k,l ↔ ∨p p′=1 g ′ i,p′,k,l, but this significantly reduces the complexity of the new socialization constraint from w.(w − 1).g2.q.(q − 1).p4/4 to w.(w − 1).g2.q.(q − 1)/4.\nThe complexity of the Triska-Musliu encoding [20] (Formulae (1)–(5), (7), and (8)) is thus O(w2.g4.p2) in terms of clauses. In the following we call this encoding TME. A more complete analysis in terms of variables and clauses is given in Section 5.2.\n3.3 SAT Encoding for Set Constraint Model\nWe propose a model for the Social Golfer Problem using set constraints in a solver independent way. These constraints are then encoded into SAT using our ⇔enc rules."
    }, {
      "heading" : "3.3.1 Set constraints model",
      "text" : "An instance of the problem is thus given by a triple g − p− w:\n– p is the number of players per group; – g is the number of groups per week; – w is the number of weeks;\nThe universe for this model is the set of players P = {p1, . . . , pq} with q = g.p being the total number of players. We need the following w.g set variables to model the groupsG1,1, . . . , Gw,g. The set Gi,j is the group number j of week i and is over the support Gi,j = P . Each Gi,j will contain p players from P . Note that the supports are minimal and cannot be reduced without loosing solutions (or symmetric solutions). We now give the constraints of the Social Golfer Problem.\np players per group every weeks:\n∀i ∈ [1..w], ∀j ∈ [1..g], |Gi,j | = p (9)\nEvery golfer plays every weeks:\n∀i ∈ [1..w] ⋃\nj=1..g\nGi,j = P (10)\nNo golfer plays in two groups the same week:\n∀i ∈ [1..w] ⋂\nj=1..g\nGi,j = ∅ (11)\nHowever, Constraints (11) are not required since they are implied by Constraints (9) and Constraints (10).\nTwo players cannot play twice together in the same group: The simplest formulation is: ∀p1, p2 ∈ P , ∀w1, w2 ∈ [1..w], ∀g1, g2 ∈ [1..g], p1 6= p2 ∧ (g1 6= g2 ∨ w1 6= w2) ∧ p1 ∈ Gg1,w1 ∧ p2 ∈ Gg1,w1 ∧ p1 ∈ Gg2,w2 → p2 6∈ Gg2,w2 meaning : if two different golfers play in the same group g1, if p1 plays in another group g2 then p2 cannot play in this group g2. However, due to the permutations p1, p2, w1, w2, and g1, g2, this constraint introduces redundancies that can be removed using the following constraint:\n∀w1, w2 ∈ [1..w], pi, pj ∈ P , g1, g2 ∈ [1..g],\nw1 > w2 ∧ i > j ∧ g1 ≥ g2 ∧ (12)\npi ∈ Gw1,g1 ∧ pj ∈ Gw1,g1 ∧ pi ∈ Gw2,g2 → pj 6∈ Gw2,g2\nAnother formulation of these constraints can be given using the cardinality constraints:\n∀w1, w2 ∈ [1..w], g1, g2 ∈ [1..g],\nw1 > w2 ∧ g1 ≥ g2 ∧ (13)\n|Gw1,g1 ∩Gw2,g2 | ≤ 1"
    }, {
      "heading" : "3.3.2 SCE: Set Constraint Encoding",
      "text" : "From the set constraint model proposed previously, our ⇔enc encoding rule automatically generates SAT instances as describe in Section 2. For each type of the above constraints we give the number of clauses generated in the SAT instance:\np players per group every weeks: Constraints (9) generates\nw.g.w.(g.p+\ng.p ∑\ni=1\n[2ug.pi (⌊ ug.pi 2 ⌋+ 1)(⌈ ug.pi 2 ⌉+ 1)− ( ug.pi 2 + 1)])\nclauses with ug.pg.p = 1,u g.p 1 = g.p and u g.p i = u g.p 2i−1 + 2u g.p 2i + u g.p 2i+1. The complexity of the formula generated by Constraints (9) is O(w2.g3.p2).\nEvery golfer plays every week: Constraints (10) generates w.g.p clauses.\nTwo players cannot play twice together in the same group: Two formulations are possible:\n– with implication formulation, Constraints (12) generates w.(w − 1).g.(g + 1).q.(q − 1)/2) clauses (O(w2.g4.p2)). – with cardinality formulation, Constraints (13) generatesw.((w−1)/2).g.((g+\n1)/2).3.q.(q+ ∑q i=1[2u q i (⌊\nu q i 2 ⌋+1)(⌈ u q i 2 ⌉+1)−( u q i 2 +1)]) clauses (O(w 2.g5.p3)).\nComplexity of the generated SAT instances Complexity of Constraints (12) is O(w2.g4.p2) whereas complexity of Constraints (13) is O(w2.g5.p3). Thus in the following we will only focus on the implication formulation (Constraints (12)). To summarize, the complexity of the SAT instances generated by the SCE model (Set Constraint Encoding model) made from Constraints (9), (10), and (12) is O(w2.g4.p2). In Section 5.2, we show the exact numbers of clauses that are required for specific instances of the Social Golfer Problem.\nPost-treatment by Unit Propagation Unit propagation is a simply process corresponding to constraint propagation. The idea is to eliminate unit clauses (clauses with only false literals and one free literal) by valuing the free literal to true. This valuation can produce new unit clauses and then the process is achieved until there is no longer any unit clause. In term of complexity, algorithms for unit propagation is in polynomial time; however, in practice, this process is insignificant compared to solving time and may significantly reduce:\n– instances size, – number of variables, – and solving time.\nNote also that the cardinality constraint encoding that we have chosen generates a lot of unit clauses that vanish using unit propagation."
    }, {
      "heading" : "4 Symmetry Breaking for the Social Golfer Problem",
      "text" : "The idea of symmetry breaking is to remove uninteresting solutions and to ease the work of a (SAT) solver. The Social Golfer Problem is highly symmetric: the position of a player in a group is not relevant; the groups in a week can be renumbered; the weeks can be swapped. Symmetry breaking thus consists in eliminating these symmetries by adding new constraints or modifying the model. [13] proposes some clauses to remove symmetries among players, to order groups within a week with respect to their first player, to order lexicographically the weeks with respect to the second player in the first group of each week, ... However, these clauses become more and more complicated and mistakes can easily be introduced. Indeed, [20] revised the clauses for symmetry breaking of [13] in order to correct the ranges of the various ∨ and ∧ appearing in these clauses.\nMore symmetries can be broken, such as in [11] or [10]. All symmetries can be broken, such as shown in [7], but this is often at the cost of a super exponential number of constraints. Thus, this cannot be considered in practice.\n4.1 Symmetry Breaking for TME\nIn [20], three types of symmetry breaking are added to the TME encoding. Note that this is done by adding constraints. The first one consists in breaking the symmetry among players within each group.\nx ∧\ni=1\np−1 ∧\nj=1\ng ∧\nk=1\nw ∧\nl=1\ni ∧\nm=1\n¬Gijkl ∨ ¬Gm(j+1)kl (14)\nThe second one consists in ordering all groups within a single week by their first players.\nx ∧\ni=1\ng−1 ∧\nk=1\nw ∧\nl=1\ni−1 ∧\nm=1\n¬Gi1kl ∨ ¬Gm1(k+1)l (15)\nThe last one consists in strictly ascending second players in the first group of each week.\nx ∧\ni=1\nw ∧\nl=1\ni ∧\nm=1\n¬Gi21l ∨ ¬Gm21(l+1) (16)\nThe encoding TMESB corresponding to the Triska-Musliu encoding with the above symmetry breaking is thus defined by Formulae (1)–(5), (7), (8), (14)–(16).\n4.2 Symmetry Breaking with Set Constraint Model\nWith our set constraint language, we have two possibilities to break symmetries. The first one consists in adding some constraints to the initial model; the second one consists in refining the model itself by modifying the supports of sets and the constraints.\nSince our model is different from the one of [13,20], we do not obtain the same symmetries. However, we try to break similar symmetries as in [13,20].\nThe first group of symmetry breaking (SB1) consists in filling the first week as follows: the first p players are sent to the first group of the first week; the next p players, on the second group of the first week; and so on.\nWe consider a second group SB2 of symmetry breaking which completes SB1. SB2 consists in spreading the first p players (who already played together the first week in the first group due to SB1) in different groups each week: the first player in the first group of each week (except the first week); the second one in the second group of each week; and so on. This approximately corresponds to group (23) of constraints of [20].\nWe first consider the following fact to simplify the following models: when p (the number of players per group) becomes greater than g (the number of groups per week) we can rather obviously see that the problem has no solution. Indeed, consider the p players of the first group of the first week; for the second week, they all must play in different groups; thus, the number of groups needs to be greater or equal to the number of players per group, otherwise, there is no solution. In the following, we thus consider g ≥ p. However, if one does not want to make this simplification, it is sufficient to change p by min(g, p) in the following, and to add the constraints ”Two players cannot play twice together in the same group” between G1,1 and the other groups. Indeed, these constraints make immediately the model unsatisfiable for g < p."
    }, {
      "heading" : "4.2.1 Symmetry breaking for the set constraint model by adding constraints",
      "text" : "In this section constraints are added to the initial model in order to break symmetries. For SB1, we only have to add the following simple constraints to the model of the SCE.\n∀i ∈ [1..p.g], pi ∈ G1,i div (p+1) (17)\nFor the second group SB2 of symmetry breaking, the required constraints are also simple:\n∀i ∈ [2..w], ∀j ∈ [1..p], pj ∈ Gi,j (18)\nWe can note that these constraints add clauses to the set model and its SAT encoding, but all these extra constraints are unit clauses that will produce unit propagation and thus they will vanish.\nThe SAT encoding of the set model with symmetry breaking by adding constraints to the model is named SCESBC and consists in Constraints (9), (10), (12), (17), and (18)."
    }, {
      "heading" : "4.2.2 Symmetry breaking for the set constraint model by modifying the model",
      "text" : "Modifying the model is more tedious. However, the gain is to reduce the supports of sets and cardinality constraints. These modified models will thus significantly reduce the size of the generated SAT instances.\nThe only modification for SB1 consists in both modifying the supports of the groups of the first week and to fix these groups:\n∀i ∈ [1..g],G1,i = {p1+(i−1).g, . . . pp+(i−1).g}\nand\n∀i ∈ [1..g], G1,i = G1,i (19)\nThe other sets, variables, and constraints remain unchanged.\nTo introduce SB2, we change the group variables. Instead of the Gi,j , we now consider the sets G′1,1, . . . , G ′ w,g such that:\n– for the first week Gi,j = G ′ i,j ; – for the following weeks Gi,j = G ′ i,j ∪ {pj} if j ≤ p, Gi,j = G ′ i,j otherwise.\nThe support of the G′1,i (i.e., the groups of the first week) are defined as with SB1. Since the min(p, g) first player are spread on the min(p, g) first groups of each week, the supports of the other groups can be reduced. Let P ′ = {pmin(p,g)+1, . . . , pq} be the set of golfers except the first ones. The supports can thus be defined by:\n∀i ∈ [2..w], ∀j ∈ [1..g],Gi,j = P ′\nConstraints are modified as follows.\nP players per group every weeks: Constraints (9) must be replaced by Constraints (20)–(22).\n∀i ∈ [1..g], |G′1,i| = p (20)\n∀j ∈ [2..w], ∀i ∈ [1..p], |G′j,i| = p− 1 (21) ∀j ∈ [2..w], ∀i ∈ [p+ 1..g], |G′j,i| = p (22)\nEvery golfer plays every week: Constraints (23) replace Constraints (10).\n∀j ∈ [2..w] ⋃\ni=1..g\nGj,i = P ′ (23)\nTwo players cannot play twice together in the same group: Constraints (12) are replaced by Constraints (24)–(27).\nWe recall here that we are working on G′i,j which has the following relation with the intial set Gi,j of the model without symmetry breaking: if j ≤ p and i > 1, then Gi,j = G ′ i,j ∪ {pj}. Since 2 groups Gi,j with j ≤ p and i > 1 have player pj in common, the corresponding groups G ′ i,j (which supports do not contain the pl, l ≤ p) cannot have any other player pk in common:\n∀w1, w2 ∈ [2..w], pi ∈ P , g1 ∈ [1..p], w1 > w2, pi ∈ G′w1,g1 → pi 6∈ G ′ w2,g1\n(24)\nThe relation between other two groups is not changed as shown below.\nConstraints between a group of the first week (except the first group) and groups of other weeks:\n∀w1 ∈ [2..w], pi, pj ∈ P , g1 ∈ [2..g], g2 ∈ [1..g], i > j, pi ∈ G′1,g1 ∧ pj ∈ G ′ 1,g1 ∧ pi ∈ G ′ w1,g2 → pj 6∈ G′w1,g2 (25)\nNote that if one does not consider the simplification p ≤ g, then g1 must be considered in [2..g] to generate the proper constraints (that will generate a failure during the resolution of the SAT instance).\nConstraints between two groups (except of the first week) equally numbered with an index greater than p:\n∀w1, w2 ∈ [2..w], pi, pj ∈ P , g1 ∈ [p+ 1..g], w1 > w2, i > j, pi ∈ G′w1,g1 ∧ pj ∈ G ′ w1,g1 ∧ pi ∈ G′w2,g1 → pj 6∈ G ′ w2,g1\n(26)\nConstraints between two groups (except of the first week) not equally numbered :\n∀w1, w2 ∈ [2..w], pi, pj ∈ P , g1, g2 ∈ [1..g], w1 > w2, g1 6= g2, i > j, pi ∈ G′w1,g1 ∧ pj ∈ G ′ w1,g1 ∧ pi ∈ G′w2,g2 → pj 6∈ G ′ w2,g2 (27)\nThe SAT encoding of the set model with symmetry breaking by modifying the model is named SCESBM and consists in Constraints (19)–(27)."
    }, {
      "heading" : "5 Comparisons of Models",
      "text" : "Table 1 summarizes the various encodings that we will compare in the following sections. These encodings have been described in previous sections. NAMEUP denotes the encoding NAME after unit propagation.\n5.1 Declarativity\nWe compare here the models in terms of declarativity. Comparisons in terms of structures (number of clauses, number of variables) are given in the next section.\nThe first remark is that the variables we use in the set model are much simpler. Indeed, we have only two indices instead of 4, making them more readable. This is due to the fact that we do not have to number the positions in a group (groups are sets), and we do not have to add an index for the number of players (players are members of the groups).\nThe second difference to be noticed is the simplicity and declarativity of constraints. Indeed, set constraints are more declarative than pure SAT clauses. Then, the encoding in SAT is performed using the encoding rules ⇔enc. The advantage is double:\n– first, constraints are readable, declarative, easy to modify, resulting in a much understandable model; – second, less mistakes are introduced since the modeling process is much simpler.\nLast, but not least, the set encoding is solver independent. Indeed, the same model (changing the syntax) could be used in a CSP solver with set constraints or in a SAT solver after applying the rule encoding ⇔enc proposed above.\nAdding symmetry breaking in the direct encodings DE and TME can only be done by adding constraints/clauses.With the set model, symmetry breaking can also be done by modifying the model itself. The process is a bit more complicateed than just adding constraints, but the result is worth: instances are smaller and solving time is faster.\nTo summarize, in terms of declarativity, readability, error introduction, and solver dependence, our set model is superior to direct encodings such as DE or TME. Breaking symmetries is also easier in the set model.\nEach encoding produces specific SAT instances. We compare the direct encodings and the set constraint encoding in two ways: the size of the provided instances and the ease to solve them with a complete SAT solver.\n5.2 Model Structure\nIn order to compare our set constraint encoding, we generate a set of social golfer instances with: the direct encoding DE, the Triska-Musliu encoding (TME) proposed in [20], and our set constraint encoding with unit propagation post-treatment (SCEUP) and without (SCE). In Table 2, each instance is defined by the triple (groups, players per group, weeks) and for each encoding the number of variables and the number of (generated) clauses are provided. It is not possible to compare efficiency of an encoding only in terms of instance size (this is done in the next section). Nevertheless, big instances are intractable due to the limited size of computer memory. It is thus necessary to generate instances as small as possible. In Table 2, for each instance, encodings generating the smallest number of clauses and variables are in bold.\nDirect encoding (DE) is clearly unsuitable when the number of players or groups increases: the number of clauses immediately blows up. With the introduction of auxiliary variables the number of clauses is less important for TME but the number of variables is increased. SCE produces more variables but less clauses. As might be expected, SCEUP provides the most interesting encoding in terms of number of clauses and number of variables: indeed, SCE generates a lot of unit clauses and binary clauses (Section 3.1) than vanish using unit propagation.\n5.3 Impact of the symmetry breaking\nSocial Golfer Problem has a lot of identical solutions modulo symmetries. In Table 3 we apply the two symmetry breaking processes presented in Section 4.2 to the instances proposed in Table 2.\nFor TME, introducing symmetry breaking constraints only increases the number of clauses (around 10% more clauses), the number of variables does not change. Note also that unit propagation is not worth for TME instances nor for TMESB instances: there is no unit clause and the size of the instance is not changed (both in terms of variables and clauses).\nFor SCE, symmetry breaking by adding constraints adds a negligible amount of constraints (see SCESBC). More interestingly, adding symmetry breaking by modifying the model (SCESBM) significantly reduces the size of the generated SAT instances: from 20 up to 60% less variables and from 40 to 60% less clauses. This significant reduction is due to the reduction of supports and to the cardinality constraints: sets with k − 1 elements instead of k, and less clauses are necessary when supports are smaller.\nWithout unit propagation, the instances of SCESBM are always the smallest one generated with respect to the number of clauses.\nUnit propagation has no impact at all on TME. However, its impact is significant on SCE, SCESBM, and SCESBC:\n– for SCE, unit propagation divides the number of variables by 6 to 25: this is mainly due to the variables of the cardinality constraints. The number of clauses is reduced of around 10%. – for SCESBC, unit propagation reduce even more the number of variables (up to 30 times less variables). The number of clauses is reduced from 30 to 60%. – for SCESBM, unit propagation is less spectacular: indeed, the initial model itself is reduced by adding symmetry breaking. However, the number of variable is divided by 5 up to 15. The number of clauses is reduced of about 10%.\nTo summarize, unit propagation is more beneficial to SCESBC; however, SCESBMUP always gives the best instances in terms of number of clauses and number of variables."
    }, {
      "heading" : "6 Experimental Analysis",
      "text" : "In the previous section we have shown that SCE enables us to obtain the smallest instances with unit propagation. The use of symmetry breaking also reduces the size of the SAT instances. It can happen that symmetry breaking makes more difficult the resolution: by changing the search landscape, an ”easy” solution can disappear; with incomplete solvers (such as local search), symmetry breaking can partitions the search space and makes difficult a path\nto a solution. In this section we will compare the efficiency of the encodings in terms of running time.\nTo compare our set constraints encoding with Triska-Musliu [20] encoding, we use the well known solver Minisat [9]. This solver won various competitions 1. Since some few years, a pre-treatment named SatELite [8] has been added to Minisat in order to drastically reduce the number of clauses (e.g., by using subsumptions detections) and variables (e.g., eliminating pure liter-\n1 http://www.satcompetition.org/\nals). This pre-treatment has a cost in terms of running time but it generally improves the global running time. It is now included in Minisat but an option enables one to desactivate it.\nExperimentations are realized on a 2.60GHz Intel Core i5-2540M CPU and 4 GB RAM. For each experiment, the time-out is 300 seconds. Larger execution times were tested but no real differences were observed. Results for the direct encoding DE are not presented since, as supposed, no results are obtained in a reasonable time.\nTable 4 and Table 5 represent respectively the running time of Minisat with the use of SatElite as pre-treatment and without pre-treatment.\nFirst of all, the two tables show that the use of SatElite is difficult to predict: for some instances, it significantly improves the results whereas for others, it significantly degrades the results. On average, it does not improve the results and the best running times are obtained without pre-treatment.\nMoreover, symmetry breaking modifying the model (SCESBM) provides the best results (or results very close to the best ones), with or without pretreament. The use of unit propagation seems to have a weak impact to the resolution time of SCESBM.\nAdding constraints to break symmetries (SCESBC) does not produce improvement except when unit propagation is applied (SCESBCUP ). Indeed, SCE SBC UP obtain results as good as SCESBM. Breaking symmetries in TME is rather fluctuating: depending on the instances and depending on the use of SatELite, it significantly improves or degrades the results.\nTo summarize, the best results are obtained with our set constraint model, with SCESBCUP when the pre-treatment is applied, or predominantly with SCE SBM UP when the pre-treatment is not applied. Finally, the best results are obtained without pre-treatment."
    }, {
      "heading" : "7 Discussion",
      "text" : "Modeling Modeling a problem with set constraints and then automatically generating the corresponding SAT instances is much simpler than writing directly encodings such as DE or TME. Breaking symmetries is rather tedious in direct encodings, very easy by adding constraints in the set model, and rather easy by modifying the set constraint model.\nUsing a higher level formalism (such as our set constraint) is thus beneficial to the modeling phase: it simplifies the task, and avoid making errors (mainly errors in the numerous indices required by a direct encoding). The SAT encoding is then automatically done.\nSAT Instances We have shown that the SAT instances that are automatically produced by our encoding rules are of good quality:\n– they always produce significantly less clauses (with or without symmetry breaking, and with or without unit propagation);\n– with unit propagation, they also generate less variables; – and finally, they are solved faster with Minisat, without ”tuning parame-\nters”, with or without pre-treatment with SatElite.\nSymmetry breaking We have shown that breaking symmetries by adding constraint to the set model is very simple. Moreover, the generated SAT instances after unit-propagation are much smaller, and the solving time is also improved.\nSymmetry breaking by modifying the model is even more beneficial. However, the effort for modifying the model is more important than the effort for adding constraints. This extra work is very beneficial for the size of the generated SAT instances, but not so much worth for the solving time (it is depending on instances, and pre-treatment). Thus, one has to make the trade-off between solving time and modeling time. The size of the generated instances can be the deciding factor: larger problems can be modeled and generated introducing symmetry breaking into the model as in SCESBM.\nSet constraints in constraint programming The declarativity of set constraints in constraint programming (such as in [16] or in [18]) is more or less the same as the one of our set constraints in terms of sets: that was our goal. However, our approach is different: in systems such as [16] or [1], sets constraints are not the only constraints, but a special set solver has to be designed to solve these models. For example, the mechanism of [16] consists in reducing the domain of the sets by working on lower and upper bounds of the sets and to combine this process with search. Note that the domain of a set is similar to our notion of support, and lower and upper bounds of sets are the smallest and largest elements of a set with respect to a given ordering. Our approach is different: we do not want to design a special solver, nor to tune an existing one for efficiently solving our SAT instances; we want to transform a high level model written with set constraints into a good quality (in terms of size and solving time) SAT instance that is efficiently solved by an existing multi-purpose SAT solver.\nNote that in the future, we want to add a pre-process to reduce support sizes. Indeed, the size of the SAT instances depends on the size of the supports. For the Social Golfer Problem, supports are minimal: they cannot be reduced without loosing solutions. But for some other problems, supports can be reduced by a deduction process (withtout loosing solution), and thus, generated SAT instances can be reduced. Such a process could be similar to one application of the first phase of the mechanism of [16] without search.\nNote also that in [2] some comparisons of set constraint solvers in constraint programming are given for the social golfer problem. Most of the results reported are obtained by giving special (dynamic) search heuristics or special solving mechanisms. The approach is thus very different from ours."
    }, {
      "heading" : "8 Conclusion",
      "text" : "We have presented a technique for encoding set constraints into SAT: the modeling process is achieved using some very declarative set constraints which are then automatically transformed into SAT variables and clauses using our⇔enc encoding rules. This technique has been applied successfully to model en encode the Social Golfer Problem, and to study some symmetry breaking on this problem.\nThe advantages of our technique are the following:\n– the modeling process is simple, declarative, and readable. Moreover, it is solver independent and independent from CSP or SAT; – the technique is less error-prone than hand-written SAT encodings; – breaking symmetry can be achieved by just adding new constraints or by\nrefining the model (this cannot be done with direct encodings such as DE or TME); – the SAT instances which are automatically generated are smaller than the ones of [20] that are hand-made written and improved; with unit propagation, our instances also contain less variables than the ones of [20]; – finally, with respect to solving time, our automatically generated instances of the Social Golfer Problem are solved faster with or without unit propagation, with or without constraint breaking, with or without SatElite (the pre-treatment mechanism of Minisat).\nWe have tested our technique to model and solve other problems (such as nqueen problem, Sudoku, WhoWithWhom, . . . ). Each time we obtained very readable and simple set models. The generated SAT instances also appeared to be well-suited for Minisat.\nIn the future, we plan to use our set constraints encoding for formalizing domain variables and sequences of elements. To this end, we will need to add some new constraints and to complete our ⇔enc encoding rule.\nWe want to refine the notion of supports and reduce their sizes. As said before, this do not have any impact on a problem such as the Social Golfer Problem for which supports are already minimal. But for many problems (in which supports are not clear at the principle), it is important to reduce the size of the supports (using a pre-treatment) before generating the SAT instances.\nFinally, we also plan to combine set constraints with arithmetic constraints, and we want to define the corresponding combining SAT encoding.\nReferences\n1. Choco. Http://www.emn.fr/z-info/choco-solver/ 2. Azevedo, F.: An attempt to dynamically break symmetries in the social golfers prob-\nlem. In: F. Azevedo, P. Barahona, F. Fages, F. Rossi (eds.) CSCLP, Lecture Notes in Computer Science, vol. 4651, pp. 33–47. Springer (2006) 3. Bacchus, F.: Gac via unit propagation. In: Proc. of CP 2007, LNCS, vol. 4741, pp. 133–147. Springer (2007)\n4. Bailleux, O., Boufkhad, Y.: Efficient cnf encoding of boolean cardinality constraints. In: Proc. of CP 2003, vol. 2833, pp. 108–122. Springer (2003) 5. Bessière, C., Hebrard, E., Walsh, T.: Local consistencies in sat. In: Selected Revised Papers of SAT 2003., LNCS, vol. 2919, pp. 299–314. Springer (2004) 6. Cotta, C., Dotú, I., Fernández, A.J., Hentenryck, P.V.: Scheduling social golfers with memetic evolutionary programming. In: Proc. of HM 2006, LNCS, vol. 4030, pp. 150– 161. Springer (2006) 7. Crawford, J.M., Ginsberg, M.L., Luks, E.M., Roy, A.: Symmetry-breaking predicates for search problems. In: Proc. of KR’96, pp. 148–159. Morgan Kaufmann (1996) 8. Eén, N., Biere, A.: Effective preprocessing in sat through variable and clause elimination. In: Proc. of SAT 2005, vol. 3569, pp. 61–75 (2005) 9. Eén, N., Sörensson, N.: An extensible sat-solver. In: Proc. of SAT 2003, vol. 2919, pp. 502–518 (2003) 10. Flener, P., Frisch, A.M., Hnich, B., Kiziltan, Z., Miguel, I., Pearson, J., Walsh, T.: Breaking row and column symmetries in matrix models. In: Proc. of CP 2002, vol. 2470, pp. 462–476. Springer (2002) 11. Frisch, A.M., Hnich, B., Kiziltan, Z., Miguel, I., Walsh, T.: Global constraints for lexicographic orderings. In: Proc. of CP 2002, vol. 2470, pp. 93–108. Springer (2002) 12. Garey, M.R., Johnson, D.S.: Computers and Intractability, A Guide to the Theory of NP-Completeness. W.H. Freeman & Company (1979) 13. Gent, I., Lynce, I.: A sat encoding for the social golfer problem. In: IJCAI’05 workshop on modelling and solving problems with constraints (2005) 14. Gent, I.P., Prosser, P.: An empirical study of the stable marriage problem with ties and incomplete lists. In: Proc. of ECAI’2002, pp. 141–145. IOS Press (2002) 15. Gent, I.P., Walsh, T.: CSPLib: A benchmark library for constraints. In: Proc. of CP 1999, LNCS, vol. 1713, pp. 480–481. Springer (1999) 16. Gervet, C.: Conjunto: Constraint propagation over set constraints with finite set domain variables. In: Proc. of ICLP’94, p. 733. MIT Press (1994) 17. Lardeux, F., Monfroy, E., Saubion, F., Crawford, B., Castro, C.: Sat encoding and csp reduction for interconnected alldiff constraints. In: Proc. of MICAI 2009, pp. 360–371 (2009) 18. Legeard, B., Legros, E.: Short overview of the clps system. In: Proc. of PLILP’91, vol. 528, pp. 431–433. Springer (1991) 19. Rossi, F., van Beek, P., Walsh, T. (eds.): Handbook of Constraint Programming. Elsevier (2006) 20. Triska, M., Musliu, N.: An improved sat formulation for the social golfer problem. Annals of Operations Research 194(1), 427–438 (2012)"
    } ],
    "references" : [ {
      "title" : "An attempt to dynamically break symmetries in the social golfers problem",
      "author" : [ "F. Azevedo" ],
      "venue" : "F. Azevedo, P. Barahona, F. Fages, F. Rossi (eds.) CSCLP, Lecture Notes in Computer Science, vol. 4651, pp. 33–47. Springer",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Gac via unit propagation",
      "author" : [ "F. Bacchus" ],
      "venue" : "Proc. of CP 2007, LNCS, vol. 4741, pp. 133–147. Springer",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Efficient cnf encoding of boolean cardinality constraints",
      "author" : [ "O. Bailleux", "Y. Boufkhad" ],
      "venue" : "Proc. of CP 2003, vol. 2833, pp. 108–122. Springer",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Local consistencies in sat",
      "author" : [ "C. Bessière", "E. Hebrard", "T. Walsh" ],
      "venue" : "Selected Revised Papers of SAT 2003., LNCS, vol. 2919, pp. 299–314. Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Scheduling social golfers with memetic evolutionary programming",
      "author" : [ "C. Cotta", "I. Dotú", "A.J. Fernández", "P.V. Hentenryck" ],
      "venue" : "Proc. of HM 2006, LNCS, vol. 4030, pp. 150– 161. Springer",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Symmetry-breaking predicates for search problems",
      "author" : [ "J.M. Crawford", "M.L. Ginsberg", "E.M. Luks", "A. Roy" ],
      "venue" : "Proc. of KR’96, pp. 148–159. Morgan Kaufmann",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Effective preprocessing in sat through variable and clause elimination",
      "author" : [ "N. Eén", "A. Biere" ],
      "venue" : "Proc. of SAT 2005, vol. 3569, pp. 61–75",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "An extensible sat-solver",
      "author" : [ "N. Eén", "N. Sörensson" ],
      "venue" : "Proc. of SAT 2003, vol. 2919, pp. 502–518",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Breaking row and column symmetries in matrix models",
      "author" : [ "P. Flener", "A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "J. Pearson", "T. Walsh" ],
      "venue" : "Proc. of CP 2002, vol. 2470, pp. 462–476. Springer",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Global constraints for lexicographic orderings",
      "author" : [ "A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "T. Walsh" ],
      "venue" : "Proc. of CP 2002, vol. 2470, pp. 93–108. Springer",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Computers and Intractability, A Guide to the Theory of NP-Completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : "W.H. Freeman & Company",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "A sat encoding for the social golfer problem",
      "author" : [ "I. Gent", "I. Lynce" ],
      "venue" : "IJCAI’05 workshop on modelling and solving problems with constraints",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "An empirical study of the stable marriage problem with ties and incomplete lists",
      "author" : [ "I.P. Gent", "P. Prosser" ],
      "venue" : "Proc. of ECAI’2002, pp. 141–145. IOS Press",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "CSPLib: A benchmark library for constraints",
      "author" : [ "I.P. Gent", "T. Walsh" ],
      "venue" : "Proc. of CP 1999, LNCS, vol. 1713, pp. 480–481. Springer",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Conjunto: Constraint propagation over set constraints with finite set domain variables",
      "author" : [ "C. Gervet" ],
      "venue" : "Proc. of ICLP’94, p. 733. MIT Press",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Sat encoding and csp reduction for interconnected alldiff constraints",
      "author" : [ "F. Lardeux", "E. Monfroy", "F. Saubion", "B. Crawford", "C. Castro" ],
      "venue" : "Proc. of MICAI 2009, pp. 360–371",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Short overview of the clps system",
      "author" : [ "B. Legeard", "E. Legros" ],
      "venue" : "Proc. of PLILP’91, vol. 528, pp. 431–433. Springer",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Handbook of Constraint Programming",
      "author" : [ "F. Rossi", "P. van Beek", "Walsh", "T. (eds." ],
      "venue" : "Elsevier",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "An improved sat formulation for the social golfer problem",
      "author" : [ "M. Triska", "N. Musliu" ],
      "venue" : "Annals of Operations Research 194(1), 427–438",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "The SAT instances that we automatically generate contain less clauses than improved hand-written instances such as in [20], and with unit propagation they also contain less variables.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 17,
      "context" : "1 Introduction Most of combinatorial problems can be formulated as Constraint Satisfaction Problems (CSP) [19].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 10,
      "context" : "On the other hand, the propositional satisfiability problem (SAT) [12] is restricted (in terms of declarativity) to Boolean variables and propositional formulae.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 1,
      "context" : ", [3,5]) in order to benefit from the declarativity of CSP and the power of SAT, or 2) introduce more declarativity into SAT, for example with global constraints (e.",
      "startOffset" : 2,
      "endOffset" : 7
    }, {
      "referenceID" : 3,
      "context" : ", [3,5]) in order to benefit from the declarativity of CSP and the power of SAT, or 2) introduce more declarativity into SAT, for example with global constraints (e.",
      "startOffset" : 2,
      "endOffset" : 7
    }, {
      "referenceID" : 15,
      "context" : ", alldifferent [17], cardinality [4]).",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 2,
      "context" : ", alldifferent [17], cardinality [4]).",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 16,
      "context" : "Various systems of set constraints (either specialized systems [18], libraries for constraint programming systems such as [16], or the set constraint library of CHOCO [1]) have been designed for solving problems such as prototyping combinatorial problems, axiomatization of set theory, analysis of programs,.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 14,
      "context" : "Various systems of set constraints (either specialized systems [18], libraries for constraint programming systems such as [16], or the set constraint library of CHOCO [1]) have been designed for solving problems such as prototyping combinatorial problems, axiomatization of set theory, analysis of programs,.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 18,
      "context" : "Coding set constraints directly into SAT is a tedious tasks (see for example [20] or [13]).",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 11,
      "context" : "Coding set constraints directly into SAT is a tedious tasks (see for example [20] or [13]).",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 13,
      "context" : "We illustrate our approach with the Social Golfer Problem (problem number 10 of the CSPLib [15]).",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 18,
      "context" : "Compared to direct encodings (such as the one of [20]), the instances we generate are smaller (less clauses), and also contain less variables using unit propagation.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 7,
      "context" : "Using Minisat [9], our automatically generated instances (with or without symmetry breaking) are solved faster than the ones of [20].",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 18,
      "context" : "Using Minisat [9], our automatically generated instances (with or without symmetry breaking) are solved faster than the ones of [20].",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 1,
      "context" : "We can compare our work with works of different types, first of all with SAT encoding techniques such as [3] and [5].",
      "startOffset" : 105,
      "endOffset" : 108
    }, {
      "referenceID" : 3,
      "context" : "We can compare our work with works of different types, first of all with SAT encoding techniques such as [3] and [5].",
      "startOffset" : 113,
      "endOffset" : 116
    }, {
      "referenceID" : 18,
      "context" : ", the Social Golfer Problem, the closest work is [20] which is a revision and improvement of [13].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : ", the Social Golfer Problem, the closest work is [20] which is a revision and improvement of [13].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 18,
      "context" : "[20] also proposes various symmetry breaking techniques to improve the model; some of these symmetries naturally disappear using our set constraint model (for example, we do not have the permutations due to numbering of groups within a week).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "In [6], the Social Golfer Problem is modeled with a combination of set constraints and arithmetic constraints.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : "Finally, our approach is similar to [17] in which alldifferent global constraints and overlapping alldifferent constraints are handled declaratively before being encoded automatically in SAT using rewrite rules.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 2,
      "context" : "Note also that we use the work of [4] about the cardinality global constraint in order to perform the encoding of set cardinality.",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 2,
      "context" : "This constraint has been studied for the encoding of global constraints, see for example [4].",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 2,
      "context" : "This encoding is presented in [4] with two main components: the totalizer and the comparator.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 18,
      "context" : "1 Direct Encoding In order to present (and then compare) a SAT model for the Social Golfer Problem which does not use set constraints, we give here a model, similar to the one of [20] (which was already a revision of [13]) without auxiliary variables.",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 11,
      "context" : "1 Direct Encoding In order to present (and then compare) a SAT model for the Social Golfer Problem which does not use set constraints, we give here a model, similar to the one of [20] (which was already a revision of [13]) without auxiliary variables.",
      "startOffset" : 217,
      "endOffset" : 221
    }, {
      "referenceID" : 11,
      "context" : "1 The Ladder matrix structure In [13] a ladder matrix is used: the ladder matrix, which was first presented in [14], introduces a set of auxiliary variables g i,k,l ↔ ∨p p′=1 g ′ i,p′,k,l.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 12,
      "context" : "1 The Ladder matrix structure In [13] a ladder matrix is used: the ladder matrix, which was first presented in [14], introduces a set of auxiliary variables g i,k,l ↔ ∨p p′=1 g ′ i,p′,k,l.",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 18,
      "context" : "2 Intermediate variables In [20], q.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 18,
      "context" : "The complexity of the Triska-Musliu encoding [20] (Formulae (1)–(5), (7), and (8)) is thus O(w.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 11,
      "context" : "[13] proposes some clauses to remove symmetries among players, to order groups within a week with respect to their first player, to order lexicographically the weeks with respect to the second player in the first group of each week, .",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "Indeed, [20] revised the clauses for symmetry breaking of [13] in order to correct the ranges of the various ∨",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 11,
      "context" : "Indeed, [20] revised the clauses for symmetry breaking of [13] in order to correct the ranges of the various ∨",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 9,
      "context" : "More symmetries can be broken, such as in [11] or [10].",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 8,
      "context" : "More symmetries can be broken, such as in [11] or [10].",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 5,
      "context" : "All symmetries can be broken, such as shown in [7], but this is often at the cost of a super exponential number of constraints.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 18,
      "context" : "1 Symmetry Breaking for TME In [20], three types of symmetry breaking are added to the TME encoding.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 11,
      "context" : "Since our model is different from the one of [13,20], we do not obtain the same symmetries.",
      "startOffset" : 45,
      "endOffset" : 52
    }, {
      "referenceID" : 18,
      "context" : "Since our model is different from the one of [13,20], we do not obtain the same symmetries.",
      "startOffset" : 45,
      "endOffset" : 52
    }, {
      "referenceID" : 11,
      "context" : "However, we try to break similar symmetries as in [13,20].",
      "startOffset" : 50,
      "endOffset" : 57
    }, {
      "referenceID" : 18,
      "context" : "However, we try to break similar symmetries as in [13,20].",
      "startOffset" : 50,
      "endOffset" : 57
    }, {
      "referenceID" : 18,
      "context" : "This approximately corresponds to group (23) of constraints of [20].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 18,
      "context" : "Table 2 Size of instances generated using the direct encoding (DE), the Triska and Musliu encoding (TME) [20], the set constraints encoding (with unit propagation post-process (SCEUP) and without (SCE)).",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 18,
      "context" : "2 Model Structure In order to compare our set constraint encoding, we generate a set of social golfer instances with: the direct encoding DE, the Triska-Musliu encoding (TME) proposed in [20], and our set constraint encoding with unit propagation post-treatment (SCEUP) and without (SCE).",
      "startOffset" : 187,
      "endOffset" : 191
    }, {
      "referenceID" : 18,
      "context" : "To compare our set constraints encoding with Triska-Musliu [20] encoding, we use the well known solver Minisat [9].",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 7,
      "context" : "To compare our set constraints encoding with Triska-Musliu [20] encoding, we use the well known solver Minisat [9].",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 6,
      "context" : "Since some few years, a pre-treatment named SatELite [8] has been added to Minisat in order to drastically reduce the number of clauses (e.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 14,
      "context" : "Set constraints in constraint programming The declarativity of set constraints in constraint programming (such as in [16] or in [18]) is more or less the same as the one of our set constraints in terms of sets: that was our goal.",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 16,
      "context" : "Set constraints in constraint programming The declarativity of set constraints in constraint programming (such as in [16] or in [18]) is more or less the same as the one of our set constraints in terms of sets: that was our goal.",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 14,
      "context" : "However, our approach is different: in systems such as [16] or [1], sets constraints are not the only constraints, but a special set solver has to be designed to solve these models.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 14,
      "context" : "For example, the mechanism of [16] consists in reducing the domain of the sets by working on lower and upper bounds of the sets and to combine this process with search.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 14,
      "context" : "Such a process could be similar to one application of the first phase of the mechanism of [16] without search.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 0,
      "context" : "Note also that in [2] some comparisons of set constraint solvers in constraint programming are given for the social golfer problem.",
      "startOffset" : 18,
      "endOffset" : 21
    } ],
    "year" : 2014,
    "abstractText" : "On the one hand, Constraint Satisfaction Problems allow one to declaratively model problems. On the other hand, propositional satisfiability problem (SAT) solvers can handle huge SAT instances. We thus present a technique to declaratively model set constraint problems and to encode them automatically into SAT instances. We apply our technique to the Social Golfer Problem and we also use it to break symmetries of the problem. Our technique is simpler, more declarative, and less error-prone than direct and improved hand modeling. The SAT instances that we automatically generate contain less clauses than improved hand-written instances such as in [20], and with unit propagation they also contain less variables. Moreover, they are well-suited for SAT solvers and they are solved faster as shown when solving difficult instances of the Social Golfer Problem.",
    "creator" : "LaTeX with hyperref package"
  }
}