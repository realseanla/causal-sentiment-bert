{
  "name" : "1708.05714.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Stronger Foundation for Computer Science and P=NP",
    "authors" : [ "Mark Inman" ],
    "emails" : [ "mark.inman@egs.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "This article constructs a Turing Machine which can solve for β ′"
    }, {
      "heading" : "1 Turing’s Proof on the Entscheidungsproblem has",
      "text" : "a Fatal Flaw"
    }, {
      "heading" : "1.1 Overview",
      "text" : ""
    }, {
      "heading" : "1.1.1 Context",
      "text" : "Turing’s monumental 1936 paper set the mechanistic description of computation which directly lead to the development of programmable computers. His motivation was the logic problem known as the Entscheidungsproblem, which asks if there exists an algorithm which can determine if any input of first order logic is valid or invalid. After defining automated computing, he described a program called an H Machine which can validate or invalidate its inputs based on reading a description number of that program. However, he did not provide an actual construction of such a machine, he only presumed its possibility to exist. His proof then depended upon this H Machine not being able to validate itself. He gives a detailed description as to why it can not validate itself.\nHowever, a close reading of his paper shows an added assumption by Turing when he constructs his H Machine. While this assumption does not effect the construction or effectiveness of a Universal Turing Machine, it does have an effect on the overall results\nar X\niv :1\n70 8.\n05 71\n4v 1\n[ cs\n.C C\n] 1\n8 A\nug 2\nregarding the Halting problem and its sister problem, the Entscheidungsproblem, as well as any related results having to do with computational complexity.\nThe significance of this discovery of a fatal assumption in Turing’s work, should not be taken lightly. It effects more than just the proof on the Entscheidungsproblem, which should remain open after this discovery, but it also effects existing, accepted results on computability and the very foundations of key concepts in computer science such as complexity. This means we must write new textbooks.\nIn this article, we point out Turing’s assumption and then construct a description of a machine which does exactly what the assumption assumes is impossible. Because we have found an erroneous assumption, we must disregard Turing’s final results and any results which are derived from his method, including the Space Hierarchy Theorem which derives from Turing’s method using the same kind of assumption.\nThe construction of such a machine may have application in fault-tolerance of run-time self-correcting code validation in artificial intelligence implementations. It may also lead to better understanding of complexity relationships between complexity classes, as several results will have to be modified in response.\nFurthermore, in a following section, we review methods which are differently constructed than Turing’s method, but are considered to be reducible to Turing’s method, such as Cantor’s Diagonalization Argument (CDA), and also Gödel’s Diagonalization Lemma (GDL). By addressing all three methods for proof in one article, we have effectively deconstructed the current foundations in computer science when it comes to the limits of computability. If we only deconstructed one method, then there might be reason to ignore our results on the foundation that it does not agree with the other two methods. However, we can and will address all three, and invalidate them all by providing non-trivial counter examples to the false assumptions in the methods."
    }, {
      "heading" : "1.1.2 Preliminary Considerations",
      "text" : "The terms Circular Machine and Circle-free Machine are suitable for our description and we will use Turing’s own definition of a computing machine. It is convenient to note here that a Circular Machine is deemed by Turing to be unsatisfactory due to forever looping, redundantly over a repeating pattern. Also, a Circle-free Machine is deemed by Turing to be satisfactory because of its ability to continue deciding indefinitely, without entering an infinite loop. We have chosen to keep Turing’s original terminology for the sake of clarity when comparing the work of this article to that of Turing’s original paper. Also, we choose his terminology because Turing’s description of the Halting problem is completely mechanical, while many modern descriptions rely on an oracle, Cantor’s Diagonalization or logic similar to Gödel’s Diagonalization Lemma. Turing’s description is independent from these reductions in significant ways as a mechanical process. This helps the reader directly compare this article with the original proof without intermediary interpretations or simplifications. [7]\nA Standard Description or S.D. is the rule set for any given Turing Machine M in a standard form. By creating a standard, the rule sets themselves can be used to create a Description Number or D.N. which itself may be readable by a Universal Turing Machine, U , as an instruction set. [7]\nFrom Turing’s paper:\n“Let D be the Turing Machine which when supplied with the Standard Description (S.D.) of any computing machine M will test this S.D. and if M is circular will mark the S.D. with the symbol ‘u’ and if it is circle free, will mark it with ‘s’ for ‘unsatisfactory’ and ‘satisfactory’ respectively. By combining machines D and U , we could construct a machine H to compute the sequence of β ′ ” [7]"
    }, {
      "heading" : "1.1.3 Turing’s Claim",
      "text" : "Turing claims that while H is circle free by construction, when H is given the description number for H , it becomes circular. [7] In the eighth section of Turing’s paper on the Entscheidungsproblem, Turing claims that β ′ can not be determined because of the following reason: “The instructions for calculating the R(K)-th [figure] would amount to ‘calculate the first R(K)-th figures computed by H and write down the R(K)-th’. This R(K)-th would never be found. I.e. H is circular...” [7]\nThis is because, since H relies on certain subroutines to make its determination, when it reaches and tries to evaluate K, it must call itself, which provides instructions on reading inputs from 1 to K-1 in order to call the R(K)-th figure, but it can never get there, because it keeps repeating its own instruction loop. [7]"
    }, {
      "heading" : "1.1.4 Turing’s False Assumption",
      "text" : "Turing assumed that there is no program that exists which can recognize itself arbitrarily and move to a circle free state upon this recognition. He assumed that any program would have to be programmed in such a way that when it reads itself, and calls its own instructions, it must be circular when trying to determine if it is circular or not, as described in the previous subsection. However, this is not necessarily the case and if we can provide an example of a program which does recognize itself arbitrarily so that it can switch to a circle-free state, then we’ve discovered a means to write H machine in such a way that it may solve for β ′ .\nThe question is, then, is there a Turing Machine which can recognize itself arbitrarily1 when it reaches its own Description Number (D.N.), such that some H machine configuration prints β ′ ?\nWe will, in the next subsection, construct a Supermachine that can recognize itself as its own input which is then instructed to change to a circle free state upon this recognition. Because such a construction exists, and because it is arbitrary for any construction of this class of Turing Machines, we may solve for β ′ non-trivially.\n1by recognizing itself arbitrarily, we mean that it can recognize its own program or description number even if K is not fixed. Also, there may not exist an initializer that feeds a fixed K to be recognized by a single read instruction that skips K and just rubber stamps approval. Such “rubber stamping” is considered a trivial case and is not of concern to this article."
    }, {
      "heading" : "1.2 The Existence of Self-validating Computers",
      "text" : ""
    }, {
      "heading" : "1.2.1 Supermachine",
      "text" : "Let us consider that H ′ is a controller machine with a D.N. of K ′ . It controls two different H machines: H0 and H1. H0 and H1 each have the ability to determine “u” or “s” on a D.N. input, except H0 tests as Turing describes, from D.N. 1 counting upwards (Each D.N. is a natural number) and H1 tests from a certain twos complement of whatever number is being tested by H0 as a simultaneous parallel input, such that its subsequent D.N. is one less than the previously tested D.N. Let us represent each D.N. by some integer i. H0 and H1 have a unique D.N. of K0 or K1 respectively.2\nUpon input of i0 to be read by H0, let H ′\nstore the value pair (i0, z) until i0 is determined to be satisfactory or unsatisfactory. When the output is determined, let H ′ replace the (i0, z) with the respective (i0, s) or (i0, u) in the data store, such that there is no longer a data store of (i0, z). Let the same process occur for i1, such that H ′ also initially stores each D.N. input with (i1, z) and H1 reads i1 to determine satisfactory or unsatisfactory, subsequently replacing the initial value pair with the respective value pair (i1, s) or (i1, u) depending on the output of H1. A redundancy occurs when some i0 = i1.\nLet H ′\nhave the ability to compare value pairs such that the machine may recognize a redundancy when it occurs, and may also recognize when a value pair contains a z value on the condition of such a redundancy. Let’s call this a z-check ability.\nLet Hs be the supermachine that is the configuration of all three H Machines as described above and let Ks be the D.N. for the supermachine.\nInitialize the identifier strings such that K1 < K0. Let the number of bits in K0 = n. Let the twos complement of the first D.N. input to H0 , which is 1, be determined by n such that it satisfies the equation c = 2n−1.\nLemma. Hs proceeds circle free, until it reads Ks. If c −K0 > K1, then re-initialize the D.N.3 in either K0 or K1 such that c −K0 < K1. This guarantees that H0 will read K1 before H1 reads K1 and also guarantees H1 will read K0 before H0 reads K0. Let the controller H ′ contain a memory command which stores the decision value pairs of H0 and H1. The controller may routinely check for a redundancy on the next input.\nNow consider when H0 reads K1, and K1 calls the D.N. for H0: H0 will call H1, which will call H0 which will result in a z-check, recognizing that the value pair (K0, z) is already stored in memory, and therefore, since K0 < c, we know that K0 is the description number for itself, which is impossible to call by construction without calling H1 first, which means it must be checking the description number for a machine which calls itself, namely H1, which allows us to correctly store the value pair (K1, s). This same reasoning can be applied for when H1 reads K0, correctly storing the value pair (K0, s).\n2This can be determined through a unique identifier string, which does not effect The machine’s function or performance, but differentiates the two machines from each other giving them each a unique D.N.\n3one may re-initialize, if necessary, the D.N. by adding irrelevant description information into some S.D. yielding a different D.N. provided such information does not affect the integrity of the original S.D.\nIf however, the machine has determined a redundancy occurred on a value pair where the value is either (i, s) or (i, u) (i.e., a negative evaluation on the z-check, but the redundancy check is positive), then we have already evaluated this D.N. from the other H machine at the top level, and we no longer have to continue within the range 1 to c, since they will all have been decided. The supermachine, at this point proceeds to utilize machine H0 and proceeds from D.N. input value c+1, and continues through the rest of all Description Numbers, c+ 2, c+ 3, etc... at least until it reaches its own D.N., Ks, for no other D.N. should be problematic in determining the output decision. Thus, Hs proceeds circle free, at least until it reaches Ks which is easily constructed to be larger than c.\n1.2.2 β ′ is Decidable\nProof. β ′ is Decidable. At the point K ′ is received as an input, it is determined satisfactory by either H0 or H1. Neither H0 nor H1 are called during this phase of the process.\nBy lemma, K0 is decided by H1, K1 is decided by H0 and Hs continues indefinitely until we reach Ks, which describes Hs. Ks is read by H ′ and as before, its Description Number is stored along with its temporary pair value of z until H0 or H1 returns a value for β ′ at that location. Ks is sent to be verified by H0, which when H ′ calls Ks for a second time, under the given recursive property of Ks which will eventually call itself, the z-check for value pair (Ks, z) is recognized as both redundant and with a z value, stored by H ′ in the data store, but because the associated value is z, the z-check ability tells us this process has already occurred, sends Ks to H1, which self-verifies repeated z-check values. By construction, the only value Ki which can provide this multiple z-check values where Ki > c is Ks, so Hs now self-verifies the input Ks as its own D.N., provides a value of “s” for satisfactory, and changes state to evaluate Ks +1 to continue indefinitely as a Circle-free Turing Machine.\nTherefore, given some Universal Turing Machine which can emulate the Hs Machine, β ′ is decidable over the set of all Description Numbers. y"
    }, {
      "heading" : "1.3 Consequences",
      "text" : "Solving for β ′\nis RE-complete. If Turing were correct, it would be impossible to solve for this output. Since we have solved for β ′ , we must consider the possibility that there is a problem with our configuration which makes it impossible, or that there is something fundamentally incorrect with our current foundations of mathematics.\nFor this reason, we continue in the next section to examine Cantor’s Diagonal Argument, of which Turing’s method is equivalent, as they can reduce the same results to each other. If there is nothing fundamentally wrong with the foundations of mathematics and computer science, we should expect that any counter examples to CDA will not exist, or will be trivial. However, if we can find counterexamples for arbitrary\nsolutions, then such solutions will not be trivial and will reinforce the findings of this first section on the Entscheidungsproblem."
    }, {
      "heading" : "2 A Non-Trivial Counterexample to Cantor’s Diag-",
      "text" : "onalization Argument"
    }, {
      "heading" : "2.1 Overview",
      "text" : ""
    }, {
      "heading" : "2.1.1 Method and Foundations",
      "text" : "Conventional thought on CDA is that we would need an entirely new axiom schema to find a counterexample to the method [2]. However, no new axioms are needed in this article to find a counterexample to CDA. We present in this section, a new grammar to generate a formal language for representation of an ω-regular language through accepted foundations in set theory and the principles of formal languages.\nFor logical consistency, in order to examine CDA, we can not assume outright that CDA is a method which produces theorems, nor can we rely on any theorems derived from CDA or those theorems that reduce to it. This includes Turing’s proof on the Entscheidungsproblem, as discussed in a pervious section, in our exploration of it, as well as the downward Lowenheim-Skolem Theorem, or complexity results which rely on diagonalization such as the Space Hierarchy Theorem, et al. We must also exclude consequences of Cantor’s First Proof of Uncountability (CFPU) because of its similarity to the method of CDA. This requires that we assume the cardinality of the Real numbers as it relates to the Natural numbers is unknown, since CDA and CFPU are the very foundation that prove the Reals are strictly larger than the Natural numbers. This is for logical consistency only, our proof does not directly concern us with the cardinality of the Real numbers. We are currently only concerned with the foundations that lead to these prior results, and the counterexamples which call them into sincere question.\nWe will re-explore CDA by creating an Abelian group which can be used as a representation of an ω-regular language, and its set of well formed strings, explore this representation’s properties and expressive power as a language, and create a class of constructions of CDA which lead to non-trivial counterexamples to CDA. The resulting counterexamples to CDA are found through a transformation of equivalent statements over the construction."
    }, {
      "heading" : "2.2 Representing an ω-language by a Recursively Enumerable Language",
      "text" : ""
    }, {
      "heading" : "2.2.1 Notation and Preliminaries",
      "text" : "Definition Let the Natural numbers be denoted by N. Definition Let ω be the rank of N, from the Von Neumann Hierarchy. Definition Let ℵ0 be the cardinality of N and the cardinality of any set bijective to N.\nDefinition An ω-expansion is an unbounded expansion of symbols on a string Lim→ω, and is denoted, for some symbol, z, as zω such that the cardinality of the set of the number of symbols represented by the ω-expansion zω is ℵ0. Definition An iteration of symbols has gone through ω-completion when an unbounded set of recursions of symbols in a string has a symbol or the empty string, at the rank of the set of iterations. Definition Let exhaustion be a necessary change in output of a recursion after ωcompletion of such recursion of symbols, where s at exhaustion is the symbol at the rank of the unbounded iteration and s 6= i when i is the first symbol of the set of symbols in the recursion.\nFor example, let x be defined as an infinite word having both 0 and 1’s written on an infinite tape, however, we know that the starting symbol is 1, and there are an ω number of 1s on the tape prior to any 0 appearing. We can prove by exhaustion that the ωth symbol of the infinite word is 0, since ω is the rank of the total number of 1s on the infinite tape and the symbol must change necessarily at that point, as we know the word contains a 0. Definition Let a special order of some set S be some ordering of S such that we may determine the value of any distinct element of S by some operation on S which guarantees the result is in S; i.e. an order which is arbitrary under closure. Definition Let ∑ be a set of terminal symbols which is its alphabet. Definition Let V be a set of non-terminal starting symbols and R be a set of rules, each in the form xAx−→ xw for some strings w ∈ ∑ , x ∈ V ⋃ ∑ when A ∈ V.\nDefinition Let ∑\nbe an alphabet with at least 6 elements and the empty string . Definition Let ∑∞ 1 be the set of all strings over ∑ which includes all ω length strings.\nDefinition Let ∑∞\n2 be the set of strings which also include strings of length ω over a subset ∑ 2 of at least two elements in ∑ .\nDefinition Let ∑ω 3 be the subset of ∑∞\n2 which are only the recursive, countably infinite length strings over ∑ 2 so that the set of all symbols in each string has a cardinality ℵ0. Definition A language of the class of computable transfinite number T has a subset of unique finite length strings ∑∗ 4 of ∑∞ 1 that is either bijective or surjective (but not\ninjective) to the set ∑ω\n3 . Definition The alphabet ∑ 4 must also have a subset of at least three elements not a\nmember of ∑\n2 with at least one of these symbols to distinguish context between other symbols of value. Remark Note that the total cardinality of the set of strings in ∑ω 3 is ℵ20 and fully\nrepresentable by an ∑∗\n4 mapping via Cantor pairing between the sets. Definition Let ∑∗ 2 be the set of finite length strings over ∑ 2. For any language L in\nthe class T, the set of strings ∑∗ over L, ∑∗ = ∑∗\n4 ⋃ ∑∗ 2."
    }, {
      "heading" : "2.2.2 A Grammar for a Language in T",
      "text" : "Chomsky, Backus and Naur laid the foundation for work in generative grammars and our understanding of computer syntax with Backus-Naur form and the Chomsky hierarchy among other means of representing and categorizing generative grammar structures. Here we utilize formal language theory to produce the following grammar which\nyields a recursively enumerable context sensitive language.[3] Definition Let the grammar LT (G) be a tuple, {V, ∑ , R, S}. S ∈ V, ∑ 2 ⊂ ∑ , ∑ 3\n⊂ ∑ , ∑ 4 ⊂ ∑ , such that: V ⋂ ∑\n= ∅, V={S, T, A, B, C, Q, U},∑\n={ ε, 0, 1, 0 , 1 , [, ] },∑ 2={0,1},∑ 3={0,1},∑ 4={ ε, 0, 1, 0 , 1 , [, ] },\nR={S−→ ε, S−→T, T−→ε, T−→A, T−→B, T−→C, T−→Q, A−→1, A−→0, A−→0A, A−→1A, A−→0C, A−→1B, B−→0, B−→0A, B−→0 , B−→0C, C−→1, C−→1A, C−→1B, C−→1 , Q−→[Q], Q−→[U], Q−→T[U]T, Q−→T[U]T[U]T, U−→01B, U−→10C, U−→0A, U−→1A, U−→0C, U−→1B}\nDefinition Let LT be a language of the elements in ∑∗\n4 which generate only from grammars generated by the non-terminals B, C, Q and U that cannot be generated exclusively by the non-terminal A. Let the elements of ∑∗ 4 have an onto mapping to\nthe recursive strings of infinite length in ∑ω 3 (i.e. those strings from ∑ω\n3 which are readable by Büchi automaton). [1]\nDefinition We define ρ∗ as the set of all well formed strings over LT .\nLemma ρ∗ is an Abelian Group"
    }, {
      "heading" : "2.2.3 Addition in ρ∗",
      "text" : "Definition LENGTH(x) is a function which outputs the length of a string within brackets. Definition PLUS1(w) = w + 1 = 1 + w and follows these rules:\nPLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1\nDefinition PLUS1 (w) = w + 1 = 1 + w and follows these rules:\nPLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]\nDefinition Let PLUS() be commutative such that PLUS(w1, w2) = w1+w2 = w2+w1, and follows these rules:\nPLUS(w10, w20) := PLUS(w1, w2)0 PLUS(w11, w20) := PLUS(w1, w2)1 PLUS(w10, w21) := PLUS(w1, w2)1 PLUS(w11, w21) := PLUS1(PLUS(w1, w2))0 PLUS(w11 , w20 ) := PLUS(w1, w2)1 PLUS(w10 , w21 ) := PLUS(w1, w2)1 PLUS(w11 , w21 ) := PLUS1(w1, w2))0 1 PLUS(w10 , w20 ) := PLUS(w1, w2)0 PLUS(w11 , w21) := PLUS(w1, PLUS1 (w2))0 PLUS(w11 , w20) := PLUS(w1, PLUS1 (w2))1 PLUS(w10 , w20) := PLUS(w10 , w2)0 PLUS(w10 , w21) := PLUS(w10 ,w2)1\nPLUS(w1[x0], w20) := PLUS(w1[0x], w2)0 PLUS(w1[x0], w21) := PLUS(w1[0x], w2)1 PLUS(w1[x1], w20) := PLUS(w1[1x], w2)1 PLUS(w1[x1], w21) := PLUS(PLUS1(w1[0x]), w2)0 PLUS(w1[x0], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1 (x)1] PLUS(w1[x1], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1 (x)0] PLUS(w1[x0 ], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1 (x)1 ] PLUS(w1[x1 ], w21 ) := PLUS(PLUS1 (w1), w2)[PLUS1(x)1 0] PLUS(w1[x1 ], w20 ) := PLUS(w1[1 x, w2)1 ] PLUS(w1[x0 ], w20 ) := PLUS(w1, w2)[x0 ]\nRemark Similarly, brackets may also appear in w2, but details are omitted for the sake of brevity.\nDefinition To define the set P∗, let us suppose Kleene star expansions of strings\nover ρ∗: ‘(w1)*([(w2)*])*(w3)*’ and an expansion rule such that when there exists the terminal 0 in a string, there can be a Kleene star expansion of ‘0’ either to the left or the right or both of 0 such that ‘0*0 0*’ is a valid string and similarly for 1 such that ‘1*1 1*’ is a valid string. P∗ is the union of ρ∗ and all such Kleene star expansions in ρ∗.\nDefinition Let an ω-expansion of a string be an infinite iteration operator similar to a Kleene star expansion, but for infinite words.\nDefinition LENDIFF( ): For all x in strings w3, w4: LENDIFF(LENGTH(x1)*LENGTH(x2)) := LENGTH(xy) where xy is a concatenation of x1 LENGTH(xy) times. LENDIFF(LENGTH(x1)*LENGTH(x2)) := LENGTH(xz) where xz is a concatenation of x2 LENGTH(xz) times.\nWhen LENGTH(x1) != LENGTH(x2):\nDefinition PLUS(w1[xy], w2[xz]) := PLUS(w3, w4)\nRemark Addition is Commutative: By the definition of the PLUS function, addition is commutative in ρ∗; the equation a+ b = b+ a holds for all a, b in ρ∗.\nRemark It is easy to allow addition to be associative in ρ∗ such that the equation (a+ b) + c = a+ (b+ c) holds for all a, b and c in ρ∗.\nRemark The identity element exists as 0, for all w:\nPLUS(w, 0)=w\nDefinition Let String Equality be the condition where expanded strings from a formal language, either by Kleene star expansions or ω-expansions, have equality with strings from which they expanded.\nDefinition Let w1 be a string from ρ ∗ and let w2 be a string expanded from w1 such that for every symbol 0 in a string, there is string equality when 0 = 0 0* and 0 = 0 0ω. There is also string equality when for every symbol 1 in a string, 1 = 1 1* and 1 = 1 1ω.\nDefinition Let Pω be all the strings in ρ∗ union all ω-expansions and Kleene star expansions of symbols in P∗. Because of string equality, for w1 in ρ ∗ and for w2 in P ω PLUS(w1, 0) := PLUS(w2, 0).\nDefinition Let P8 be all strings in Pω which are not in ρ∗.\nProposition Addition in ρ∗ is closed. PLUS( ) will only yield answers in ρ∗ or P8\nby the function PLUS( ). For any strings w1 ∈ ρ∗, w2 ∈ ρ∗, PLUS(w1, w2):=wa, if wa ∈ P8, there exists a String Equality in ρ∗, such that wa = wb where wb is in ρ∗ and PLUS(w1, w2):=wb through reflexivity. Since wb /∈ P8, it must be in ρ∗. Therefore, addition is closed in ρ∗.\nProposition There is an additive inverse for each w ∈ ρ∗. For every wx, there exists some wy through iteration in PLUS(wx, wy) such that the output string will be some combination of terminals 0* and 0 *, which through String Equality=0.\nLemma. ρ∗ is an Abelian Group under addition. From the previous two propositions, and because or definition of PLUS( ) includes commutativity, by the definition of an Abelian Group as having closure, associativity, an identity element, an inverse element and commutativity, ρ∗ is an Abelian Group under addition."
    }, {
      "heading" : "2.3 A Non-trivial Counterexample to Cantor’s Diagonal Argument",
      "text" : ""
    }, {
      "heading" : "2.3.1 Formalizing a Diagonal Argument Function",
      "text" : "For Cantor’s Diagonal Argument, one may generalize an argument function, for proof by contradiction, through constructing an arbitrary sequence of infinite length strings in any order into an N by N matrix of symbols and assuming all rows of the matrix contains all string values. Then, one proceeds to the ithcolumn, jth row of the matrix, where (i, j ) moves along the diagonal of the matrix- (1,1), (2,2), (3,3)... etc. The symbol at that position is then changed to a different symbol within the language of the system and concatenated to produce a new string, which when so constructed, the new string of symbols can’t be found in any row or column of the matrix, thus providing a string of a value not listed in the matrix. The new string is considered transcendental in Cantor’s Universe and the proof by contradiction tells us that not every string value can be calculated in Cantor’s Universe through iterative process, and as such, R is “uncountable” and has a cardinality strictly larger than N. This is necessarily true for all constructions of the diagonal argument prior to the method employed in this paper because the ith string must contain the symbol found at (i, j ) which can not be in the constructed string at (i, j ) from the diagonal and there did not yet exist a mapping relationship suitable for counterexample to CDA. [3]\nThe following construction maps the set ρ∗ with equivalent strings in Pω, showing that the diagonal argument applied to a special ordering of subsets in Pω, yields a non-trivial counterexample to Cantor’s argument function.\nRemark It should be noted that because the elements of Pω are not the Real numbers, and thus, the trivial exception where .9̄=1 is not a concern because this evaluation or any equivalent evaluation does not exist in Pω by construction and this exception simply cannot occur. We will not concern ourselves with this exception, since it is a special case, it is considered trivial. However, if such a case could be generalized, it would no\nlonger be trivial."
    }, {
      "heading" : "2.3.2 Additional Notations and Preliminaries",
      "text" : "Consider a proof by contradiction as an argument function f (S ) over a set S yielding a domain f(S)→ g(S) and some countable set of matrices reducible via Cantor Pairing to size N× N, {f (S )}, to which we will apply an argument function f (S ).\nDefinition A counterexample to an argument function (which is a proof by contradiciton), is the condition when there exists f (S )→g(S ) such that for any g(S )∈ {f (S )} iff g(Q)/∈ {f (Q)} OR if any g(S )/∈ {f (S )} iff g(Q)∈ {f (Q)} for sets S and Q.\nDefinition Let right-concatenation be the concatenation operator * such that when w1 right concatenates over w2, w1*w2=w2w1 and likewise, w1*w2*w3*w4=w4w3w2w1\nDefinition Let str(f ( xj ) ) be the cumulative string of the output of the function f (xj)* f (xj−1)* f (xj−2)... *f (xj−j). Similarly for str(g( xj ) ).\nDefinition Let the argument function f (R) be a construction of Cantor’s diagonal method on the N × N matrix {f (R)} of arbitrary unbounded binary strings. They are listed in any order, assuming that all possible string values of R are listed. Let g(R)=str(g(xj)) where xj is the value, 0 or 1 at the coordinate (i,j ) for all j on the constructed matrix at row j such that j=i. It is well established that in Cantor’s Universe, g(R)/∈ {f (R)}, and we can produce a string which is in R but not in {f (R)}.\nFor counterexample, since we accept g(R)/∈ {f (R)}, we must find some set of recursively enumerable sets or set of uncountable sets S where g(S) ∈ {f (S)}.\nDefinition Let the argument function f (Pω0 ) be an equivalent construction of Cantor’s diagonal method where a series of N × N matrices, {f (Pω0 )}, is partitioned into two specially ordered matrices, {f (Pω1 )} and {f (Pω2 )}. {f (Pω1 )} ⊂ {f (Pω0 )} and {f (Pω2 )} ⊂ {f (Pω0 )}. These two partitions will be proper disjoint subsets of {f (Pω0 )} such that {f (Pω1 )} ⋃ {f (Pω2 )}={f (Pω0 )}.\nConstruct the argument function for application of CDA to Pω0 , {f (Pω0 )}, in the following manner: Let ρ∗ map to two sets, ρ∗1 and ρ ∗ 2, through choice, choosing the strings in ρ∗1 as all the strings where each string is denoted by the initial with Kleene star expansions, from left to right as follows: 0w, 0w, [∗0w or [∗0w. And likewise, choose the strings in ρ∗2 as all the strings where each string is denoted by the initial, from left to right, 1w, 1w, [∗1w or [∗1w, thus creating a strictly bijective disjunction between the sets whose union is ρ∗. Choose some string set in ρ∗1 such that it maps to an infinite length string by String Equality in Pω to form the set Pω1 . Choose some string set in ρ∗2 such that it maps to some infinite length string by String Equality in P\nω to form the set Pω2 . Let the union of P ω 1 and P ω 2 be P ω 0 .\nWe will begin the proof of the existence of the counterexample to CDA by proceeding\nwith a construction of f (Pω1 ) and f (P ω 2 ) individually, and then providing a retrograde on str(g(Pω2 )) to construct the diagonal of {f (Pω0 )}."
    }, {
      "heading" : "2.3.3 Theorem",
      "text" : "Proof. There is a Non-trivial Counterexample to Cantor’s Diagonal Argument. 1. ρ∗ is an Abelian group by Lemma. 2. By String Equality we can create an Abelian Relationship in all extended sets\nrelated to ρ∗ by providing an operation on a string in ρ∗ to yield another result in ρ∗, which can then be made equal to some string in Pω and its subsets, thus allowing for special order, utilizing exhaustion, if necessary. 3. We will choose the elements of Pω1 and P ω 2 in such a way, that when proceeding\nwith the argument function down the diagonal of the respected matrices, {f (Pω1 )} and {f (Pω2 )}, we will encounter only the symbols 0 and 1, respectively. This can be ensured by expanding other symbols when necessary. We will reserve the axiom of replacement if necessary when forming the sets to aid in our choice for the rows in the respective matrix sets. 4. Proceeding to f(Pω1 ), we choose to write the row, j = 1, as some 01 as it’s defined mapped string, 01 1ω and by the argument function, utilize the symbol from the 1st column of this row such that f (x1):=0 and str(g(x1)):=1. 5. Choose in the set such that the second row in {f (Pω1 )} is 01=0 0ω1ω1 and f (x2):=0, and str(g(x2)):=11 in accordance with the argument function. 6. Thus, through ω-completion of the recursive iterations resulting in an unbounded series, for all j in {f (Pω1 )}, f (xj):=0; g(xj):=1. 7. It follows through String Equality that g(Pω1 )=1 . 8. Likewise, proceeding to f(Pω2 ), we choose to write the row, j = 1, 10 as it’s\ndefined mapped string as some 10 0ω and by the argument function, utilize the symbol from the 1st column of this row such that f (x1):=1 and str(g(x1)):=0. 9. Choose in the set such that the second row in {f (Pω2 )} is 10=1 1ω0ω0 and f (x2):=1, and str(g(x2)):=00 in accordance with the argument function. 10. Thus, through ω-completion of the recursive iterations resulting in an unbounded series, for all j in {f (Pω2 )}, f (xj):=1; g(xj):=0. 11. It follows through String Equality that g(Pω2 )=0 . 12. The retrograde of g(Pω2 )=0 is reflexive, 0 . 13. The special order of {f (Pω0 )} is the special order of {f (Pω1 )} union the retrograde\nof the special order of {f (Pω2 )}, allowing for an inversion on the strings in the diagonal, because of retrograde, for consistency in the argument function. 14. Through String Equality, g(Pω0 )=10 15. By choice of {f (Pω2 )} which is a subset of {f (Pω0 )}, as illustrated by step 9 in this\nproof, the string 10=1 1ω0ω0 is in {f (Pω0 )}. 16. Therefore, there exists a counterexample; when g(R) /∈ R, g(Pω0 ) ∈ Pω0 .\ny"
    }, {
      "heading" : "2.4 Discussion",
      "text" : "We can easily generalize this counterexample for all elements in ρ∗ by choosing the appropriate ordering of the list of elements used for constructing the diagonal.\nFinding such a non-trivial counterexample to CDA provides a new understanding about the limits of computability and these results confirm the flaw found in the Entscheidungsproblem. It would be wise for logicians, mathematicians and computer scientists to revise all their texts accordingly. However, I recognize that this is quite an ordeal, so we will venture one step further, beyond what would be required of any other paper or result, and provide a third argument as it relates to Gödel’s Diagonalization Lemma, which is a third method that differs from the previous two already discussed, but is reducible to the same result."
    }, {
      "heading" : "3 Gödel’s Diagonalization Lemma is Not Logically",
      "text" : "Contingent"
    }, {
      "heading" : "3.1 Some Impredicative Statements Reduce to Circular Logic",
      "text" : "An impredicative statement is a statement with self-referencing. Self-reference alone is not enough to invalidate a proposition, however, as we will show, a certain class of impredicative statements are intrinsically circular and tautological. Such circular logic is not well-formed for proof of a proposition which depends on its circular nature, and is thus not logically contingent.\nIn this section, we will show that Gödel’s Diagonalization Lemma is within this class of impredicative statements. We will then review this lemma and show that his utilization of substitution is not strict enough for a strong foundation in logic. Furthermore, we will actually construct the Gödel numbers suitable for his proof, and carry out the operations to see if indeed such arithmetic is outside of a formal system, Q.\nFirst, we must determine a means to identify when a tautology is present in an impredicative definition. Let’s start with an example of a tautology. We would not accept the following as a logical statement as true in any meaningful way (it is, in fact, ”true” semantically), because there is no proof or causal relationship, only tautology:\n(S ∨ ¬S) We can determine if a statement is a tautology or not, by creating a truth table over the distinct valuations for the formula. If all valuations for each variable lead to truth, then the statement is a tautology.\nFor (S ∨ ¬S), When S is true, (S ∨ ¬S) is true. When S is false, (S ∨ ¬S) is true. Thus, (S ∨ ¬S) is a tautology.\nSo what about impredicativity? Intuitively, it is easy to see how we risk creating a tautology by using such a tactic to define one’s terms: Self reference intrinsically eliminates the possibility for that variable to contradict itself, increasing the likelihood of tautology.\nHowever, self-reference or impredicativity alone, is not enough to prove tautology. For example, the greatest lower bound (glb) of a set, can be defined impredicatively, y = glb(X) if and only if for all elements x of X, y is less than or equal to x, and any z\nless than or equal to all elements of X is less than or equal to y. [8] This definition is impredicative, but it is not tautological.\nBut now, intuitively, before we prove for GDL, I would like to claim that Russell’s paradox uses an impredicative definition that is itself actually tautological.\nDefine S as the set of all sets that do not contain themselves. This is impredicative, and it is tautological, because there seems to be this infinite self-referencing that goes on when we apply S to itself.\nSo what differentiates these two classes of impredicative definitions from each other? Heuristically, in the first instance, we are using the set of X to define y, which is the greatest lowest bound of X. In the second instance, we are defining S as a set defined by sets. When we apply the distinguishing property to the definition that makes the term unique, in the instance of the greatest lowest bound, the property is not applied to the impredicative portion of the statement. Rather, the property is applied to an independent portion. That is, the property of being an element is distinguished from the property of being a set, the set, in this instance, being the impredicative portion of the statement.\nIn Russell’s paradox, the property of being a set that does not contain itself, is a property applied to a dependent portion of the impredicative statement, that is, the property when applied to sets in general, also applies to the specific set we are defining. This dependence of the property of the set on the set, is the distinguishing factor. I believe it was Wittgenstein, at a dinner party with Russell, who first noted that Russell’s paradox is easily overcome by defining a class of sets that do not contain themselves. When you define a class of sets, you break the dependence of it as a set (since it is no longer a set, but a class) with given properties that apply to sets.\nBut I believe this heuristic falls short. It is not just this dependence that creates a tautologial impredicative statement, it is also the nature of the property itself. We could easily define the set of all sets which contain the letter A. Such a definition has a dependence on impredicative portion of the statement, yet does not seem to create create a tautology or an infinite regression or anything of that sort. That is, in order to create a tautology, A itself would have to be defined, not only in terms of sets, but in terms of the class of sets in question. As such, in order for impredicatives to be a problem for logic, the property itself must point back to the impredicative dependence in a self referential way.\nDefinition Let impredicative dependence be the condition of a statement S, whose property P depends on self-referencing. ∃x|P (x)↔ {x→ P (x)}\nDefinition Let impredicative pointing be a condition of self-reference where a dependent property also references an impredicative dependence, i.e. the existence of S depends on S containing an impredicative dependence. ∃x|P (S) ↔ P (x) ↔ {x → P (x)} → S\nDefinition Let a tautological impredicative be a statement which satisfies impredicative pointing. ∃x|P (S)↔ P (x)↔ {x→ P (x)} → S\nProposition Tautological impredicatives are logical tautologies. S ∃x|P (S)↔ {x→\nP (x)} → S\nThe final statement S is always true, even when S is assumed to be false.\nS x P(S) ↔ {x → P(x)} → S true true true true false true false true true false false true"
    }, {
      "heading" : "3.2 Gödel’s Diagonalization Lemma Depends on a Tautological Impredicative",
      "text" : "Gödel’s Diagonalization Lemma states that there is a sentence Ψ such that Ψ ↔ F (o#(Ψ)) is provable in Q where o#(Ψ) is the Gödel number for Ψ and F is some well formed formula provable in a formal system Q.\nIt is clear to see that the statement concerning Ψ is a tautological impredicative, as Gödel derives Ψ by the following proof."
    }, {
      "heading" : "3.2.1 Gödel’s Diagonalization Lemma",
      "text" : "Proof : Q ` Ψ↔ F (o#(Ψ)). Given a formula with one free variable, F(x) in Q and a number n, we may substitute some number n for x. We may also represent the formula F(x) by the Gödel number of the formula, o#(F (x)) and of a number n, and that it is possible that n :=o #(F (x)), but note that it is impossible that n :=o #(F (n)) We can refer to this process of substitution by the function substn(o#(F (x)), n) :=o #(F (n)). We can also let S(x, y, z) be a formula which strongly represents this operation in the language of Q if and only if:\nx =o #(F (x)), y = n, and z =o #(F (n)) Nothing prevents y := x, such that we may have the formula S(x, x, z). Given any formula F(x), we may also create the formula ∃z[F (z)∧S(x, x, z)] with one free variable, x. This formula has the Gödel number k =o #(∃z[F (z) ∧ S(x, x, z)]) At this point, we may substitute k for x, such that ∃z[F (z) ∧ S(k, k, z)] Let Ψ := ∃z[F (z) ∧ S(k, k, z)] Let m =o #(∃z[F (z) ∧ S(k, k, z)]) Q ` ∀z[S(k, k, z)↔ z = m] Q ` ∀z[S(k, k, z)↔ z =o #(∃z[F (z) ∧ S(k, k, z)]) Q ` Ψ↔ ∃z[F (z) ∧ z =o #(∃z[F (z) ∧ S(k, k, z)]) and from this... Q ` Ψ↔ F (o#(∃z[F (z) ∧ S(k, k, z)]), which is Q ` Ψ↔ F (o#(Ψ)) [6]\nRemark. Bew() is short for the german word beweisbar, which means “provable”. Note that “Bew(x)” is merely an abbreviation that represents a particular, very long, formula in the original language of Q; the string “Bew” itself is not claimed to be part\nof this language.[9]\nOk, fine. This seems logical, but what happens when F (x) := ¬Bew(x)?\nWe get Q ` Ψ ↔ ¬Bew(o#(Ψ)). This is a contradiction. The proper question, given the previous two section in this article, is to ask, why do we have such a contradiction arise? Is it because of incompleteness, or is it a result which only exists because of a fundamental flaw in the diagonalization lemma, which creates a logical tautology?\nI wish to point out, that if ¬Bew(x) applies to Ψ, then, this is the function which must also apply to z.\nSuch that ¬Bew(Ψ)↔ ¬Bew(z), where: z =o #(∃z[¬Bew(z) ∧ S(k, k, z)]) thus, Q ` Ψ↔ ¬Bew(o#(∃z[¬Bew(z) ∧ S(k, k, z)])), directly implies Q ` ¬Bew(o#(¬Bew(z))), which is obviously a self-contradiction.\nwhich means that the fundamental assumption we made about there existing a function F (x) with one free variable, is what is incorrect... that it is through improperly initiating substitutions, when we create tautology, which allows contradiction. This is a fundamental problem with the logic used in Gödel’s proof, not necessarily Q. There could be some Q where stronger foundations in logic is mandatory. Furthermore, we can easily see that Q allows tautological impredicatives by proving Ψ."
    }, {
      "heading" : "3.2.2 Q ` Ψ↔ F (o#(Ψ)) is a Tautological Impredicative",
      "text" : "Let the formal system Q be represented by the statement S in Q. Let o#(x) be the property P (x), such that Q ` Ψ↔ F (o#(Ψ)) := S ` Ψ↔ F (P (Ψ)), then Ψ↔ S ` ∃z[F (z) ∧ S(k, k, z)], since k ↔ P (x), and z ↔ k → P (P (x)), then P (x)↔ P (P (x))→ z, which proves impredicative dependence, our first condition of tautological impredicativity. If Ψ↔ ∃z[F (z) ∧ S(k, k, z)], and P (x)↔ P (P (x))→ z, then Ψ↔ {P (x)→ P (P (x))} → z, thus, P (z)↔ {P (x)→ P (P (x))} → Ψ, and since Ψ↔ z, P (Ψ) ↔ {P (x) → P (P (x))} → Ψ which satisfies our definition of a tautological impredicative, which means that GDL is a logical tautology and his proof can not be logically contingent. y"
    }, {
      "heading" : "3.2.3 Discussion",
      "text" : "Did Gödel overstep in his logic by taking too many liberties with free variables?\nThe answer to such a question, is perhaps a matter of opinion. It is either OK to prove the existence of statement which is a logical tautology in a formal system, or it is not. If it is OK, I think we would have to also assume it would be difficult to prevent such a tautology from occurring, or that tautologies must be desirable in logic. However, because tautologies are not desirable, as they open up systems to paradox, meaninglessness and contradiction, I believe it would be of a higher opinion to seek out a rule which invalidates their existence in a consistent system; that any system which can prove tautologies, is in fact inconsistent.\nSuch a rule is relatively easy to find. It seems, unless one can offer an additional example than the one provided by Gödel, that tautologies in a formal system such as Q, are only made possible by misusing substitution over a free variable. Substitution, being an important foundational element in logic, is not itself in question. But rather, a limit on how substitution may be applied, perhaps should be.\nWe could just create a postulate or axiom which makes x a bounded variable after substitution.\nSuch a postulate will allow some impredicative statements, all of which can avoid tautology, but through preventing re-substitution on x, will prevent impredicative pointing, and thus prevent tautologies from forming in Q. Thus, creating a much stronger foundation to our systems of logic and computability.\nOr, if such a postulate is too restrictive, we can modify the limit of substitution over bounded x, not to substitution in general, but to statements from the free variable x, formally as follows:\nAxiom. For any formal systemQ, with a free variable x in formula A(x), after substitution is applied to x, x is bounded by the substitution function such that subst(subst(x)) != subst(x).\nSuch a rule will strengthen, not weaken the logical prowess of humanity."
    }, {
      "heading" : "4 Conclusion, P=NP",
      "text" : "While only one method was ever truly necessary, by three novel, independent and rigorous methods, we have been able to deconstruct one of the key foundations of mathematics and computer science, diagonalization. In Section 1, we constructed an impossible Supermachine which should not exist, yet it does. In section 2, we constructed a formal language which yields a non-trivial counterexample to Cantor’s Diagonal Argument. And in Section 3, we tackled the impredicative nature of Gödel’s diagonalization lemma, revealing a tautology, which is logically unfounded. Again, any one method should have been enough for proof, but because of the significance of such a finding, I decided to combine over a decades worth of research and original thought into this single cohesive, self-contained paper.\nFinally with diagonalization methods invalid, the entire complexity hierarchy collapses, and we now have a foundation in computer science where there is enough information to solve the P vs. NP problem. Without diagonalization, our reasons for not using an oracle to solve P vs. NP vanish, as the contradictions which formally prevented the use of such oracle no longer exist. It was inconcsistency, through the use of diagonalization that lead to Hierarchy results which created oracle contradictions.\nLemma. If PSPACE = EXPSPACE, P = NP . If the SPACE of a problem increases polynomially as with any PSPACE-complete problem, this is comparable to the TIME of a problem increasing polynomially, such that given an oracle, =poly, which solves polynomial equivalence between SPACE and TIME, PSPACE =poly P . Similarly, if the SPACE of a problem increases exponentially as with any EXPSPACEcomplete problem, this is comparable to NP which is at maximum, in exponential TIME, such that EXPSPACE >=poly NP . If PSPACE = EXPSPACE, then PSPACE >=poly NP . Since PSPACE =poly P , P >=poly NP , which is the same as P = NP .\nSolving for β ′\nin Section 1 is RE complete, and because the Space Hierarchy Theorem relies fully on the now defunct diagonalization method, its results must be discarded.\nAnd as such, with the Entschiedungsproblem being RE-complete, and since we may solve for arbitrary β ′ using the Supermachine configuration, we may now conclude:\nProof. Since by definition, PSPACE ⊆ RE, and since any given Recursively Enumerable set is contained in PSPACE, and β ′ solves for all Recursively Enumerable sets in PSPACE, and since we can no longer accept the Space Hierarchy Theorem, RE ⊆ PSPACE ... RE = PSPACE, such that EXPSPACE ⊆ RE and RE = PSPACE, implies PSPACE = EXPSPACE, proves through the above Lemma ... P = NP y\nMark Inman, Ph.D. Prague, Czech Republic"
    } ],
    "references" : [ {
      "title" : "On a decision method in restricted second order arithmetic",
      "author" : [ "J.R. Büchi" ],
      "venue" : "Proc. International Congress on Logic, Method, and Philosophy of Science",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1960
    }, {
      "title" : "Introduction to Formal Systems and Computation CS121",
      "author" : [ "Lewis", "Harry" ],
      "venue" : "Harvard College December 2007 http://www.seas.harvard.edu/courses/cs121",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2007
    }, {
      "title" : "Introduction to the Theory of Computation, 3rd ed",
      "author" : [ "M. Sipser" ],
      "venue" : "Cengage Learning,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2013
    }, {
      "title" : "Axiomatic Set Theory Mineola",
      "author" : [ "Suppes", "Patrick" ],
      "venue" : "NY: Dover Publications,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1972
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "Conventional thought on CDA is that we would need an entirely new axiom schema to find a counterexample to the method [2].",
      "startOffset" : 118,
      "endOffset" : 121
    }, {
      "referenceID" : 2,
      "context" : "[3]",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "[1]",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1",
      "startOffset" : 111,
      "endOffset" : 116
    }, {
      "referenceID" : 0,
      "context" : "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1",
      "startOffset" : 121,
      "endOffset" : 126
    }, {
      "referenceID" : 0,
      "context" : "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1",
      "startOffset" : 134,
      "endOffset" : 139
    }, {
      "referenceID" : 0,
      "context" : "PLUS1(0) := 1 PLUS1(1) := 10 PLUS1(1 ) := 0 PLUS1(0 ) := 0 1 PLUS1([10]) := [10]11 PLUS1([01]) := [01]10 PLUS1([1 0]) := [1 0]1 PLUS1([0 1]) := [0 1]0 PLUS1([01 ]) := [01 ]0 10 PLUS1([10 ]) := [10 ]1",
      "startOffset" : 144,
      "endOffset" : 149
    }, {
      "referenceID" : 0,
      "context" : "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]",
      "startOffset" : 117,
      "endOffset" : 122
    }, {
      "referenceID" : 0,
      "context" : "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]",
      "startOffset" : 127,
      "endOffset" : 132
    }, {
      "referenceID" : 0,
      "context" : "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]",
      "startOffset" : 141,
      "endOffset" : 146
    }, {
      "referenceID" : 0,
      "context" : "PLUS1 (0) := 1 PLUS1 (1) := 0 PLUS1 (1 ) := 1 0 PLUS1 (0 ) := 1 PLUS1 ([10]) := [10]01 PLUS1 ([01]) := [01]00 PLUS1 ([1 0]) := [1 0]1 PLUS1 ([0 1]) := [10 ] PLUS1 ([01 ]) := [1 0] PLUS1 ([10 ]) := 1 [01 ]",
      "startOffset" : 174,
      "endOffset" : 179
    }, {
      "referenceID" : 2,
      "context" : "[3] The following construction maps the set ρ∗ with equivalent strings in P, showing that the diagonal argument applied to a special ordering of subsets in P, yields a non-trivial counterexample to Cantor’s argument function.",
      "startOffset" : 0,
      "endOffset" : 3
    } ],
    "year" : 2017,
    "abstractText" : "This article constructs a Turing Machine which can solve for β ′ which is REcomplete. Such a machine is only possible if there is something wrong with the foundations of computer science and mathematics. We therefore check our work by looking very closely at Cantor’s diagonalization and construct a novel formal language as an Abelian group which allows us, through equivalence relations, to provide a non-trivial counterexample to Cantor’s argument. As if that wasn’t enough, we then discover that the impredicative nature of Gödel’s diagonalization lemma leads to logical tautology, invalidating any meaning behind the method, leaving no doubt that diagonalization is flawed. Our discovery in regards to these foundational arguments opens the door to solving the P vs NP problem. 1 Turing’s Proof on the Entscheidungsproblem has",
    "creator" : "LaTeX with hyperref package"
  }
}