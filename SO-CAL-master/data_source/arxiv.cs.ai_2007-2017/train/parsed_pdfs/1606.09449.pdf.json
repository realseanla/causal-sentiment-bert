{
  "name" : "1606.09449.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "(bliem@dbai.tuwien.ac.at)", "(sordyniak@gmail.com)", "(woltran@dbai.tuwien.ac.at)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 6.\n09 44\n9v 2\n[ cs\n.A I]\n3 0\nD ec\n2 01"
    }, {
      "heading" : "1 Introduction",
      "text" : "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems. Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].\nSince the main decision problems of propositional ASP are located at the second level of the polynomial hierarchy [24, 54], the quest for easier fragments are important research contributions that could lead to improvements in ASP systems. An interesting approach to dealing with intractable problems comes from parameterized complexity theory [22] and is based on the fact that many hard problems become polynomial-time tractable if some problem parameter is bounded by a fixed constant. If the order of the polynomial bound on the runtime is independent of the parameter, one speaks of fixed-parameter tractability (FPT). Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors). Also related is the parameterized complexity analysis of reasoning under subset-minimal models, see, e.g., [41].\nAs many prominent representations of logic programs are given in terms of directed graphs (consider, e.g., the dependency graph), it is natural to investigate parameters for ASP that apply to directed graphs. Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50]. These are typically smaller than, e.g., the popular parameter of treewidth [7]. In particular, all these measures are zero on directed acyclic graphs (DAGs), but the treewidth of DAGs can be arbitrarily high. Moreover, since these measures are based on some notion of “closeness” to acyclicity and the complexity of ASP is closely related to the “cyclicity” of the rules in a program, such measures seem promising for obtaining efficient algorithms for ASP. Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].\nAnother graph parameter for capturing the structural complexity of a graph is clique-width [15–17]. It applies to directed and undirected graphs, and in its general form (known as signed clique-width) to edge-labeled graphs. It is defined via graph construction where only a limited number of vertex labels is available; vertices that share\nthe same label at a certain point of the construction process must be treated uniformly in subsequent steps. Constructions can be given by expressions in a graph grammar (so-called cwd-expressions) and the minimal number of labels required for constructing a graph G is the clique-width of G. While clique-width is in a certain way orthogonal to other directed width measures, it is more general than treewidth; there are classes of graphs with constant clique-width but arbitrarily high treewidth (e.g., complete graphs). In contrast, graphs with bounded treewidth also have bounded clique-width [12, 15].\nBy means of a meta-theorem due to Courcelle, Makowsky, and Rotics [18], one can solve any graph problem that can be expressed in Monadic Second-Order Logic with quantification on vertex sets (MSO1) in linear time for graphs of bounded clique-width. This result is similar to Courcelle’s theorem [13, 14] for graphs of bounded treewidth, which has been used for the FPT result for ASP w.r.t. treewidth [31]. There, the incidence graph of a program is used as an underlying graph structure (i.e., the graph containing a vertex for each atom a and rule r of the program, with an edge between a and r whenever a appears in r). Since the formula given in [31] is in MSO1, the FPT result for ASP applies also to signed clique-width.\nClique-width is NP-hard to compute [25], which might be considered as an obstacle toward practical applications. However, one can check in polynomial time whether the width of a graph is bounded by a fixed k [40, 47]. (These algorithms involve an additive approximation error that is bounded in terms of k). Recently, SAT solvers have been used to obtain sequences of vertex partitions that correspond to cwd-expressions [34] for a given graph. For some applications, it might not even be necessary to compute clique-width and the underlying cwd-expression: As mentioned in [27, Section 1.4], applications from the area of verification are supposed to already come with such an expression. Moreover, it might even be possible to partially obtain cwd-expressions during the grounding process of ASP.\nThis all calls for dedicated algorithms for solving ASP for programs of bounded clique-width. In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width. In fact, we are not aware of any FPT algorithm for bounded clique-width for a reasoning problem located on the second level of the polynomial hierarchy (except [23] from the area of abstract argumentation).\nThe main contributions of this paper are as follows. First, we show some negative results for several directed width measures, indicating that the structure of the dependency graph and of various natural directed versions of the signed incidence graph does not adequately measure the complexity of evaluating the corresponding program.\nSecond, concerning signed clique-width, we give a novel dynamic programming algorithm that runs in polynomial time for programs where this parameter is bounded on their incidence graphs. We do so by suitably generalizing the seminal approach of [27] for the SAT problem. We also give a preliminary analysis how many signs are required in order to obtain FPT."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Graphs. We use standard graph terminology, see for instance the handbook [21]. All our graphs are simple. An undirected graph G is a tuple (V,E), where V or V (G) is the vertex set and E or E(G) is the edge set. For a subset V ′ ⊆ V (G), we denote by G[V ′], the induced subgraph of G induced by the vertices in V ′, i.e., G[V ′] has vertices V ′ and edges { {u, v} ∈ E(G) | u, v ∈ V ′ }. We also denote by G \\ V ′ the graph G[V (G) \\ V ′]. Similarly to undirected graphs, a digraph D is a tuple (V,A), where V or V (D) is the vertex set and A or A(D) is the arc set. A strongly connected component of a digraph D is a maximal subgraph Z of D that is strongly connected, i.e., Z contains a directed path between each pair of vertices in Z . We denote by UND(D) the symmetric closure of D, i.e., the graph with vertex set V (D) and arc set { (u, v), (v, u) | (u, v) ∈ A(D) }. Finally, for a directed graph D, we denote by DI(G), the undirected graph with vertex set V (G) and edge set { {u, v} | (u, v) ∈ A(D) }.\nParameterized Complexity. In parameterized algorithmics [22] the runtime of an algorithm is studied with respect to a parameter k ∈ N and input size n. The most favorable class is FPT (fixed-parameter tractable) which contains all problems that can be decided by an algorithm running in time f(k) · nO(1), where f is a computable function. We also call such an algorithm fixed-parameter tractable, or FPT for short. Formally, a\nparameterized problem is a subset of Σ∗ ×N, where Σ is the input alphabet. Let L1 ⊆ Σ∗1 ×N and L2 ⊆ Σ ∗ 2 ×N be two parameterized problems. A parameterized reduction (or FPT-reduction) from L1 to L2 is a mapping P : Σ∗1 × N → Σ ∗ 2 × N such that: (1) (x, k) ∈ L1 iff P (x, k) ∈ L2, (2) the mapping can be computed by an FPT-algorithm w.r.t. parameter k, and (3) there is a computable function g such that k′ ≤ g(k), where (x′, k′) = P (x, k). The class W[1] captures parameterized intractability and contains all problems that are FPTreducible to PARTITIONED CLIQUE when parameterized by the size of the solution. Showing W[1]-hardness for a problem rules out the existence of an FPT-algorithm under the usual assumption FPT 6= W[1].\nAnswer Set Programming. A program Π consists of a set A(Π) of propositional atoms and a set R(Π) of rules of the form\na1 ∨ · · · ∨ al ← al+1, . . . , am,¬am+1, . . . ,¬an,\nwhere n ≥ m ≥ l and ai ∈ A(Π) for 1 ≤ i ≤ n. Each rule r ∈ R(Π) consists of a head h(r) = {a1, . . . , al} and a body given by p(r) = {al+1, . . . , am} and n(r) = {am+1, . . . , an}. A set M ⊆ A(Π) is a called a model of r if p(r) ⊆ M and n(r) ∩M = ∅ imply h(r) ∩M 6= ∅. We denote the set of models of r by Mods(r) and the models of Π are given by Mods(Π) = ⋂\nr∈R(Π)Mods(r).\nThe reduct ΠI of a program Π with respect to a set of atoms I ⊆ A(Π) is the program ΠI with A(ΠI) = A(Π) and R(ΠI) = {r+ | r ∈ R(Π), n(r) ∩ I = ∅)}, where r+ denotes rule r without negative body, i.e., h(r+) = h(r), p(r+) = p(r), and n(r+) = ∅. Following [29], M ⊆ A(Π) is an answer set of Π if M ∈ Mods(Π) and for no N ( M , we have N ∈ Mods(ΠM ). In what follows, we consider the problem of ASP consistency, i.e., the problem of deciding whether a given program has at least one answer set. As shown by Eiter and Gottlob, this problem is ΣP2 -complete [24].\nGraphical Representations of ASP. Let Π be a program. The dependency graph of Π, denoted by DEP(Π), is the directed graph with vertex set A(Π) and that contains an arc (x, y) if there is a rule r ∈ R(Π) such that either x ∈ h(r) and y ∈ p(r) ∪ n(r) or x, y ∈ h(r) [26]. Note that there are other notions of dependency graphs used in the literature, most of them, however, are given as subgraphs of DEP(Π). As we will see later, our definition of dependency graphs allows us to draw immediate conclusions for such other notions.\nThe incidence graph of Π, denoted by INC(Π), is the undirected graph with vertices A(Π) ∪ R(Π) that contains an edge between a rule vertex r ∈ R(Π) and a atom vertex a ∈ A(Π) whenever a ∈ h(r)∪ p(r)∪n(r). The signed incidence graph of Π, denoted by SINC(Π), is the graph INC(Π), where addionally every edge of INC(Π) between an atom a and a rule r is annotated with a label from {h, p, n} depending on whether a occurs in h(r), p(r), or n(r)."
    }, {
      "heading" : "3 Directed Width Measures",
      "text" : "Since many representations of ASP programs are in terms of directed graphs, it is natural to consider parameters for ASP that are tailor-made for directed graphs. Over the past two decades various width measures for directed graphs have been introduced, which are better suited for directed graphs than treewidth, on which they are based. The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]). Since these width measures are usually smaller on directed graphs than treewidth, it is worth considering them for problems that have already been shown to be fixed-parameter tractable parameterized by treewidth. In particular, all of these measures are zero on directed acyclic graphs (DAGs), but the treewidth of DAGs can be arbitrary high. Moreover, since these measures are based on some notion of “closeness” to acyclicity and the complexity of ASP is closely related to the “cyclicity” of the logical rules, one would consider such measures as promising for obtaining efficient algorithms for ASP.\nIn this section, we give results for directed width measures when applied to dependency graphs as defined in Section 2. To state our results in the most general manner, we will employ the parameter cycle-rank [11]. Since the cycle-rank is always greater or equal to any of the above mentioned directed width measures [32, 38], any (parameterized) hardness result obtained for cycle-rank carries over to the aforementioned width measures for directed graphs.\nDefinition 1. Let D = (V,A) be a directed graph. The cycle-rank of D, denoted by cr(D), is inductively defined as follows: if D is acyclic, then cr(D) = 0. Moreover, if D is strongly connected, then cr(D) = 1 + minv∈V cr(D \\ {v}). Otherwise the cycle-rank of D is the maximum cycle-rank of any strongly connected component of D.\nWe will also consider a natural “undirected version” of the cycle-rank for directed graphs, i.e., we define the undirected cycle-rank of a directed graph D, denoted by cr↔(D), to be the cycle-rank of UND(D). It is also well known (see, e.g., [30]) that the cycle-rank of UND(D) is equal to the treedepth of DI(D), i.e., the underlying undirected graph of D, and that the treedepth is always an upper bound for the pathwidth and the treewidth of an undirected graph [8]. Putting these facts together implies that any hardness result obtained for the undirected cycle-rank implies hardness for pathwidth, treewidth, treedepth as well as the aforementioned directed width measures. See also Figure 1 for an illustration how hardness results for the considered width measures propagate.\nFinally, we would like to remark that both the cycle-rank and the undirected cycle-rank are easily seen to be closed under taking subgraphs, i.e., the (undirected) cycle-rank of a graph is always larger or equal to the (undirected) cycle-rank of every subgraph of the graph.\nHardness Results\nWe show that ASP consistency remains as hard as in the general setting even for instances that have a dependency graph of constant width in terms of any of the directed width measures introduced.\nFor our hardness results, we employ the reduction given in [24] showing that ASP consistency is ΣP2 -hard in general. The reduction is given from the validity problem for quantified Boolean formulas (QBF) of the form: Φ := ∃x1 · · · ∃xn∀y1 · · · ∀ym ∨r\nj=1 Dj where each Dj is a conjunction of at most three literals over the variables x1, . . . , xn and y1, . . . , ym. We will denote the set of all QBF formulas of the above form in the following by QBFDNF2,∃ .\nGiven Φ ∈ QBFDNF2,∃ , a program Π(Φ) is constructed as follows. The atoms of Π(Φ) are x1, v1, . . . , xn, vn, y1, z1, . . . , ym, zm, and w and Π(Φ) contains the following rules:\n• for every i with 1 ≤ i ≤ n, the rule xi ∨ vi ←,\n• for every i with 1 ≤ i ≤ m, the rules yi ∨ zi ←, yi ← w, zi ← w, and w ← yi, zi,\n• for every j with 1 ≤ j ≤ r, the rule w ← σ(Lj,1), σ(Lj,2), σ(Lj,3), where Lj,l (for l ∈ {1, 2, 3}) is the l-th literal that occurs in Dj (if |Dj | < 3, the respective parts are omitted) and the function σ is defined by setting σ(L) to vi if L = ¬xi, to zi if L = ¬yi, and to L otherwise.\n• the rule ← ¬w (i.e., with an empty disjunction in the head).\nIt has been shown [24, Theorem 38] that a QBFDNF2,∃ formula Φ is valid iff Π(Φ) has an answer set. As checking validity of QBFDNF2,∃ formulas is Σ P 2 -complete [53], this reduction shows that ASP is Σ P 2 -hard.\nLemma 1. Let Φ be a QBFDNF2,∃ , then cr ↔(DEP(Π(Φ))) ≤ 2.\nProof. Figure 2 illustrates the symmetric closure of DEP(Π(Φ)) for a simple QBFDNF2,∃ formulaΦ. As this example illustrates, the only arcs in UND(DEP(Π(Φ))) not incident to w are the arcs incident to xi and vi and the arcs incident to yj and zj , for 1 ≤ i ≤ n and 1 ≤ j ≤ m. Hence, after removing w from UND(DEP(Π(Φ))), every strongly connected component of the remaining graph contains at most two vertices and each of those has hence cycle-rank at most one. It follows that the cycle-rank of UND(DEP(Π(Φ))) and hence the undirected cycle-rank of DEP(Π(Φ)) is at most two.\nTogether with our considerations from above, we obtain:\nTheorem 1. ASP consistency is ΣP2 -complete even for instances whose dependency graph has width at most two for any of the following width measures: undirected cycle-rank, pathwidth, treewidth, treedepth, cycle-rank, directed treewidth, directed pathwidth, DAG-width, Kelly-width, and D-width.\nObserve that because the undirected cycle-rank is closed under taking subgraphs and we chose the “richest” variant of the dependency graph, the above result carries over to the other notions of dependency graphs of ASP programs considered in the literature.\nThe above result draws a very negative picture of the complexity of ASP w.r.t. restrictions on the dependency graph. In particular, not even structural restrictions of the dependency graph by the usually very successful parameter treewidth can be employed for ASP. This is in contrast to our second graphical representation of ASP, the incidence graph, for which it is known that ASP is fixed-parameter tractable parameterized by the treewidth [36]. It is hence natural to ask whether the same still holds under restrictions provided by one of the directed width measures under consideration. We first need to discuss how to obtain a directed version of the usually undirected incidence graph. For this, observe that the incidence graph, unlike the signed incidence graph, provides merely an incomplete model of the underlying ASP instance. Namely, it misses the information about how atoms occur in rules, i.e., whether they occur in the head, in the positive body, or in the negative body of a rule. A directed version of the incidence graph should therefore use the additional expressiveness provided by the direction of the arcs to incorporate the information given by the labels of the signed incidence graph. For instance, a natural directed version of the incidence graph could orient the edges depending on whether an atom occurs in the head or in the body of a rule. Clearly, there are many ways to orient the edges and it is not a priori clear which of those orientations leads to a directed version of the incidence graph that is best suited for an application of the directed width measures. Every orientation should, however, be consistent with the labels of the signed incidence graph, i.e., whenever two atoms are connected to a rule via edges having the same label, their arcs should be oriented in the same way. We call such an orientation of the incidence graph a homogeneous orientation.\nLemma 2. Let Φ be a QBFDNF2,∃ , then the cycle-rank of any homogeneous orientation of the incidence graph of Π(Φ) is at most one.\nProof. Let D be a homogeneous orientation of INC(Π(Φ)) and let G = SINC(Π(Φ). First observe that in G \\ {w} every rule vertex is either only incident to edges with label h or to edges of label p. Hence, as D is a homogeneous orientation, we obtain that every rule vertex of D \\ {w} is either a source vertex (i.e., having only outgoing arcs) or a sink vertex (i.e., having only incoming arcs). So D \\ {w} cannot contain a cycle through a rule vertex. However, since there are no arcs between atom vertices in D, we obtain that D \\ {w} is acyclic, which shows that the cycle-rank of D is at most one.\nWe can thus state the following result:\nTheorem 2. ASP consistency is ΣP2 -complete even for instances whose directed incidence graph has width at most one for any of the following width measures: cycle-rank, directed treewidth, directed pathwidth, DAG-width, Kelly-width, and D-width."
    }, {
      "heading" : "4 Clique-Width",
      "text" : "The results in [31] imply that bounding the clique-width of the signed incidence graph of a program leads to tractability.\nProposition 1. For a programΠ such that the clique-width of its signed incidence graph is bounded by a constant, we can decide in linear time whether Π has an answer set.\nThis result has been established via a formulation of ASP consistency as an MSO1 formula. Formulating a problem in this logic automatically gives us an FPT algorithm. However, such algorithms are primarily of theoretical interest due to huge constant factors, and for actually solving problems, it is preferable to explicitly design dynamic programming algorithms [19].\nSince our main tractability result considers the clique-width of an edge-labeled graph, i.e., the signed incidence graph, we will introduce clique-width for edge-labeled graphs. This definition also applies to graphs without edge-labels by considering all edges to be labeled with the same label. A k-graph, for k > 0, is a graph whose vertices are labeled by integers from {1, . . . , k} =: [k]. Additionally, we also allow for the edges of a k-graph to be labeled by some arbitrary but finite set of labels (in our case the labels will correspond to the signs of the signed incidence graph). The labeling of the vertices of a graph G = (V,E) is formally denoted by a function L : V → [k]. We consider an arbitrary graph as a k-graph with all vertices labeled by 1. We call the k-graph consisting of exactly one vertex v (say, labeled by i ∈ [k]) an initial k-graph and denote it by i(v).\nGraphs can be constructed from initial k-graphs by means of repeated application of the following three operations.\n• Disjoint union (denoted by ⊕);\n• Relabeling: changing all labels i to j (denoted by ρi→j);\n• Edge insertion: connecting all vertices labeled by i with all vertices labeled by j via an edge with label ℓ (denoted by ηℓi,j); i 6= j; already existing edges are not doubled.\nA construction of a k-graph G using the above operations can be represented by an algebraic term composed of i(v), ⊕, ρi→j , and ηℓi,j , (i, j ∈ [k], and v a vertex). Such a term is then called a cwd-expression defining G. For any cwd-expression σ, we use Lσ : V → [k] to denote the labeling of the graph defined by σ. A k-expression is a cwd-expression in which at most k different labels occur. The set of all k-expressions is denoted by CWk.\nAs an example consider the complete bipartite graph Kn,n with bipartition A = {a1, . . . , an} and B = {b1, . . . , bn} and assume that all edges of Kn,n are labeled with the label ℓ. A cwd-expression of Kn,n using at most two labels is given by the following steps: (1) introduce all vertices in A using label 1, (2) introduce all vertices in B using label 2, (3) take the disjoint union of all these vertices, and (4) add all edges between vertices with label 1 and vertices with label 2, i.e., such a cwd-expression is given by ηℓ1,2(1(a1)⊕ · · · ⊕ 1(an)⊕ 2(b1)⊕ · · · ⊕ 2(bn)). As a second example consider the complete graph Kn on n vertices, where all edges are labeled with label ℓ. A cwd-expression for Kn using at most two labels can be obtained by the following iterative process: Given a cwd-expression σn−1 for Kn−1, where every vertex is labeled with label 1, one takes the disjoint union\nof σn−1 and 2(v) (where v is the vertex only contained in Kn but not in Kn−1), adds all edges between vertices with label 1 and vertices with label 2, and then relabels label 2 to label 1. Formally, the cwd-expression σn for Kn is given by (ρ2→1(ηℓ1,2(σn−1 ⊕ 2(v2))).\nDefinition 2. The clique-width of a graph G, cwd(G), is the smallest integer k such that G can be defined by a k-expression.\nOur discussion above thus witnesses that complete (bipartite) graphs have clique-width 2. Furthermore, cographs also have clique-width 2 (co-graphs are exactly given by the graphs which are P4-free, i.e., whenever there is a path (a, b, c, d) in the graph then {a, c}, {a, d} or {b, d} is also an edge of the graph) and trees have clique-width 3.\nWe have already introduced the notion of incidence graphs (resp. signed incidence graphs) of a program in Section 2. We thus can use cwd-expressions to represent programs.\nExample 1. Let Π be the program with A(Π) = {x, y} and R(Π) = {r, s}, where r is the rule x ← ¬y and s is the rule ← x,¬y. Its signed incidence graph SINC(Π) can be constructed by the 3-expression\nηn3,2\n(\nρ3→2 ( ηp1,3(η h 1,2(1(x)⊕ 2(r))⊕ 3(s)) )\n⊕ 3(y) ) , as depicted in Figure 3.\nSince every k-expression of the signed incidence graph can be transformed into a k-expression of the unsigned incidence graph (by replacing all operations of the form ηℓi,j with η α i,j , where α is new label), it holds that cwd(INC(Π)) ≤ cwd(SINC(Π)).\nProposition 2. Let Π be a program. It holds that cwd(INC(Π)) ≤ cwd(SINC(Π)), and there is a class C of programs such that, for each Π ∈ C, cwd(INC(Π)) = 2 but cwd(SINC(Π)) is unbounded.\nFor showing the second statement of the above proposition, consider a program Πn that has n2 atoms and n2 rules (for some n ∈ N), such that every atom occurs in every rule of Πn. Because the incidence graph is a complete bipartite graph it has clique-width two and moreover it contains a grid G of size n × n as a subgraph. Assume that Πn is defined in such a way that an atom a occurring in a rule r is in the head of r if the edge between a and r occurs in the grid G and otherwise a is in the (positive) body of r. Then, the clique-width of SINC(Πn) is at least the clique-width of the n × n grid G, which grows with n [39]. Hence, the class C containing Πn for every n ∈ N shows the second statement of the above proposition."
    }, {
      "heading" : "4.1 Algorithms",
      "text" : "In this section, we provide our dynamic programming algorithms for deciding existence of an answer set. We start with the classical semantics for programs, where it is sufficient to just slightly adapt (a simplified version of) the algorithm for SAT by [27]. For answer-set semantics, we then extend this algorithm in order to deal with the intrinsic higher complexity of this semantics.\nBoth algorithms follow the same basic principles by making use of a k-expression σ defining a program Π via its signed incidence graph in the following way: We assign certain objects to each subexpression of σ and manipulate these objects in a bottom-up traversal of the parse tree of the k-expression such that the objects in the root of the parse tree then provide the necessary information to decide the problem under consideration. The size of these objects is bounded in terms of k (and independent of the size of Π) and the number of such objects required is linear in the size of Π. Most importantly, we will show that these objects can also be efficiently computed for bounded k. Thus, we will obtain the desired linear running time."
    }, {
      "heading" : "4.1.1 Classical Semantics",
      "text" : "Definition 3. A tuple Q = (T, F, U) with T, F, U ⊆ [k] is called a k-triple, and we refer to its parts using QT = T , QF = F , and QU = U . The set of all k-triples is given by Qk.\nThe intuition of a triple (T, F, U) is to characterize a set of interpretations I in the following way:\n• For each i ∈ T , at least one atom with label i is true in I;\n• for each i ∈ F , at least one atom with label i is false in I;\n• for each i ∈ U , there is at least one rule with label i that is “not satisfied yet”.\nFormally, the “semantics” of a k-triple Q with respect to a given program Π is given as follows.\nDefinition 4. Let Q ∈ Qk and Π be a program whose signed incidence graph (V,E) is labeled by L : V → [k]. A Π-interpretation of Q is a set I ⊆ A(Π) that satisfies\nQT = {L(a) | a ∈ I},\nQF = {L(a) | a ∈ A(Π) \\ I}, and\nQU = {L(r) | r ∈ R(Π), I /∈ Mods(r)}.\nExample 2. Consider again program Π from Example 1 and the 3-expression σ from Figure 3. Let Q be the 3-triple ({1}, {3}, {2}). Observe that {x} is a Π-interpretation of Q: It sets x to true and y to false, and Lσ(x) ∈ QT and Lσ(y) ∈ QF hold as required; the rule s is not satisfied by {x}, and indeed Lσ(s) ∈ QU . We can easily verify that no other subset of A(Π) is a Π-interpretation of Q: Each Π-interpretation of Q must set x to true and y to false, as these are the only atoms labeled with 1 and 3, respectively.\nWe use the following notation for k-triples Q, Q′, and set S ⊆ [k].\n• Q⊕Q′ = (QT ∪Q′T , QF ∪Q ′ F , QU ∪Q ′ U )\n• Qi→j = (Qi→jT , Q i→j F , Q i→j U ) where for S ⊆ [k],\nSi→j = S \\ {i} ∪ {j} if i ∈ S and Si→j = S otherwise.\n• QS,i,j = (QT , QF , QU \\ {j}) if i ∈ S; QS,i,j = Q otherwise.\nUsing these abbreviations, we define our dynamic programming algorithm: We assign to each subexpression σ of a given k-expression a set of triples by recursively defining a function f , which associates to σ a set of k-triples as follows.\nDefinition 5. The function f : CWk → 2Qk is recursively defined along the structure of k-expressions as follows.\n• f(i(v)) =\n{\n{( {i}, ∅, ∅ ) , ( ∅, {i}, ∅ )}\nif v is an atom node {(\n∅, ∅, {i} )}\nif v is a rule node\n• f(σ1 ⊕ σ2) = {Q⊕Q′ | Q ∈ f(σ1), Q′ ∈ f(σ2)}\n• f(ρi→j(σ)) = {Qi→j | Q ∈ f(σ)}\n• f(ηhi,j(σ)) = f(η n i,j(σ)) = {Q QT ,i,j | Q ∈ f(σ)}\n• f(ηpi,j(σ)) = {Q QF ,i,j | Q ∈ f(σ)}\nExample 3. Consider again programΠ from Example 1 and the 3-expression depicted in Figure 3. To break down the structure of σ, let σ1, . . . , σ6 be subexpressions of σ such that σ = ηn3,2(σ1), σ1 = σ2⊕3(y), σ2 = ρ3→2(σ3), σ3 = η p 1,3(σ4), σ4 = σ5⊕3(s), σ5 = η h 1,2(σ6) and σ6 = 1(x)⊕2(r). We get f(1(x)) = { ({1}, ∅, ∅), (∅, {1}, ∅) } and f(2(r)) = { (∅, ∅, {2}) } . These sets are then combined to f(σ6) = { ({1}, ∅, {2}), (∅, {1}, {2}) }\n. The program defined by σ6 consists of atom x and rule r, but x does not occur in r yet. Accordingly, the k-triple ({1}, ∅, {2}) models the situation where x is set to true, which does not satisfy r (since the head and body of r are still empty), hence the label of r is in the last component; the 3-triple (∅, {1}, {2}) represents x being set to false, which does not satisfy r either. Next, σ5 causes all atoms with label 1 (i.e., just x) to be inserted into the head of all rules with label 2 (i.e., just r), and we get f(σ5) = { ({1}, ∅, ∅), (∅, {1}, {2}) }\n. We obtain the first element ({1}, ∅, ∅) = QQT ,1,2 from Q = ({1}, ∅, {2}) by removing the label 2 from QU because 1 ∈ QT . The idea is that the heads of all rules labeled with 2 now contain all atoms labeled with 1, so these rules become satisfied by every interpretation that sets some atom labeled with 1 to true. Next, σ4 adds the rule s with label 3 and we get f(σ4) = { ({1}, ∅, {3}), (∅, {1}, {2, 3}) }\n. The edge added by σ3 adds all atoms with label 1 (i.e., just x) into the positive body of all rules with label 3 (i.e., just s), which results in f(σ3) = { ({1}, ∅, {3}), (∅, {1}, {2}) }\n. Observe that the last component of the second element no longer contains 3, i.e., setting x to false makes s true. Now the label 3 is renamed to 2, and we get f(σ2) = { ({1}, ∅, {2}), (∅, {1}, {2}) }\n. Note that now r and s are no longer distinguishable since they now share the same label. Hence all operations that add edges to r will also add edges to s and vice versa. In σ1, atom y is added with label 3 and we get four 3-triples in f(σ1): From ({1}, ∅, {2}) in f(σ2) we obtain ({1, 3}, ∅, {2}) and ({1}, {3}, {2}), and from (∅, {1}, {2}) in f(σ2) we get ({3}, {1}, {2}) and (∅, {1, 3}, {2}). In σ, we add a negative edge from all atoms labeled with 3 (i.e., just y) to all rules labeled with 2 (both r and s). From ({1, 3}, ∅, {2}) in f(σ1) we now get ({1, 3}, ∅, ∅), from ({3}, {1}, {2}) we get ({3}, {1}, ∅), and the 3-triples ({1}, {3}, {2}) and (∅, {1, 3}, {2}) from f(σ1) occur unmodified in f(σ). As we will prove shortly, for each k-triple Q in f(σ), there is a Π-interpretation of Q. So if there is a k-triple Q in f(σ) such that QU = ∅, then Π has a classical model due to the definition of QU . For instance, ({1, 3}, ∅, ∅) has a Π-interpretation {x, y}, which is obviously a model of Π.\nWe now prove correctness of our algorithm:\nLemma 3. Let Π be a program and θ be a k-expression for SINC(Π). For every set I ⊆ A(Π), there is a k-triple Q ∈ f(θ) such that I is a Π-interpretation of Q, and for every k-triple Q ∈ f(θ) there is a set I ⊆ A(Π) such that I is a Π-interpretation of Q.\nProof. We prove the first statement by induction on the structure of a k-expression θ defining Π. Let σ be a subexpression of θ, let Πσ denote the program defined by σ, and let I ⊆ A(Πσ).\nIf σ = i(r), for r ∈ R(Π), then A(Πσ) = ∅, so I = ∅. Moreover, R(Πσ) consists of an unsatisfiable rule (its head and body are empty). Hence I is a Πσ-interpretation of (∅, ∅, {i}) in f(σ).\nIf σ = i(a), for a ∈ A(Π), then A(Πσ) = {a} and R(Πσ) = ∅. If I = ∅, then I is a Πσ-interpretation of the k-triple (∅, {i}, ∅) in f(σ). Otherwise I = {a} and I is a Πσ-interpretation of the k-triple ({i}, ∅, ∅) in f(σ).\nIf σ = σ1⊕σ2, let i ∈ {1, 2}, Πi = Πσi and Ii = I ∩A(Πi). By definition of Πi, it holds that A(Π) = A(Π1)∪ A(Π2), R(Π) = R(Π1) ∪R(Π2) and I = I1 ∪ I2. By induction hypothesis, Ii is a Πi-interpretation of some ktriple Qi in f(σi). By definition of f , there is a k-triple Q in f(σ) with QT = Q1T ∪Q2T , QF = Q1F ∪Q2F and QU = Q1U ∪ Q2U . This allows us to easily verify that I is a Πσ-interpretation of Q by checking the conditions in Definition 4.\nIf σ = ρi→j(σ′), then Πσ = Πσ′ and, by induction hypothesis, I is a Πσ′ -interpretation of some k-triple Q in f(σ′). By definition of f , the k-triple Qi→j in f(σ) is the result of replacing i by j in each of QT , QF and QU . Hence we can easily verify that I satisfies all conditions for being a Πσ-interpretation of Qi→j .\nIf σ = ηℓi,j(σ ′), for ℓ ∈ {h, n}, then A(Πσ) = A(Πσ′ ). Hence, by induction hypothesis, I is a Πσ′ -interpretation of some k-triple Q′ in f(σ′). We use Q to denote the k-triple Q′Q ′\nT ,i,j , which is in f(σ). Since QT = Q′T ,\nQF = Q ′ F and Lσ = Lσ′ , I satisfies the first two conditions for being a Πσ-interpretation of Q. It remains to check the third condition. For every j′ ∈ [k] \\ {j} it holds that j′ ∈ QU if and only if j′ ∈ Q′U . By induction hypothesis, the latter is the case if and only if there is a rule r′ ∈ R(Πσ′ ) such that Lσ′ (r′) = j′ and I /∈ Mods(r′). This is equivalent\nto the existence of a rule r ∈ R(Πσ) such that Lσ(r) = j′, h(r) = h(r′), p(r) = p(r′), n(r) = n(r′) and I /∈ Mods(r), since SINC(Πσ) only differs from SINC(Πσ′) by additional edges that are not incident to r due to j′ 6= j.\nIt remains to check that j ∈ QU if and only if there is a rule r ∈ R(Πσ) such that Lσ(r) = j and I /∈ Mods(r). First suppose toward a contradiction that j ∈ QU while I is a model of every rule r ∈ R(Πσ) such that Lσ(r) = j. Since QU ⊆ Q′U , also j ∈ Q ′ U and by induction hypothesis there is a rule r\n′ ∈ R(Πσ′ ) such that Lσ′(r′) = j and I is not a model of r′. There is a corresponding rule r ∈ R(Πσ), for which Lσ(r) = j, h(r′) ⊆ h(r), n(r′) ⊆ n(r) and p(r′) = p(r) hold. Since I is a model of r but not of r′, I contains some atom labeled with i (by both Lσ′ and Lσ) because all atoms in h(r) \\ h(r′) and n(r) \\ n(r′) are labeled with i. By induction hypothesis, this implies i ∈ Q′T , which leads to the contradiction j /∈ QU by construction of f .\nFinally, suppose toward a contradiction that j /∈ QU and there is a rule r ∈ R(Πσ) such that Lσ(r) = j and I /∈ Mods(r). The rule r′ corresponding to r in Πσ′ with Lσ′ (r′) = j is not satisfied by I either, since h(r′) ⊆ h(r), n(r′) ⊆ n(r) and p(r′) = p(r). By induction hypothesis, this entails j ∈ Q′U . Due to j /∈ QU , it holds that i ∈ Q′T , so there is an a ∈ I with Lσ′ (a) = Lσ(a) = i. Due to the new edge from a to r, either a ∈ h(r) or a ∈ n(r). This yields the contradiction that I is a model of r.\nThe case σ = ηpi,j(σ ′) is symmetric.\nThe proof of the second statement is similar.\nWe can now state our FPT result for classical models:\nTheorem 3. Let k be an integer and Π be a program. Given a k-expression for the signed incidence graph of Π, we can decide in linear time whether Π has a model.\nProof. Let k be a constant, Π be a program and σ be a k-expression of SINC(Π). We show that there is a model of Π if and only if there is a k-triple Q in f(σ) with QU = ∅: If Π has a model I , then I is a Π-interpretation of a k-triple Q in f(σ), by Lemma 3, and QU = ∅ by Definition 4. Conversely, if there is a k-triple Q in f(σ) with QU = ∅, then there is a Π-interpretation I of Q, by Lemma 3, and QU = ∅ implies that I is a model of Π by Definition 4. Finally, it is easy to see that f(σ) can be computed in linear time."
    }, {
      "heading" : "4.1.2 Answer-Set Semantics",
      "text" : "For full disjunctive ASP we need a more involved data structure.\nDefinition 6. A pair (Q,Γ) with with Q ∈ Qk and Γ ⊆ Qk is called a k-pair. The set of all k-pairs is given by Pk.\nGiven a k-pair (Q,Γ), the purpose of Q is, as for classical semantics, to represent Π-interpretations I (that in the end correspond to models). Every k-triple in Γ represents sets J of atoms such that J ⊂ I . If, in the end, there is such a set J that still satisfies every rule in the reduct w.r.t. I , then we conclude that I is not an answer set.\nDefinition 7. Let Q ∈ Qk, let Π be a program whose signed incidence graph (V,E) is labeled by L : V → [k], and let I ⊆ A(Π). A ΠI -interpretation of Q is a set J ⊆ A(Π) such that\nQT = {L(a) | a ∈ J},\nQF = {L(a) | a ∈ A(Π) \\ J}, and\nQU = {L(r) | r ∈ R(Π), n(r) ∩ I = ∅, J /∈ Mods(r +)}.\nWe can now define our dynamic programming algorithm for ASP:\nDefinition 8. The function g : CWk → 2Pk is recursively defined along the structure of k-expressions as follows.\n• g(i(v)) = { ( ({i}, ∅, ∅), { (∅, {i}, ∅) }) , ( (∅, {i}, ∅), ∅ ) } if v is at atom node\n• g(i(v)) = { ( (∅, ∅, {i}), ∅ ) } if v is a rule node\n• g(σ1 ⊕ σ2) = { ( Q1 ⊕ Q2, RQ1,Q2,Γ1,Γ2 | (Qi,Γi) ∈ g(σi) ) }, where RQ1,Q2,Γ1,Γ2 = { S1 ⊕ S2 | Si ∈\nΓi } ∪ { Q1 ⊕ S | S ∈ Γ2 } ∪ { S ⊕Q2 | S ∈ Γ1 })\n• g(ρi→j(σ)) = { ( (Qi→j , {Ri→j | R ∈ Γ} ) | (Q,Γ) ∈ g(σ)}\n• g(ηhi,j(σ)) = { ( QQT ,i,j , {RRT ,i,j | R ∈ Γ} ) | (Q,Γ) ∈ g(σ)}\n• g(ηpi,j(σ)) = { ( QQF ,i,j , {RRF ,i,j | R ∈ Γ} ) | (Q,Γ) ∈ g(σ)}\n• g(ηni,j(σ)) = { ( QQT ,i,j , {RQT ,i,j | R ∈ Γ} ) | (Q,Γ) ∈ g(σ)}\nNote the use of QT in RQT ,i,j in the definition of g(ηni,j(σ)): Whenever an interpretation I represented by Q sets an atom from the negative body of a rule r to true, the rule r has no counterpart in the reduct w.r.t. I , so, for each subset J of I , we remove r from the set of rules whose counterpart in the reduct is not yet satisfied by J .\nExample 4. Let Π be the program consisting of a single rule ← ¬x, which we denote by r, and let σ = ηn1,2(1(x) ⊕ 2(r)). Let (Q,Γ) be the k-pair in g(1(x)) with Q = ({1}, ∅, ∅) and Γ = {(∅, {1}, ∅)}. The k-triple Q represents the set of atoms {x}. Since this set has the proper subset ∅, there is a k-triple in Γ that indeed corresponds to this subset. Now let (Q,Γ) = ((∅, {1}, ∅), ∅) be the other k-pair in g(1(x)). Here Q represents the empty set of atoms, which has no proper subsets, hence Γ is empty. For the single k-pair ((∅, ∅, {2}), ∅) in g(2(r)), the situation is similar. Next, at g(1(x) ⊕ 2(r)), we combine every k-pair (Q1,Γ1) from g(1(x)) with every k-pair (Q2,Γ2) from g(2(r)) to a new k-pair. For instance, consider Q1 = ({1}, ∅, ∅) and Γ1 = {S}, where S = (∅, {1}, ∅), as well as Q2 = (∅, ∅, {2}) and Γ2 = ∅. By definition of g, we obtain a new k-pair (Q,Γ), where Q = Q1 ⊕Q2 = ({1}, ∅, {2}), and Γ contains the single element Q2 ⊕ S = (∅, {1}, {2}). Recall that the purpose of Q is to represent sets of atoms I , and each element of Γ shall represent proper subsets of I; in this case, Q represents {x}, and the element Q2 ⊕ S in Γ represents the proper subset ∅. Next, at g(σ) we introduce a negative edge from x to r. From the k-pair (Q, {S}) in g(1(x)⊕ 2(r)), where Q = ({1}, ∅, {2}) and S = (∅, {1}, {2}), we obtain the k-pair (Q′, {S′}) in g(σ), where Q′ = QQT ,i,j = ({1}, ∅, ∅) (i.e., the label 2 from QU has disappeared) and S′ = SQT ,i,j = (∅, {1}, ∅). Here 2 has disappeared from SU because the reduct w.r.t. all sets of atoms represented by Q′ no longer contains any rule labeled with 2. Note that the classical model {x} represented by Q′ is no answer set even though Q′U = ∅. The reason is that S\n′ witnesses (by S′U = ∅) that ∅ ∈ Mods(Π{x}).\nWe now prove correctness of the algorithm from Definition 8.\nLemma 4. Let Π be a program and θ be a k-expression for SINC(Π). For every set I ⊆ A(Π) there is a k-pair (Q,Γ) ∈ g(θ) such that (i) I is a Π-interpretation of Q and (ii) for every set J ⊂ I there is a k-triple R ∈ Γ such that J is a ΠI -interpretation of R. Moreover, for every k-pair (Q,Γ) ∈ g(θ) there is a set I ⊆ A(Π) such that (i’) I is a Π-interpretation of Q and (ii’) for each k-triple R ∈ Γ, there is a set J ⊂ I such that J is a ΠI -interpretation of R.\nProof. Observe that for each (Q,Γ) in g(θ) it holds that Q ∈ f(θ), and for each Q in f(θ) there is some (Q,Γ) in g(θ). Hence we can apply the same arguments as in the proof of Lemma 3 for (i) and (i’). In addition, similar arguments can be used within each of the distinguished cases for (ii) and (ii’). We use induction on the structure of a k-expression θ defining Π. Let σ be a subexpression of θ, let Πσ denote the program defined by σ, and let I ⊆ A(Πσ).\nIf σ = i(r), for r ∈ R(Π), then A(Πσ) = ∅, so I = ∅. As in the proof of Lemma 3, we can show that I is a Πσ-interpretation of the k-triple Q = (∅, ∅, {i}). Since I has no proper subsets, condition (ii) holds trivially for the k-pair (Q, ∅) in g(σ).\nIf σ = i(a), for a ∈ A(Π), then A(Πσ) = {a} and R(Πσ) = ∅. If I = ∅, then I is a Πσ-interpretation of the k-triple Q = (∅, {i}, ∅) and (ii) holds trivially for the k-pair (Q, ∅) in g(σ). Otherwise I = {a} holds. Let (Q,Γ) be the k-pair in g(σ) for which Q = ({i}, ∅, ∅) and Γ = {(∅, {i}, ∅)} hold. Clearly I is a Πσ-interpretation of Q. The only proper subset of I is ∅, which is a ΠIσ-interpretation of the only element of Γ.\nIf σ = σ1 ⊕ σ2, let Πi = Πσi and Ii = I ∩ A(Πi), for any i ∈ {1, 2}. By definition of Πi, it holds that A(Π) = A(Π1) ∪ A(Π2), R(Π) = R(Π1) ∪ R(Π2) and I = I1 ∪ I2. Let J ⊂ I and, for i ∈ {1, 2}, let\nJi = J ∩ A(Πi). Observe that J1 ⊆ I1 and J2 ⊆ I2, and at least one inclusion is proper. We distinguish three cases:\n• If J1 ⊂ I1 and J2 ⊂ I2, then, by induction hypothesis, for any i ∈ {1, 2} there is a k-pair (Qi,Γi) in g(σi) such that Ii is a Πi-interpretation of Qi and there is a k-triple Ri ∈ Γi such that Ji is a Π Ii i -interpretation of Ri.\nBy definition of g, there is a k-pair (Q,Γ) in g(σ) such that Q = Q1 ⊕ Q2 and there is a k-triple R in Γ such that R = R1 ⊕ R2. We can easily check that I is a Πσ-interpretation of Q and that J is a ΠIσ-interpretation of R.\n• If J1 ⊂ I1 and J2 = I2, then, by induction hypothesis, there is a k-pair (Q1,Γ1) in g(σ1) such that I1 is a Π1-interpretation of Q1 and there is a k-triple R1 ∈ Γ1 such that J1 is a Π I1 1 -interpretation of R1. Also, there is\na k-pair (Q2,Γ2) in g(σ2) such that I2 is a Π2-interpretation of Q2. By definition of g, there is a k-pair (Q,Γ) in g(σ) such that Q = Q1 ⊕Q2 and there is a k-triple R in Γ such that R = R1 ⊕Q2. We can easily check that I is a Πσ-interpretation of Q and that J is a ΠIσ-interpretation of R.\n• The case J1 = I1, J2 ⊂ I2 is symmetric.\nWe omit the cases σ = ρi→j(σ′), σ = ηhi,j(σ ′) and σ = ηpi,j(σ ′), as they are do not offer much additional insight, given the proof of Lemma 3 and the following case.\nIf σ = ηni,j(σ ′), then there is again a k-pair (Q′,Γ′) in g(σ′) such that (i) I is a Πσ′ -interpretation of Q′ and (ii) for each J ⊂ I there is a k-triple R in Γ′ such that J is a ΠIσ′ -interpretation of R. Let (Q,Γ) be the k-pair in g(σ) for which Q = Q′Q ′ T ,i,j and Γ = {RQ ′ T ,i,j | R ∈ Γ′} hold. As before, I is a Πσ-interpretation of Q. Let J ⊂ I , let R′ be the k-triple in Γ′ such that J is a ΠIσ′ -interpretation of R ′, and let R = R′Q ′ T ,i,j . As before, J satisfies the first two conditions for being a ΠIσ-interpretation of R. It remains to check the third condition. For all labels except j, we proceed as before. We now check that j ∈ RU if and only if there is a rule r ∈ R(Πσ) such that Lσ(r) = j, n(r) ∩ I = ∅ and J /∈ Mods(r+). First suppose toward a contradiction that j ∈ RU while J ∈ Mods(r+) for each r ∈ R(Πσ) such that Lσ(r) = j and n(r) ∩ I = ∅. Since RU ⊆ R′U , also j ∈ R′U and by induction hypothesis there is a rule r\n′ ∈ R(Πσ′ ) such that Lσ′ (r′) = j, n(r′) ∩ I = ∅ and J is not a model of r′+. There is a corresponding rule r ∈ R(Πσ), for which Lσ(r) = j, h(r′) = h(r), p(r′) = p(r) and n(r′) ⊆ n(r) hold. Since J is a model of r+ but not of r′+ (and these rules are identical), there is an a ∈ n(r) ∩ I with Lσ(a) = i. From a ∈ I it follows by induction hypothesis that i ∈ Q′T , but this leads to the contradiction j /∈ RU .\nFinally, suppose toward a contradiction that j /∈ RU and there is a rule r ∈ R(Πσ) such that Lσ(r) = j, n(r) ∩ I = ∅ and J /∈ Mods(r+). Let r′ be the rule corresponding to r in Πσ′ . For this rule it holds that Lσ′(r′) = j and n(r′) ⊆ n(r), so n(r′)∩ I = ∅. The set J does not satisfy r′+ either, since h(r′+) = h(r+) and p(r′+) = p(r+). By induction hypothesis, this entails j ∈ R′U . Due to j /∈ RU , it holds that i ∈ Q ′ T , so there is an atom a ∈ I such that Lσ′ = Lσ(a) = i. Due to the new edge from a to r, a ∈ n(r) holds, which contradicts n(r) ∩ I = ∅.\nThe other direction is similar.\nHence we get an FPT result for answer-set semantics:\nTheorem 4. Let k be a constant and Π be a program. Given a k-expression for the signed incidence graph of Π, we can decide in linear time whether Π has an answer set.\nProof. Let k be a constant, Π be a program and σ be a k-expression of SINC(Π). Using the same ideas as for Theorem 3, we can easily show that there is an answer set of Π if and only if there is a k-pair (Q,Γ) in g(σ) such that QU = ∅ and RU 6= ∅ for every R ∈ Γ. Again, it is easy to see that g(σ) can be computed in linear time."
    }, {
      "heading" : "4.2 The Role of Signs for Results on Clique-Width",
      "text" : "We have shown that ASP parameterized by the clique-width of the signed incidence graph is FPT. Because the clique-width of the (unsigned) incidence graph is usually smaller than (and always at most as high as) the clique-width of the signed incidence graph (Proposition 2), an FPT result w.r.t. the clique-width of the (unsigned)\nincidence graph would be a significantly stronger result. It is therefore natural to ask whether ASP is already FPT w.r.t the clique-width of the unsigned incidence graph. A similar situation is known for the satisfiability problem of propositional formulas (SAT), which was first shown in [27] to be FPT parameterized by the clique-width of the signed incidence graph, and the authors conjectured that the same should hold already for the unsigned version. Surprisingly, this turned out not to be the case [46]. In comparison to SAT, the situation for ASP is similar but slightly more involved. Whereas there are only two potential signs for SAT (signaling whether a variable occurs positively or negatively in a clause), ASP has three signs (h, p, n). So how many signs are necessary to obtain tractability for ASP? To settle this question, let SINCL(Π), for L ⊆ {h, p, n}, be the (“semi-signed”) incidence graph obtained from SINC(Π) by joining all labels in L, i.e., every label in L is renamed to a new label, which we denote by α. We will show below that joining any set L of labels other than {h, n} leads to intractability for ASP parameterized by the clique-width of SINCL(Π). Together with our tractability result w.r.t. the clique-width of SINC(Π) (Theorem 4), this provides an almost complete picture of the complexity of ASP parameterized by clique-width. We leave it as an open question whether ASP parameterized by the clique-width of SINC{h,n}(Π) is FPT.\nTheorem 5. Let L ⊆ {h, p, n} with |L| > 1 and L 6= {h, n}, then ASP is W[1]-hard parameterized by the clique-width of SINCL(Π).\nProof. We show the result by a parameterized reduction from the W [1]-complete problem PARTITIONED CLIQUE [48].\nInstance: A k-partite graph G = (V,E) with partition V1, . . . , Vk where |Vi| = |Vj | for every i, j with 1 ≤ i, j ≤ k.\nParameter: The integer k.\nQuestion: Does G have a clique of size k?\nRecall that a k-partite graph is a graph whose vertex set can be partitioned into k sets such that there are no edges between vertices contained in the same set. To prove the theorem it is sufficient to show that the result holds for L being any combination of two labels other than {h, n}. In other words, it suffices to show the result for L = {h, p} and L = {p, n}. Because the reduction for the case that L = {h, p} is very similar to the reduction from PARTITIONED CLIQUE to SAT given in [46, Corollary 1], we omit its proof here and only give the proof for the case that L = {p, n}. Let L = {p, n} and G, k, V1, . . . , Vk be as in the definition of PARTITIONED CLIQUE and assume that the vertices of G are labeled such that vji is the i-th vertex contained in Vj . We will construct a program Π in polynomial-time such that G has a clique of size k if and only if Π has an answer set, and the clique-width of SINCL(Π) is at most k′ = 2k + k2.\nThe program Π contains one atom vji for every vertex v j i of G, and the following rules:\n(R1) For every j with 1 ≤ j ≤ k, the rule: vj1 ∨ · · · ∨ v j n ←. (R2) The rule:\n← vj1i1 , v j2 i2 ,¬vj11 , . . . ,¬v j1 i1−1 ,¬vj1i1+1, . . . ,¬v j1 n ,\n¬vj21 , . . . ,¬v j2 i2−1 ,¬vj2i2+1, . . . ,¬v j2 n\nfor every {vj1i1 , v j2 i2 } /∈ E(G) with 1 ≤ j1, j2 ≤ k and 1 ≤ i1, i2 ≤ n.\nWe first show that G has a clique of size k if and only if Π has an answer set. Toward showing the forward direction, let C be a clique of size k of G. We claim that C is also an answer set of Π and first show that C is indeed a model of Π. Because C contains exactly one vertex from every Vi, all rules of type (R1) are satisfied by C. Moreover, the same holds for all rules of type (R2), because there is no pair u, v ∈ C with {u, v} /∈ E(G) and hence the body of every such rule is always falsified. This shows that C is a model of Π. Finally, because all the rules of type (R1) are also contained in the reduct ΠC of Π, we obtain that C is an answer set of Π.\nToward showing the reverse direction, let C be an answer set of Π. We claim that C is also a clique of G of size k and first show that C contains exactly one variable from every Vi. Because of the rules of type (R1) (which will also remain in the reduct ΠC ), it holds that C contains at least one variable corresponding to a vertex of Vi for every i with 1 ≤ i ≤ k. Assume for a contradiction that C contains more than one variable from some Vi. Then for every j with j 6= i, C has to contain at least three variables from Vi ∪ Vj . Consequently, every rule of type (R2) corresponding to a non-edge of G incident to a vertex in Vi does not appear in the reduct ΠC of Π,\nwhich shows that C is not an answer set (minimal model) of ΠC . This shows that C contains exactly one variable from every Vi. Now, suppose for a contradiction that C is not a clique of G of size k. Then there are u and w in C with u ∈ Vi and w ∈ Vj such that {u,w} /∈ E(G). Hence, there is a rule of type (R2) (corresponding to the non-edge {u, v}), which is violated by C, a contradiction to our assumption that C is model of Π.\nIt remains to show that the clique-width of SINCL(Π) is at most k′ = 2k + k2. We show this by providing a k′-expression for SINCL(Π). We start by giving the terms that introduce the vertices of SINCL(Π): (1) We introduce every atom vertex vji of SINCL(Π) with the term j(v j i ). (2) For every rule vertex r of the form (R1) corresponding to a rule vj1 ∨ · · · ∨ v j n ←, we introduce the term l(r) where l = k + j. (3) For every rule vertex r of the form (R2) corresponding to a non-edge between Vi and Vj with 1 ≤ i < j ≤ k, we introduce the term l(r), where l = 2k + k(i − 1) + j. We then combine all these terms using the disjoint union operator ⊕. Now it only remains to show how the edges between the rule and the atom vertices of SINCL(Π) are added: First, for every j with 1 ≤ j ≤ k, we add the edges between the rule vertices of the form (R1) and the atom vertices contained in those rules using the operator ηℓj,k+j , where ℓ = h. Second, for every i and j with 1 ≤ i < j ≤ k, we add the edges between the rule vertices of the form (R2) and the atom vertices contained in those rules using the operators ηαi,2k+k(i−1)+j and η α j,2k+k(i−1)+j ."
    }, {
      "heading" : "5 Conclusion",
      "text" : "In this paper, we have contributed to the parameterized complexity analysis of ASP. We first gave some negative observations showing that most directed width measures (applied to the dependency graph or incidence graph of a program) do not lead to FPT results. On the other hand, we turned a theoretical tractability result (which implicitly follows from previous work [31]) for the parameter clique-width (applied to the signed incidence graph of a program) into a novel dynamic programming algorithm. The algorithm is applicable to arbitrary programs, whenever a defining k-expression is given. The algorithm is expected to run efficiently in particular for small k, i.e., programs for which the signed incidence graph has low clique-width.\nFuture work includes solving the remaining question whether ASP parameterized by the clique-width of SINC{h,n}(Π) is FPT or not. Another open question is whether ASP parameterized by the clique-width of the unsigned incidence graph is in the class XP (as is the case for SAT [51]).\nAcknowledgments. This work was supported by the Austrian Science Fund (FWF) projects P25518 and Y698."
    } ],
    "references" : [ {
      "title" : "A trichotomy for regular simple path queries on graphs",
      "author" : [ "G. Bagan", "A. Bonifati", "B. Groz" ],
      "venue" : "Proc. PODS, pages 261–272. ACM,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Answer set based design of knowledge systems",
      "author" : [ "M. Balduccini", "M. Gelfond", "M. Nogueira" ],
      "venue" : "Ann. Math. Artif. Intell., 47(1-2):183–219,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Directed path-width and monotonicity in digraph searching",
      "author" : [ "J. Barát" ],
      "venue" : "Graphs and Combinatorics, 22(2): 161–172,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A hierarchy of tractable subsets for computing stable models",
      "author" : [ "R. Ben-Eliyahu" ],
      "venue" : "J. Artif. Intell. Res. (JAIR), 5:27–52,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Propositional semantics for disjunctive logic programs",
      "author" : [ "R. Ben-Eliyahu", "R. Dechter" ],
      "venue" : "Ann. Math. Artif. Intell., 12(1-2):53–87,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "The dag-width of directed graphs",
      "author" : [ "D. Berwanger", "A. Dawar", "P. Hunter", "S. Kreutzer", "J. Obdrzálek" ],
      "venue" : "Journal of Combinatorial Theory, Series B, 102(4):900–923,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A tourist guide through treewidth",
      "author" : [ "H.L. Bodlaender" ],
      "venue" : "Acta Cybernetica, 11:1–21,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Approximating treewidth, pathwidth, frontsize, and shortest elimination tree",
      "author" : [ "H.L. Bodlaender", "J.R. Gilbert", "H. Hafsteinsson", "T. Kloks" ],
      "venue" : "J. Algorithms, 18(2):238–255,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Decomposition theorems and model-checking for the modal μ-calculus",
      "author" : [ "M. Bojańczyk", "C. Dittmann", "S. Kreutzer" ],
      "venue" : "Proc. CLS/LICS, pages 17:1–17:10. ACM,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. Brewka", "T. Eiter", "M. Truszczyński" ],
      "venue" : "Comm. ACM, 54(12): 92–103,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Transition graphs and the star height problem",
      "author" : [ "R.S. Cohen" ],
      "venue" : "Proc. of the 9th Annual Symposium on Switching and Automata Theory, pages 383–394. IEEE Computer Society,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1968
    }, {
      "title" : "On the relationship between clique-width and treewidth",
      "author" : [ "D.G. Corneil", "U. Rotics" ],
      "venue" : "SIAM J. Comput., 34(4):825–847,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Recognizability and second-order definability for sets of finite graphs",
      "author" : [ "B. Courcelle" ],
      "venue" : "Technical Report I-8634, Université de Bordeaux,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Graph rewriting: an algebraic and logic approach",
      "author" : [ "B. Courcelle" ],
      "venue" : "Handbook of theoretical computer science, Vol. B, pages 193–242. Elsevier Science Publishers, North-Holland, Amsterdam,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Upper bounds to the clique-width of graphs",
      "author" : [ "B. Courcelle", "S. Olariu" ],
      "venue" : "Discr. Appl. Math., 101(1-3): 77–114,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Context-free handle-rewriting hypergraph grammars",
      "author" : [ "B. Courcelle", "J. Engelfriet", "G. Rozenberg" ],
      "venue" : "Proc. Graph-Grammars, volume 532 of LNCS, pages 253–268,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Handle-rewriting hypergraph grammars",
      "author" : [ "B. Courcelle", "J. Engelfriet", "G. Rozenberg" ],
      "venue" : "JCSS, 46(2):218– 270,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Linear time solvable optimization problems on graphs of bounded clique-width",
      "author" : [ "B. Courcelle", "J.A. Makowsky", "U. Rotics" ],
      "venue" : "Theory Comput. Syst., 33(2):125–150,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Parameterized Algorithms",
      "author" : [ "M. Cygan", "F.V. Fomin", "L. Kowalik", "D. Lokshtanov", "D. Marx", "M. Pilipczuk", "M. Pilipczuk", "S. Saurabh" ],
      "venue" : "Springer,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Quantitative Graph Theory, chapter Width-Measures for Directed Graphs and Algorithmic Applications",
      "author" : [ "M. Dehmer", "F. Emmert-Streib", "editors" ],
      "venue" : null,
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2014
    }, {
      "title" : "Graph Theory, 4th Edition, volume 173 of Graduate texts in mathematics",
      "author" : [ "R. Diestel" ],
      "venue" : "Springer,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Fundamentals of Parameterized Complexity",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "Texts in Computer Science. Springer,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Reasoning in argumentation frameworks of bounded cliquewidth",
      "author" : [ "W. Dvorák", "S. Szeider", "S. Woltran" ],
      "venue" : "Proc. COMMA, volume 216 of Frontiers in Artificial Intelligence and Applications, pages 219–230. IOS Press,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "On the computational cost of disjunctive logic programming: Propositional case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Ann. Math. Artif. Intell., 15(3–4):289–323,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Clique-width is NP-complete",
      "author" : [ "M.R. Fellows", "F.A. Rosamond", "U. Rotics", "S. Szeider" ],
      "venue" : "SIAM J. Discrete Math., 23(2):909–939,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Backdoors to tractable answer set programming",
      "author" : [ "J. Fichte", "S. Szeider" ],
      "venue" : "Artif. Intell., 220:64–103,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Counting truth assignments of formulas of bounded tree-width or clique-width",
      "author" : [ "E. Fischer", "J.A. Makowsky", "E.R. Ravve" ],
      "venue" : "Discr. Appl. Math., 156(4):511–529,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Comput., 9(3/4):365–386,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "LIFO-search: A min-max theorem and a searching game for cycle-rank and tree-depth",
      "author" : [ "A.C. Giannopoulou", "P. Hunter", "D.M. Thilikos" ],
      "venue" : "Discrete Applied Mathematics, 160(15):2089–2097,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Bounded treewidth as a key to tractability of knowledge representation and reasoning",
      "author" : [ "G. Gottlob", "R. Pichler", "F. Wei" ],
      "venue" : "Artif. Intell., 174(1):105–132,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Digraph complexity measures and applications in formal language theory",
      "author" : [ "H. Gruber" ],
      "venue" : "Discrete Mathematics & Theoretical Computer Science, 14(2):189–204,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Exhaustively characterizing feasible logic models of a signaling network using answer set programming",
      "author" : [ "C. Guziolowski", "S. Videla", "F. Eduati", "S. Thiele", "T. Cokelaer", "A. Siegel", "J. Saez-Rodriguez" ],
      "venue" : "Bioinformatics, 29(18):2320–2326, 2013. doi: 10.1093/bioinformatics/btt393. Erratum see Bioinformatics 30, 13,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 1942
    }, {
      "title" : "A SAT approach to clique-width",
      "author" : [ "M. Heule", "S. Szeider" ],
      "venue" : "ACM Trans. Comput. Log., 16(3):24,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Digraph measures: Kelly decompositions, games, and orderings",
      "author" : [ "P. Hunter", "S. Kreutzer" ],
      "venue" : "TCS, 399(3): 206–219,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Answer-set programming with bounded treewidth",
      "author" : [ "M. Jakl", "R. Pichler", "S. Woltran" ],
      "venue" : "Proc. IJCAI, pages 816–822,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Directed tree-width",
      "author" : [ "T. Johnson", "N. Robertson", "P.D. Seymour", "R. Thomas" ],
      "venue" : "Journal of Combinatorial Theory, Series B, 82(1):138–154,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Directed width measures and monotonicity of directed graph searching",
      "author" : [ "L. Kaiser", "S. Kreutzer", "R. Rabinovich", "S. Siebertz" ],
      "venue" : "CoRR, abs/1408.4745,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Recent developments on graphs of bounded clique-width",
      "author" : [ "M. Kaminski", "V.V. Lozin", "M. Milanic" ],
      "venue" : "Discrete Applied Mathematics, 157(12):2747–2761,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "The rank-width of directed graphs",
      "author" : [ "M.M. Kanté" ],
      "venue" : "CoRR, abs/0709.1433,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Fixed-parameter algorithms for finding minimal models",
      "author" : [ "M. Lackner", "A. Pfandler" ],
      "venue" : "Proc. KR, pages 85–95. AAAI Press,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On odd and even cycles in normal logic programs",
      "author" : [ "F. Lin", "X. Zhao" ],
      "venue" : "Proc. AAAI, pages 80–85. AAAI Press / The MIT Press,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Fixed-parameter complexity of semantics for logic programs",
      "author" : [ "Z. Lonc", "M. Truszczyński" ],
      "venue" : "ACM Trans. Comput. Log., 4(1):91–119,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Stable Models and an Alternative Logic Programming Paradigm",
      "author" : [ "V.W. Marek", "M. Truszczyński" ],
      "venue" : "The Logic Programming Paradigm – A 25-Year Perspective, pages 375–398. Springer Verlag,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "A dynamic-programming based ASP-solver",
      "author" : [ "M. Morak", "R. Pichler", "S. Rümmele", "S. Woltran" ],
      "venue" : "Proc. JELIA’10, pages 369–372,",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Satisfiability of acyclic and almost acyclic CNF formulas",
      "author" : [ "S. Ordyniak", "D. Paulusma", "S. Szeider" ],
      "venue" : "TCS, 481:85–99,",
      "citeRegEx" : "46",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Approximating clique-width and branch-width",
      "author" : [ "S. Oum", "P. Seymour" ],
      "venue" : "J. Combin. Theory Ser. B, 96(4): 514–528,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "On the parameterized complexity of the fixed alphabet shortest common supersequence and longest common subsequence problems",
      "author" : [ "K. Pietrzak" ],
      "venue" : "JCSS, 67(4):757–771,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Team-building with answer set programming in the Gioia-Tauro seaport",
      "author" : [ "F. Ricca", "G. Grasso", "M. Alviano", "M. Manna", "V. Lio", "S. Iiritano", "N. Leone" ],
      "venue" : "TPLP, 12:361–381, 4",
      "citeRegEx" : "49",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "D-width: A more natural measure for directed tree width",
      "author" : [ "M.A. Safari" ],
      "venue" : "Proc. MFCS, volume 3618 of LNCS, pages 745–756. Springer,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Model counting for formulas of bounded clique-width",
      "author" : [ "F. Slivovsky", "S. Szeider" ],
      "venue" : "Proc. ISAAC, volume 8283 of LNCS, pages 677–687. Springer,",
      "citeRegEx" : "51",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Developing a declarative rule language for applications in product configuration",
      "author" : [ "T. Soininen", "I. Niemelä" ],
      "venue" : "Proc. PADL, volume 1551 of LNCS, pages 305–319. Springer Verlag,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Word problems requiring exponential time",
      "author" : [ "L.J. Stockmeyer", "A.R. Meyer" ],
      "venue" : "Proc. Theory of Computing, pages 1–9. ACM,",
      "citeRegEx" : "53",
      "shortCiteRegEx" : null,
      "year" : 1973
    }, {
      "title" : "Trichotomy and dichotomy results on the complexity of reasoning with disjunctive logic programs",
      "author" : [ "M. Truszczyński" ],
      "venue" : "TPLP, 11(6):881–904,",
      "citeRegEx" : "54",
      "shortCiteRegEx" : null,
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems.",
      "startOffset" : 41,
      "endOffset" : 53
    }, {
      "referenceID" : 28,
      "context" : "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems.",
      "startOffset" : 41,
      "endOffset" : 53
    }, {
      "referenceID" : 43,
      "context" : "Disjunctive Answer Set Programming (ASP) [10, 29, 44] is an active field of AI providing a declarative formalism for solving hard computational problems.",
      "startOffset" : 41,
      "endOffset" : 53
    }, {
      "referenceID" : 27,
      "context" : "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 51,
      "context" : "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 1,
      "context" : "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].",
      "startOffset" : 201,
      "endOffset" : 204
    }, {
      "referenceID" : 48,
      "context" : "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].",
      "startOffset" : 222,
      "endOffset" : 226
    }, {
      "referenceID" : 32,
      "context" : "Thanks to the high sophistication of modern solvers [28], ASP was successfully used in several applications, including product configuration [52], decision support for space shuttle flight controllers [2], team scheduling [49], and bio-informatics [33].",
      "startOffset" : 248,
      "endOffset" : 252
    }, {
      "referenceID" : 23,
      "context" : "Since the main decision problems of propositional ASP are located at the second level of the polynomial hierarchy [24, 54], the quest for easier fragments are important research contributions that could lead to improvements in ASP systems.",
      "startOffset" : 114,
      "endOffset" : 122
    }, {
      "referenceID" : 53,
      "context" : "Since the main decision problems of propositional ASP are located at the second level of the polynomial hierarchy [24, 54], the quest for easier fragments are important research contributions that could lead to improvements in ASP systems.",
      "startOffset" : 114,
      "endOffset" : 122
    }, {
      "referenceID" : 21,
      "context" : "An interesting approach to dealing with intractable problems comes from parameterized complexity theory [22] and is based on the fact that many hard problems become polynomial-time tractable if some problem parameter is bounded by a fixed constant.",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 42,
      "context" : "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 41,
      "context" : "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 4,
      "context" : "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).",
      "startOffset" : 117,
      "endOffset" : 120
    }, {
      "referenceID" : 3,
      "context" : "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 25,
      "context" : "Results in this direction for the ASP domain include [43] (parameter: size of answer sets), [42] (number of cycles), [5] (length of longest cycles), [4] (number of non-Horn rules), and [26] (backdoors).",
      "startOffset" : 185,
      "endOffset" : 189
    }, {
      "referenceID" : 40,
      "context" : ", [41].",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 2,
      "context" : "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].",
      "startOffset" : 91,
      "endOffset" : 109
    }, {
      "referenceID" : 5,
      "context" : "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].",
      "startOffset" : 91,
      "endOffset" : 109
    }, {
      "referenceID" : 34,
      "context" : "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].",
      "startOffset" : 91,
      "endOffset" : 109
    }, {
      "referenceID" : 36,
      "context" : "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].",
      "startOffset" : 91,
      "endOffset" : 109
    }, {
      "referenceID" : 49,
      "context" : "Over the past two decades, various width measures for directed graphs have been introduced [3, 6, 35, 37, 50].",
      "startOffset" : 91,
      "endOffset" : 109
    }, {
      "referenceID" : 6,
      "context" : ", the popular parameter of treewidth [7].",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 36,
      "context" : "Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 0,
      "context" : "Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 8,
      "context" : "Prominent applications of directed width measures include the k-Disjoint Path Problem [37], query evaluation in graph databases [1], and model checking [9].",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 14,
      "context" : "Another graph parameter for capturing the structural complexity of a graph is clique-width [15–17].",
      "startOffset" : 91,
      "endOffset" : 98
    }, {
      "referenceID" : 15,
      "context" : "Another graph parameter for capturing the structural complexity of a graph is clique-width [15–17].",
      "startOffset" : 91,
      "endOffset" : 98
    }, {
      "referenceID" : 16,
      "context" : "Another graph parameter for capturing the structural complexity of a graph is clique-width [15–17].",
      "startOffset" : 91,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "In contrast, graphs with bounded treewidth also have bounded clique-width [12, 15].",
      "startOffset" : 74,
      "endOffset" : 82
    }, {
      "referenceID" : 14,
      "context" : "In contrast, graphs with bounded treewidth also have bounded clique-width [12, 15].",
      "startOffset" : 74,
      "endOffset" : 82
    }, {
      "referenceID" : 17,
      "context" : "By means of a meta-theorem due to Courcelle, Makowsky, and Rotics [18], one can solve any graph problem that can be expressed in Monadic Second-Order Logic with quantification on vertex sets (MSO1) in linear time for graphs of bounded clique-width.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 12,
      "context" : "This result is similar to Courcelle’s theorem [13, 14] for graphs of bounded treewidth, which has been used for the FPT result for ASP w.",
      "startOffset" : 46,
      "endOffset" : 54
    }, {
      "referenceID" : 13,
      "context" : "This result is similar to Courcelle’s theorem [13, 14] for graphs of bounded treewidth, which has been used for the FPT result for ASP w.",
      "startOffset" : 46,
      "endOffset" : 54
    }, {
      "referenceID" : 30,
      "context" : "treewidth [31].",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 30,
      "context" : "Since the formula given in [31] is in MSO1, the FPT result for ASP applies also to signed clique-width.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 24,
      "context" : "Clique-width is NP-hard to compute [25], which might be considered as an obstacle toward practical applications.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 39,
      "context" : "However, one can check in polynomial time whether the width of a graph is bounded by a fixed k [40, 47].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 46,
      "context" : "However, one can check in polynomial time whether the width of a graph is bounded by a fixed k [40, 47].",
      "startOffset" : 95,
      "endOffset" : 103
    }, {
      "referenceID" : 33,
      "context" : "Recently, SAT solvers have been used to obtain sequences of vertex partitions that correspond to cwd-expressions [34] for a given graph.",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 30,
      "context" : "In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 35,
      "context" : "In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 44,
      "context" : "In contrast to treewidth where the FPT result from [31] has been used for designing [36] and implementing [45] a dynamic programming algorithm, to the best of our knowledge there are no algorithms yet that explicitly exploit the fixedparameter tractability of ASP on bounded clique-width.",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 22,
      "context" : "In fact, we are not aware of any FPT algorithm for bounded clique-width for a reasoning problem located on the second level of the polynomial hierarchy (except [23] from the area of abstract argumentation).",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 26,
      "context" : "We do so by suitably generalizing the seminal approach of [27] for the SAT problem.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 20,
      "context" : "We use standard graph terminology, see for instance the handbook [21].",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 21,
      "context" : "In parameterized algorithmics [22] the runtime of an algorithm is studied with respect to a parameter k ∈ N and input size n.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "The class W[1] captures parameterized intractability and contains all problems that are FPTreducible to PARTITIONED CLIQUE when parameterized by the size of the solution.",
      "startOffset" : 11,
      "endOffset" : 14
    }, {
      "referenceID" : 0,
      "context" : "Showing W[1]-hardness for a problem rules out the existence of an FPT-algorithm under the usual assumption FPT 6= W[1].",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "Showing W[1]-hardness for a problem rules out the existence of an FPT-algorithm under the usual assumption FPT 6= W[1].",
      "startOffset" : 115,
      "endOffset" : 118
    }, {
      "referenceID" : 28,
      "context" : "Following [29], M ⊆ A(Π) is an answer set of Π if M ∈ Mods(Π) and for no N ( M , we have N ∈ Mods(Π ).",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 23,
      "context" : "As shown by Eiter and Gottlob, this problem is Σ2 -complete [24].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 25,
      "context" : "The dependency graph of Π, denoted by DEP(Π), is the directed graph with vertex set A(Π) and that contains an arc (x, y) if there is a rule r ∈ R(Π) such that either x ∈ h(r) and y ∈ p(r) ∪ n(r) or x, y ∈ h(r) [26].",
      "startOffset" : 210,
      "endOffset" : 214
    }, {
      "referenceID" : 36,
      "context" : "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 5,
      "context" : "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 34,
      "context" : "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 49,
      "context" : "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 19,
      "context" : "The most prominent of those are directed treewidth [37], directed pathwidth [3], DAG-width [6], Kellywidth [35], and D-width [50] (see also [20]).",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 10,
      "context" : "To state our results in the most general manner, we will employ the parameter cycle-rank [11].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 31,
      "context" : "Since the cycle-rank is always greater or equal to any of the above mentioned directed width measures [32, 38], any (parameterized) hardness result obtained for cycle-rank carries over to the aforementioned width measures for directed graphs.",
      "startOffset" : 102,
      "endOffset" : 110
    }, {
      "referenceID" : 37,
      "context" : "Since the cycle-rank is always greater or equal to any of the above mentioned directed width measures [32, 38], any (parameterized) hardness result obtained for cycle-rank carries over to the aforementioned width measures for directed graphs.",
      "startOffset" : 102,
      "endOffset" : 110
    }, {
      "referenceID" : 29,
      "context" : ", [30]) that the cycle-rank of UND(D) is equal to the treedepth of DI(D), i.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 7,
      "context" : ", the underlying undirected graph of D, and that the treedepth is always an upper bound for the pathwidth and the treewidth of an undirected graph [8].",
      "startOffset" : 147,
      "endOffset" : 150
    }, {
      "referenceID" : 23,
      "context" : "For our hardness results, we employ the reduction given in [24] showing that ASP consistency is Σ2 -hard in general.",
      "startOffset" : 59,
      "endOffset" : 63
    }, {
      "referenceID" : 52,
      "context" : "As checking validity of QBF 2,∃ formulas is Σ P 2 -complete [53], this reduction shows that ASP is Σ P 2 -hard.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 35,
      "context" : "This is in contrast to our second graphical representation of ASP, the incidence graph, for which it is known that ASP is fixed-parameter tractable parameterized by the treewidth [36].",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 30,
      "context" : "The results in [31] imply that bounding the clique-width of the signed incidence graph of a program leads to tractability.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 18,
      "context" : "However, such algorithms are primarily of theoretical interest due to huge constant factors, and for actually solving problems, it is preferable to explicitly design dynamic programming algorithms [19].",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 38,
      "context" : "Then, the clique-width of SINC(Πn) is at least the clique-width of the n × n grid G, which grows with n [39].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 26,
      "context" : "We start with the classical semantics for programs, where it is sufficient to just slightly adapt (a simplified version of) the algorithm for SAT by [27].",
      "startOffset" : 149,
      "endOffset" : 153
    }, {
      "referenceID" : 26,
      "context" : "A similar situation is known for the satisfiability problem of propositional formulas (SAT), which was first shown in [27] to be FPT parameterized by the clique-width of the signed incidence graph, and the authors conjectured that the same should hold already for the unsigned version.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 45,
      "context" : "Surprisingly, this turned out not to be the case [46].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 0,
      "context" : "Let L ⊆ {h, p, n} with |L| > 1 and L 6= {h, n}, then ASP is W[1]-hard parameterized by the clique-width of SINCL(Π).",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 0,
      "context" : "We show the result by a parameterized reduction from the W [1]-complete problem PARTITIONED CLIQUE [48].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 47,
      "context" : "We show the result by a parameterized reduction from the W [1]-complete problem PARTITIONED CLIQUE [48].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 30,
      "context" : "On the other hand, we turned a theoretical tractability result (which implicitly follows from previous work [31]) for the parameter clique-width (applied to the signed incidence graph of a program) into a novel dynamic programming algorithm.",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 50,
      "context" : "Another open question is whether ASP parameterized by the clique-width of the unsigned incidence graph is in the class XP (as is the case for SAT [51]).",
      "startOffset" : 146,
      "endOffset" : 150
    } ],
    "year" : 2017,
    "abstractText" : "Disjunctive Answer Set Programming (ASP) is a powerful declarative programming paradigm whose main decision problems are located on the second level of the polynomial hierarchy. Identifying tractable fragments and developing efficient algorithms for such fragments are thus important objectives in order to complement the sophisticated ASP systems available to date. Hard problems can become tractable if some problem parameter is bounded by a fixed constant; such problems are then called fixed-parameter tractable (FPT). While several FPT results for ASP exist, parameters that relate to directed or signed graphs representing the program at hand have been neglected so far. In this paper, we first give some negative observations showing that directed width measures on the dependency graph of a program do not lead to FPT results. We then consider the graph parameter of signed clique-width and present a novel dynamic programming algorithm that is FPT w.r.t. this parameter. Clique-width is more general than the well-known treewidth, and, to the best of our knowledge, ours is the first FPT algorithm for bounded clique-width for reasoning problems beyond SAT.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}