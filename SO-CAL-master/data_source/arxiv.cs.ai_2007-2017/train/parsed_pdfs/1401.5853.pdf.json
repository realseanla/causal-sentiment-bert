{
  "name" : "1401.5853.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reasoning over Ontologies with Hidden Content: The Import-by-Query Approach",
    "authors" : [ "Bernardo Cuenca Grau", "Boris Motik" ],
    "emails" : [ "bernardo.cuenca.grau@cs.ox.ac.uk", "boris.motik@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "of an ontology Kh that is being reused by another ontology Kv. Towards this goal, in this paper we propose the import-by-query framework, which makes the content of Kh accessible through a limited query interface. If Kv reuses the symbols from Kh in a certain restricted way, one can reason over Kv ∪Kh by accessing only Kv and the query interface. We map out the landscape of the import-by-query problem. In particular, we outline the limitations of our framework and prove that certain restrictions on the expressivity of Kh and the way in which Kv reuses symbols from Kh are strictly necessary to enable reasoning in our setting. We also identify cases in which reasoning is possible and we present suitable import-by-query reasoning algorithms."
    }, {
      "heading" : "1. Introduction",
      "text" : "Ontologies—formal conceptualizations of a domain of interest—have become increasingly important in computer science. They play a central role in many applications, such as the Semantic Web and biomedical information systems. The most widely used ontology languages are the Web Ontology Language (OWL) (Horrocks, Patel-Schneider, & van Harmelen, 2003) and its revision OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler, 2008), which have been standardized by the World Wide Web Consortium (W3C). The formal underpinning of the OWL family of languages is provided by description logics (DLs) (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2007)—knowledge representation formalisms with well-understood computational properties.\nConstructing ontologies is a labor-intensive task, so reusing (parts of) well-established ontologies is seen as key to reducing ontology development cost. Consequently, the problem of ontology reuse has recently received significant attention (Stuckenschmidt, Parent, & Spaccapietra, 2009; Lutz & Wolter, 2010; Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008, 2007; Doran, Tamma, & Iannone, 2007; Jiménez-Ruiz, Cuenca Grau, Sattler, Schneider, & Berlanga Llavori, 2008).\nWe discuss the problems of ontology reuse by means of an example from the health-care domain. In particular, ontologies are currently being used in several countries to describe electronic patient records (EPR). The representation of patients’ data typically involves ontological descriptions of human anatomy, medical conditions, drugs and treatments, and so on. The latter domains have already been described in well-established reference ontologies, such as SNOMED-CT, GALEN, or the Foundational Model of Anatomy (FMA). In order to save resources, increase interoperability between applications, and rely on experts’\nc2012 AI Access Foundation. All rights reserved.\nknowledge, these and other reference ontologies should be reused whenever possible. For example, assume that some reference ontology Kh describes concepts such as the “ventricular septum defect”; then, one might reuse the terms from Kh in order to define an ontology Kv of concepts such as “patients having a ventricular septum defect,” which might then be embedded in an EPR application.\nTo enable ontology reuse, OWL provides an importing mechanism: an ontology Kv can import another ontology Kh, and the result is logically equivalent to Kv ∪Kh. OWL reasoners deal with imports by loading both ontologies and merging their contents, thus requiring physical access to the axioms of Kh. The vendor of Kh, however, may be reluctant to distribute (parts of) the contents of Kh, as doing so might allow competitors to plagiarize Kh. Moreover, Kh may contain information that is sensitive from a privacy point of view. Finally, one may want to impose a varying cost on the reuse of different parts of Kh.\nRather than publishing the entire ontology, the vendor of Kh might want to freely distribute the symbols that describe organs and medical conditions, but without distributing the axioms describing these symbols. Furthermore, the vendor might want to completely hide the sensitive information from Kh, such as the information about treatments. It should, however, be possible to reuse the published part of Kh without affecting the ontology’s consequences; that is, if a part of Kh is used to construct an ontology Kv, then any query q mentioning only symbols from Kv should be answered over Kv and the respective part of Kh in the same way as this would be done over Kv ∪Kh. To stipulate that Kh should not be publicly available, we call the ontology Kh hidden and, by analogy, we call Kv visible.\nMotivated by such scenarios, several approaches to hiding a subset Υ of the signature of Kh have been developed. For example, one possible approach is to publish an Υ-interpolant ofKh—an ontology that contains no symbols fromΥ and that coincides withKh on all logical consequences formed using the symbols not in Υ (Konev, Walther, & Wolter, 2009; Wang, Wang, Topor, Pan, & Antoniou, 2009; Wang, Wang, Topor, & Pan, 2008; Wang, Wang, Topor, & Zhang, 2010; Wang et al., 2008; Lutz & Wolter, 2011; Nikitina, 2011). Publishing an interpolant ensures that the sensitive information in Kh (i.e., the information about the symbols from Kh not mentioned in the interpolant) is not exposed in any way; furthermore, interpolants preserve all consequences of symbols not inΥ and have the additional advantage that the developers of Kv can reason over the union of Kv and the interpolant using off-theshelf reasoners. The interpolation approach may, however, exhibit several drawbacks. First, an interpolant may exist only if Kh is expressed in a relatively weak ontology language and if it satisfies certain syntactic conditions (Konev et al., 2009). Second, although interpolants preserve logical consequences formed using symbols not in Υ, they are not robust under replacement (Sattler, Schneider, & Zakharyaschev, 2009)—that is, the union of Kv and an Υ-interpolant of Kh is not guaranteed to yield the same consequences as Kh ∪Kv for a query q involving only symbols from Kv. Finally, an Υ-interpolant of Kh can be exponentially larger than Kh, and it may reveal more information than what is strictly needed. We refer the reader to Section 7 for a detailed discussion of the related work.\nIn this paper, we propose a novel approach to ontology reuse that addresses the problems outlined above by making Kh accessible via a limited query interface called an oracle. The oracle advertises a public subset Γ of the signature of Kh (e.g., all symbols describing organs or medical conditions), and it can answer queries over Kh that are expressed in a particular query language and that use only the symbols from Γ. Under certain assumptions, a so-\ncalled import-by-query algorithm can reason over Kv ∪Kh (e.g., determine the satisfiability of Kv ∪Kh) by posing queries to the oracle for Kh, and without accessing any of the axioms from Kh. Furthermore, reasoning can be performed without making the axioms of Kv available to Kh, which is beneficial as Kv might also contain sensitive information from a privacy point of view. Finally, our framework can be applicable even in cases when the relevant interpolant for Kh does not exist.\nIn order to achieve these benefits, however, Kv must reuse the symbols from Γ only in a syntactically restricted way, and the formal properties of import-by-query algorithms and the specific restrictions necessary for an import-by-query algorithm to exist depend on the oracle query language and the ontology languages used to express Kv and Kh. In this paper, we explore the properties of import-by-query reasoning with languages ranging from the lightweight description logic EL (Baader, Brandt, & Lutz, 2005) to the expressive logic ALCHOIQ (Horrocks & Sattler, 2005), combined with the following types of oracles.\n• Queries for concept satisfiability oracles are concepts constructed using the symbols in Γ expressed in a particular DL; for each query, the oracle decides the satisfiability of the query concept w.r.t. Kh.\n• Queries for ABox satisfiability oracles are ABoxes constructed using the symbols in Γ; for each query, the oracle decides the satisfiability of the query ABox w.r.t. Kh.\n• Queries for ABox entailment oracles consist of an ABox and an assertion, both constructed using the symbols in Γ; for each query, the oracle determines whether the assertion is entailed by Kh and the query ABox.\nConcept satisfiability, ABox satisfiability, and ABox entailment have been implemented in most state-of-the-art DL reasoners, so the above mentioned query languages seem like a natural foundation for practical implementations of our framework.\nThe main contributions of this paper are as follows:\n1. We present the import-by-query framework, formalize the notions of an oracle and an import-by-query algorithm, and establish the connections between import-by-query algorithms based on different types of oracles.\n2. We explore the limitations of our framework for a wide range of description logics and formulate precise conditions under which import-by-query algorithms fail to exist.\n3. We identify sufficient conditions on the visible ontology Kv for which an import-byquery algorithm can be obtained.\n4. We present a general hypertableau-based (Motik, Shearer, & Horrocks, 2009) importby-query algorithm that relies on ABox satisfiability oracles and that is applicable to Kv and Kh given in the expressive description logic ALCHIQ (Horrocks & Sattler, 1999), provided that Kv satisfies our sufficient conditions.\n5. Our general algorithm, however, is unlikely to be suitable for practice due to a high degree of nondeterminism. Therefore, we present a practical (goal-oriented) variant that is applicable whenever Kh is expressed in a Horn DL. This algorithm can be\nreadily applied to ontologies expressed in the lightweight description logic EL, but it is not guaranteed to be computationally optimal. Therefore, we also present a practical and computationally optimal algorithm that can be used if both Kv and Kh are expressed in EL.\n6. We establish the lower bounds on the size and the number of queries that an importby-query algorithm may need to ask an oracle in order to solve a reasoning task.\nOur results provide flexible and useful ways for ontology designers to ensure selective access to their ontologies, as well as a family of reasoning algorithms that provide a starting point for implementation and optimization. Furthermore, we believe our techniques can also be adapted to other settings, such as distributed ontology reasoning, or collaborative ontology development scenarios in which ontology developers have restricted access to the parts of the ontology developed by others."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section, we recapitulate the description logic notation used in this paper, we present an overview of various hypertableau reasoning algorithms for description logics (Motik et al., 2009), and we recapitulate various notions of modular ontology reuse (Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Konev, Lutz, Walther, & Wolter, 2008)."
    }, {
      "heading" : "2.1 Description Logics",
      "text" : "The syntax of the description logic ALCHOIQ is defined w.r.t. pairwise-disjoint countably infinite sets of atomic concepts NC , atomic roles NR, and named individuals NI . Set NC contains a distinguished infinite subset NO ⊆ NC of nominal concepts (or simply nominals). A role is either an atomic role or an inverse role R− for R an atomic role.\nThe set of concepts is the smallest set containing , A, ¬C, C1 C2, ∃R.C (existential restriction), and ≥n R.C (cardinality restriction), for A an atomic concept, C, C1, and C2 concepts, R a role, and n a nonnegative integer. Furthermore, ⊥, C1  C2, ∀R.C, and ≤n R.C are abbreviations of ¬, ¬(¬C1  ¬C2), and ¬(∃R.¬C), and ¬(≥n+1R.C), respectively. We also often treat concepts of the form ∃R.C as abbreviations of ≥ 1 R.C.\nA concept inclusion axiom has the form C1  C2 for C1 and C2 concepts, a concept equivalence C1 ≡ C2 is an abbreviation for C1  C2 and C2  C1, and a concept definition is a concept equivalence of the form A ≡ C with A an atomic concept. A role inclusion axiom has the form R1  R2 for R1 and R2 roles. A TBox axiom is either a concept inclusion axiom or a role inclusion axiom. A TBox T is a finite set of TBox axioms. An assertion has the form C(a), R(a, b), ¬R(a, b), a ≈ b, or a ≈ b, for C a concept, R a role, and a and b individuals. An ABox A is a finite set of assertions. An ABox is normalized if it contains only assertions of the form A(a), ¬A(a), R(a, b), ¬R(a, b), and a ≈ b, where A is an atomic concept and R is an atomic role. An axiom is either a TBox axiom or an assertion. A knowledge base K = T ∪A consists of a TBox T and an ABox A.\nA signature is a set of atomic concepts and atomic roles. For α a concept, a role, an axiom, or a set of axioms, the signature of α, written sig(α), is the set of atomic concepts and atomic roles occurring in α.1\nThe cardinality of a set S is written S. An interpretation I = (I , ·I) consists of a nonempty domain setI and a function ·I that assigns an object aI ∈ I to each individual a, a set AI ⊆ I to each atomic concept A such that A ∈ NO implies AI = 1, and a relation RI ⊆ I ×I to each atomic role R. Table 1 defines the extension of ·I to roles and concepts, as well as the satisfaction of axioms in I. An interpretation I is a model of K, written I |= K, if I satisfies all axioms in K; if such I exists, then K is satisfiable. A concept C is satisfiable w.r.t. K if a model I of K exists such that CI = ∅.\nSometimes, nominal concepts are defined as having the form {a} for a an individual, and such a concept is interpreted as ({a})I = {aI}; that is, a nominal concept contains precisely the given individual. The drawback of such a definition is that it blurs the distinction between concepts and individuals at the syntactic level. Such a distinction is important for the import-by-query framework since our framework supports sharing concepts, but not individuals. In this paper we thus use the above given alternative definition, where nominals are “special” atomic concepts with a singleton interpretation. It is well known that these two definitions are equally expressive (Baader et al., 2007).\nSome of our results use a general notion of a description logic. Formally, we define a description logic DL as a pair consisting of a set of concepts and a set of knowledge bases. We call the elements of the former set DL-concepts and the elements of the latter set DLknowledge bases. Each concept in a DL-knowledge base must be a DL-concept. A DL-TBox (resp. DL-ABox ) is a DL-knowledge base containing no assertions (resp. no TBox axioms).\n1. Note that we are treating nominals as special atomic concepts (and not as individuals); hence, sig(α) includes the nominals, but not the individuals occurring in α.\nA DL-TBox axiom (resp. DL-assertion) is a TBox axiom (resp. assertion) that occurs in some DL-knowledge base. A description logic DL1 is a fragment of DL2 (or, conversely, DL2 extends DL1) if each DL1-concept is a DL2-concept and each DL1-knowledge base is a DL2-knowledge base. Since the “unqualified” notions of a concept and knowledge base are defined for ALCHOIQ, our definitions imply that each description logic considered in this paper is a fragment of ALCHOIQ.\nLet DL1 and DL2 be description logics. We say that DL1 allows for DL2-definitions if, for each DL1-knowledge base K, each atomic concept A, and each DL2-concept C, we have that K ∪ {A ≡ C} is a DL1-knowledge base. Furthermore, DL1 has the finite model property if each satisfiable DL1-knowledge base has a model with a finite domain.\nThe description logic ALC is obtained from ALCHOIQ by disallowing nominal concepts (O), inverse roles (I), role inclusion axioms (H), and cardinality restrictions (Q). The description logics between ALC and ALCHOIQ are named by appending combinations of letters O, H, I, and Q to ALC.\nThe DL EL (Baader et al., 2005) (resp. FL0, see Baader et al., 2007) is obtained from ALC by allowing only concepts of the form , ⊥, A, C1  C2, and ∃R.C (resp. ∀R.C) for A and R atomic, and by allowing only assertions of the form C(a) or R(a, b), with C an EL (resp. FL0) concept and R an atomic role. In recent years, significant effort has been devoted to the development of DL languages with good computational properties, such as EL, DL-Lite (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007), and Horn-SHIQ (Hustadt, Motik, & Sattler, 2005). An ALCHIQ knowledge base is Horn if it is expressed in the Horn-SHIQ fragment of ALCHIQ.\nFor an ABoxA, with G(A) we denote the graph whose nodes are precisely the individuals occurring in A, and that contains an undirected edge between individuals a and b if and only if a = b or both a and b occur together in an assertion in A. Individuals a and b are connected in A if a and b are connected in G(A); furthermore, A is connected if all pairs of individuals occurring in A are connected. An ABox A ⊆ A is a connected component of A if G(A) is a connected component of G(A)."
    }, {
      "heading" : "2.2 Hypertableau Reasoning Algorithm",
      "text" : "The hypertableau calculus by Motik et al. (2009) decides the satisfiability of an ALCHOIQ knowledge base K. As we show in Section 4.1, the presence of nominals precludes the existence of an import-by-query algorithm; hence, in this section we present an overview of a simplified version of the algorithm that is applicable if K is an ALCHIQ knowledge base.\nThe algorithm first preprocesses K into a set of rules R—implications interpreted under first-order semantics—and a normalized ABox A such that K is equisatisfiable with R ∪ A. Preprocessing consists of three steps. First, transitivity axioms are eliminated from K by encoding them using concept inclusions. Second, axioms are normalized and complex concepts are replaced with atomic ones in a way similar to the structural transformation for first-order logic. Third, the normalized axioms are translated into rules by using the correspondence between description and first-order logic. We omit the details of the preprocessing for the sake of brevity; Motik et al. (2009) present all the relevant details. Preprocessing produces so-called HT-rules—syntactically restricted rules on which\nthe hypertableau calculus is guaranteed to terminate; the precise syntactic form of HT-rules is described in Section 2.2.1.\nAfter preprocessing, the satisfiability ofR∪A is decided using the hypertableau calculus, which is described in Section 2.2.2."
    }, {
      "heading" : "2.2.1 HT-Rules",
      "text" : "Let NV be a set of variables disjoint with the set of individuals NI . An atom is an expression of the form C(s) (a concept atom), R(s, t) (a role atom), or s ≈ t (an equality atom), where s, t ∈ NV ∪NI , C is a concept, and R is a role. A rule is an expression of the form\nU1 ∧ . . . ∧ Um → V1 ∨ . . . ∨ Vn (1)\nwhere Ui and Vj are atoms, m ≥ 0, and n ≥ 0. Conjunction U1 ∧ . . . ∧ Um is called the body, and disjunction V1 ∨ . . . ∨ Vn is called the head of the rule. The empty body and the empty head are written as  and ⊥, respectively. Rules are interpreted as universally quantified FOL implications in the usual way. A rule is Horn if it contains at most one head atom.\nAn HT-rule is a rule of the form \nAi(x) ∧  Rij(x, yi) ∧  Sij(yi, x) ∧ \nBij(yi) → Ci(x) ∨  R ij (x, yi) ∨  S ij (yi, x) ∨  Dij(yi) ∨  yi ≈ yj\n(2)\nwhere Rij , Sij , Rij , and S  ij are atomic roles; Ai, Bij , and Dij are atomic concepts; and Ci are either atomic concepts or concepts of the form ≥n R.A or ≥n R.¬A. In addition, each variable yi occurring in an HT-rule is required to occur in a body atom of the form Rij(x, yi) or Sij(yi, x). Intuitively, the body and the head of HT-rules can be seen as being star-shaped: “center variable” x represents the center of the star, and “branch variables” yi can be connected to the center only through role atoms. Such shape ensures that satisfiable HT-rules will always have a tree-like model—a property that can be used to explain the good computational properties of many DLs.\nAs Motik et al. (2009) have shown, the preprocessing of K produces an equisatisfiable set of HT-rules and a normalized ABox; furthermore, if K is Horn, then the resulting set contains only Horn HT-rules. Furthermore, if certain description logic constructors are not used in K, then R satisfies certain syntactic restrictions as discussed next.\n• If K does not use cardinality restrictions, then no HT-rule  ∈ R contains an atom of the form yi ≈ yj in the head.\n• If K does not use inverse roles, then no HT-rule  ∈ R contains an atom of the form S\nij (yi, x) in the head or an atom of the form Sij(yi, x) in the body.\n• If K does not use role hierarchies, then no HT-rule  ∈ R contains a role atom in the head.\nAs an example, consider the following knowledge base K and the corresponding set of HT-rules R obtained from K.\nA  ∃R.B  A(x) → ∃R.B(x) (3) A  ∃R.C  A(x) → ∃R.C(x) (4)\n  ≤ 1 R.  R(x, y1) ∧R(x, y2) → y1 ≈ y2 (5) B  C  D  B(x) ∧ C(x) → D(x) (6) ∃R.D  E  R(x, y) ∧D(y) → E(x) (7)\nNote that R is a set of Horn HT-rules. Note also that K uses a cardinality restriction ≤ 1 R., so R contains a rule with an equality atom in the head. Furthermore, K does not use role hierarchies, so no rule in R contains a role atom in the head. Finally, K does not use inverse roles, so each role atom occurring in the body of a rule in R contains the center variable x in the first position and a branch variable yi in the second position.\nWhen applied to an EL knowledge base, the transformation by Motik et al. (2009) produces EL-rules—HT-rules of the form (8) in which C is either an atomic concept or a concept of the form ∃R.A with A an atomic concept.\nk\ni=1\nAi(x) ∧ m\ni=1\n Ri(x, yi) ∧ mi\nj=1\nBij(yi)\n\n→ C(x) (8)\nNote that all the rules in our previous example except for the third one (which uses equality in the head) are EL-rules."
    }, {
      "heading" : "2.2.2 Hypertableau Calculus for HT-Rules",
      "text" : "Given an arbitrary set of HT-rules R and a normalized ABox A, satisfiability of R∪A can be decided using the calculus described in Definition 1.\nDefinition 1. Individuals. For a set of named individuals NI , the set of all individuals NX is inductively defined as the smallest set such that NI ⊆ NX and, if x ∈ NX , then x.i ∈ NX for each integer i. The individuals in NX \\NI are unnamed. An individual x.i is a successor of x, and x is a predecessor of x.i; descendant and ancestor are the transitive closures of successor and predecessor, respectively.\nPairwise Anywhere Blocking. The label LA(s) of an individual s and the label LA(s, t) of an individual pair s, t in an ABox A are defined as follows:\nLA(s) = {A | A(s) ∈ A and A is atomic} LA(s, t) = {R | R(s, t) ∈ A}\nLet ≺ be a strict ordering on NX containing the ancestor relation. By induction on ≺, we assign to each individual s in A a blocking status as follows.\n• Individual s is directly blocked by individual t iff the following conditions hold, for s and t the predecessors of s and t, respectively:\n– s and t are unnamed, t is not blocked, and t ≺ s;2\n– LA(s) = LA(t) and LA(s) = LA(t); and – LA(s, s) = LA(t, t) and LA(s, s) = LA(t, t).\n2. When blocking is used with ALCHOIQ knowledge bases, individuals s and t are also required to be unnamed; however, this restriction is not needed for ALCHIQ knowledge bases.\nPruning and Merging. The ABox pruneA(s) is obtained from A by removing all assertions containing a descendant of s. The ABox mergeA(s → t) is obtained from pruneA(s) by replacing s with t in all assertions.\nClash. An ABox A contains a clash if ⊥ ∈ A; otherwise, A is clash-free. Derivation Rules. The derivation rules consist of the Hyp-, ≥-, ≈-, and ⊥-rule from Table 2, which, given R and a clash-free ABox A, derive the ABoxes A1, . . . ,An. In the Hyp-rule, σ(U) is obtained from U by replacing each variable x with σ(x). For a role R and individuals s and t, function ar(R, s, t) returns assertion R(s, t) if R is atomic, or assertion S(t, s) if R is an inverse role and R = S−.\nDerivation. A derivation for R and A is a pair (T, ρ) where T is a finitely branching tree and ρ labels the nodes of T with ABoxes such that ( i) ρ() = A for  the root, and ( ii) for each node t, if a derivation rule is applicable to R and ρ(t), then t has children t1, . . . , tn such that ρ(t1), . . . , ρ(tn) are the result of applying one derivation rule to R and ρ(t). The algorithm returns t if some derivation for R and A has a leaf node labeled with a clash-free ABox, and f otherwise.\nThe Hyp-rule is similar to the one of the hypertableau calculus for first-order logic: given an HT-rule of he form (1) and an ABox A, the Hyp-rule tries to unify the atoms U1, . . . , Um with a subset of the assertions in A; if a unifier σ is found, the rule nondeterministically derives σ(Vj) for some 1 ≤ j ≤ n. For example, given the rule A(x) → ∃R.C(x) ∨D(x) and an assertion A(a), the Hyp-rule derives either ∃R.C(a) or D(a). The ≥-rule deals with existential quantifiers; for example, given ∃R.C(a), the rule introduces a fresh individual t and derives R(a, t) and C(t). The ≈-rule deals with equality; for example, given a ≈ b, the rule replaces the individual a in all assertions with the individual b. Finally, the ⊥-rule detects obvious contradictions such as A(a) and ¬A(a), R(a, b) and ¬R(a, b), or a ≈ a.\nSince ALCHIQ allows for cyclic concept inclusions of the form C  ∃R.C, termination of the hypertableau calculus requires a blocking mechanism to prevent the ≥-rule from generating infinite sequences of successors. When an individual s is directly blocked by another individual t, the ≥-rule is no longer applicable to s, which prevents the introduction of fresh successors of s. Furthermore, all descendants of s are then indirectly blocked, which prevents the application of any of the rules in Table 2 to the descendants of s.\nIf a derivation for R and A exists in which a leaf node is labeled with a clash-free ABox A, then a model of R ∪ A can be constructed from A via a well-known technique called unraveling. Models of R∪A obtained in such a way are called canonical forest models, and Motik et al. (2009) discuss in depth the properties of such models.\nLet R be the set of HT-rules (3)–(7) given in Section 2.2.1, and let A = {A(a),¬E(a)}; we next show how to demonstrate using the hypertableau algorithm that R ∪A is unsatisfiable. By applying the Hyp-rule to A(a), we derive ∃R.B(a) and ∃R.C(a). Next, by applying the ≥-rule to ∃R.B(a) we derive R(a, t1) and B(t1); and by applying the ≥-rule to ∃R.C(a) we derive R(a, t2) and C(t2). Individuals t1 and t2 are fresh successors of s and are actually of the form s.1 and s.2; however, for clarity we write them simply as t1 and t2. By applying the Hyp-rule to R(a, t1) and R(a, t2), we derive t1 ≈ t2. Furthermore, to apply the ≈-rule to t1 ≈ t2, we must replace t1 with t2 in all assertions; thus, we replace R(a, t1) and B(t1) with R(a, t2) and B(t2), respectively. Next, by applying the Hyp-rule to B(t2) and C(t2) we derive D(t2). Next, by applying the Hyp-rule to R(a, t2) and D(t2) we derive E(a). Finally, by applying the the ⊥-rule to E(a) and ¬E(a) we derive ⊥. We have thus constructed a derivation for R and A whose (only) leaf contains a clash, and so R ∪A is unsatisfiable.\n2.2.3 Hypertableau Algorithm for EL-rules Since any EL knowledge base is an ALCHIQ knowledge base as well, the hypertableau algorithm can straightforwardly be applied to EL KBs. Motik and Horrocks (2008) showed, however, that a worst-case optimal algorithm can be obtained by modifying the ≥-rule. This modified algorithm works on a set R of EL-rules.\nThe following algorithm checks satisfiability of R ∪A, for R a set of EL-rules and A a normalized ABox.\nDefinition 2. For each named individual a ∈ NI and each atomic concept A ∈ NC , let aA be a fresh individual that is uniquely associated with a and A. The hypertableau algorithm for EL is the same as the one described in Definition 1, but the derivation rules include the Hyp-, ⊥-, and ∃-rule from Table 2."
    }, {
      "heading" : "2.3 Modularity",
      "text" : "Let Kv be a knowledge base that reuses a knowledge base Kh, and let Γ be the subset of sig(Kh) that is being reused in Kv—that is, Γ = sig(Kh) ∩ sig(Kv). It is often beneficial if Kv reuses Kh in a modular way; intuitively, this is the case if the knowledge base Kv does not “affect the meaning” of the symbols in Γ (Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Konev, Lutz, Walther, & Wolter, 2008). Two different notions of modularity have been considered in literature, each providing a different formal account of what it means for Kv to “affect the meaning” of the symbols in Γ.\nA knowledge base Kv is deductively modular w.r.t. a signature Γ if, for all concepts C and D expressed in the same description logic as Kv such that sig(C) ⊆ Γ and sig(D) ⊆ Γ, we have that Kv |= C  D implies ∅ |= C  D. That is, the axioms of Kv must not give rise to nontrivial logical consequences that involve only the symbols from Γ.\nA knowledge base Kv is semantically modular w.r.t. a signature Γ if, for each interpretation I = (I , ·I) for the symbols in Γ, there exists an interpretation J = (J , ·J) such that I = J , XI = XJ for each X ∈ Γ, and J |= Kv. That is, the axioms of Kv are not allowed to impose any constraints on the interpretation of the symbols from Γ.\nSemantic modularity is stronger than the deductive one: if Kv is semantically modular w.r.t. Γ, then it is also deductively modular w.r.t. Γ; the converse does not hold necessarily. Deciding whether a knowledge base Kv is deductively or semantically modular w.r.t. a signature Γ is a very hard computational problem for most DLs, and it is often undecidable (Lutz et al., 2007; Konev et al., 2008). Cuenca Grau, Horrocks, Kazakov, and Sattler (2008) have defined several practically useful sufficient syntactic conditions that guarantee semantic modularity."
    }, {
      "heading" : "3. The Import-by-Query Framework",
      "text" : "In this section we introduce our framework. We first present a motivating example, after which we proceed with a formalization of the import-by-query problem.\nConsider a medical research company (MRC) that has developed a knowledge base of human anatomy. This knowledge base contains concepts describing organs such as Heart and TV (tricuspid valve); medical conditions such as CHD (congenital heart defect), VSD (ventricular septum defect), and AS (aortic stenosis); and treatments such as Surgery. The roles part, con, and treatment relate organs with their parts, medical conditions, and treatments, respectively, and they are used to define concepts such as VSD Heart (a heart with a ventricular septum defect) and Sur Heart (a heart that requires surgical treatment). We focus on reusing schema knowledge, so we assume that the knowledge base consists only of a TBox Th, which is shown in Table 3. Assume that MRC wants to freely distribute information about organs and conditions, but hide the information about treatments. Thus, MRC identifies a set Γ of public symbols of Th; we write these symbols in bold, and the remaining private symbols in sans serif. MRC does not want to distribute the axioms of Th, as this might allow competitors to copy parts of Th; therefore, we say that knowledge base Th is hidden.\nConsider also a health-care provider (HCP) that reuses Th to describe types of patients such as VSD Patient (patients with a ventricular septum defect), HS Patient (patients requiring heart surgery), AS Patient (patients with aortic stenosis), EA Patient (patients\nwith Ebstein’s anomaly), and TVD Patient (patients with a tricuspid valve defect). Since the TBox Th does not describe Ebstein’s anomaly, HCP defines EA Heart as a heart with a ventricular septum defect and with a displaced tricuspid valve Dis TV ; furthermore, it defines a displaced tricuspid valve as abnormal, and Ab TV Heart as a heart with an abnormal tricuspid valve. In general, HCP’s knowledge base could contain ABox assertions, so we denote the knowledge base with Kv and call it visible. The axioms of Kv are shown in Table 3, and the private symbols of Kv are written in italic. HCP can use the combined knowledge base Kv ∪ Th to deduce that VSD Patient  HS Patient (patients with ventricular septum defect require heart surgery) and EA Patient  TVD Patient (patients with Ebstein’s anomaly are a kind of patients with a tricuspid valve defect).\nTo support such scenarios, we propose the import-by-query framework. Instead of publishing (a subset of) the axioms of Th, MRC can publish an oracle for Th—a service that advertises a set Γ of public symbols in Th and a query language L, and that can answer L-queries over Th provided that these queries use only symbols in Γ. A so-called import-byquery algorithm can then reason with Kv ∪ Th (e.g., determine the satisfiability of Kv ∪ Th) without having physical access to the contents of Th, by just asking queries to the oracle. The existence of such an algorithm, however, depends on the oracle’s query language, the DLs used to express Kv and Th, and the way in which the symbols from Γ are reused in Kv.\nOne of the most popular query languages in description logics is concept satisfiability, which is available in all DL reasoners known to us. It is thus natural to consider concept satisfiability oracles, which advertise a signature Γ and check the satisfiability w.r.t. Th of (not necessarily atomic) concepts formed using the symbols in Γ. Later on we show that import-by-query algorithms based on concept satisfiability oracles exist only if rather strong\nrestrictions are imposed on the way Kv reuses the symbols from Γ; roughly speaking, it is not possible to mix roles from Γ with concepts private to Kv in existential and universal restrictions. In our example, this means that axioms δ6 and δ8 from Table 3 would not be allowed in Kv. To overcome the limitations of concept satisfiability oracles, we consider two additional types of (closely related) oracles that are more powerful than the oracles based on concept satisfiability. An ABox satisfiability oracle is given an ABox A with sig(A) ⊆ Γ, and it checks the satisfiability of A ∪ Th. An ABox entailment oracle is given an ABox A and an assertion α with sig(A) ⊆ Γ and sig(α) ⊆ Γ, and it checks whether A ∪ Th |= α. ABox satisfiability and entailment have been implemented in most state-of-the-art DL reasoners, so oracles based on such inferences seem natural.\nIn practice, it is natural to express oracle queries in the same DL as Th; however, for the sake of generality we allow queries to be expressed in an arbitrary description logic L. Intuitively, this allows Kv to “learn more about the structure of the models of Th,” which allows us to obtain more general results about nonexistence of import-by-query algorithms. Definition 3 formally introduces different types of oracles.\nDefinition 3. Let Th be a TBox, let Γ be a signature, and let L be a description logic. The concept satisfiability oracle for Th, Γ, and L is the Boolean function ΩcTh,Γ,L that, for each L-concept C with sig(C) ⊆ Γ, returns t if and only if C is satisfiable w.r.t. Th. The ABox satisfiability oracle for Th, Γ, and L is the Boolean function ΩaTh,Γ,L that, for each connected L-ABox A with sig(A) ⊆ Γ, returns t if and only if Th ∪A is satisfiable. The ABox entailment oracle for Th, Γ, and L is the Boolean function ΩeTh,Γ,L that, for each connected L-ABox A such that sig(A) ⊆ Γ and each L-assertion α that mentions only the individuals in A such that sig(α) ⊆ Γ, returns t if and only if Th ∪A |= α.\nWe use the generic term oracle for either a concept satisfiability, an ABox satisfiability, or an ABox entailment oracle. Furthermore, if L is the same as the description logic of Th, we abbreviate ΩTh,Γ,L to ΩTh,Γ. Finally, we often refer to the oracle arguments (i.e., the concepts C, the ABoxes A, and the pairs A,α in the case of concept satisfiability, ABox satisfiability, and ABox entailment oracles, respectively) as oracle queries.\nWe next formally define import-by-query algorithms using the well-known notion of an oracle Turing machine. A precise definition of the latter is given by Papadimitriou (1993); we next present just an informal overview of the main ideas. An oracle Turing machine T has a separate query tape, on which it can write arbitrary strings over a given alphabet. At any point in time, T can enter a special state q?, upon which a black-box oracle Ω checks whether the string currently written on the query tape belongs to the language associated with Ω; if that is the case, then T enters a special state qyes , and otherwise T enters a special state qno . This allows the oracle’s answers to affect the computation of T . A combination of T and Ω is usually written as TΩ. This definition assumes that the computation of T depends only on the input and the oracle’s answers; that is, if Ω1 and Ω2 are two distinct oracles, the computations of TΩ1 will be indistinguishable from the computations of TΩ2 if Ω1 and Ω2 return the same answers to queries encountered in computations. In the rest of this paper, we do not make any assumptions on the type of T : any “reasonable” Turing machine model can be used. We merely assume that T is equipped with a suitable notion of a run which captures the computation of TΩ on each input. A run can (but does not need to) accept or reject the input.\nDefinition 4. A class of inputs C is a class of triples of the form ΓC ,KCv , T Ch  where ΓC is a signature, KCv is a knowledge base, and T Ch is a TBox such that sig(KCv ) ∩ sig(T Ch ) ⊆ ΓC. Each triple in C is called an input.\nAn import-by-query algorithm for a description logic L and a class of inputs C based on oracles of type x ∈ {a, e, c} is an oracle Turing machine ibqx that can be combined with an oracle of type x. For each input Γ,Kv, Th ∈ C the following properties must be satisfied, where ibqx[Th,Γ,L] is the combination of ibqx and the oracle ΩxTh,Γ,L:\n1. whenever ibqx[Th,Γ,L] enters the state q? in a run, the string on the query tape encodes a query accepted by ΩxTh,Γ,L;\n2. ibqx[Th,Γ,L] has an accepting run on Kv if and only if Kv ∪ Th is satisfiable; and\n3. each run of ibqx[Th,Γ,L] on Kv is finite. Intuitively, the transition relation of ibqx takes into account the possible answers of an\noracle of type x, but ibqx is not “executable” because the actual oracle is unknown. Thus, ibqx can be seen as a computer program in which a particular subroutine is missing. Given an input Γ,Kv, Th ∈ C, we can parameterize ibqx by ΩxTh,Γ,L to obtain ibq\nx[Th,Γ,L], and the latter Turing machine can be freely applied to Kv.\nIn the rest of this paper, whenever the oracle type is not explicitly given, our discussion applies to all oracle types. We will consider various classes of inputs, each of which can be defined using the following formulation:\nC is the largest class of triples ΓC ,KCv , T Ch  where sig(KCv ) ∩ sig(T Ch ) ⊆ ΓC and ΓC , KCv , and T Ch satisfy some condition.\nUsually, however, we abbreviate such formulations as follows:\nC[ΓC ,KCv , T Ch ] is a class of inputs where ΓC , KCv , and T Ch satisfy some condition. Definition 4 straightforwardly implies the following property, which essentially just re-\nformulates the idea that the runs of a Turing machine are determined only by the oracles’ answers, and not the oracles themselves.\nProposition 1. Let ibq be an import-by-query algorithm for a description logic L and a class of inputs C, let Γ,Kv, T 1h  be an arbitrary input from C, and let Q1, . . . , Qn be the oracle queries encountered in all possible runs of ibq[T 1\nh ,Γ,L] on Kv. Then, for each T 2h\nsuch that Γ,Kv, T 2h  ∈ C and ΩT 1h ,Γ,L(Qi) = ΩT 2h ,Γ,L(Qi) for each 1 ≤ i ≤ n, each run of ibq[T 1\nh ,Γ,L] on Kv is a run of ibq[T 2h ,Γ,L] on Kv and vice versa.\nIn Section 4 we will identify DLs defining the oracle query language and classes of inputs for which no import-by-query algorithm based on oracles of a particular type exists. The following proposition shows that it suffices to prove nonexistence results for the most expressive DL and the smallest class of inputs; then, analogous results then hold for each weaker DL and each larger class of inputs.\nProposition 2. Let L1 be a description logic and let L2 be a fragment of L1; let C1 and C2 be classes of inputs such that each triple in C1 also belongs to C2; and let x ∈ {a, c, e} be an oracle type. If there is no import-by-query algorithm for L1 and C1 based on oracles of type x, then there is also no import-by-query algorithm for L2 and C2 based on oracles of type x.\nProof. We prove the contrapositive claim. Let ibqx be an import-by-query algorithm for L2 and C2. Since each triple in C1 is also contained in C2, ibqx is clearly an import-byquery algorithm for L2 and C1. Let Γ,Kv, Th ∈ C1 be an arbitrary input, and let Q be an arbitrary L2-query encountered in a run of ibqx[Th,Γ,L] on Kv. Since L2 is a fragment of L1, Q is an L1-query as well. Thus, ibqx is an import-by-query algorithm for L1 and C1.\nThe following theorem shows that oracles of certain types can simulate oracles of other types. This is important because if Ω1 can simulate Ω2 and we show that no import by query algorithm exists for a particular class of inputs applicable to Ω1, then also no such algorithm exists that is applicable to Ω2.\nTheorem 1. Let ≤ be the smallest partial order on the class of all oracles that satisfies the following conditions for each TBox Th, each signature Γ, and each description logic L:\n1. ΩcTh,Γ,L ≤ Ω a Th,Γ,L ≤ Ω e Th,Γ,L; and\n2. if for each L-ABox A and each L-assertion α we have that A ∪ {¬α} is an L-ABox, then ΩeTh,Γ,L ≤ Ω a Th,Γ,L holds as well.\nLet L be a description logic, let C be a class of inputs, and let x1, x2 ∈ {a, c, e} be oracle types such that Ωx1Th,Γ,L ≤ Ω x2 Th,Γ,L for each Γ,Kv, Th ∈ C. Then, each import-by-query algorithm ibqx1 for L and C can be transformed into an import-by-query algorithm ibqx2 for L and C such that, for each input Γ,Kv, Th ∈ C, ibqx1 [Th,Γ,L] has a run on Kv with n oracle queries if and only if ibqx2 [Th,Γ,L] has a run on Kv with n oracle queries.\nProof. Let ibqx1 be an arbitrary import-by-query algorithm for L and C, and consider an arbitrary input Γ,Kv, Th ∈ C. Conditions 1 and 2 ensure that Ωx1Th,Γ,L is reducible to Ωx2Th,Γ,L in the sense that a computable total function f exists from the domain of Ωx1Th,Γ,L to the domain of Ω x2 Th,Γ,L such that for each query Q accepted by Ω x1 Th,Γ,L, we have Ωx1Th,Γ,L(Q) = Ω x2 Th,Γ,L(f(Q)). In particular, an ABox satisfiability oracle is reducible to an ABox entailment oracle via f(A) = (A,⊥) for each ABox A. Furthermore, if Condition 2 holds, then an ABox entailment oracle is reducible to an ABox satisfiability oracle via f(A,α) = A ∪ {¬α}. Finally, a concept satisfiability oracle is reducible to an ABox satisfiability oracle via f(C) = {C(a)} for a a fresh individual.\nAlgorithm ibqx2 can then simply simulate ibqx1 on each input Γ,Kv, Th ∈ C; furthermore, whenever ibqx1 [Th,Γ,L] poses a query Q to Ωx1Th,Γ,L, then ibq\nx2 [Th,Γ,L] computes f(Q) and poses the query f(Q) to Ωx2Th,Γ,L. Since ibq\nx1 is an import-by-query algorithm for L and C, so is ibqx2 . Furthermore, for each input, there is a one-to-one correspondence between the runs of both algorithms with corresponding runs posing exactly the same number of oracle queries.\nWe next show that, if the shared signature Γ contains only atomic concepts, there is a close correspondence between ABox and concept satisfiability oracles.\nTheorem 2. Let L be a description logic and let C[ΓC ,KCv , T Ch ] be a class of inputs where ΓC contains only atomic concepts. Then, each import-by-query algorithm ibqa for L and C can be transformed into an import-by-query algorithm ibqc for L and C such that the following statements hold for each input Γ,Kv, Th ∈ C.\n• For each run of ibqa[Th,Γ,L] on Kv with n oracle queries and m the maximum number of individuals in a query ABox, a run of ibqc[Th,Γ,L] on Kv with at most n×m oracle queries exists.\n• For each run of ibqc[Th,Γ,L] on Kv with n oracle queries, a run of ibqa[Th,Γ,L] on Kv with at most n oracle queries exists.\nProof. Let ibqa be an import-by-query algorithm for L and C. We define ibqc such that, on each input Γ,Kv, Th ∈ C, algorithm ibqc[Th,Γ,L] simulates the steps of algorithm ibqa[Th,Γ,L]; furthermore, when ibqa[Th,Γ,L] queries ΩaTh,Γ,L with an ABox A, algorithm ibqc[Th,Γ,L] proceeds as follows.\n1. The algorithm transforms A into an ABox A by iterating over all assertions of the form a ≈ b in A and, for each such assertion, replacing one individual (say a) with the other one (say b) in all assertions.\n2. IfA contains an individual a such that a ≈ a ∈ A or ΩcTh,Γ,L(B1  . . . Bn) = f where B1, . . . , Bn are all concepts such that Bi(a) ∈ A, then ibqc[Th,Γ,L] proceeds in the same way as ibqa[Th,Γ,L] for ΩaTh,Γ,L(A) = f; otherwise, ibq\nc[Th,Γ,L] proceeds in the same way as ibqa[Th,Γ,L] for ΩaTh,Γ,L(A) = t.\nThere is an obvious correspondence between the runs of ibqa[Th,Γ,L] and ibqc[Th,Γ,L] on Kv; furthermore, whenever ibqa[Th,Γ,L] issues a query to ΩaTh,Γ,L, then ibq\nc[Th,Γ,L] issues at most m queries to ΩcTh,Γ,L in order to determine how to proceed. Finally, note that the second statement in the theorem directly follows from Theorem 1.\nWe finally show that we can without loss of generality assume Kv to contain no concept such as ∃con.AS in axiom δ3 in Table 3.\nDefinition 5. Let Γ be a signature. A concept C is Γ-modal if sig(C) ⊆ Γ and C is of the form ∃R.D, ∀R.D, ≥n R.D, or ≤n R.D.\nIntuitively, Γ-modal concepts can always be treated as “atomic” from the point of view of Kv, so we can rely on the oracle to compute all relevant consequences of such concepts.\nTheorem 3. Let L, DL1, and DL2 be description logics such that each DL1-concept is also an L-concept and DL2 allows for DL1-definitions; let x ∈ {a, c, e}; let C[ΓC ,KCv , T Ch ] be a class of inputs where KCv is a DL1-knowledge base and T Ch is a DL2-TBox; and let D[ΓD,KDv , T Dh ] be the class of inputs consisting of all triples Γ,Kv, Th in C[ΓC ,KCv , T Ch ] in which Kv contains no Γ-modal concepts. Then, each import-by-query algorithm ibqx2 for L and D can be transformed into an import-by-query algorithm ibqx1 for L and C.\nProof. For Γ a signature, C a concept, and α a concept, axiom, or knowledge base, we say that C is Γ-outermost in α if C is Γ-modal and C does not occur in α as a proper subconcept of another Γ-modal concept.\nLet Γ,Kv, Th ∈ C be an arbitrary input in C, let S be the set of all Γ-outermost concepts in Kv, and let XC be a fresh atomic concept uniquely associated with each C ∈ S. We define Γ, T \nh , and Kv as follows: Γ = Γ ∪ {XC | C ∈ S}; Kv is obtained from Kv by replacing each\nC ∈ S with XC ; and T h = Th ∪ {XC ≡ C | C ∈ S}. Clearly, Kv ∪ Th is equisatisfiable with\nKv ∪ T h, and Γ,Kv, T h ∈ D. Let ibqx2 be an arbitrary import-by-query algorithm for L and D. We define ibqx1 as the algorithm that on each Γ,Kv, Th ∈ C simulates the steps of ibqx2 on input Γ,Kv, T h ∈ D, but with the following modifications:\n• ibqx1 [Th,Γ,L] treats all concepts in S as if they were atomic; and\n• whenever ibqx2 [T h,Γ,L] queries ΩxT h,Γ,L with a query Q , then ibqx1 [Th,Γ,L] queries\nΩxTh,Γ,L with a query Q obtained from Q  by replacing each occurrence of XC with C.\nThere is an obvious correspondence between the runs of ibqx2 [T h,Γ,L] and ibqx1 [Th,Γ,L] on Kv, so ibqx1 is an import-by-query algorithm for L and C."
    }, {
      "heading" : "4. Limitations of the Import-by-Query Framework",
      "text" : "In this section, we explore the limitations of the import-by-query framework and show that import-by-query algorithms do not exist under certain conditions. Our negative results apply to classes of input where Kv and Th are expressed in a description logic DL that is as lightweight as possible, the oracle is based on ABox satisfiability, and the oracle accepts queries expressed in a description logic L that is as expressive as possible. By Theorem 1 and Proposition 2, our results also apply to all other oracle types, queries expressed in a fragment of L, and all classes of input where Kv and Th are expressed in a description logic that extends DL.\nIn particular, in Section 4.1 we establish the following general limitations of the importby-query framework.\n• The presence of nominals in Th may preclude the existence of an import-by-query algorithm even if Γ = ∅ (cf. Theorem 4).\n• Deductive modularity of the TBox of Kv w.r.t. Γ is a necessary condition for the existence of an import-by-query algorithm (cf. Theorem 5).\n• Deductive modularity, however, is not sufficient, even if Kv and Th are in EL and Γ is allowed to contain only atomic concepts (cf. Theorem 6).\nIn response to these negative results, all import-by-query algorithms proposed in this paper are subjected to the following restrictions:\nR1. Th is not allowed to contain nominals.\nR2. The TBox of Kv is required to be semantically modular w.r.t. Γ.\nWe show in Section 5.1 that these two restrictions are sufficient to guarantee the existence of an import-by-query algorithm for Kv in ALCHIQ and Th in ALCHIQ, provided that Γ contains only atomic concepts.\nIn Section 4.2, however, we show that further restrictions on the input are necessary if Γ is allowed to contain atomic roles. Roughly speaking, restrictions R1 and R2 are insufficient since the axioms in Kv can arbitrarily propagate information about the symbols private to Kv via a role in Γ to a “hidden” part of the canonical model of Kv∪Th (that is, a part of the canonical model that cannot be constructed using only the axioms in Kv); such propagation\ncan occur both via existential (cf. Theorem 7) and universal quantification (cf. Theorem 8). To overcome these negative results, we define in Section 5.1 the HT-safety condition that, on the one hand, ensures semantic modularity and, on the other hand, prevents arbitrary transfer of information about the symbols private to Kv to hidden parts of the canonical model via a role in Γ. This condition, however, is still insufficient to enable import-byquery reasoning if Th contains universal quantifiers, inverse roles, and functional roles, and Kv entails cyclic axioms of the form A  ∃R.A for R ∈ Γ and A ∈ Γ (cf. Theorem 9). To overcome this negative result, in Section 5.1 we introduce an acyclicity condition that together with HT-safety guarantees the existence of an import-by-query algorithm based on ABox satisfiability oracles for Kv and Th expressed in ALCHIQ.\nFinally, in Section 4.3 we show that no import-by-query algorithm based on concept satisfiability oracles exists for the class of inputs C[ΓC ,KCv , T Ch ] where KCv is in EL and it satisfies the HT-safety condition, and T C\nh is in EL (cf. Theorem 10). In Section 5.2.2,\nhowever, we present an algorithm based on ABox entailment oracles that applies to this class of inputs C. Thus, practically relevant cases exist for which import-by-query reasoning is impossible with concept satisfiability oracles, but it becomes feasible with ABox oracles."
    }, {
      "heading" : "4.1 General Limitations",
      "text" : "We first show that the presence of nominals in the hidden knowledge base precludes the existence of an import-by-query algorithm if the visible knowledge base is satisfiable only in infinite models. Expressive DLs used in practice often do not have the finite model property, and our negative result holds even if the shared signature is empty; thus, in the rest of this paper we do not further consider DLs with nominals, and we leave an investigation of conditions that enable import-by-query reasoning with such DLs for future work.\nTheorem 4. For each description logic DL without the finite model property, no importby-query algorithm based on ABox satisfiability oracles exists for L = ALCHOIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC = ∅, KCv is a DL-knowledge base, and T Ch is an ALCHOIQ-TBox.\nProof. Let C be an arbitrary class of inputs and let ibqa be an arbitrary import-by-query algorithm such that C and ibqa both satisfy the theorem’s assumptions. Furthermore, let Γ,Kv, T 1h  ∈ C be an arbitrary input where KCv is satisfiable only in infinite models, Γ = ∅, and T 1\nh = ∅. Since all runs of ibqa[T 1 h ,Γ,L] on Kv are finite, the number of individuals\noccurring in a query ABox in each such run is bounded by some integer n. Let T 2 h be as follows, where O1, . . . , On are fresh nominal concepts:\nT 2h = {  O1  . . . On} (9)\nClearly, Kv ∪ T 1h is satisfiable, but Kv ∪ T 2h is not. Consider now an arbitrary query ABox A occurring in a run of ibqa[T 1\nh ,Γ,L]. Since Γ = ∅, A consists only of assertions of the form\na ≈ b or a ≈ b; furthermore, A contains at most n individuals, so ΩaT 1h ,Γ(A) = t implies ΩaT 2h ,Γ\n(A) = t, and the converse holds by the monotonicity of first-order logic. But then, by Proposition 1, the runs of ibqa[T 1\nh ,Γ,L] on Kv coincide with the runs of ibqa[T 2h ,Γ,L] on\nKv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nWe next present a very strong result: deductive modularity is a necessary requirement for the existence of an import-by-query algorithm; that is, no import-by-query algorithm exists for any class of inputs that contains a triple Γ,Kv, Th such that the TBox of Kv is not deductively modular w.r.t. Γ. Intuitively, without deductive modularity, Kv can arbitrarily influence the consequences of Th, and the oracle cannot take this into account since it does not have access to the axioms of Kv. For the sake of generality, we do not impose any conditions on Γ.\nTheorem 5. Let DL1 be an arbitrary fragment of ALCHIQ; let DL2 be an arbitrary description logic that extends EL and allows for DL1-definitions; let Γ be an arbitrary signature; and let Kv be an arbitrary satisfiable DL1-knowledge base whose TBox is not deductively modular w.r.t. Γ. Then, no import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC = Γ, KCv = Kv, and T Ch is a DL2-TBox.\nProof. Let C be a class of inputs satisfying the theorem’s conditions, and let Γ,Kv, T 1h  ∈ C be an input where T 1\nh = ∅. Since Kv is not deductively modular w.r.t. Γ, possibly com-\nplex DL1 concepts C1 and C2 exist such that sig(C1) ⊆ Γ, sig(C2) ⊆ Γ, Tv |= C1  C2, and ∅ |= C1  C2. Let ibqa be an import-by-query algorithm for L = ALCHIQ and C. Finally, let T 2\nh be as follows, where A, B1, B2, and R do not occur in Γ.\nT 2h = { B1 ≡ C1, B2 ≡ C2,   ∃R.(A B1), A B2  ⊥ } (10)\nClearly, Kv ∪ T 1h is satisfiable, but Kv ∪ T 2h is not. Consider now an arbitrary L-ABox A such that sig(A) ⊆ Γ. If A ∪ T 1\nh is unsatisfiable, so is A ∪ T 2 h . Conversely, assume\nthat A ∪ T 1 h is satisfiable in a model I  = (I , ·I). Since ∅ |= C1  C2, an interpretation I  = (I , ·I) and a domain element x ∈ I exist such that x ∈ CI1 but x ∈ CI  2 . Without loss of generality we assume that I ∩I = ∅. Let I be the following interpretation:\nI = I ∪I\naI = aI for each individual a occurring in A AI = {x} BI1 = CI  1 ∪ CI  1 BI2 = CI  2 ∪ CI  2 RI = {o, x | o ∈ I} XI = XI ∪XI for each atomic concept or role X ∈ Γ\nNow for each ALCHIQ-concept E such that sig(E) ⊆ Γ, since I and I are disjoint, by a straightforward induction on the structure of E one can show that EI = EI ∩I and EI\n = EI ∩I . Furthermore, SI ⊆ SI for each atomic role S ∈ Γ. Thus I |= A, and it is straightforward to check that I |= T 2\nh . Consequently, ΩaT 1h ,Γ,L (A) = ΩaT 2h ,Γ,L(A) for each LABox A with sig(A) ⊆ Γ. Hence, by Proposition 1, the runs of ibqa[T 1\nh ,Γ,L] on Kv coincide\nwith the runs of ibqa[T 2 h ,Γ,L] on Kv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nWhile Theorem 5 shows that deductive modularity is a necessary requirement for an import-by-query algorithm to exist, the following theorem shows that it is not a sufficient\nrequirement, even if Γ contains only atomic concepts, Kv is an EL-knowledge base, and Th is an EL-TBox.\nTheorem 6. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC contains only atomic concepts, KCv and T Ch are in EL, and the TBox of KCv is deductively modular w.r.t. ΓC.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem’s assumptions, let Γ = {A, B,C}, and let Kv, T 1h , and T 2h be the following EL knowledge bases:\nKv = { A(a), B  ∃R.C } (11) T 1h = { C  ⊥ } (12) T 2h = T 1h ∪ { A  ∃S.B } (13)\nThe TBox of Kv is clearly deductively modular w.r.t. Γ, so Γ,Kv, T ih  ∈ C for i ∈ {1, 2}; furthermore, Kv ∪ T 1h is satisfiable, whereas Kv ∪ T 2h is not. Consider now an arbitrary query ABox A such that sig(A) ⊆ Γ; since A contains only assertions of the form X(a), ¬X(a), a ≈ b, and a ≈ b where sig(X) ⊆ Γ, we have ΩaT 1h ,Γ,L(A) = Ω a T 2h ,Γ,L\n(A). But then, by Proposition 1, the runs of ibqa[T 1\nh ,Γ,L] on Kv coincide with the runs of ibqa[T 2h ,Γ,L]\non Kv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nWhile deductive modularity is not sufficient, semantic modularity is sufficient in some cases: in Section 5.1 we present an import-by-query algorithm that can be applied to the case when Γ contains only atomic concepts, Kv and Th are in ALCHIQ, and the TBox of Kv is semantically modular w.r.t. Γ."
    }, {
      "heading" : "4.2 Limitations of Importing Atomic Roles",
      "text" : "In this section, we establish the limitations of the import-by-query framework for the cases when Γ is allowed to contain atomic roles. In particular, we show that semantic modularity is not sufficient to guarantee existence of an import-by-query algorithm.\nTheorems 7 and 8 demonstrate problems that arise due to certain fundamental limitations of our oracle query languages. To understand the intuition behind these results, assume that the shared signature Γ contains one atomic role R. Even in the relatively simple DL EL, knowledge base Th can imply existence of arbitrarily long R-chains using an axiom such as C  ∃R.C. All of the oracle languages that we consider, however, can examine only bounded prefixes of such chains. For example, assume that we use an ABox satisfiability oracle and a query language based on ALCHIQ. Each concept in a query ABox corresponds to a first-order formula, and it is well known that the satisfiability of such a formula in a first-order interpretation depends on the formula’s quantifier depth. Since the number of oracle calls in a run of an import-by-query algorithm must be bounded, an import-by-query algorithm can examine only a bounded prefix of a model of Th. But this leads us to a fundamental problem: if Th is changed so that it has “interesting consequences” that can be detected only by examining longer R-chains, then such consequences will go undetected by our algorithm and render the algorithm incorrect. Theorem 7 exploits the fact that the\n“interesting consequences” of Th are detected by Kv using axioms with existentially quantified concepts (i.e., our proof uses axiom ∃R.B2  B2), whereas Theorem (8) analogously uses axioms with universally quantified concepts (i.e., B  ∀R.B).\nAn alternative intuitive explanation of the results in Theorems 7 and 8 is to think of the culprit axioms ∃R.B2  B2 and B  ∀R.B in Kv as propagating information from Kv into Th. In order not to miss the “interesting consequences” of Th, an import-by-query algorithm must examine a “sufficiently large” portion of the hidden part of a canonical model of Kv ∪ Th in order to correctly evaluate the culprit axioms. This, however, is impossible because no bound on the portion size can be determined from the algorithm’s inputs.\nTheorem 7. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC is arbitrary, KCv and T Ch are expressed in EL, and the TBox of KCv is semantically modular w.r.t. ΓC.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem’s assumptions, let Γ = {A1, A2, R}, and let Kv be the following EL knowledge base:\nKv = { B1(a), B1  ∃S.A1, A2  B2, ∃R.B2  B2, ∃S.B2  ⊥ } (14)\nThe TBox of Kv is semantically modular w.r.t. Γ: for each interpretation I of the symbols in Γ, the interpretation J such that XJ = XI for each X ∈ Γ, BJ1 = ∅, BJ2 = J , and SJ = ∅ is a model of the TBox of Kv. Let T 1h be the following EL TBox:\nT 1h = { A1  C, C  ∃R.C } (15)\nSince each run of ibqa[T 1 h ,Γ,L] on Kv is finite, an integer n exists such that each query ABox occurring in a run contains concepts of quantifier depth at most n. Let T 2\nh be the\nfollowing EL TBox:\nT 2 h = {A1  ∃R . . . ∃R   .A2 } n + 1 times\n(16)\nClearly, Kv ∪ T 1h is satisfiable, whereas Kv ∪ T 2h is not. Consider an arbitrary query ABox A occurring in a run of ibqa[T 1\nh ,Γ,L]. We next show that ΩaT 1h ,Γ,L(A) = Ω a T 2h ,Γ,L (A). Assume that T 1\nh ∪A is satisfiable. Since A is expressed in ALCHIQ and T 1 h is in EL, a\ncanonical forest model I = (I , ·I) of T 1 h ∪A exists (e.g., such a model can be obtained by applying the hypertableau algorithm to T 1 h\nand A). Due to (15), for each x ∈ AI1, an infinite sequence {αx0 ,αx1 ,αx2 , . . .} ⊆ I exists such that αx0 = x and αxi ,αxi+1 ∈ RI for each 0 ≤ i. Let J = (J , ·J) be the interpretation defined as follows:\nJ = I AJ2 = AI2 ∪ {αxn+1 | x ∈ AI1} XJ = XI for each X = A2\nClearly, J |= T 2 h . Furthermore, since I |= A, A contains concepts of quantifier depth at most n, and I and J “coincide up to depth n,” we have J |= A. Thus, T 2\nh ∪A is satisfiable.\nAssume that T 2 h ∪A is satisfiable. Then a canonical forest model I = (I , ·I) of T 2 h ∪A exists. Due to (16), for each x ∈ AI1, a finite sequence {αx0 ,αx1 ,αx2 , . . . ,αxn+1} ⊆ I exists\nsuch that αx0 = x and αxi ,αxi+1 ∈ RI for each 0 ≤ i < n. Let J = (J , ·J) be the interpretation defined as follows:\nJ = I RJ = RI ∪ {αx n+1,α x n+1 | x ∈ AI1} CJ = {αx0 , . . . ,αxn+1 | x ∈ AI1} XJ = XI for each X ∈ {R,C}\nClearly, J |= T 1 h . Furthermore, since I |= A, C ∈ sig(A), A contains only concepts of quantifier depth at most n, and I and J “coincide up to depth n”, we have J |= A. Thus, T 1\nh ∪A is satisfiable. By Proposition 1, the runs of ibqa[T 1\nh ,Γ,L] on Kv coincide with the runs of ibqa[T 2h ,Γ,L]\non Kv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nTheorem 8. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC is arbitrary, KCv is expressed in FL0, T Ch is expressed in EL, and the TBox of KCv is semantically modular w.r.t. ΓC.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem’s assumptions, let Γ = {A1, A2, R}, and let Kv be the following FL0 knowledge base.\nKv = { A1(a), B(a), B  ∀R.B, A2 B  ⊥ } (17)\nThe TBox of Kv is semantically modular w.r.t. Γ: for each interpretation I for Γ, the interpretation J such that XJ = XI for each X ∈ Γ and BJ = ∅ is a model of the TBox of Kv. Let T 1h be the EL TBox (15) given in the proof of Theorem 7. Since each run of ibqa[T 1\nh ,Γ,L] on Kv is finite, an integer n exists such that each query ABox occurring in\na run contains concepts of quantifier depth at most n. Let T 2 h be the the EL TBox (16) from Theorem 7. Clearly, Kv ∪ T 1h is satisfiable, whereas Kv ∪ T 2h is not. Using arguments analogous to those from the proof of Theorem 7, one can show that ΩaT 1h ,Γ,L\n(A) = ΩaT 2h ,Γ,L(A) for each query ABox A occurring in a run of ibqa[T 1\nh ,Γ,L]. By Proposition 1, the runs of\nibqa[T 1 h ,Γ,L] on Kv coincide with the runs of ibqa[T 2h ,Γ,L] on Kv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nA possible way to overcome these negative results is to prevent the axioms in Kv from propagating information via the roles in Γ into the hidden part of a canonical model of Kv ∪ Th. In Section 5.1, we achieve this by requiring Kv to be HT-safe. Roughly speaking, such Kv is semantically modular w.r.t. Γ, but, in addition, it can be translated into a set of HT-rules Rv where variables x and y in each role atom of the form R(x, y) with R ∈ Γ are “guarded” by suitable concepts. For example, although the knowledge base Kv in (17) is semantically modular w.r.t. Γ = {A1, A2, R}, the axiom B  ∀R.B ∈ Kv violates the HTsafety condition since the body of its corresponding HT-rule B(x) ∧R(x, y) → B(y) does not contain a “guard” concept atom for variable y. In order to streamline the presentation and ensure that all notions needed to enable import-by-query reasoning are defined in one place, we formalize HT-safety in Definition 6 in Section 5.1. Unfortunately, as Theorem 9 shows, HT-safety alone does not ensure existence of an import-by-query algorithm.\nTheorem 9. No import-by-query algorithm based on ABox satisfiability oracles exists for L = ALCHIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC is arbitrary, KCv is expressed in EL, T C\nh is expressed in Horn-ALCIF , and the TBox of KCv is HT-safe w.r.t. ΓC.\nProof. Let ibqa be an import-by-query algorithm satisfying the theorem’s assumptions, let Γ = {B, R}, and let Kv be the following EL knowledge base:\nKv = { A(a), B(a), A  ∃R.A } (18)\nThe TBox of Kv is semantically modular w.r.t. Γ: for each interpretation I for Γ, the interpretation J such that XJ = XI for each X ∈ Γ and AJ = ∅ is a model of the TBox of Kv. According to Definition 6, the TBox of Kv is then HT-safe as well. Let T 1h be the following Horn-ALCIF TBox:\nT 1h = { B  C  ⊥, B  ∀R.C, C  ∀R.C,   ≤ 1 R− } (19)\nSince each run of ibqa[T 1 h ,Γ,L] on Kv is finite, integers n and m exist such that each query ABox occurring in a run contains at most n individuals and concepts of quantifier depth at most m. Let k = n + m and let D0, . . . ,Dk be distinct and fresh atomic concepts. Let T 2h be the following Horn-ALC TBox:\nT 2 h = T 1 h ∪ { Di Dj  ⊥, | 0 ≤ i < j ≤ k } ∪ { Dj−1  ∀R.Dj | 1 ≤ i ≤ k } ∪ { B  D0, Dk  ⊥ }\n(20)\nClearly, Kv ∪ T 1h is satisfiable, whereas Kv ∪ T 2h is not. Consider an arbitrary query ABox A occurring in a run of ibqa[T 1\nh ,Γ,L]. We next show that ΩaT 1h ,Γ,L(A) = Ω a T 2h ,Γ,L (A). This clearly holds if T 1\nh ∪A is unsatisfiable, so assume that T 1 h ∪A is satisfiable. Then, there\nexists a canonical forest model I = (I , ·I) of T 1 h ∪A. Consider now an arbitrary domain element x ∈ BI . We say that a domain element y ∈ I is reachable from x in  steps if a sequence of domain elements α0 = x,α1,α2, . . . ,α = y exist such that αi,αi+1 ∈ RI for each 1 ≤ i < . For each such x and y, the axioms of T 1\nh ensure the following properties:\n1. Each such sequence is unique and it consists of unique domain elements. This is because RI is an inverse-functional relation so, for each 0 ≤ i < , domain element αi is the only element such that αi,αi+1 ∈ RI , so αi = αj for 0 < i < j ≤ ; furthermore, α0 ∈ BI and α0 ∈ CI , and αi ∈ CI for 0 < i ≤ , which ensures α0 = αi for 0 < i ≤ .\n2. No x ∈ BI distinct from x exists such that y is reachable form x. This is because xi ∈ BI for each 0 < i ≤  and RI is inverse-functional.\n3.  < k. This is because A contains at most n individuals and all concepts in A are of quantifier depth at most m.\nLet J = (J , ·J) be an interpretation defined as follows:\nJ = I XJ = XI for each X ∈ sig(T 1 h ) DJ k = ∅ DJ\ni =\n\nx∈BI {y ∈ I | y is reachable from x in i steps } for each 0 ≤ i < k\nInterpretations I and J coincide on the symbols from T 1 h , so J |= A ∪ T 1 h . Furthermore, if y ∈ DI\ni with i < k, by properties 1–3 then y ∈ DI j for each j = i, so J |= A ∪ T 2 h . But then,\nby Proposition 1, the runs of ibqa[T 1 h ,Γ,L] on Kv coincide with the runs of ibqa[T 2h ,Γ,L] on Kv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nThe proof of Theorem 9 uses Kv that implies A  ∃Rn.A for arbitrary n, where A ∈ Γ and R ∈ Γ. Furthermore, axioms in Th containing universally quantified concepts propagate information along an R-chain to an unknown level m. An import-by-query algorithm cannot determine the depth to which it must examine a model of Kv, which precludes the termination requirement of Definition 4. In Section 5.1, we present a sufficient acyclicity restriction on Kv that bounds n and ensures the existence of an import-by-query algorithm."
    }, {
      "heading" : "4.3 ABox vs. Concept Satisfiability Oracles",
      "text" : "In this section we show that, for Kv an EL-knowledge base and and Th an EL-TBox, no import-by-query algorithm based on concept satisfiability oracles exists, even if Kv is HTsafe w.r.t. Γ. This is interesting because in Section 5.2.2 we present an algorithm based on ABox entailment oracles that can handle such a case. Thus, ABox oracles are strictly more expressive than concept satisfiability oracles.\nTheorem 10. No import-by-query algorithm based on concept satisfiability oracles exists for L = ALCHIQ and the class of inputs C[ΓC ,KCv , T Ch ] where ΓC is arbitrary, KCv and T Ch are expressed in EL, and the TBox of KCv is HT-safe w.r.t. ΓC. Proof. Let ibqc be an import-by-query algorithm satisfying the theorem’s assumptions, let Γ = {R}, and let Kv be the following EL knowledge base:\nKv = { A(a), A  ∃R.A } (21)\nBy Definition 6, the TBox of Kv is HT-safe. Let T 1h = ∅. Each run of ibqc[T 1h ,Γ,L] on Kv is finite, so an integer n exists such that each query concept occurring in a run contains concepts of quantifier depth at most n. Let T 2\nh be the following EL TBox:\nT 2 h = { ∃R. . . .∃R   .  ⊥ } n + 1 times\n(22)\nClearly, Kv ∪ T 1h is satisfiable, whereas Kv ∪ T 2h is not. Furthermore, it is straightforward to see that, for each ALCHIQ concept C of quantifier depth at most n with sig(C) ⊆ Γ, we have T 1\nh |= C  ⊥ if and only if T 2 h |= C  ⊥, so ΩcT 1h ,Γ(C) = Ω c T 2h ,Γ (C). But then, by Proposition 1, the runs of ibqc[T 1\nh ,Γ,L] on Kv coincide with the runs of ibqc[T 2h ,Γ,L] on\nKv, which contradicts the fact that Kv ∪ T 1h is satisfiable but Kv ∪ T 2h is not.\nNote that the knowledge base Kv used in the proof of Theorem 10 is analogous to the one from the proof of Theorem 9—that is, it entails a cyclic axiom of the form A  ∃R.A with R ∈ Γ but A ∈ Γ. The negative result from Theorem 9, however, does not apply in this case because Th is expressed in EL. The algorithm presented in Section 5.2.2 can handle such knowledge bases via an ABox entailment oracle. Intuitively, this is because ABoxes can encode cyclic structures, whereas concepts cannot."
    }, {
      "heading" : "5. Import-by-Query Algorithms",
      "text" : "In this section, we identify several cases in which import-by-query algorithms exist. For simplicity, throughout this section we assume that Kv does not contain Γ-modal concepts; by Theorem 3 this is without loss of generality.\nTo overcome the negative results from Section 4, in Sections 5.1.1 and 5.1.2 we introduce the HT-safety and acyclicity conditions, respectively, that Kv must satisfy in order to prevent the undesirable interactions between the axioms of Kv and Th. Furthermore, in the rest of this paper we assume that Kv is preprocessed as described by Motik et al. (2009) into the corresponding set of HT-rules Rv and ABox Av; this will be convenient because HT-rules do not contain nested quantifiers. We thus formulate HT-safety and acyclicity in terms of Rv and Av, and we define Kv as being HT-safe (resp. acyclic) if the corresponding Rv and Av are HT-safe (resp. acyclic). All our algorithms take as inputs Rv and Av, and we specify the allowed inputs using classes C[ΓC ,RCv ∪ ACv , T Ch ] of triples ΓC ,RCv ∪ACv , T Ch  where Rv is a set of HT-clauses, Av is a normalized ABox, and sig(RCv ∪ACv ) ∩ sig(T Ch ) ⊆ ΓC .\nIn Section 5.1 we present a general import-by-query algorithm based on ABox satisfiability oracles that is applicable to the case when Kv imports both atomic concepts and roles, and Kv and Th are expressed in ALCHIQ. In order for the algorithm to be applicable, however, Kv must be both HT-safe and acyclic. If Γ contains only atomic concepts, then acyclicity is vacuously satisfied for each Kv and HT-safety becomes equivalent to semantic modularity; thus, if only atomic concepts are shared, our algorithms is applicable whenever Kv is semantically modular w.r.t. Γ.\nThe algorithm from Section 5.1, however, is unlikely to be suitable for practice due to a high degree of nondeterminism. Therefore, in Section 5.2.1 we present an import-by-query algorithm based on ABox entailment oracles that, we believe, is suited for implementation and optimization. The algorithm requires Th to be a Horn knowledge base, which allows the algorithm to be more goal-oriented.\nThe practical algorithm from Section 5.2.1 can readily be applied to EL knowledge bases, but it is not guaranteed to be optimal. Therefore, in Section 5.2.2 we present an EL-specific import-by-query algorithm for the case when Kv and Th are expressed in EL. In addition to being optimal on EL knowledge bases, this EL-specific algorithm does not require Kv to be acyclic and it somewhat relaxes the HT-safety requirement.\n5.1 Import-by-Query in ALCHIQ We next present an import-by-query algorithm based on ABox satisfiability oracles that is applicable to a set of HT-rules Rv and a TBox Th in ALCHIQ. No assumptions are made on the type of symbols in Γ: Rv can reuse both atomic concepts and roles from Th."
    }, {
      "heading" : "5.1.1 HT-Safety",
      "text" : "We now define the HT-safety condition that allows us to overcome the negative results of Theorems 7 and 8, and that also guarantees semantic modularity required to overcome the negative results of Theorems 5 and 6. If Γ contains only atomic concepts, then HT-safety reduces to the semantic modularity of Rv w.r.t. Γ.\nThe notion of HT-safety forRv consists of the following building blocks. We first identity the safe concepts—that is, concepts private to Rv that should not be “propagated” into the models of Th. Next, we transform Rv into a reduct by replacing in Rv all safe concepts with ⊥, and we require the reduct to be semantically modular w.r.t. Γ. The latter property ensures that any interpretation for the symbols in Γ can be extended to an interpretation of the symbols in Rv by interpreting safe concepts as the empty set. Finally, as motivated in\nSection 4.2, we impose a syntactic restriction on each HT-rule  ∈ Rv: for each body atom R(x, y) in  with R ∈ Γ, we require variables x and y to be “guarded” by a safe concept.\nDefinition 6. Let Rv be a set of HT-rules and let Γ be a signature. The set of safe concepts of Rv and Γ is the smallest set safe(Rv,Γ) such that, for each HT-rule  ∈ Rv whose body contains an atom of the form R(x, yi) or R(yi, x) with R ∈ Γ and an atom of the form A(x) or A(yi) with A ∈ Γ, we have A ∈ safe(Rv,Γ).\nThe reduct of Rv w.r.t. Γ is the set of rules obtained from Rv by removing each rule containing a concept in safe(Rv,Γ) in the body, and then removing from the head of the remaining rules each atom containing a concept in safe(Rv,Γ).\nThe set Rv is HT-safe w.r.t. Γ if\n1. the reduct of Rv w.r.t. Γ is semantically modular w.r.t. Γ, and\n2. for each rule  ∈ Rv and each body atom of  of the form R(x, yi) or R(yi, x) with R ∈ Γ, the body of  contains atoms A(x) and B(yi) such that A, B ∈ safe(Rv,Γ).\nHT-safety invalidates the proofs of Theorems 7 and 8: the knowledge bases Kv used in the proofs of these two theorems are not HT-safe w.r.t. the respective signatures Γ. In particular, consider Kv used in the proof of Theorem 7. The set of HT-rules Rv obtained from the TBox of Kv is shown below.\nB1  ∃S.A1  B1(x) → ∃S.A1(x) (23) A2  B2  A2(x) → B2(x) (24)\n∃R.B2  B2  R(x, y) ∧B2(y) → B2(x) (25) ∃S.B2  ⊥  S(x, y) ∧B2(y) → ⊥ (26)\nNow safe(Rv,Γ) = {B2}. It is straightforward to see that the reduct of Rv w.r.t. Γ, shown below, is not semantically modular w.r.t. Γ = {A1, A2, R}.\nB1(x) → ∃S.A1(x) (27) A2(x) → ⊥ (28)\nConsider now Kv used in the proof of Theorem 8. The set of HT-rules Rv obtained from the TBox of Kv is shown below.\nB  ∀R.B  B(x) ∧R(x, y) → B(y) (29) A2 B  ⊥  A2(x) ∧B(x) → ⊥ (30)\nNow safe(Rv,Γ) = {B}, so the reduct ofRv w.r.t. Γ is empty and thus semantically modular w.r.t. Γ = {A1, A2, R}; however, the first HT-rule does not satisfy Condition 2 from Definition 6 since the rule body does not contain an atom of the form A(y) with A ∈ safe(Rv,Γ).\nNote that, if Γ contains only atomic concepts, then safe(Rv,Γ) = ∅. The reduct of Rv w.r.t. Γ is then equal to Rv, so Condition 1 from Definition 6 holds if and only if Rv is semantically modular w.r.t. Γ; furthermore, Condition 2 vacuously holds for Rv. Thus, HT-safety reduces to semantic modularity w.r.t. Γ if only atomic concepts are shared. The following proposition shows that, given an interpretation for the symbols in Γ, we can obtain a model of Rv by interpreting safe concepts as the empty set.\nProposition 3. Let Rv be a set of HT-rules that is HT-safe w.r.t. Γ. Then, for each interpretation I of the symbols in Γ, a model J of Rv exists such that J = I , XJ = XI for each symbol X ∈ Γ, and XJ = ∅ for each atomic concept X ∈ safe(Rv,Γ).\nProof. Let I be an interpretation for the symbols in Γ, and let Rv be the reduct of Rv w.r.t Γ. Since Rv is semantically modular w.r.t. Γ, a model I  of Rv exists such that I\n = I and XI = XI for each symbol X ∈ Γ. Let J be the interpretation obtained from I  by setting XJ = ∅ for each X ∈ safe(Rv,Γ). Consider now an arbitrary HT-rule  ∈ Rv. If some A ∈ safe(Rv,Γ) occurs in the body of , then AJ = ∅ clearly implies J |= . Otherwise, let  ∈ Rv be the rule obtained by removing in  all head atoms that contain a safe concept; then I  |=  clearly implies J |= . Consequently, J |= Rv.\nFinally, note that HT-safety is not a syntactic condition; in fact, checking HT-safety is undecidable in general because it requires checking semantic modularity of a set of HT-rules w.r.t. a signature. As mentioned in Section 2.3, however, several practically useful syntactic conditions are known that guarantee semantic modularity (Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008), and any such condition can be used to obtain a purely syntactic HT-safety notion."
    }, {
      "heading" : "5.1.2 Acyclicity",
      "text" : "The negative result of Theorem 9 relies on Kv containing a cyclic axiom A  ∃R.A with R ∈ Γ and A ∈ Γ. We next present a sufficient condition that can detect such cycles in polynomial time.\nOur test involves a set of function-free first-order formulae with equality D(Rv,Av) whose consequences “summarize” the models ofRv ∪ Th ∪Av; more precisely, the projection of each canonical model of Rv ∪ Th ∪Av to the symbols in sig(Rv) can be homomorphically embedded into the set of ground facts entailed by D(Rv,Av). Intuitively, since the axioms of Th are not available, the facts entailed by D(Rv,Av) should reflect all possible consequences of Th and all information that can be derived using Rv ∪Av. Theory D(Rv,Av) also keeps track of the paths in the “visible” part of the canonical models of Rv ∪ Th ∪Av by using two special binary predicates: Succ keeps track the “successorship” relation between domain elements, and Γ-Desc keeps track the “descendant” relation via roles contained in Γ. The acyclicity condition then checks whether the Γ-Desc relation as entailed by D(Rv,Av) is cyclic; if this is not the case, we can establish a bound on the length of paths of roles in Γ.\nDefinition 7. Let Rv be a set of HT-rules, let Av be an ABox, and let Γ be a signature. For each atomic concept A ∈ sig(Rv) ∪ sig(Av), let vA and v¬A be individuals uniquely associated with A and ¬A, respectively; furthermore, let Succ and Γ-Desc be binary predicates not occurring in Rv or Av. Function tt(·) maps each atom α occurring in Rv ∪Av into a conjunction of atoms as follows, where z is an arbitrary term:\n• tt(¬A(z)) = ;\n• tt(≥n R.C(z)) = ar(R, z, vC) ∧ tt(C(vC)) ∧ Succ(z, vC); and\n• tt(α) = α for each atom α of the form not covered by the above two cases.\nFurthermore, D(Rv,Av) is the set of function-free formulas of first-order logic with equality defined as follows, where all variables are implicitly universally quantified.\n• For each assertion α ∈ Av, set D(Rv,Av) contains tt(α).\n• For each individual c occurring in Av and each atomic concept A ∈ Γ, set D(Rv,Av) contains A(c).\n• For each HT-rule  ∈ Rv of the form (1) and each 1 ≤ j ≤ n, set D(Rv,Av) contains the following formula:\ntt(U1) ∧ . . . ∧ tt(Um) → tt(Vj) (31)\n• For each atomic concept A ∈ Γ, set D(Rv,Av) contains the following formula:\nSucc(z1, z2) → A(z2) (32)\n• For all atomic roles R,R ∈ Γ, set D(Rv,Av) contains the following formulae:\nR(z1, z2) → R(z1, z2) (33) R(z1, z2) → R(z2, z1) (34)\nR(z, z1) ∧R(z, z2) → z1 ≈ z2 (35) R(z1, z) ∧R(z2, z) → z1 ≈ z2 (36) R(z1, z) ∧R(z, z2) → z1 ≈ z2 (37)\n• For each atomic role R ∈ Γ, set D(Rv,Av) contains the following formulae:\nSucc(z1, z2) ∧R(z1, z2) → Γ-Desc(z1, z2) (38) Γ-Desc(z1, z2) ∧ Γ-Desc(z2, z3) → Γ-Desc(z1, z3) (39)\nSet D(Rv,Av) contains a harmful cycle if D(Rv,Av) |= Γ-Desc(vC , vC) for some vC . Furthermore, Rv ∪Av is acyclic w.r.t. Γ if D(Rv,Av) does not contain a harmful cycle.\nThe set of formulae D(Rv,Av) can be straightforwardly transformed into an equivalent datalog program with equality using the well-known equivalences of first-order logic; therefore, we often refer to D(Rv,Av) as a datalog program.\nAcyclicity allows us to express axioms δ6 and δ8 from Table 3. Intuitively, acyclicity ensures that the “visible parts” of the canonical forest models ofRv ∪ Th ∪Av do not contain infinite chains of roles from Γ; we use this property in our algorithm to define a suitable blocking condition. We explain this intuition by means of an example. Let Γ = {C, R, U} where C is a concept and R and U roles, Av = {A(a)}, and Rv contains the following HTrules; the corresponding formulae in D(Rv,Av) are shown after the “” symbol. Note that Rv is HT-safe w.r.t. Γ.\nA(x) → ∃R.B(x)  A(x) → R(x, vB) ∧B(vB) ∧ Succ(x, vB) (40) A(x) → ∃S.C(x)  A(x) → S(x, vC) ∧ C(vC) ∧ Succ(x, vC) (41)\nA(x) → ∃S.D(x)  A(x) → S(x, vD) ∧D(vD) ∧ Succ(x, vD) (42) S(x, y1) ∧ S(x, y2) → y1 ≈ y2  S(x, y1) ∧ S(x, y2) → y1 ≈ y2 (43)\nC(x) ∧D(x) → ∃S.A(x)  C(x) ∧D(x) → S(x, vA) ∧A(vA) ∧ Succ(x, vA) (44)\nConsider also the following hidden TBox expressed in ALCHIQ:\nTh = {   ≤ 1 R., R  U−, ∃U.  C } (45)\nFigure 1(a) shows a canonical model I of Rv ∪Th∪Av. Furthermore, Figure 1(c) shows the ground atoms entailed by D(Rv,Av) represented as a graph G in which solid arrows show roles R, U , and S, and dashed arrows show the special predicate Γ-Desc; for clarity, the atoms involving the special predicate Succ have not been included in this and the following figures. Note that D(Rv,Av) entails R(vA, vB) and R(a, vB); these atoms, together with rules (34) and (35), entail vA ≈ va; consequently, vA and va are represented in Figure 1(c) by the same node. Structure G “summarizes” I in the sense that I can be homomorphically embedded into G. The repetitive structure of I is represented in G as a cycle over nodes vA and vC via S; however, since S is not a shared symbol (i.e., S ∈ Γ), this does not give rise to a harmful cycle. Consequently, Rv ∪ Av is acyclic w.r.t. Γ, which guarantees that the “visible” part of a model of Rv ∪ Th ∪Av does not contain R-chains of unbounded length, regardless of the contents of Th. Accordingly, the canonical model I of Rv ∪ Th ∪Av shown in Figure 1(a) contains no such R-chains.\nNote, however, that G overestimates the canonical model I; for example, G contains an individual vA that is an instance of both A and C, which is not reflected in I. Now let us assume that Rv is Rv extended with the following HT-rule:\nA(x) ∧ C(x) → ∃R.C(x)  A(x) ∧ C(x) → R(x, vC) ∧ C(vC) ∧ Succ(x, vC) (46) The canonical model of Rv ∪ Th ∪Av is clearly the same as that of Rv ∪ Th ∪Av; however, D(Rv,Av) contains a harmful cycle, as shown in Figure 1(d). Intuitively, D(Rv,Av) provides us with a conservative overestimate of the canonical models, which can in some cases detect “cycles” that do not really exist in canonical models. This is a necessary consequence of the fact that acyclicity can be checked in polynomial time.\nDefinition 7, however, provides us with a sufficient check. For example, let Rv be Rv extended with the following HT-rules:\nA(x) → ∃R.E(x)  A(x) → R(x, vE) ∧ E(vE) ∧ Succ(x, vE) (47)\nB(x) ∧ C(x) ∧ E(x) → ∃R.A(x)  B(x) ∧ C(x) ∧ E(x) → R(x, vA) ∧A(vA) ∧ Succ(x, vA) (48)\nThe canonical model of Rv∪Th∪Av and the ground atoms entailed by D(Rv ,Av) are shown in Figures 1(b) and 1(e), respectively. The HT-rules in Rv \\Rv enforce the existence of an infinite R-chain, which is reflected as a harmful cycle (e.g., the self-loop on vA).\nAcyclicity can indeed be checked in polynomial time, as shown next.\nProposition 4. Acyclicity of Rv ∪Av w.r.t. Γ can be checked in polynomial time. Proof. Let D(Rv,Av) be as specified in Definition 7. The number of fresh individuals of the form vA and v¬A is clearly linear in the size of Rv, Av, and Γ, so the size of D(Rv,Av) is polynomial in the size of Rv, Av, and Γ.\nWe can compute the set of all positive ground atoms that follow from D(Rv,Av) in polynomial time using forward chaining. All predicates in D(Rv,Av) are of bounded arity, so the number of such atoms is polynomial in the size of D(Rv,Av). This straightforwardly implies the claim of this proposition if we show that, given a set of facts and a rule  ∈ D(Rv,Av), we can compute the set of entailed facts in polynomial time. Rules not of the form (31) contain a bounded number of variables, so the set of entailed facts can be computed in polynomial time by simply considering all possible mappings of variables to individuals. Assume now that  is of the form (31). The number of variables in  is linear in the size of Rv, so there are exponentially many mappings of variables to individuals. We can, however, determine the values for x and yi that make the body true as follows. For each variable yi, let Pi be a binary relation that initially contains all pairs of individuals occurring in D(Rv,Av); this relation will eventually contain all pairs of values for x and yi that make the body of  true. We then remove from each Pi all pairs that do not satisfy all body atoms of  that contain only variables x and yi. Next, for all Pi and Pj , we remove all pairs c, c from Pi for which no c exists such that c, c ∈ Pj . We then consider each consequent atom α of ; if α contains only variables x and yi, we infer all ground atoms obtained by replacing x with c and yi with c for each c, c ∈ Pi; if α contains only variables yi and yj , we infer all ground atoms c ≈ c such that an individual c exists where c, c ∈ Pi and c, c ∈ Pj . This can clearly be done by polynomially many steps in the number of individuals in D(Rv,Av) and the maximal number of variables in a rule in Rv."
    }, {
      "heading" : "5.1.3 An Import-by-Query Algorithm",
      "text" : "We next present our import-by-query algorithm applicable to Rv ∪Av that is HT-safe and acyclic w.r.t. Γ. The algorithm modifies the standard hypertableau algorithm as follows. First, several cut rules nondeterministically guess all “relevant” assertions involving the symbols in Γ. Second, the Ωa-rule checks whether the guesses are indeed consistent with Th. Third, a relaxed blocking condition ensures termination.\nDefinition 8. Let C[ΓC ,RCv ∪ACv , T Ch ] be the class of inputs where RCv ∪ACv is acyclic w.r.t. ΓC, RCv is HT-safe w.r.t. ΓC, and T Ch is an ALCHIQ TBox. The ALCHIQ Ωa-algorithm takes a triple Γ,Rv ∪Av, Th ∈ C and is obtained by modifying Definition 1 as follows.\nBlocking. An unnamed individual s is blocking-relevant in A if, for s the predecessor of s, we have\nLA(s, s) ∩ Γ = LA(s, s) ∩ Γ = ∅.\nThen, each individual s in an ABox A is assigned a blocking status in the same way as in Definition 1, with the difference that s is directly blocked by t if, in addition to the conditions in Definition 1, both s and t are blocking-relevant.\nDerivation Rules. The derivation rules are given in Tables 2 and 4, where A|Γ is the ABox obtained from A by removing each assertion containing an indirectly blocked individual and each assertion α such that sig(α) ⊆ Γ.\nIn Section 5.1.4 we show that some of the cut rules in Table 4 are not needed if we know that Th is expressed in a description logic between ALC and ALCHIQ. Our algorithm is indeed an import-by-query algorithm, as we show next.\nTheorem 11. The ALCHIQ Ωa-algorithm is an import-by-query algorithm based on ABox satisfiability oracles for the class of inputs C[ΓC ,RCv ∪ ACv , T Ch ] from Definition 8. The algorithm can be implemented such that it runs in N2ExpTime in N , and the total number of oracle queries and the size of each query are both at most exponential in N , where N = |Rv ∪Av|+ |Γ| for the input Rv, Av, and Γ.\nThe proof of Theorem 11 is lengthy and quite technical, so we defer it to the appendix and next discuss only the intuitions. The derivation rules from Table 2 are clearly sound.\nFurthermore, due to acyclicity, the chains of assertions involving roles from Γ are bounded in length, which enables blocking and ensures termination. We next sketch the completeness argument. In particular, for completeness we need to show that the existence of a clash-free ABox in a derivation to which no rule is applicable implies the satisfiability of the input. Let A be a clash-free ABox labeling the leaf of a derivation for Γ,Rv ∪Av, Th, and let Rh be the set of HT-rules corresponding to Th. Each model of Rv ∪A ∪ Th can be extended to a model of Rv ∪Av ∪ Th, so it suffices to show the satisfiability of Rv ∪A ∪ Th. To this end, we extend A to a clash-free ABox Afin such that no derivation rule of the standard hypertableau algorithm is applicable to Rv ∪Rh and Afin; thus, Rv ∪Afin ∪ Th is satisfiable, and since A ⊆ Afin so is Rv ∪A ∪ Th by monotonicity. The construction of Afin proceeds as follows:\n1. We split the projection A|Γ of A to Γ. In particular, we define Anm as the ABox containing all assertions of A|Γ involving individuals reachable from a named individual; furthermore, for each nonblocked blocking-relevant individual t, we define At as the ABox containing all assertions of A|Γ involving individuals reachable from t.\n2. We apply the standard hypertableau algorithm to Rh and each of the connected components of Anm, and Rh and each At; let Anmfin and Atfin be clash-free ABoxes labeling leaves of the respective derivations. The Ωa-rule is not applicable to A so such ABoxes exist.\n3. We define Afin as the union of A, Anmfin , all Atfin, and all assertions C(s) such that s is blocked in A by the blocker s, C(s) ∈ As￿fin, and sig(C) ⊆ sig(Rh).\nLet us call the individuals from A old, and the individuals introduced in the second step new ; we then observe the following. (1) Due to the cut rules, the second step above cannot derive fresh assertions involving only old individuals and the symbols in Γ without leading to a contradiction. (2) Each of the connected components of Anm and each At are disjoint, so the HT-rules from Rh can be applied in Afin only to subsets that correspond to a connected component of Anm and At. (3) Due to (1), no HT-rule from Rv can become applicable to assertions involving only old individuals. (4) Due to HT-safety, no HT-rule from Rv can become applicable to an assertion of Afin that involves a new individual. (5) Due to (1) and the third step from the construction above, if an individual s is blocked in A, Anmfin , or Atfin, then s is blocked in Afin as well. Then, (1)–(5) imply that no derivation rule of the standard hypertableau algorithm is applicable to Rv ∪Rh and Afin, which proves completeness.\nWe explain this intuition on an example where Γ = {C, R}, Av = {A(a)}, Rv consists of HT-rules (40)–(44), and Th is defined as follows:\nTh = { ∃R.  C, C  ∃T.C, C  E } (49)\nAs shown in Section 5.1.2, Rv ∪ Av is acyclic w.r.t. Γ, so the ALCHIQ Ωa-algorithm is applicable. The algorithm produces a derivation in which a leaf is labeled with the ABox A shown in Figure 2(a); for readability, we show neither the negative assertions nor the assertions involving complex concepts. Individual f is directly blocked by c in A, and assertions C(a) and C(d) are introduced by the A-cut rule. To construct Afin, the assertions containing a symbol not in Γ are removed, resulting in the ABox A|Γ shown in\nFigure 2(b). This ABox is then split into connected components Anm, Ac, and Ad; note that c and d are the only nonblocked blocking-relevant individuals. Next, Anm, Ac, and Ad are completed w.r.t. Rh using the standard hypertableau algorithm; Figure 2(c) shows the resulting ABoxes Anmfin , Acfin, and Adfin. Note that C(a) and C(d) in A are consistent with the axiom ∃R.  C from Th. Finally, Afin is obtained by taking the union of A, Anmfin , Acfin, and Adfin, and adding E(f); the latter is because f is blocked by c and E(c) ∈ Acfin. The result is shown in Figure 2(d); clearly, no derivation rule of the standard hypertableau algorithm is applicable to Afin.\n5.1.4 Hidden Ontology in DLs Between ALC and ALCHIQ The main limitation of the acyclicity condition from Definition 7 stems from the fact that we must anticipate all possible consequences of Th. Both the acyclicity conditions and the derivation rules from Table 4 can be simplified if the hidden ontology is known to be expressed in a description logic between ALC and ALCHIQ.\n• If Th is known not to use cardinality restrictions, then we can omit rules (35)–(37) in the definition of D(Rv,Av), and the ≈-cut rule in Table 4 is not required.\n• If Th is known not to use inverse roles, then we can omit rules (34), (36), and (37) in the definition of D(Rv,Av), the R−-cut rule is not required, and Conditions 3.2 and 3.3 can be removed from the ≈-cut rule.\n• If Th is known not to use role hierarchies, then we can omit rules (33) and (34) in the definition of D(Rv,Av), the R-cut in Table 4 is not required, and the R−-cut rule need only be applied if R and R are the same.\nThese simplifications allow our approach to be applied to a wider range of visible ontologies. For example, consider the set Rv consisting of HT-rules (40)–(44) and (47)–(48), for which we obtained a harmful cycle w.r.t. Γ = {C, R, U}, as shown in Figure 1(e). If Th is known to be expressed in ALCHI (and so does not use cardinality restrictions), we\ncan omit formulas of the form (35)–(37) in the definition of D(Rv,Av); the ground atoms entailed by such D(Rv,Av) are shown in Figure 3. This change makes Rv ∪Av acyclic w.r.t. Γ: we can now be sure that, for an arbitrary hidden TBox expressed in ALCHI, no infinite R-chains need to be considered during reasoning with Rv."
    }, {
      "heading" : "5.2 Practical Import-by-Query Algorithms",
      "text" : "The algorithm presented in Section 5.1.3 is not suited for practical implementation because the derivation rules in Table 4 incur a huge amount of nondeterminism. In this section, we present practical import-by-query algorithms in which nondeterministic rules are replaced with “on demand” oracle calls, which makes the algorithms “more goal-oriented.” Our algorithms make no assumptions about the kinds of symbols contained in Γ: both atomic concepts and roles can be shared."
    }, {
      "heading" : "5.2.1 Importing Horn Ontologies",
      "text" : "In this section, we present a practical algorithm that applies when Th is expressed in the Horn-ALCHIQ fragment of ALCHIQ. It is well known that Th can then be transformed into a set of Horn HT-rules. This allows us to eliminate the nondeterministic cut rules, use an ABox entailment oracle instead of an ABox satisfiability oracle, and define oracle query rules that deterministically “complete” the query ABox A with the missing assertions entailed by Th∪A. Such an algorithm issues oracle queries on demand, so it is goal oriented and thus more amenable to implementation.\nDefinition 9. Let C[ΓC ,RCv ∪ACv , T Ch ] be the class of inputs where RCv ∪ACv is acyclic w.r.t. ΓC, RCv is HT-safe w.r.t. ΓC, and T Ch is a Horn-ALCHIQ TBox. The Horn-ALCHIQ Ωealgorithm takes a triple Γ,Rv ∪Av, Th ∈ C and is obtained from Definition 8 by replacing the derivation rules from Table 4 with those in Table 5.\nOur algorithm is indeed an import-by-query algorithm with the same worst-case complexity as the algorithm for the non-Horn case.\nTheorem 12. The Horn-ALCHIQ Ωe-algorithm is an import-by-query algorithm based on ABox entailment oracles for the class of inputs C[ΓC ,RCv ∪ACv , T Ch ] from Definition 9. The algorithm can be implemented such that it runs in N2ExpTime in N , and the total number of oracle queries and the size of each query are both also at most exponential in N , where N = |Rv ∪Av|+ |Γ| for the input Rv, Av, and Γ.\nThe proof of Theorem 12 is obtained by a modification of the one for Theorem 11 and is given in the appendix."
    }, {
      "heading" : "5.2.2 Import-by-Query in EL",
      "text" : "In this section, we present an import-by-query algorithm based on ABox entailment oracles that can handle the case when both Kv and Th are expressed in EL. In this setting, only Theorems 5 and 7 provide clues about features that hinder existence of an import-by-query algorithm. In particular, it is no longer necessary for Kv to be acyclic.\nOur algorithm is again based on the hypertableau framework, so Kv is first converted into a set Rv of EL-rules and a normalized ABox Av. Since EL does not allow for inverse roles\nor universal quantification, there is no danger of information propagating from a successor to a predecessor; therefore, we can relax the HT-safety condition as shown in Definition 10.\nDefinition 10. Let Rv be a set of EL-rules, and let Γ be a signature Then, Rv is EL-safe w.r.t. Γ if\n• it satisfies Condition 1 from Definition 6, and\n• for each rule  ∈ Rv and each body atom of  of the form R(x, yi) with R ∈ Γ, the body of  contains an atom B(yi) such that B ∈ safe(Rv,Γ).\nOur algorithm takes a set Rv of EL-safe rules and a normalized ABox Av. It applies the standard EL hypertableau derivation rules; furthermore, just like the Horn-ALCHIQ Ωe-algorithm from Section 5.2.1, it uses the oracle to complete the ABoxes encountered in a derivation with the relevant concept assertions.\nDefinition 11. Let C[ΓC ,RCv ∪ACv , T Ch ] be the class of inputs where RCv is a set of EL-rules that is EL-safe w.r.t. ΓC, ACv is a normalized ABox, and T Ch is an EL TBox. The EL Ωe-algorithm takes a triple Γ,Rv ∪Av, Th ∈ C and is obtained by extending the algorithm from Definition 2 with the Ωe-concept derivation rule shown in Table 5.\nOur algorithm is indeed an import-by-query algorithm, and it can be implemented to run in polynomial time, as shown by the following theorem. In contrast to algorithms we have presented thus far, the EL Ωe-algorithm is both optimal and amenable to implementation.\nTheorem 13. The EL Ωe-algorithm is an import-by-query algorithm based on ABox entailment oracles for the class of inputs C[ΓC ,RCv ∪ACv , T Ch ] from Definition 11. The algorithm can be implemented such that it runs in PTime in N with a polynomial number in N of calls to ΩeTh,Γ, where N = |Rv ∪Av|+ |Γ| for the input Rv, Av, and Γ.\nThe proof of Theorem 13 is rather technical and lengthy, and it is given in the appendix. The intuition behind the proof, however, is the same as in the case of the ALCHIQ Ωaalgorithm, and the differences are due to the fact that the ABoxes produced by the EL Ωe-algorithm have a specific shape."
    }, {
      "heading" : "6. A Lower Bound on the Complexity of Import-by-Query Reasoning",
      "text" : "In this section we show that no import-by-query algorithm that handles the same input as our ALCHIQ Ωa-algorithm can make only a polynomial number (in |Γ|) of queries each of which is of polynomial size (in |Γ|). This result applies already if Γ contains only atomic concepts, so the only requirement for the ALCHIQ Ωa-algorithm to be applicable is that the TBox of Kv is semantically modular w.r.t. Γ.\nTheorem 14. Let C[ΓC ,KCv , T Ch ] be the class of inputs where ΓC contains only atomic concepts, KCv is an ALCHIQ knowledge base that is semantically modular in ΓC, and T Ch is an ALCHIQ TBox. Then, no import-by-query algorithm ibqa based on ABox satisfiability oracles for L = ALCHIQ and C exists such that, for each input Γ,Kv, Th ∈ C, the total number of oracle queries in all possible runs of ibqa[Th,Γ,L] on Kv, as well as the size of each query, are both polynomial in |Γ|.\nProof. Assume that ibqa is an algorithm that satisfies the theorem’s assumptions; then, integers c1 and c2 exist such that, for each input Γ,Kv, Th ∈ C, the total number of oracle queries in all possible runs of ibqa[Th,Γ,L] on Kv is smaller than or equal to |Γ|c1 , and the maximal size of each query ABox is smaller than or equal to |Γ|c2 .\nWe next construct a particular input in C for which we show that ibqa violates the above assumption. Let k be an arbitrary integer such that kc1+c2 < 2k; such k exists since c1 and c2 are fixed. Let Γ = {A1, . . . , Ak} be arbitrary atomic concepts, and let Z, B, C1, . . ., Ck, C1, . . ., Ck be atomic concepts not occurring in Γ. Then, we define Kv = Tv ∪Av such that Av = {Z(a)} and Tv contains the following axioms:\nB  ∃R.B (50) Z  B  C1  . . .  Ck (51)\nCj  Cj  ⊥ 1 ≤ j ≤ k (52)   (¬C1  ∀R.C1)  (¬C1  ∀R.C1) (53)\nCj−1  ∃R.Cj−1  (¬Cj  ∀R.Cj)  (¬Cj  ∀R.Cj) 1 < j ≤ k (54) Cj−1  (Cj−1  ∃R.Cj−1)  (¬Cj  ∀R.Cj)  (¬Cj  ∀R.Cj) 1 < j ≤ k (55)\nCi  Ai 1 ≤ i ≤ k (56)\nCi  ¬Ai 1 ≤ i ≤ k (57)\nTBox Tv uses the well-known “integer counting” technique (Tobies, 2000). Consider an arbitrary model I of Kv. Domain elements of I can be assigned integers between 0 and 2k − 1 by means of 2k atomic concepts C1, . . ., Ck, C1, . . ., Ck. Axiom (51) implies that aI ∈ (Ck  . . .  C1)I , which “initializes the counter” to 0. Axiom (50) ensures that aI is an origin of an infinite R-chain. Axioms (52) ensure that no domain element in this chain is labeled with both Cj and Cj . Axioms (53), (54), and (55) increment the counter over R. Finally, these axioms together with axioms (56) and (57) ensure that each possible number between 0 and 2k − 1 is assigned to some domain element of I in the R-chain. Clearly, Tv is semantically modular w.r.t. Γ since we can extend each interpretation of the symbols of Γ to a model of Tv by interpreting the symbols not in Γ with the empty set.\nLet T 1 h = ∅, let A1, . . . ,Am be the query ABoxes occurring in all possible runs of ibqa[T 1\nh ,Γ,L] on Kv, and let n be the maximal size of Ai for 1 ≤ i ≤ m. By our assumptions,\nwe have m ≤ kc1 and n ≤ kc2 , which implies m× n = kc1+c2 < 2k due to the way we chose k. For each 1 ≤ i ≤ m, let A\ni be the following ABox equivalent to Ai:\n• If Ai is unsatisfiable, then Ai = {⊥}.\n• If Ai is satisfiable, let Ai be an ABox that contains for each individual s exactly one concept assertion of the form D(s) where D is in disjunctive normal form; that is, D is expressed as a disjunction of concepts of the form (¬)A1  . . .  (¬)Ak. Such Ai can be obtained from Ai by applying de Morgan’s laws.\nLet D1, . . . ,D be all disjunctive concepts that occur in some satisfiable ABox Ai. Each Ai contains at most n such concepts, so 1 ≤  ≤ m× n. Furthermore, let U be the subset of {D1, . . . ,D} containing precisely those Di that have exactly one disjunct. Finally, let S be a concept of the form (¬)A1  . . .  (¬)Ak that does not occur in U ; such S exists because  ≤ m× n < 2k. Now let T 2\nh be the following TBox:\nT 2h = {S  ⊥} (58)\nWe next show that, for each 1 ≤ j ≤ , concept Dj is satisfiable w.r.t. T 2h . The claim is trivial if Dj does not contain S; otherwise, Dj contains a disjunct S = S, so an interpretation satisfying T 2\nh and Dj can be obtained by interpreting S as a nonempty set.\nWe next show that ΩaT 1h ,Γ,L (A i ) = ΩaT 2h ,Γ,L (A i ) for each 1 ≤ i ≤ m; since Ai and Ai are\nequivalent, then ΩaT 1h ,Γ,L (Ai) = ΩaT 2h ,Γ,L(Ai) as well. The statement clearly holds if A  i is unsatisfiable, so assume that A\ni is satisfiable. Since A i consists of assertions of the form\nD(s) where D is satisfiable w.r.t. T 2 h , an interpretation satisfying A i ∪ T 2 h can be obtained as a disjoint union of the interpretations satisfying each D. By Proposition 1, the runs of ibqa[T 1\nh ,Γ,L] on Kv then coincide with the runs of\nibqa[T 2 h ,Γ,L] on Kv; however, it is straightforward to see that Kv∪T 1h is satisfiable, whereas Kv ∪ T 2h is unsatisfiable, which is a contradiction."
    }, {
      "heading" : "7. Related Work",
      "text" : "There is currently a growing interest in techniques for hiding parts of an ontology Th. One possible approach is to hide a subsetΥ of the signature of Th by first extracting from Th anΥ-\nmodule MΥ—a subset of Th that preserves all Υ-consequences (i.e., all logical consequences formed using only the symbols in Υ)—and then publishing the ontology Th \\MΥ. In order to ensure that no sensitive information about Υ is being disclosed, the module MΥ should be depleting (Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009)—that is, ontology Th \\MΥ should be indistinguishable from the empty ontology w.r.t. Υ-consequences. This approach ensures that no Υ-consequences are disclosed to external applications and offers the additional advantage that one can reason over the union of Kv and Th \\MΥ using off-the-shelf DL reasoners. Finally, although determining whether a subset of an ontology is a depleting module for a signature is an undecidable problem for many DLs (and hence extraction of minimal depleting modules is often computationally infeasible), several practical techniques for extracting (not necessarily minimal) depleting modules are known (Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008).\nAn important disadvantage of this approach is that the module MΥ may also contain relevant information that is not sensitive (e.g., MΥ may entail consequences about symbols Γ not in Υ) and hence the union of Kv (which may use symbols from Γ) and Th \\MΥ may not contain enough information to answer relevant queries. Furthermore, by adopting this approach, the vendor of Th would distribute a subset of the axioms of Th, which may allow competitors to plagiarize parts of Th. Finally, the published axioms might mention symbols in Υ (even if they do not entail any Υ-consequence) and external applications would be aware of the presence of those symbols in the ontology.\nSome of these drawbacks can be overcome by publishing an Υ-interpolant of Th—an ontology that contains no symbols from Υ and that coincides with Th on all logical consequences formed using the symbols not in Υ (Konev et al., 2009; Wang et al., 2009, 2008; Lutz & Wolter, 2011; Nikitina, 2011). In contrast to the module extraction approach, publishing an interpolant ensures that the sensitive information in Th (i.e., the information about the symbols from Th not mentioned in the interpolant) is not exposed in any way to external applications; furthermore, interpolants preserve all consequences of symbols not in Υ. Similarly to the module extraction approach, using interpolation has the additional advantage that the developers of Kv can reason over the union of Kv and the interpolant using off-the-shelf DL reasoners.\nThe interpolation approach may, however, have several drawbacks. First, an interpolant may exist only if Th is expressed in a relatively weak DL and satisfies certain syntactic conditions (Konev et al., 2009). In contrast, import-by-query is often possible even if an interpolant of Th for the signature of interest does not exist.\nSecond, although interpolants preserve logical consequences formed using symbols not in Υ, they are not robust under replacement (Sattler et al., 2009)—that is, the union of Kv and an Υ-interpolant of Th is not guaranteed to yield the same consequences as Th ∪Kv for a query q involving no symbols from Υ. For example, given Υ = {R} and Th = {A  ∃R.B}, the empty ontology is anΥ-interpolant (it preserves all consequences of the form C  D with C and D arbitrary boolean concepts over the signature {A, B}); however, for Kv = {B  ⊥} we have that Kv ∪ Th entails the consequence A  ⊥, whereas the union of Kv and the (empty) interpolant does not. Thus, once an interpolant has been published, it cannot be imported into Kv with the guarantee that all relevant consequences will be preserved, unless suitable restrictions are imposed to Kv.\nFinally, an Υ-interpolant of Th can be exponentially larger than Th, and may reveal more information than what is strictly needed. Although import-by-query algorithms can also formulate in the worst-case exponentially many queries to the oracle, our algorithms may limit the flow of irrelevant information from Th to Kv, especially if Th is expressed in a Horn DL, in which case our import-by-query algorithms issue queries “on demand.” For example, for Γ = {R,C}, Υ = ∅, Kv = {A  ∃R.B,B  C} and Th = {∃R.∃R.C  C}, the Υ-interpolant is equal to Th and thus publishing the interpolant reveals entire contents of Th. In contrast, our import-by-query algorithm for EL would not reveal any positive information about Th, as it would only disclose the fact that an ABox of the form {R(a, b), C(b)} is satisfiable w.r.t. Th.\nThe idea of accessing an ontology through an oracle is similar in spirit to the proposal by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2004) for query answering in a peerto-peer setting. The authors consider the problem of answering a conjunctive query q over KBs Kv and Kh and mappings M by reformulating q as queries that can be evaluated over Kv and Kh in isolation. The query reformulation algorithm accesses only Kv and M , so q can be answered using an oracle for Kh. In this setting, however, the focus is on the reuse of data, rather than schema. Since a satisfiable Kh cannot affect the subsumption of concepts in Kv, the results by Calvanese et al. (2004) are not applicable to schema reasoning."
    }, {
      "heading" : "8. Conclusion",
      "text" : "In this paper, we have proposed and studied the import-by-query framework. Our results provide a flexible way for ontology designers to ensure selective access to their ontologies. Our framework thus provides key theoretical insights into the issues surrounding ontology privacy. Furthermore, we believe our algorithms to be practicable when applied to Horn ontologies; thus, our results provide a starting point for the development of practical importby-query systems.\nThe problem of import-by-query is novel, and we see many open questions. For example, a problem that is relevant to both theory and practice is to allow the hidden ontology to selectively export data and not just schema statements."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This is an extended version of the paper “Import-by-Query: Ontology Reasoning under Access Limitations” by Bernardo Cuenca Grau, Boris Motik, and Yevgeny Kazakov published at IJCAI 2009 and the paper “Pushing the Limits of Reasoning over Ontologies with Hidden Content” by Bernardo Cuenca Grau and Boris Motik published at KR 2010.\nThis research has been supported by the Royal Society and the EPSRC projects ExODA (EP/H051511/1) and HermiT (EP/F065841/1)."
    }, {
      "heading" : "Appendix A. Proof of Theorem 11",
      "text" : "We will use the following definitions and intermediate results to prove the theorem.\nDefinition 12. An ABox A is an HT-ABox if all of its assertions satisfy the following conditions, for B an atomic or a negated atomic concept, S a role, R an atomic role, a and b named individuals, s an individual, and i and j integers.\n1. Each concept assertion in A is of the form B(s) or ≥n S.B(s).\n2. Each role assertion in A is of the form R(a, b), R(s, s.i), or R(s.i, s).\n3. If an individual s.i occurs in an assertion in A, then A contains a role assertion of the form R(s, s.i) or R(s.i, s).\n4. Each equality in A is of the form s.i ≈ s.j, s.i.j ≈ s, s ≈ s, or a ≈ b.i. Furthermore, an extended HT-ABox A is additionally allowed to contain assertions of the form R(s, s) and s.i ≈ s. Lemma 1. Let R be a set of HT-rules and let A be an ABox. Then, each ABox labeling a node of a derivation for R and A is an HT-ABox. Proof. The proof is a straightforward modification of the proof of Lemma 4 by Motik et al. (2009), which are due the following observations: since HT-rules do not allow for atoms of the form R(x, x) in the head, one cannot derive atoms of the form R(s, s); this, in turn, guarantees that one cannot derive equalities of the form s.i ≈ s.\nLemma 2. (Motik et al., 2009, Lemma 6) Let R be a set of HT-rules and let A be a clashfree extended HT-ABox not containing indirectly blocked individuals. If no derivation rule is applicable to R and A, then R ∪A is satisfiable. Definition 13. The weakened pairwise anywhere blocking, abbreviated w-blocking, is the same as in Definition 1, with the difference that the following condition is used instead of LA(s) = LA(t):\nFor each HT-rule  ∈ R containing a body atom of the form R(x, y) or R(y, x) with R an atomic role such that R ∈ LA(s, s) ∪ LA(s, s), and for each atomic concept A occurring in , we have A ∈ LA(s) if and only if A ∈ LA(t).\nLemma 3. Lemma 2 holds even if the derivation for R and A uses w-blocking. Proof (Sketch). Let A be an ABox labeling a leaf of a derivation for R and A; let s be an individual that is blocked in A by t by w-blocking; and let s and t be the parents of s and t. For the proof by Motik et al. (2009, Lemma 6) to hold, we must show that no HT-rule is applicable to an interpretation obtained by unraveling A. Let  ∈ R be an arbitrary HT-rule. If  does not contain in the body a role atom with a role R ∈ LA(s, s) ∪ LA(s, s), then the Hyp-rule cannot be applied to  with mapping σ(x) = s. Furthermore, if  does not contain an atomic concept A, then the fact that A ∈ LA(s) but A ∈ LA(t) or vice versa cannot affect the applicability of . Thus, by a straightforward modification of the proof by Motik et al. (2009, Lemma 6), we can construct a model for A and R by unraveling A.\nIt is straightforward to see that the derivation rules in Table 4 do not invalidate Lemma 1—that is, given an HT-ABox, they always produce an HT-ABox.\nA.1 Termination\nWe first show that the logical consequences of the datalog program D(Rv,Av) from Definition 7 “overestimate” the ABoxes produced by the hypertableau algorithm; that is, we show that each ABox ρ(t) labeling a derivation node can be homomorphically embedded into the set of ground facts entailed by D(Rv,Av).\nIf s = s.i and either R(s, s) ∈ ρ(t) or R(s, s) ∈ ρ(t) with R ∈ Γ, we say that s is a Γ-successor of s.\nLemma 4. Let Rv be a set of HT-rules, let Av be an ABox, let Γ be a signature, let D(Rv,Av) be as given in Definition 7, let Th be an ALCHIQ TBox, and let (T, ρ) be a derivation for Γ,Rv ∪Av, Th. Then, for each derivation node t ∈ T , a mapping µ from the individuals in ρ(t) to the individuals in D(Rv,Av) exists satisfying all of the following properties for all individuals s and s occurring in ρ(t):\n1. A(s) ∈ ρ(t) with A an atomic concept implies D(Rv,Av) |= A(µ(s)).\n2. R(s, s) ∈ ρ(t) implies D(Rv,Av) |= R(µ(s), µ(s)).\n3. If s is a successor of s in ρ(t), then D(Rv,Av) |= Succ(µ(s), µ(s)).\n4. If s is a Γ-successor of s in ρ(t), then D(Rv,Av) |= Γ-Desc(µ(s), µ(s)).\n5. If ≥n R.C(s) ∈ ρ(t) with R a possibly inverse role, then the following conditions hold:\n(a) if C is an atomic concept, then D(Rv,Av) |= C(vC); (b) D(Rv,Av) |= ar(R,µ(s), vC); (c) D(Rv,Av) |= Succ(µ(s), vC); and (d) if R ∈ Γ, then D(Rv,Av) |= Γ-Desc(µ(s), vC).\n6. If s ≈ s ∈ ρ(t), then D(Rv,Av) |= µ(s) ≈ µ(s).\n7. If s is an unnamed individual in ρ(t), an atomic concept A ∈ sig(Rv) ∪ sig(Av) exists such that µ(s) = vA or µ(s) = v¬A.\nProof. We prove the lemma by induction on the structure of the derivation. For  ∈ T the root node of the derivation, let µ map each individual in Av to itself. ABox ρ() = Av trivially satisfies Properties 3, 4, and 7 since Av contains only named individuals. Properties 5 and 6 also hold trivially because ρ() is a normalized ABox and hence it does not contain assertions of the form ≥n R.C(s) or of the form s ≈ s. Finally, Properties 1 and 2 hold because ρ() ⊆ D(Rv,Av).\nFor the induction step, assume that, for some derivation node t ∈ T , ABox ρ(t) satisfies the claim for some mapping µ. For each child node t of t in T , we consider the possible ways ρ(t) can be derived from ρ(t).\n• Ωa-rule: All properties hold trivially for ρ(t) and µ.\n• A-cut: All properties hold trivially for ρ(t) and µ except for Property 1 in case ρ(t) = ρ(t) ∪ {A(s)} with A ∈ Γ. If s is a named individual in ρ(t), then s occurs in Av and Property 1 holds because D(Rv,Av) contains the assertion A(s) for each A ∈ Γ and each s occurring in Av. If s is unnamed, then s is the successor of some individual s in ρ(t); by the induction hypothesis (Property 3) we have D(Rv,Av) |= Succ(µ(s), µ(s)); however, D(Rv,Av) contains the formula (32) for each A ∈ Γ, so we have D(Rv,Av) |= A(µ(s)), as required.\n• R-cut: All properties hold trivially for ρ(t) and µ except for Property 2 in case ρ(t) = ρ(t) ∪ {R(s, s)} with R ∈ Γ. By Condition 2 of R-cut we have R(s, s) ∈ ρ(t) for some atomic role R ∈ Γ, so we have D(Rv,Av) |= R(µ(s), µ(s)) by the induction assumption. Since R,R ∈ Γ and D(Rv,Av) contains formulae (33) for all roles in Γ, we have D(Rv,Av) |= R(µ(s), µ(s)), so ρ(t) satisfies Property 2 for µ.\n• R−-cut: All properties hold trivially for ρ(t) and µ except for Property 2 in case ρ(t) = ρ(t) ∪ {R(s, s)} with R ∈ Γ. By Condition 2 of R−-cut we have R(s, s) ∈ ρ(t) for some atomic role R ∈ Γ, so we have D(Rv,Av) |= R(µ(s), µ(s)) by the induction assumption. Since R,R ∈ Γ and D(Rv,Av) contains formulae (34) for all roles in Γ, we have D(Rv,Av) |= R(µ(s), µ(s)), so ρ(t) satisfies Property 2 for µ.\n• ⊥-rule: All properties hold trivially for ρ(t) and µ.\n• ≥-rule: Assume that ρ(t) is defined as follows, where ≥n R.C(s) ∈ ρ(t), si are fresh successors of s, and C is a possibly negated atomic concept:\nρ(t) = ρ(t) ∪ { ar(R, s, si), C(si) | 1 ≤ i ≤ n } ∪ { si ≈ sj | 1 ≤ i < j ≤ n }\nLet µ = µ ∪ {si → vC | 1 ≤ i ≤ n}. Properties 5 and 6 hold trivially for ρ(t) and µ, and it is obvious that Property 7 holds as well. Hence, we focus on showing Properties 1—4. For Property 1, assume that C is an atomic concept; since Property 5(a) holds for ρ(t) and µ by the induction assumption, we have D(Rv,Av) |= C(vC), as required. For Property 2, since Property 5(b) holds for ρ(t) and µ by the induction assumption, we have D(Rv,Av) |= ar(R,µ(s), vC), as required. For Property 3, since Property 5(c) holds for ρ(t) and µ by the induction assumption, we have D(Rv,Av) |= Succ(µ(s), vC), so Property 3 holds for ρ(t) and µ. For Property 4, assume that R ∈ Γ; Property 5(d) holds for ρ(t) and µ by the induction assumption, we have D(Rv,Av) |= Γ-Desc(µ(s), vC), so Property 4 holds for ρ(t) and µ.\n• Hyp-rule: Assume that ρ(t) = ρ(t) ∪ {α} for α the head atom of an HT-rule  of the form (2). Properties 3, 4, and 7 hold trivially for ρ(t) and µ, so we focus on the remaining properties. By Condition 2 of the Hyp-rule, ρ(t) contains individuals s, s1, . . . , sn such that the statements from the left column from the following table holds. But then, by the induction assumption, the statements from the right column hold as well.\nAi(s) ∈ ρ(t) ⇒ D(Rv,Av) |= Ai(µ(s)) Rij(s, si) ∈ ρ(t) ⇒ D(Rv,Av) |= Rij(µ(s), µ(si)) Sij(si, s) ∈ ρ(t) ⇒ D(Rv,Av) |= Sij(µ(si), µ(s))\nBij(si) ∈ ρ(t) ⇒ D(Rv,Av) |= Bij(µ(si))\nFor the HT-rule , the datalog program contains the rule (31). Thus, the statements from the following table then hold as well:\nD(Rv,Av) |= tt(Ci(µ(s))) D(Rv,Av) |= Rij(µ(s), µ(si)) D(Rv,Av) |= Sij(µ(si), µ(s)) D(Rv,Av) |= Dij(µ(si)) D(Rv,Av) |= µ(si) ≈ µ(sj)\nConsequently, Properties 2 and 6 clearly hold; Property 1 also holds since for an atomic concept atom α we have tt(α) = α. To show Property 5, assume that Ci(µ(s)) is of the form ≥n R.C(µ(s)), so\ntt(Ci(µ(s))) = ar(R,µ(s), vC) ∧ tt(C(vC)) ∧ Succ(µ(s), vC).\nThen, the following holds:\nD(Rv,Av) |= ar(R,µ(s), vC) D(Rv,Av) |= tt(C(vC)) D(Rv,Av) |= Succ(µ(s), vC)\nThus, Properties (5a), (5b), and (5c) hold. Finally, if R ∈ Γ, then Property (5d) holds because the datalog program entails assertion Succ(µ(s), vC), and it contains formulae (38) and (34) for all roles in Γ.\n• ≈-cut rule: Assume that ρ(t) = ρ(t) ∪ {α} with α an assertion of the form s1 ≈ s2 or s1 ≈ s2. Then, ρ(t) trivially satisfies Properties 1–5 and 7 for µ. Property 6 also holds trivially if α is of the form s1 ≈ s2, so assume that α of the form s1 ≈ s2. By the preconditions of the ≈-cut rule, an individual s in ρ(t) and atomic roles R,R ∈ Γ exist such that\n{ R(s, s1), R(s, s2) } ⊆ ρ(t) or { R(s1, s), R(s2, s) } ⊆ ρ(t) or { R(s1, s), R(s, s2) } ⊆ ρ(t).\nBy the induction hypothesis (Property 2), then\nD(Rv,Av) |= { R(µ(s), µ(s1)), R(µ(s), µ(s2)) } or D(Rv,Av) |= { R(µ(s1), µ(s)), R(µ(s2), µ(s)) } or D(Rv,Av) |= { R(µ(s1), µ(s)), R(µ(s), µ(s2)) }.\nBut then, since the datalog program contains formulas (35)–(37) for all roles in Γ, we have D(Rv,Av) |= µ(s1) ≈ µ(s2), as required.\n• ≈-rule: Assume that ρ(t) = mergeρ(t)(s → s). Then, by Conditions 1 and 2 of the ≈-rule, s ≈ s ∈ ρ(t) with s = s. Furthermore, by the induction assumption, we have D(Rv,Av) |= µ(s) ≈ µ(s). Since merging merely replaces s with s, by the semantics of equality ρ(t) satisfies all the required properties.\nWe next use Lemma 4 to prove that the length of chains of role assertions involving a role in Γ is bounded.\nLemma 5. Let Rv, Av, Γ, D(Rv,Av), and (T, ρ) be as in Lemma 4 with the additional restriction that Rv ∪Av is acyclic w.r.t. Γ. Let N be the number of individuals of the form vC occurring in D(Rv,Av), let t ∈ T be an arbitrary derivation node of (T, ρ), and let s1, . . . , s be unnamed individuals occurring in ρ(t) such that si+1 is a Γ-successor of si for each 1 ≤ i < . Then,  ≤ N .\nProof. Assume that, for some integer  > N , unnamed individuals s1, . . . , s satisfying the conditions of this lemma exist, and let µ be a mapping satisfying Lemma 4. By Property 7 in Lemma 4, for each 1 ≤ i ≤  we have µ(si) = vCi for some Ci (because each si is unnamed). Furthermore, by Property 4 in Lemma 4, we also have D(Rv,Av) |= Γ-Desc(µ(si), µ(si+1)) for each 1 ≤ i < . But then, since  > N and predicate Γ-Desc(x, y) is axiomatized as transitive by formula (39) in D(Rv,Av), we clearly obtain a harmful cycle, which is a contradiction.\nWe are now ready to prove our main claim.\nLemma 6 (Termination). Let Rv, Av, Γ, D(Rv,Av), N , and (T, ρ) be as in Lemma 5. Then, (T, ρ) is finite.\nProof. Let the depth of an individual s be the number of its ancestors, and let c and r be the numbers of atomic concepts and roles, respectively, occurring in Rv and Av; finally, let ℘ = (22cr + 1)(N + 1) + 1. Consider now an arbitrary derivation node t ∈ T . Let s be an individual in ρ(t) of depth i(N + 1) + 1. By a simple induction on i, one can show that s has at least i ancestors that are blocking-relevant. The induction base is straightforward for i = 0; furthermore, the induction step holds because, by Lemma 5 and the fact that ρ(t) is an HT-ABox, the depth of the nearest blocking-relevant ancestor of s can be at most N + 1 less than the depth of s. Thus, each individual s of depth ℘ has at least 22cr + 1 blocking-relevant ancestors; since there are at most 22cr possible concept and role labelings for an individual and its predecessor, one of the blocking ancestors of s is blocked due to the definition of blocking; hence, s is either directly or indirectly blocked in ρ(t). The rest of the proof of our claim is then analogous to the proof of Lemma 7 by Motik et al. (2009).\nA.2 Soundness\nLemma 7 (Soundness). Let Rv be a set of HT-rules, let Th be an ALCHIQ TBox, let A be an ABox such that Rv ∪ Th ∪A is satisfiable, and let A1, . . . ,An be the ABoxes obtained by applying a derivation rule from Table 2 or 4 to Rv and A. Then, Rv ∪ Th ∪Ai is satisfiable for some 1 ≤ i ≤ n.\nProof. Let I be a model of Rv ∪ Th ∪A, and let us consider the possible derivation rules that derive A1, . . . ,An. The cases for the Hyp-, ≥-, ≈-, and ⊥-rule are the same as in the proof by Motik et al. (2009, Lemma 5). Furthermore, by the law of excluded middle of first-order logic, the claim is true for A, R-cut, R−-cut and ≈-cut rules. Assume that the Ωa-rule derives ⊥—that is, that Th ∪A is unsatisfiable for some connected component A of A|Γ. But then, since A ⊆ A|Γ ⊆ A, by the monotonicity of first-order logic Rv ∪ Th ∪A is unsatisfiable as well, which is a contradiction.\nA.3 Completeness\nDefinition 14 and Proposition 5 show that the part of a model that is implied by Th can always be extended to a model of Rv. We say that an assertion is atomic if it is of the form A(a) with A an atomic concept, or R(a, b) with R an atomic role.\nDefinition 14. Let Γ be a signature, let Rv be a set of HT-rules, and let A be a nonempty clash-free ABox containing exactly one individual such that sig(A) ⊆ Γ. An ABox A is an Rv-extension of A w.r.t. Γ if the following conditions hold:\n1. A contains exactly one individual, A|Γ = A, and sig(A) ⊆ sig(Rv);\n2. no derivation rule from Table 2 is applicable to A and Rv; and\n3. A does not contain an assertion of the form A(s) with A ∈ safe(Rv,Γ).\nProposition 5. For each Γ, Rv, and A as in Definition 14 where Rv is additionally HTsafe, at least one Rv-extension A of A w.r.t. Γ exists.\nProof. Let s be the individual occurring in A, and let I = (I , ·I) be the interpretation for the symbols in Γ defined as follows:\nI = {s} AI =  {s} if A(s) ∈ A ∅ otherwise R I =  {s, s} if R(s, s) ∈ A ∅ otherwise\nSince Rv is HT-safe w.r.t. Γ and sig(A) ⊆ Γ, by Proposition 3 a model J of Rv exists such that J = I , XJ = XI for each symbol X ∈ Γ, and XJ = ∅ for each X ∈ safe(Rv,Γ). We define the ABox A as follows:\nA = {s ≈ s} ∪ {A(s) | s ∈ AJ and A ∈ sig(Rv)} ∪ {¬A(s) | s ∈ AJ and A ∈ sig(Rv)} ∪ {R(s, s) | s, s ∈ RJ and R ∈ sig(Rv)} ∪ {≥ 1 R.A(s) | s ∈ (≥ 1 R.A)J and {R,A} ⊆ sig(Rv)} ∪ {≥ 1 R.¬A(s) | s ∈ (≥ 1 R.¬A)J and {R,A} ⊆ sig(Rv)}\nWe now show that A is an Rv-extension of A w.r.t. Γ. Since J coincides with I on the interpretation of all atomic concepts and roles in Γ, A satisfies Properties 1 and 3 of Definition 14. We next show that no hypertableau derivation rule is applicable to A and Rv. The ≈- and the ⊥-rule are clearly not applicable to A. Furthermore, the construction of A ensures that ≥ 1 R.C(s) ∈ A if and only if {R(s, s), C(s)} ⊆ A, so the ≥-rule is not applicable to A either. Finally, assume that the Hyp-rule is applicable to an HT-rule ρ ∈ Rv and A with a mapping σ. Since A contains only the individual s, the mapping σ maps all variables in ρ to s. Since J |= Rv, rule  contains a head atom Vj such that J |= σ(Vj). Note that if Vj is of the form ≥n R.C, then n = 1 since J contains just one element. Thus, σ(Vj) can be of the form A(s), R(s, s), ≥ 1 R.C(s), or s ≈ s, where A ∈ sig(Rv), R ∈ sig(Rv), and sig(C) ⊆ sig(Rv). But then, by the construction of A we have σ(Vj) ∈ A, which contradicts the assumption that the Hyp-rule is applicable to Rv and A.\nWe are now ready to prove the main claim of the section.\nLemma 8 (Completeness). Let Γ,Rv ∪Av, Th be an input of the ALCHIQ Ωa-algorithm. If a derivation for Γ,Rv ∪Av, Th contains a leaf node labeled with a clash-free ABox, then Rv ∪Av ∪ Th is satisfiable.\nProof. Let A be an ABox obtained from a clash-free ABox labeling a leaf of a derivation for Γ,Rv ∪Av, Th by removing all assertions involving an indirectly blocked individual. Since Rv ∪Av is acyclic w.r.t. Γ, ABox A is finite by Lemma 6. Furthermore, A is clearly an HTABox and no derivation rule is applicable to Rv, A, and ΩaTh,Γ. Finally, it is straightforward to see that a mapping h from the individuals in Av to the individuals in A exists such that h(a) = a for each individual a occurring in A, C(a) ∈ Av implies C(h(a)) ∈ A, and R(a, b) ∈ Av implies R(h(a), h(b)) ∈ A. Hence, each model of Rv ∪A ∪ Th can be extended to a model of Rv ∪Av ∪ Th by interpreting each individual a not occurring in Av in the same way as h(a). Thus, we prove this lemma by showing that Rv ∪A ∪ Th is satisfiable.\nLet Rh be the result of transforming Th into a set of HT-rules as described by Motik et al. (2009); then, Rv ∪Av ∪ Th is equisatisfiable with Rv ∪Av ∪Rh, and each model of the latter is a model of the former as well. Therefore, in the rest of the proof we extend A to a clash-free extended HT-ABox Afin such that no derivation rule from Table 2 is applicable to Rv ∪Rh and Afin. By Lemma 3, Rv ∪Afin ∪Rh is satisfiable, which, together with A ⊆ Afin, implies the satisfiability of Rv ∪A ∪Rh. Before proceeding with the construction of Afin, we next introduce several useful definitions and notational conventions.\n• Let Γv = sig(Rv) ∪ sig(Av) and let Γh = sig(Rh).\n• In this proof, term “blocking” refers to the version of blocking given in Definition 8; term “w-blocking” refers to the version of blocking in Definition 13; and term “sblocking” refers to the standard blocking given in Definition 1 with the additional requirement that individuals s, s, t, and t are all unnamed.\n• For each blocked individual s, we pick an arbitrary but fixed individual s that blocks s, which we call the blocker of s.\n• The modified hypertableau algorithm is the same as the standard hypertableau algorithm from Definition 1 with the difference that it uses s-blocking and that it can be applied to ABoxes that contain unnamed individuals; such individuals are then treated by the algorithm as if they were named. The modified hypertableau algorithm is clearly sound, complete, and terminating.\n• The projection of an ABox A to a set of individuals S is the ABox consisting of exactly those assertions from A that contain only individuals in S.\nWe now proceed with the construction of Afin. To this end, we split A|Γ into ABoxes Anm and At as follows; we use these ABoxes later to construct Afin.\n– The ABox Anm is the projection of A|Γ to the set containing all named individuals in A and all unnamed individuals that are connected to a named individual in A|Γ.\n– For each nonblocked blocking-relevant individual t in A, the ABox At is the projection of A|Γ to the set containing t and all (unnamed) individuals connected to t in A|Γ.\nLet Anmder be the result of taking any clash-free ABox labeling a leaf of a derivation for Rh ∪Anm by the modified hypertableau algorithm and then removing all assertions containing an indirectly blocked individual; furthermore, for each nonblocked blockingrelevant individual t in A, let Atder be obtained from At in an analogous way. ABoxes Anmder andAtder exist because ΩaTh,Γ(A ) = t for each connected componentA ofAnm, ΩaTh,Γ(A t) = t for each t, and the modified hypertableau algorithm is sound, complete, and terminating. Since the supply of unnamed individuals is unlimited, we assume without loss of generality that the ≥-rule always introduces individuals that are “globally fresh”—that is, that do not occur in any other ABox.\nWe next extend Anmder and each Atder with assertions necessary to satisfy Rv. Let A be Anm (resp. some At) and let Ader be Anmder (resp. the corresponding Atder). We say that an individual u is fresh in Ader if u occurs in Ader but not in A. For each fresh individual u in Ader, we define Ader[u] as an Rv-extension of the projection of Ader|Γ to {u}; without loss of generality, we assume that Ader[u1] = Ader[u2] for all u1 and u2 for which the projections of Ader|Γ to {u1} and {u2} are isomorphic (i.e., identical up to the renaming of individuals). Finally, let A￿fin be the union of Ader and Ader[u] for each u that is fresh in Ader; thus, we obtain ABoxes Anmfin and Atfin. By Condition 1 of Definition 14, the atomic assertions of Ader|sig(Rh) coincide with the atomic assertions of A|sig(Rh). Furthermore, since all individuals involved in s-blocking are required to be unnamed and all isomorphic individuals are extended in the same way, this construction does not affect s-blocking—that is, u is s-blocked in A if and only if u is s-blocked in Ader.\nWe now define Afin as the ABox obtained by\n1. taking the union of A, Anmfin , and Atfin for each nonblocked blocking-relevant individual t in A, and\n2. adding A(s) for each blocked individual s in A with blocker s such that A(s) ∈ As￿fin and A ∈ Γh.3\nBy Lemma 1, Anmfin and all Atfin are HT-ABoxes, and Afin is clearly an extended HT-ABox. We next show that no hypertableau derivation rule is applicable to Rv ∪Rh and Afin.\nTo this end, we first show that Afin satisfies the following property (*): if α ∈ Afin is an atomic assertion or an assertion of the form a ≈ b such that sig(α) ⊆ Γv and all individuals mentioned in α occur in A, then α ∈ A. In particular, note that the extension of Anmder and Atder to Anmfin and Atfin, respectively, does not introduce an atomic assertion α that involves an individual from A and for which sig(α) ∩ (Γv \\ Γ) = ∅; hence, the only possibility for α ∈ Afin, α ∈ A, and sig(α) ⊆ Γv is if α ∈ Anmder or α ∈ Atder for some t. We consider next the former case; the latter one is analogous. We prove (*) by induction on the application of the derivation rules in the construction of Anmder. To this end, we show that each ABox A in a derivation for Anm and Rh satisfies the following properties: 3. Note that, since s is blocked, it is blocking-relevant.\n1. If α ∈ A is an atomic assertion or an assertion of the form a ≈ b such that sig(α) ⊆ Γv and all individuals mentioned in α occur in A, then α ∈ A or ¬α ∈ A.\n2. If R(a, b) ∈ A such that a and b occur in A and R ∈ Γh \\ Γ, then S ∈ Γ exists such that S(a, b) ∈ A or S(b, a) ∈ A.\n3. If a ≈ b ∈ A such that a occurs in A, then R ∈ Γ and an individual c occurring in A exist such that R(a, c) ∈ A or R(c, a) ∈ A.\nThe base case is trivial. We next consider ways in which an assertion in A can be derived. An application of the ⊥-rule or the ≥-rule clearly preserves (1)–(3). In an application of the ≈-rule, the modified hypertableau algorithm treats the individuals in A as named; furthermore, if a ≈ b ∈ A and a and b occur in A, by (1) we have a ≈ b ∈ A, so a = b since the ≈-rule is not applicable to A; but then, it is straightforward to see that (1)–(3) remain preserved. Finally, the following types of assertions are relevant in an application of the Hyp-rule to an HT-rule  ∈ Rh:\n• A(a) with a in A and A ∈ Γ. Since the A-cut rule is not applicable to A, we have A(a) ∈ A or ¬A(a) ∈ A, so (1) holds.\n• R(a, b) with a and b in A. The body of  then contains an atom that is matched to an assertion R(a, b) ∈ A or R(b, a) ∈ A with R ∈ Γv that satisfies the induction assumption; thus, S ∈ Γ exists such that S(a, b) ∈ A or S(b, a) ∈ A, so (2) holds. Furthermore, if R ∈ Γ, then this assertion satisfies the preconditions of the R-cut and the R−-cut rule; since these rules are not applicable to A, we have R(a, b) ∈ A or ¬R(a, b) ∈ A, so (1) holds.\n• a ≈ b with a inA. The body of  then contains an atom that is matched to an assertion R(a, c) ∈ A or R(c, a) ∈ A with R ∈ Γv that satisfies the induction assumption; thus, S ∈ Γ exists such that S(a, c) ∈ A or S(c, a) ∈ A, so (3) holds. Furthermore, if b is in A, then the body of  also contains an atom that is matched to an assertion R(a, c) ∈ A or R(c, a) ∈ A that satisfies the induction assumption; thus, S ∈ Γ exists such that S(a, c) ∈ A or S(c, a) ∈ A. The precondition of the ≈-cut rule is then satisfied and, since the rule is not applicable to A, we have a ≈ b ∈ A or a ≈ b ∈ A, so (1) holds.\nThis completes the proof of (1)–(3). Property (*) is a straightforward consequence of (1): a derivation of an assertion α such that sig(α) ⊆ Γv and all individuals mentioned in α occur in A either makes no difference or it leads to a contradiction. A straightforward consequence of (*) is that (59) and (60) hold for all individuals u and v that occur in A:\nLAfin(u) ∩ Γv =LA(u) (59) LAfin(u, v) ∩ Γv =LA(u, v) (60)\nWe now show that no derivation rule of the hypertableau algorithm with w-blocking is applicable to Rv ∪Rh and Afin. We do so by considering the possible derivation rules.\n(≥-rule) Assume that the ≥-rule is applicable to an assertion ≥n R.C(s) ∈ Afin, so s is not w-blocked in Afin. We show that then s is not blocked in A, or s is not s-blocked in Anmfin , or s is not s-blocked in some Atfin. We have the following cases.\n• ≥n R.C(s) ∈ A. Assume that s is blocked in A with blocker t, and let s and t be the predecessors of s and t, respectively. By the definition of blocking, (61)–(65) hold:\nLA(s) =LA(t) (61) LA(s) =LA(t) (62) LA(s, s) =LA(t, t) (63) LA(s, s) =LA(t, t) (64)\nLA(s, s) ∪ LA(s, s) ⊆Γv \\ Γ (65)\nBy (59) and (60), the following properties hold as well:\nLAfin(s) ∩ Γv =LAfin(t) ∩ Γv (66) LAfin(s￿) ∩ Γv =LAfin(t￿) ∩ Γv (67)\nFurthermore, the second item in the construction of Afin ensures that LAfin(s) and LAfin(t) coincide on each concept C ∈ Γh, which ensures the following property:\nLAfin(s) = LAfin(t) (68)\nBy (65), A|Γ does not contains an assertion involving individuals s and s, or individuals t and t. By the construction of Afin, the following properties hold:\nLAfin(s, s) =LAfin(t, t) (69) LAfin(s￿, s) =LAfin(t￿, t) (70)\nConsider now each rule  ∈ Rv ∪Rh. If  ∈ Rh, then no role in the body of  occurs in LAfin(s, s) ∪ LAfin(s￿, s), so  satisfies the condition of weakened pairwise anywhere blocking. If  ∈ Rv, then  satisfies the condition of weakened pairwise anywhere blocking due to (67). Together with (68)–(70), this implies that s is w-blocked by t, which is a contradiction. Consequently, s is not blocked in A.\n• ≥n R.C(s) ∈ Anmfin and ≥n R.C(s) ∈ A. If s occurs in A or if s is a successor of an individual that occurs in A, then s is not s-blocked in Anmfin since the modified hypertableau algorithm treats the individuals occurring in A as named and such individuals cannot be s-blocked. Otherwise, by the construction of Afin, LAfin(u) = LAnmfin (u) and LAfin(u, v) = LAnmfin (u, v) for all individuals u and v occurring in A nm fin but not in A;\nagain, s is not s-blocked in Anmfin .\n• ≥n R.C(s) ∈ Atfin for some t and ≥n R.C(s) ∈ A. This case is completely analogous to the previous one.\nLet A be the ABox for which the above property holds; note that ≥n R.C(s) ∈ A. The ≥-rule is not applicable to s in A, so A contains individuals u1, . . . , un such that\n{ar(R, s, ui), C(ui) | 1 ≤ i ≤ n} ∪ {ui ≈ uj | 1 ≤ i < j ≤ n} ⊆ A.\nBy the construction of Afin we have A ⊆ Afin, which then contradicts the assumption that the ≥-rule is applicable to s and Afin.\n(⊥-rule, first variant) Property (59) holds for each individual s occurring in A, and (71) and (72) hold for each individual s occurring in Anmfin and Atfin, respectively.\nLAfin(s) ∩ Γh =LAnmfin (s) ∩ Γh (71) LAfin(s) ∩ Γh =LAtfin(s) ∩ Γh (72)\nThus, {A(s),¬A(s)} ⊆ Afin implies {A(s),¬A(s)} ⊆ A, where A can be A, or Anmfin , or some Atfin. Since the first variant of the ⊥-rule is not applicable to A, it is not applicable to Afin either.\n(⊥-rule, second variant) Property (60) holds for each pair of individuals s and t occurring inA. Furthermore, Anmfin andAtfin do not contain negative assertions other than those already present in A. Since the second variant of the ⊥-rule is not applicable to A, Anmfin , and all Atfin, it is not applicable to Afin either.\n(⊥-rule, third variant) Suppose that the ⊥-rule is applicable to an assertion of the form s ≈ s ∈ Afin. By the construction of Afin, then s ≈ s ∈ A for A being A, Anmfin , or Atfin for some t. But then, since the ⊥-rule is not applicable to A, it is not applicable to Afin either.\n(≈-rule) Assume now that the ≈-rule is applicable to Afin. Then, an assertion s ≈ s in Afin exists with s = s. By the construction of Afin, we have that s ≈ s ∈ A, with A = A, or A = Anmfin , or A = Atfin for some t. But then, since the ≈-rule is not applicable to A, it is not applicable to Afin either.\n(Hyp-rule) Assume that the Hyp-rule is applicable to Afin and an HT-rule  ∈ Rv ∪Rh of the form (2). Thus, a mapping σ from the variables in  to the individuals Afin exists such that σ(Ui) ∈ Afin for each 1 ≤ i ≤ m, but σ(Vj) ∈ Afin for each 1 ≤ j ≤ n. Let s = σ(x) and ui = σ(yi). We have the following possibilities:\n•  ∈ Rh. Let A be the ABox chosen among Anmfin and Atfin containing the individual s. Consider now each ui. Then  contains an atom of the form Rij(x, yi) or Rij(yi, x) with Rij ∈ Γh, so Afin contains an assertion of the form Rij(s, ui) or Rij(ui, s). By the definition of blocking, for each pair of individuals u and v that belong to different Anm and At, the ABox A does not contain an assertion of the form T (u, v) with T ∈ Γh; but then, by the construction of Afin, if u and v belong to different Anmfin and Atfin, the ABox Afin does not contain such an assertion either. Thus, all ui occur in A, so the Hyp-rule is applicable to  and A, which is a contradiction.\n•  ∈ Rv. We first show the following property (**): if s or some ui does not occur in A, then s = uj for each uj . We consider first the case when s does not occur in A. Consider an arbitrary uj . Since  is an HT-rule, the body of  contains an atom of the form Rjk(x, yj) or Rjk(yj , x), so Afin contains an assertion of the form Rjk(s, uj) or Rjk(uj , s). We have the following two possibilities for Rjk.\n– Rjk ∈ Γv\\Γ. By the construction of Afin, assertion Rjk(s, uj) or Rjk(uj , s) with s not occurring in A must have been introduced via some Rv-extension, so uj = s.\n– Rjk ∈ Γ. Since  is HT-safe w.r.t. Γ,  contains an atom of the form A(x) such that A ∈ safe(Rv,Γ) in the body. By Condition 3 of Definition 14, A(s) ∈ Afin, which is a contradiction.\nThe case when some ui does not occur in A is symmetric; the only difference is that in case Rjk ∈ Γ we consider a body atom B(yj) of  such that B ∈ safe(Rv,Γ). Let A = A if s occurs in A, and let A be the ABox that contains s otherwise. A straightforward consequence of (**) is that σ(Ui) ∈ A for each 1 ≤ i ≤ m; furthermore, A ⊆ Afin and σ(Vj) ∈ Afin imply σ(Vj) ∈ A for each 1 ≤ j ≤ n. But then, the Hyp-rule is applicable to A for  and σ, which is a contradiction.\nThus, no derivation rule of the hypertableau algorithm with w-blocking is applicable to Rv ∪Rh and Afin, so Rv ∪Rh ∪Afin is satisfiable by Lemma 3. As explained earlier, this then proves the claim of this lemma.\nLemmas 6, 7, and 8 immediately imply Theorem 11."
    }, {
      "heading" : "Appendix B. Proof of Theorem 12",
      "text" : "The termination argument for the Horn-ALCHIQ Ωe-algorithm is analogous to the nonHorn case: for each derivation for Γ,Rv ∪Av, Th, and each node t in the derivation, we can find an embedding µ as in Lemma 4; the proof is a straightforward variant of the proof given for the non-Horn case. Termination then follows exactly as in the non-Horn case. Soundness is a consequence of the soundness of the standard hypertableau algorithm together with the following lemma.\nLemma 9. Let Rv be a set of HT-rules, let Th be a Horn-ALCHIQ TBox, and let A an ABox such that Rv ∪ Th ∪A is satisfiable. Furthermore, let A1 be the ABox obtained by applying a derivation rule from Table 5 to Rv and A. Then, Rv ∪ Th ∪A1 is satisfiable.\nProof. Let I be a model of Rv ∪ Th ∪A, and let us assume that a derivation rule from Table 5 derives A1 = A ∪ {α}. By the preconditions of the Ωe-concept, Ωe-role, and Ωe-≈ rules, then ΩeTh,Γ(A\n,α) = t for some connected component A of A|Γ, so Th ∪A |= α. Since A ⊆ A|Γ ⊆ A, we have that I |= Th ∪A, so I |= α, which implies our claim.\nWe now show completeness of the algorithm. If a set of HT-rules R is Horn, then each derivation of the hypertableau algorithm contains exactly one leaf node, so we can identify a derivation with a sequence of ABoxes A0, . . . ,An. The following proposition is a straightforward consequence of the fact that R is a Horn set of HT-rules.\nProposition 6. Let R be a set of Horn HT-rules, let A an ABox, and let A0, . . . ,An be a derivation for R and A. Then, for each assertion α that mentions only the individuals from A such that α ∈ Ai for some 1 ≤ i ≤ n, we have R ∪A |= α.\nLemma 10 (Completeness). Let Γ,Rv ∪Av, Th be an input of the Horn-ALCHIQ Ωealgorithm. If a derivation for Γ,Rv ∪Av, Th contains a leaf node labeled with a clash-free ABox, then Rv ∪Av ∪ Th is satisfiable.\nProof. The proof is analogous to the proof of Lemma 8: given an ABox A labeling a derivation leaf, we construct an ABox Afin such that no derivation rule of the hypertableau algorithm with w-blocking is applicable to Rv ∪Rh and Afin. The construction and the\nbulk of the proof are exactly the same as in Lemma 8, and we next prove only properties that are affected by the difference in the derivation rules.\nThe preconditions of the derivation rules in Table 5 clearly ensure that, whenever a derivation rule is applied to an HT-ABox, the result is also an HT-ABox; consequently, Afin is an extended HT-ABox.\nWe next show that property (*) holds despite the change in the derivation rules: if α ∈ Afin is an atomic assertion or an assertion of the form a ≈ b such that sig(α) ⊆ Γv and all individuals mentioned in α occur in A, then α ∈ A. In particular, note that the construction of Afin does not introduce an atomic assertion α that involves an individual from A and for which sig(α) ∩ (Γv \\ Γ) = ∅. Assume now that sig(α) ⊆ Γ and all individuals in α occur in A. By Proposition 6 we have Rh ∪A |= α. Furthermore, in the same say as in Lemma 8 one can show that the preconditions of the Ωe-concept, Ωe-role, or Ωe-≈ rule are satisfied in A; since the relevant rule in not applicable to A, we have α ∈ A, which proves our claim.\nThe rest of the proof is exactly the same as in Lemma 8.\nTheorem 12 follows immediately from Lemmas 9 and 10."
    }, {
      "heading" : "Appendix C. Proof of Theorem 13",
      "text" : "For each set of EL-rules R and each ABox A, each derivation of the EL hypertableau algorithm contains exactly one leaf node, so we identify a derivation with a sequence of ABoxes A0,A1, . . . ,An. Since Aj−1 ⊆ Aj for each 1 ≤ i ≤ n, the ABox labeling the derivation leaf is uniquely defined by R and A. The following lemma captures the relevant properties of the standard EL hypertableau algorithm, and it can be proved by a slight variation of the proofs by Motik and Horrocks (2008) and Baader et al. (2005).\nLemma 11. Let R be a set of EL-rules, let A be an ABox containing only named individuals, and let Af be the ABox labeling a leaf of a derivation for R and A. Then the following properties hold for each pair of atomic concepts A, B ∈ sig(R) and each individual s in A:\n1. A(s) ∈ Af if and only if R ∪A |= A(s).\n2. B(aA) ∈ Af if and only if R |= A  B.\n3. For each A ⊆ A and each R ⊆ R, we have A f ⊆ Af , where Af is the ABox labeling\na leaf of a derivation for R and A.\nJust like in the EL hypertableau algorithm, each derivation of the EL Ωe-algorithm contains exactly one leaf node, and the ABox labeling the derivation leaf is uniquely defined by Γ,Rv ∪Av, Th. We next show several useful properties of this algorithm.\nLemma 12. Let Γ,Rv ∪Av, Th be an input of the EL Ωe-algorithm and let Ae be the ABox labeling a leaf of a derivation for Γ,Rv ∪Av, Th. Then the following holds.\n1. Let Rh be the set of EL-rules corresponding to Th as described by Motik et al. (2009), and let AEL be the ABox labeling a leaf of a derivation of the standard EL hypertableau algorithm for Rv ∪Rh and Av; then, Ae ⊆ AEL.\n2. If ⊥ ∈ Ae and B(aA) ∈ Ae with A ∈ Γ, then B ∈ safe(Rv,Γ).\nProof. (Claim 1) Let A0, . . . ,An be a derivation of the EL Ωe-algorithm for Rv, Av, and ΩeTh,Γ such that A0 = Av and An = A\ne. We prove the claim inductively by showing that Aj ⊆ AEL for each 0 ≤ j ≤ n. For the induction base, we clearly have A0 ∈ AEL. Assume now that Aj−1 ⊆ AEL and let Aj be obtained from Aj−1 by applying a derivation rule of the EL Ωe-algorithm. If the Hyp-rule is applied to Aj−1 and some  ∈ Rv, then  ∈ Rv ∪Rh, Aj−1 ⊆ AEL, and the fact that Hyp-rule is not applicable to AEL and  imply Aj ⊆ AEL. The argument is analogous for the ∃-rule. Finally, assume that the Ωe-concept rule derives A(s) with A ∈ Γ ∪ {⊥} from Aj−1. By the preconditions of the Ωe-concept rule, then ΩeTh,Γ(A\n, A(s)) = t for some connected component A of Aj−1|Γ. By Property 1 of Lemma 11 then A(s) ∈ A, where A is the ABox labeling a leaf of a derivation of the standard EL hypertableau algorithm for A and Rh. Now A ⊆ AEL, Rh ⊆ Rh ∪Rv, and Property 3 of Lemma 11 imply A ⊆ AEL; consequently, A(s) ∈ AEL and Aj ∈ AEL.\n(Claim 2) Consider an arbitrary individual of the form aA with A ∈ Γ and an arbitrary assertion B(aA) ∈ Ae. By Claim 1, B(aA) ∈ AEL, so by Property 2 of Lemma 11 we have Av ∪Rv ∪Rh |= A  B. Since Rv ∪Rh are EL-rules, Av does not affect subsumption inferences, so Rv ∪Rh |= A  B. Since ⊥ ∈ Ae, an interpretation I exists such that AI = ∅ and I |= Rh. Assume now that B ∈ safe(Rv,Γ). By Proposition 3 and the fact that Rv is EL-safe, a model J of Rv exists such that XJ = XI for each X ∈ sig(Rh), and BJ = ∅. Thus, J |= Rv ∪Rh, which contradicts the fact that Rv ∪Rh |= A  B.\nSoundness of the EL Ωe-algorithm follows immediately from Property 1 of Lemma 12 and the fact that the standard EL hypertableau algorithm is sound. We next prove that the algorithm is complete.\nLemma 13 (Completeness). Let Γ,Rv ∪Av, Th be an input of the EL Ωe-algorithm and let Th be an EL TBox, and let Ae be the ABox labeling a leaf of a derivation for Γ,Rv ∪Av, Th. If ⊥ ∈ Ae, then Rv ∪Av ∪ Th is satisfiable.\nProof. Let Rh be the result of transforming Th into a set of EL-rules as described by Motik et al. (2009); then, Rv ∪Av ∪ Th is equisatisfiable with Rv ∪Av ∪Rh, and each model of the latter is a model of the former as well. Therefore, in the rest of the proof we extend A to a clash-free ABox Afin such that no derivation rule from Table 2 is applicable to Rv ∪Rh and Afin. By Lemma 3, then Rv ∪Afin ∪Rh is satisfiable, which, together with A ⊆ Afin, implies the satisfiability of Rv ∪A ∪Rh. Let Γv = sig(Rv) ∪ sig(Av) and Γh = sig(Rh).\nWe next present the construction of Afin. The first step is to extend Ae such that it satisfies Rh, which we achieve by applying the EL hypertableau algorithm to Rh and Ae. We assume that the individuals in Ae of the form aA are reused whenever A ∈ Γv. We call the individuals from Ae old and the freshly introduced individuals new, and we call an individual Γ-relevant if it is of the form aA with A ∈ Γ.\nWe next show that each ABox Aj in a derivation for Rh and Ae satisfies the following properties (*):\n1. α ∈ Aj implies α ∈ Ae whenever α is of the form\n(a) C(s) with sig(C) ⊆ Γv and s an old individual, or\n(b) R(s, t) with R ∈ Γv and s and t old individuals.\n2. For each C(s) ∈ Aj , the following properties hold:\n(a) sig(C) ⊆ Γv or sig(C) ⊆ Γh, and (b) if s is a new individual, then sig(C) ⊆ Γh.\n3. For each R(s, t) ∈ Aj , the following properties hold:\n(a) if t is a new individual, then R ∈ Γh, and (b) if s is new and t is old, then t is Γ-relevant and R ∈ Γh.\nThe proof of (*) is by induction on the application of the derivation rules. For the induction base, we have A0 = Ae. Statements (1) and (2a) hold trivially, and (2b) and (3) are vacuously true since Ae contains only old individuals. Assume now that (1)–(3) hold for Aj−1 and consider an application of a derivation rule that derives Aj .\nAssume that the ∃-rule is applied to ∃R.A(s) ∈ Aj−1, deriving R(s, aA) and A(aA). If {R,A} ⊆ Γv and s is old, then ∃R.A(s) ∈ Ae by the induction assumption; since the ∃- rule is not applicable to Ae, then {R(s, aA), A(aA)} ⊆ Ae, so (1) holds. Furthermore, if A ∈ Γv \\ Γ, then s is old by (2b), and R ∈ Γv by (2a); but then ∃R.A(s) ∈ Ae, so the ∃-rule cannot be applicable to ∃R.A(s) in Aj−1. Consequently, we have {R,A} ⊆ Γh, so A(aA) clearly satisfies (2), and R(s, aA) clearly satisfies (3a). Finally, aA can be old only if A ∈ Γ, so R(s, aA) clearly satisfies (3b).\nAssume that the Hyp-rule is applied to an EL-rule ρ ∈ Rh of the form (8), deriving C(s). Then, individuals t1, . . . , tm in Aj−1 exist such that Ai(s) ∈ Aj−1 for each 1 ≤ i ≤ k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} ⊆ Aj−1 for each 1 ≤ i ≤ m. ABox Aj trivially satisfies (1b) and (3), and it satisfies (2) because ρ ∈ Rh, so sig(C) ⊆ Γh. To show (1a), assume that s is an old individual and sig(C) ⊆ Γv; since ρ ∈ Rh, then sig(C) ⊆ Γ. By Property 1 of Lemma 11, then Rh ∪Ae |= C(s). Since sig(C) ⊆ Γ, we have Rh ∪Ae|Γ |= C(s). Since the Ωe-concept rule is not applicable to Ae, we have C(s) ∈ Ae, so Aj satisfies (1a).\nThis completes the proof of (*). Let Ader be the ABox labeling a leaf of a derivation of the EL hypertableau algorithm for Rh and Ae. Such Ader is clash-free since ⊥ /∈ Ae and the Ωe-rule is not applicable to Ae; furthermore, Ader satisfies (*).\nWe now extend Ader such that the EL-rules in Rv are satisfied when they are matched to new individuals. To this end, for each new individual u in Ader, let Ader[u] be an Rvextension w.r.t. Γ of the projection of Ader on {u}; such Ader[u] exists by Proposition 5 and the fact that Rv is EL-safe. Let Afin be the union of Ader and all such Ader[u]. Since Av ⊆ Ae and Ae ⊆ Afin, we have Av ⊆ Afin. Furthermore, since ⊥ ∈ Ader and ⊥ ∈ Ader[u] for each u that is new in Ader, we have ⊥ ∈ Afin. Finally, by (*), Property 2 of Lemma 12, and the fact that each Ader[u] contains only one individual and no safe concepts, Afin satisfies the following properties (**):\n1. For each B(s) ∈ Afin such that s is Γ-relevant or new, we have B ∈ safe(Rv,Γ).\n2. For each R(s, t) ∈ Afin, the following properties hold:\n(a) if t is a new individual and s = t, then R ∈ Γh, and\n(b) if s is new and t is old, then t is Γ-relevant and R ∈ Γh.\nTo complete the proof of this lemma, we show that no derivation rule of the hypertableau algorithm is applicable to Afin and Rv ∪Rh.\n(∃-rule) Consider an arbitrary ∃R.C(s) ∈ Afin. If ∃R.C(s) ∈ Ader, since the ∃-rule is not applicable to Ader, we have {R(s, t), C(t)} ⊆ Ader ⊆ Afin. If ∃R.C(s) ∈ Ader[u] for some individual u that is new in Ader, by Definition 14 the ∃-rule is not applicable to Ader[u], so {R(s, t), C(t)} ⊆ Ader[u] ⊆ Afin. Either way, the ∃-rule is not applicable to ∃R.C(s) in Afin.\n(Hyp-rule) Assume that the Hyp-rule is applicable to an EL-rule ρ ∈ Rv ∪Rh of the form (8), deriving C(s). Then, individuals t1, . . . , tm in Afin exist such that Ai(s) ∈ Afin for each 1 ≤ i ≤ k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} ⊆ Afin for each 1 ≤ i ≤ m. Then we have the following possibilities:\n•  ∈ Rh. For each new individual u and each assertion α ∈ Ader[u] \\ Ader, by Definition 14 either sig(α) ∈ Γv \\ Γ or α is of the form ∃R.C. Thus, Ai(s) ∈ Ader for each 1 ≤ i ≤ k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} ⊆ Ader for each 1 ≤ i ≤ m, so the Hyp-rule is applicable to  and Ader, which is a contradiction.\n•  ∈ Rv. We first show the following property (***): if s or some ti is new, then s = tj for each tj . We have the following cases.\n– Assume that s is new and consider an arbitrary 1 ≤ i ≤ m. Clearly, Ri ∈ Γv; furthermore, if Ri ∈ Γ, since  is EL-safe, the body of  contains an atom that is matched to some Bij(ti) ∈ Afin such that Bij ∈ safe(Rv,Γ). Assume now that ti = s. If ti is new, then Ri ∈ Γ by Statement (2a) of (**); furthermore, if ti is old, then Ri ∈ Γ and ti is Γ-relevant by Statement (2b) of (**); consequently, Ri ∈ Γ and ti is either new or Γ-relevant. But then, by Statement (1) of (**) and Property 3 of Definition 14, then Bij(ti) ∈ Afin, which is a contradiction. Hence, we conclude that s = ti.\n– Assume that ti is new for some 1 ≤ i ≤ m. If ti = s, by Statement (2a) of (**) then Ri ∈ Γ. Since  is EL-safe, the body of  then contains an atom that is matched to some Bij(ti) ∈ Afin such that Bij ∈ safe(Rv,Γ). Statement (1) of (**) then implies Bij(ti) ∈ Afin, which is a contradiction. Hence, we conclude that s = ti; by the previous case then s = tj for each 1 ≤ j ≤ m.\nLet A = Ae if s is old, and A = Ader[s] otherwise. A straightforward consequence of (***) is that Ai(s) ∈ A for each 1 ≤ i ≤ k and {Ri(s, ti), Bi,1(ti), . . . , Bi,mi(ti)} ⊆ A for each 1 ≤ i ≤ m. The Hyp-rule is not applicable to  and A, so C(s) ∈ A. Since A ⊆ Afin, we have C(s) ∈ Afin, which contradicts the assumption that the Hyp-rule is applicable to  and Afin.\nThis completes the proof of this lemma.\nFinally, we prove that the EL Ωe-algorithm is an optimal import-by-query algorithm.\nTheorem 13. The EL Ωe-algorithm is an import-by-query algorithm based on ABox entailment oracles for the class of inputs C[ΓC ,RCv ∪ACv , T Ch ] from Definition 11. The algorithm can be implemented such that it runs in PTime in N with a polynomial number (in N) of calls to ΩeTh,Γ, where N = |Rv ∪Av|+ |Γ| for the input Rv, Av, and Γ.\nProof. That the EL Ωe-algorithm is an import-by-query algorithm is a straightforward consequence of Lemmas 12 and 13. To estimate the algorithm’s running time, note that each application of a derivation rule adds an assertion of the form C(a) or R(a, b) for C ∈ Γv ∪ {⊥}, where a and b are individuals occurring either in Av or are of the form aA with A ∈ sig(Rv). Clearly, the maximal number of individuals occurring in an ABox in a derivation is polynomial in the size of Av, Rv, and Γ, and so is the maximal number of assertions. Furthermore, no derivation rule removes assertions from an ABox, so the number of assertions in an ABox monotonically increases in the course of a derivation. Consequently, the number of rule applications is polynomial in the size of Av, Rv, and Γ. In the same way as in the standard EL hypertableau algorithm (Motik & Horrocks, 2008), one can show that each derivation rule can be applied in polynomial time, which implies the claim of this theorem."
    } ],
    "references" : [ {
      "title" : "Pushing the EL Envelope",
      "author" : [ "F. Baader", "S. Brandt", "C. Lutz" ],
      "venue" : "Proc. of the 19th Int. Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Baader et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2005
    }, {
      "title" : "The Description Logic Handbook: Theory, Implementation and Applications (2nd edition)",
      "author" : [ "F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2007
    }, {
      "title" : "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "What to Ask to a Peer: Ontolgoy-based Query Reformulation",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Proc. of the 9th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2004
    }, {
      "title" : "A Logical Framework for Modularity of Ontologies",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Grau et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2007
    }, {
      "title" : "Modular Reuse of Ontologies: Theory and Practice",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "OWL 2: The next step for OWL",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. Patel-Schneider", "U. Sattler" ],
      "venue" : "Journal of Web Semantics: Science, Services and Agents on the World Wide Web,",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "Ontology module extraction for ontology reuse: an ontology engineering perspective",
      "author" : [ "P. Doran", "V.A.M. Tamma", "L. Iannone" ],
      "venue" : null,
      "citeRegEx" : "Doran et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Doran et al\\.",
      "year" : 2007
    }, {
      "title" : "A Description Logic with Transitive and Inverse Roles and Role Hierarchies",
      "author" : [ "I. Horrocks", "U. Sattler" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "Horrocks and Sattler,? \\Q1999\\E",
      "shortCiteRegEx" : "Horrocks and Sattler",
      "year" : 1999
    }, {
      "title" : "Data Complexity of Reasoning in Very Expressive Description Logics",
      "author" : [ "U. Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2005
    }, {
      "title" : "Safe and Economic Re-Use of Ontologies: A Logic-Based Methodology and Tool Support",
      "author" : [ "E. Jiménez-Ruiz", "B. Cuenca Grau", "U. Sattler", "T. Schneider", "R. Berlanga Llavori" ],
      "venue" : "Proc. of the 5th European Semantic Web Conference (ESWC 2008),",
      "citeRegEx" : "Jiménez.Ruiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Jiménez.Ruiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Semantic Modularity and Module Extraction in Description Logics",
      "author" : [ "B. Konev", "C. Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "Proc. of the 18th European Conf. on Artificial Intelligence (ECAI",
      "citeRegEx" : "Konev et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2008
    }, {
      "title" : "Forgetting and Uniform Interpolation in Large-Scale Description Logic Terminologies",
      "author" : [ "B. Konev", "D. Walther", "F. Wolter" ],
      "venue" : "Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Konev et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2009
    }, {
      "title" : "Minimal Module Extraction from DL-Lite Ontologies Using QBF Solvers",
      "author" : [ "R. Kontchakov", "L. Pulina", "U. Sattler", "T. Schneider", "P. Selmer", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2009
    }, {
      "title" : "Conservative Extensions in Expressive Description Logics",
      "author" : [ "C. Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Lutz et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2007
    }, {
      "title" : "Deciding inseparability and conservative extensions in the description logic EL",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "Journal of Symbolic Computation,",
      "citeRegEx" : "Lutz and Wolter,? \\Q2010\\E",
      "shortCiteRegEx" : "Lutz and Wolter",
      "year" : 2010
    }, {
      "title" : "Foundations for Uniform Interpolation and Forgetting in Expressive Description Logics",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Lutz and Wolter,? \\Q2011\\E",
      "shortCiteRegEx" : "Lutz and Wolter",
      "year" : 2011
    }, {
      "title" : "Individual Reuse in Description Logic Reasoning",
      "author" : [ "B. Motik", "I. Horrocks" ],
      "venue" : "Proc. of the 4th Int. Joint Conf. on Automated Reasoning (IJCAR 2008),",
      "citeRegEx" : "Motik and Horrocks,? \\Q2008\\E",
      "shortCiteRegEx" : "Motik and Horrocks",
      "year" : 2008
    }, {
      "title" : "Hypertableau Reasoning for Description Logics",
      "author" : [ "B. Motik", "R. Shearer", "I. Horrocks" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "Computational Complexity",
      "author" : [ "C.H. Papadimitriou" ],
      "venue" : "Addison Wesley.",
      "citeRegEx" : "Papadimitriou,? 1993",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1993
    }, {
      "title" : "Which Kind of Module Should I Extract",
      "author" : [ "U. Sattler", "T. Schneider", "M. Zakharyaschev" ],
      "venue" : "Proc. of the 22nd Int. Workshop on Description Logics (DL 2009),",
      "citeRegEx" : "Sattler et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Sattler et al\\.",
      "year" : 2009
    }, {
      "title" : "Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, Vol",
      "author" : [ "H. Stuckenschmidt", "C. Parent", "S. Spaccapietra" ],
      "venue" : null,
      "citeRegEx" : "Stuckenschmidt et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Stuckenschmidt et al\\.",
      "year" : 2009
    }, {
      "title" : "The Complexity of Reasoning with Cardinality Restrictions and Nominals in Expressive Description Logics",
      "author" : [ "S. Tobies" ],
      "venue" : "Journal of Artificial Intelligence Research, 12, 199– 217.",
      "citeRegEx" : "Tobies,? 2000",
      "shortCiteRegEx" : "Tobies",
      "year" : 2000
    }, {
      "title" : "Concept and Role Forgetting inALC Ontologies",
      "author" : [ "K. Wang", "Z. Wang", "R.W. Topor", "J.Z. Pan", "G. Antoniou" ],
      "venue" : "Proc. of the 8th Int. Semantic Web Conference (ISWC 2009),",
      "citeRegEx" : "Wang et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2009
    }, {
      "title" : "Forgetting Concepts in DL-Lite",
      "author" : [ "Z. Wang", "K. Wang", "R.W. Topor", "J.Z. Pan" ],
      "venue" : "Proc. of the 5th European Semantic Web Conference (ESWC 2008),",
      "citeRegEx" : "Wang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2008
    }, {
      "title" : "Tableau-based Forgetting in ALC Ontologies",
      "author" : [ "Z. Wang", "K. Wang", "R.W. Topor", "X. Zhang" ],
      "venue" : "Proc. of the 19th European Conference on Artificial Intelligence,",
      "citeRegEx" : "Wang et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 24,
      "context" : "For example, one possible approach is to publish an Υ-interpolant ofKh—an ontology that contains no symbols fromΥ and that coincides withKh on all logical consequences formed using the symbols not in Υ (Konev, Walther, & Wolter, 2009; Wang, Wang, Topor, Pan, & Antoniou, 2009; Wang, Wang, Topor, & Pan, 2008; Wang, Wang, Topor, & Zhang, 2010; Wang et al., 2008; Lutz & Wolter, 2011; Nikitina, 2011).",
      "startOffset" : 202,
      "endOffset" : 398
    }, {
      "referenceID" : 12,
      "context" : "First, an interpolant may exist only if Kh is expressed in a relatively weak ontology language and if it satisfies certain syntactic conditions (Konev et al., 2009).",
      "startOffset" : 144,
      "endOffset" : 164
    }, {
      "referenceID" : 18,
      "context" : "In this section, we recapitulate the description logic notation used in this paper, we present an overview of various hypertableau reasoning algorithms for description logics (Motik et al., 2009), and we recapitulate various notions of modular ontology reuse (Lutz, Walther, & Wolter, 2007; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Konev, Lutz, Walther, & Wolter, 2008).",
      "startOffset" : 175,
      "endOffset" : 195
    }, {
      "referenceID" : 1,
      "context" : "It is well known that these two definitions are equally expressive (Baader et al., 2007).",
      "startOffset" : 67,
      "endOffset" : 88
    }, {
      "referenceID" : 0,
      "context" : "The DL EL (Baader et al., 2005) (resp.",
      "startOffset" : 10,
      "endOffset" : 31
    }, {
      "referenceID" : 18,
      "context" : "The hypertableau calculus by Motik et al. (2009) decides the satisfiability of an ALCHOIQ knowledge base K.",
      "startOffset" : 29,
      "endOffset" : 49
    }, {
      "referenceID" : 18,
      "context" : "The hypertableau calculus by Motik et al. (2009) decides the satisfiability of an ALCHOIQ knowledge base K. As we show in Section 4.1, the presence of nominals precludes the existence of an import-by-query algorithm; hence, in this section we present an overview of a simplified version of the algorithm that is applicable if K is an ALCHIQ knowledge base. The algorithm first preprocesses K into a set of rules R—implications interpreted under first-order semantics—and a normalized ABox A such that K is equisatisfiable with R ∪ A. Preprocessing consists of three steps. First, transitivity axioms are eliminated from K by encoding them using concept inclusions. Second, axioms are normalized and complex concepts are replaced with atomic ones in a way similar to the structural transformation for first-order logic. Third, the normalized axioms are translated into rules by using the correspondence between description and first-order logic. We omit the details of the preprocessing for the sake of brevity; Motik et al. (2009) present all the relevant details.",
      "startOffset" : 29,
      "endOffset" : 1031
    }, {
      "referenceID" : 18,
      "context" : "As Motik et al. (2009) have shown, the preprocessing of K produces an equisatisfiable set of HT-rules and a normalized ABox; furthermore, if K is Horn, then the resulting set contains only Horn HT-rules.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 18,
      "context" : "When applied to an EL knowledge base, the transformation by Motik et al. (2009) produces EL-rules—HT-rules of the form (8) in which C is either an atomic concept or a concept of the form ∃R.",
      "startOffset" : 60,
      "endOffset" : 80
    }, {
      "referenceID" : 18,
      "context" : "Models of R∪A obtained in such a way are called canonical forest models, and Motik et al. (2009) discuss in depth the properties of such models.",
      "startOffset" : 77,
      "endOffset" : 97
    }, {
      "referenceID" : 17,
      "context" : "Motik and Horrocks (2008) showed, however, that a worst-case optimal algorithm can be obtained by modifying the ≥-rule.",
      "startOffset" : 0,
      "endOffset" : 26
    }, {
      "referenceID" : 14,
      "context" : "a signature Γ is a very hard computational problem for most DLs, and it is often undecidable (Lutz et al., 2007; Konev et al., 2008).",
      "startOffset" : 93,
      "endOffset" : 132
    }, {
      "referenceID" : 11,
      "context" : "a signature Γ is a very hard computational problem for most DLs, and it is often undecidable (Lutz et al., 2007; Konev et al., 2008).",
      "startOffset" : 93,
      "endOffset" : 132
    }, {
      "referenceID" : 11,
      "context" : ", 2007; Konev et al., 2008). Cuenca Grau, Horrocks, Kazakov, and Sattler (2008) have defined several practically useful sufficient syntactic conditions that guarantee semantic modularity.",
      "startOffset" : 8,
      "endOffset" : 80
    }, {
      "referenceID" : 19,
      "context" : "A precise definition of the latter is given by Papadimitriou (1993); we next present just an informal overview of the main ideas.",
      "startOffset" : 47,
      "endOffset" : 68
    }, {
      "referenceID" : 18,
      "context" : "Furthermore, in the rest of this paper we assume that Kv is preprocessed as described by Motik et al. (2009) into the corresponding set of HT-rules Rv and ABox Av; this will be convenient because HT-rules do not contain nested quantifiers.",
      "startOffset" : 89,
      "endOffset" : 109
    }, {
      "referenceID" : 22,
      "context" : "TBox Tv uses the well-known “integer counting” technique (Tobies, 2000).",
      "startOffset" : 57,
      "endOffset" : 71
    }, {
      "referenceID" : 12,
      "context" : "Some of these drawbacks can be overcome by publishing an Υ-interpolant of Th—an ontology that contains no symbols from Υ and that coincides with Th on all logical consequences formed using the symbols not in Υ (Konev et al., 2009; Wang et al., 2009, 2008; Lutz & Wolter, 2011; Nikitina, 2011).",
      "startOffset" : 210,
      "endOffset" : 292
    }, {
      "referenceID" : 12,
      "context" : "First, an interpolant may exist only if Th is expressed in a relatively weak DL and satisfies certain syntactic conditions (Konev et al., 2009).",
      "startOffset" : 123,
      "endOffset" : 143
    }, {
      "referenceID" : 20,
      "context" : "Second, although interpolants preserve logical consequences formed using symbols not in Υ, they are not robust under replacement (Sattler et al., 2009)—that is, the union of Kv and an Υ-interpolant of Th is not guaranteed to yield the same consequences as Th ∪Kv for a query q involving no symbols from Υ.",
      "startOffset" : 129,
      "endOffset" : 151
    }, {
      "referenceID" : 2,
      "context" : "Since a satisfiable Kh cannot affect the subsumption of concepts in Kv, the results by Calvanese et al. (2004) are not applicable to schema reasoning.",
      "startOffset" : 87,
      "endOffset" : 111
    }, {
      "referenceID" : 18,
      "context" : "The proof is a straightforward modification of the proof of Lemma 4 by Motik et al. (2009), which are due the following observations: since HT-rules do not allow for atoms of the form R(x, x) in the head, one cannot derive atoms of the form R(s, s); this, in turn, guarantees that one cannot derive equalities of the form s.",
      "startOffset" : 71,
      "endOffset" : 91
    }, {
      "referenceID" : 18,
      "context" : "The rest of the proof of our claim is then analogous to the proof of Lemma 7 by Motik et al. (2009).",
      "startOffset" : 80,
      "endOffset" : 100
    }, {
      "referenceID" : 18,
      "context" : "Let Rh be the result of transforming Th into a set of HT-rules as described by Motik et al. (2009); then, Rv ∪Av ∪ Th is equisatisfiable with Rv ∪Av ∪Rh, and each model of the latter is a model of the former as well.",
      "startOffset" : 79,
      "endOffset" : 99
    }, {
      "referenceID" : 15,
      "context" : "The following lemma captures the relevant properties of the standard EL hypertableau algorithm, and it can be proved by a slight variation of the proofs by Motik and Horrocks (2008) and Baader et al.",
      "startOffset" : 156,
      "endOffset" : 182
    }, {
      "referenceID" : 0,
      "context" : "The following lemma captures the relevant properties of the standard EL hypertableau algorithm, and it can be proved by a slight variation of the proofs by Motik and Horrocks (2008) and Baader et al. (2005).",
      "startOffset" : 186,
      "endOffset" : 207
    }, {
      "referenceID" : 18,
      "context" : "Let Rh be the set of EL-rules corresponding to Th as described by Motik et al. (2009), and let AEL be the ABox labeling a leaf of a derivation of the standard EL hypertableau algorithm for Rv ∪Rh and Av; then, Ae ⊆ AEL.",
      "startOffset" : 66,
      "endOffset" : 86
    }, {
      "referenceID" : 18,
      "context" : "Let Rh be the result of transforming Th into a set of EL-rules as described by Motik et al. (2009); then, Rv ∪Av ∪ Th is equisatisfiable with Rv ∪Av ∪Rh, and each model of the latter is a model of the former as well.",
      "startOffset" : 79,
      "endOffset" : 99
    } ],
    "year" : 2012,
    "abstractText" : "There is currently a growing interest in techniques for hiding parts of the signature of an ontology Kh that is being reused by another ontology Kv. Towards this goal, in this paper we propose the import-by-query framework, which makes the content of Kh accessible through a limited query interface. If Kv reuses the symbols from Kh in a certain restricted way, one can reason over Kv ∪Kh by accessing only Kv and the query interface. We map out the landscape of the import-by-query problem. In particular, we outline the limitations of our framework and prove that certain restrictions on the expressivity of Kh and the way in which Kv reuses symbols from Kh are strictly necessary to enable reasoning in our setting. We also identify cases in which reasoning is possible and we present suitable import-by-query reasoning algorithms.",
    "creator" : "TeX"
  }
}