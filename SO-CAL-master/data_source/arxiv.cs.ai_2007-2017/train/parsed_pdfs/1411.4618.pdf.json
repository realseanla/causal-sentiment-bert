{
  "name" : "1411.4618.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Relations World: A Possibilistic Graphical Model1",
    "authors" : [ "Christopher J.C. Burges", "Erin Renshaw" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "system. As a first step we have developed a system that uses text-based dialog to derive a model of the user’s family relations. The system leverages its world model to infer relational triples, to learn to recover from upstream coreference resolution errors and ambiguities, and to learn context-dependent paraphrase models. We also explore some theoretical aspects of the underlying graphical model."
    }, {
      "heading" : "Introduction",
      "text" : "Recently we listed some desiderata that appear to us to be sensible design principles in the quest to develop\nthe machine comprehension of text [1]. We summarize them here:\n1. Inference should leverage world models which are kept\n2. as simple as possible such that\n3. they can be combined in a modular fashion. This should help us keep the design\n4. scalable, in three senses: learning time, inference time, and portability to arbitrary domains. Learning\nshould be\n5. correctable, so that mistakes the system makes can be corrected without introducing new mistakes\nelsewhere,\n6. interpretable, so that for example developers can easily understand what inferences the system has\nmade, and all the reasoning it has done,\n7. generative, so that the system can ask the user for more information about the data it would benefit\nmost from knowing, and\n8. interrogable, so that the user can ask if the system believes something and get an answer in real time.\n(1) and (2) are uncontroversial: a world model is often needed to resolve ambiguities in language. For\nexample, in the sentence Sam is my father and I have a brother named Sam, a family relations model is needed\nto infer that the two Sams must refer to different entities. Regarding (3), modularity, and composability of\nthose modules, is a fundamental principle of software design but is also expected to be a key design principle\nfor large semantic models [2]. (4), especially portability, is an open research question. (5) is a key property that\ndistinguishes human learning from machine learning (ML). Most ML approaches do not address this issue at\nall. Errors are corrected by adding more training data, or by designing better features, or by finding a better\nmodel, but all of these approaches will in general introduce new errors on the original data; a human analog\nwould be that one consequence of learning to ride a bicycle is that a child forgets how to brush his teeth. In\nthis sense (3) is not addressed by ML either: a human analog would be a teacher correcting a student’s\nmisunderstanding by locking him in a library with terabytes of data for a week and asking him to update his\nparameters. Instead, the teacher can correct the student’s misunderstanding by exchanging a small number of\n1 This work will appear in the 2014 NIPS Workshop on Learning Semantics.\nbits of information, correcting a specific component (module) of the student’s world model. It seems unlikely\nthat the brain is moving global decision surfaces around in some high dimensional space. This also argues\nstrongly for (1), i.e. a rich shared world model, which even allows entities to model each others’ models. ML\nmodels (neural nets, trees, ensembles of these, and even moderately sized probabilistic graphical models) are\nnot easily interpretable (see for example [3]): in general we do not understand why our statistical systems make\nthe errors they do. ML achieves (7) to some extent through active learning, but not in the sense of maximally\nreducing the uncertainty in a semantic world model. Similarly while ML approaches (8) by simply applying the\nmodel to unseen data, it does not do so in a modular fashion, so that for example there are no semantic\ncomponents in the model that we can interrogate individually.\nThe approach described here, although only a preliminary step, meets all these desiderata except for (4), which we hope to investigate as the models grow in complexity. We call our simple world models meaning projections, where a given meaning projection extracts meaning about one, or a very few, aspects of a piece of text (for example, spatial information about the entities involved), and can interact with other meaning projections to both correct upstream errors (for example, coreference resolution) and to make its own inferences. The idea is roughly analogous to the “agents” in Minsky’s Society of Mind [4]. Our first step, as outlined in this paper, is a dialog system2 that maps English text to model family relations. The work can be viewed as a semantic modeling analog of Blocks World [4,5], in that it takes a simple task and uses it to explore the ideas. Although the machine is learning, there is currently no statistical machine learning involved;\nrather than using probabilistic graphical models, uncertainties are modeled using graphs and sets, and\nrobustness is achieved by carefully tracking the sources of the uncertainty and polling the user directly when\nnecessary. Clearly statistical methods will need to be added at some point, and one goal of this research is to\nunderstand how to incorporate them while meeting the above desiderata. Here, we concentrate on an approach called possibilistic graphical models3 (pGMs) that are a simple instantiation of classical relational logic\n[6], but with data structures chosen to meet the above desiderata. The uncertainty in the model is exposed\nexplicitly and actionably. While logic problems involving family relations have been given as homework\nexercises since the beginning of AI, we’ve found it a useful test bed to focus on, in particular to generate dialog\ndriven by the uncertainty in the model, and to explore growing and correcting the model through dialog."
    }, {
      "heading" : "A Possibilistic Graphical Model",
      "text" : "We explain pGMs by describing how we use them to model family relations. Assume that we are given a set of \uD835\uDC5B animate entities (“AEs”) (usually, but not necessarily, people4), denoted below by \uD835\uDC38\uD835\uDC56 , \uD835\uDC56 = 1, … , \uD835\uDC5B. Each AE has an associated name and gender which may or may not be known. The AEs are not necessarily unique: for example, upstream natural language processing may have in error separated entities which are in fact the same. It is also possible that what is presented to the system as a single AE may in fact refer to more than one, due to upstream coreference resolution errors: the system can also (often) detect and correct these kinds of error. The pGM is a directed multigraph with a node for each AE and an edge set for the possible relations between those two AEs. Thus an edge set represents our current state of knowledge about the possible relations that could hold for the two endpoints: it is assumed that exactly one of the relations is correct, but we do not know which. The pGM grows as more entities are encountered in the text, and its\n2 A demo of the system will be presented at the workshop. 3 We use pGM to emphasize that possibilistic graphical models are precursors to probabilistic GMs (PGMs). 4 For example when modeling fiction, one might have to model the fact that objects which in the real world are inanimate are treated in the text as though they are animate, with gender, name, mood, etc.\nedge sets shrink (to a minimum cardinality of one) as more information concerning its entities is discovered. Our pGM is populated from binary predicates (we use the term “relations” interchangeably), for example Mother(Anne,Bill), derived from natural text using a few simple pattern matching rules; from unary predicates (e.g. IsFemale(Anne)) derived using Census data and user input; and consistency rules, such as gender propagation (where for example spouseOf would be resolved to wifeOf if its first argument is discovered to be female5; the second argument would be set to male; the outgoing relations of the latter might then be resolved from parentOf to fatherOf; and so on). While this graph constitutes our evolving knowledge base, we also use a (hand crafted) fixed knowledge base matrix \uD835\uDC40 that captures relations between relations. Both rows and columns of \uD835\uDC40 are indexed by a relation, which is a member of the fixed set of relations ℝ that we wish to model. Our current system has ℝ = {Grandparent, Parent, Parent-in-Law, Spouse, Sibling, Sibling-in-Law, Child, Child-in-Law, Grandchild, Aunt or Uncle, Niece or Nephew, Cousin, Self, OutOfGraph} together with the gender specific versions of these. We will denote any subset of ℝ by ℛ and an individual element by \uD835\uDC45. Self is used to model the fact that some entities that are passed to the system as different may in reality be the same (thus enabling the system to correct coreference errors). OutOfGraph, which we denote below by \uD835\uDC450, is necessary to model the fact that we know that an induced relation may not be in the fixed knowledge base.\nThe graph encodes relations as follows. Let ℛ\uD835\uDC56\uD835\uDC57 be a set of relations such that for exactly one element \uD835\uDC45 ∈ ℛ\uD835\uDC56\uD835\uDC57, we have that \uD835\uDC45(\uD835\uDC38\uD835\uDC56 , \uD835\uDC38\uD835\uDC57) = \uD835\uDC47; we do not know which element this is, unless |ℛ\uD835\uDC56\uD835\uDC57| = 1. These sets of relations are captured in a matrix \uD835\uDC40 such that \uD835\uDC40\uD835\uDC451\uD835\uDC452 = ℛ 12, which we also write, for any entities \uD835\uDC381, \uD835\uDC382, \uD835\uDC383, as\n\uD835\uDC45(1)(\uD835\uDC381, \uD835\uDC382) ∧ \uD835\uDC45 (2)(\uD835\uDC382, \uD835\uDC383) → ℛ (12)(\uD835\uDC381, \uD835\uDC383) (1)\nSometimes the set ℛ(12) will be a singleton (e.g. Parent(\uD835\uDC34, \uD835\uDC35) ∧ Sibling(\uD835\uDC35, \uD835\uDC36) → Parent(\uD835\uDC34, \uD835\uDC36)), but it need not be (e.g. Cousin(\uD835\uDC34, \uD835\uDC35) ∧ Cousin(\uD835\uDC35, \uD835\uDC36) → ℛ(\uD835\uDC34, \uD835\uDC36) where ℛ = {Cousin, Self, Sibling, \uD835\uDC450}). Every relation is assumed to have a unique inverse: that is, for any \uD835\uDC381 and \uD835\uDC382, and for every predicate \uD835\uDC45, there is a unique predicate \uD835\uDC45−1 : \uD835\uDC45(\uD835\uDC381, \uD835\uDC382) ⇔ \uD835\uDC45 −1(\uD835\uDC382, \uD835\uDC381). Thus (1) also implies the set ℛ (21)(\uD835\uDC383, \uD835\uDC381) which is in 1-1 correspondence with the set ℛ(12)(\uD835\uDC381, \uD835\uDC383) and where each element of ℛ (21) is the inverse of an element in ℛ(12). We use ℛ\uD835\uDC56\uD835\uDC57 to denote the set of edges from node \uD835\uDC38\uD835\uDC56 to node \uD835\uDC38\uD835\uDC57 and ℛ\uD835\uDC57\uD835\uDC56 to denote the corresponding set of inverse edges. Equation (1) may also be written with sets on the left, in which case the\nright hand side is the union of all such implications: that is, we use \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57, ℛ\uD835\uDC57\uD835\uDC58) as shorthand for ⋃ \uD835\uDC40(\uD835\uDC451, \uD835\uDC452)\uD835\uDC451∈ℛ\uD835\uDC56\uD835\uDC57,\uD835\uDC452∈ℛ\uD835\uDC57\uD835\uDC58 .\nGraphs are always either fully connected, or are composed of fully connected subgraphs. There are two kinds of updates. The first takes an existing graph, updates one of the edges by reducing its multiplicity (to at least one), and propagates the inferred edge set reductions, recursively. Thus suppose that we have a 3- clique6 ℛ\uD835\uDC56\uD835\uDC57, ℛ\uD835\uDC57\uD835\uDC58, ℛ\uD835\uDC56\uD835\uDC58, and that new information leads us to replace ℛ\uD835\uDC56\uD835\uDC57 by ℛ\uD835\uDC56\uD835\uDC57 ′ ⊂ ℛ\uD835\uDC56\uD835\uDC57. For example, if ℛ12 = {Cousin, Sibling, Self, \uD835\uDC450}, then one initial update might be that we have learned that \uD835\uDC381 is not the self of \uD835\uDC382. The first step of the recursion is then either to replace ℛ\uD835\uDC56\uD835\uDC58 by ℛ\uD835\uDC56\uD835\uDC58 ′ ≔ \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 ′ , ℛ\uD835\uDC57\uD835\uDC58) ∩ ℛ\uD835\uDC56\uD835\uDC58, or to replace ℛ\uD835\uDC57\uD835\uDC58 by ℛ\uD835\uDC57\uD835\uDC58 ′ ≔ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56, ℛ\uD835\uDC56\uD835\uDC58) ∩ ℛ\uD835\uDC57\uD835\uDC58 (we prove below that it doesn’t matter which we do first). The second kind\n5 The system currently models “traditional” family structures to keep the analysis simple. Relations resulting from, for example, same sex marriages, or step-relations, are easily added. 6 We use the term “3-clique” rather than “triangle” because the structure is more general than a geometric construct.\nof update is when an edge is added to join previously disconnected graphs, which after applying inference results in a single fully connected graph. One can think of any relation as always being added or removed simultaneously with its inverse relation.\nWe emphasize that inference in this system is simply using relational logic [6]. Our intent here is to examine data structures that support the above desiderata, in particular correctability and interpretability, through the ability to track uncertainty explicitly, efficiently and actionably. Thus, for example, a pGM yields all possible relations between any two entities by simply examining the edge set connecting those two entities. To this end we provide some analysis of pGMs here.\nDefinition 1: We overload the → symbol as follows: for any two edges \uD835\uDC451, \uD835\uDC452 from different edge sets and which join at node \uD835\uDC38 in a 3-clique, we write \uD835\uDC451 → \uD835\uDC452 to mean that there exists an \uD835\uDC45 from the third edge set (or its inverse) such that the following holds: for \uD835\uDC451, \uD835\uDC452 both terminating on \uD835\uDC38, \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC45, \uD835\uDC451); for both \uD835\uDC451 and \uD835\uDC452 starting at \uD835\uDC38, \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC451, \uD835\uDC45); for \uD835\uDC451 ending at \uD835\uDC38 and \uD835\uDC452 starting there, \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC451 −1, \uD835\uDC45); and for \uD835\uDC451 starting at \uD835\uDC38 and \uD835\uDC452 ending there, \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC45, \uD835\uDC451 −1). We read \uD835\uDC451 → \uD835\uDC452 as “\uD835\uDC451 supports \uD835\uDC452” and we define \uD835\uDC45 → ℛ to mean that every edge in ℛ is supported by \uD835\uDC45, and ℛ1 → ℛ2 to mean that every edge in ℛ2 is supported by at least one edge in ℛ1.\nNote that the empty set is supported by any pair of relations. Note also that if \uD835\uDC45 is supported by another edge in a 3-clique, it does not mean that \uD835\uDC45 must occur, just that its occurrence is not inconsistent with the other edges in the clique.\nDefinition 2: A 3-clique with (different) vertex indices \uD835\uDC4E, \uD835\uDC4F, \uD835\uDC50 ∈ ℕ is stable if \uD835\uDC45\uD835\uDC56\uD835\uDC57 ⊆ \uD835\uDC40(\uD835\uDC45\uD835\uDC56\uD835\uDC58 , \uD835\uDC45\uD835\uDC58\uD835\uDC57) ∀ {\uD835\uDC56, \uD835\uDC57, \uD835\uDC58} ∈ \uD835\uDC43\uD835\uDC45\uD835\uDC40{\uD835\uDC4E, \uD835\uDC4F, \uD835\uDC50}, that is, if every edge set is supported by the other two. A fully-connected graph is stable if all of its three-cliques are stable.\nNote that, given the definition of the inverse of an edge, and since \uD835\uDC40 is just the encapsulation of the logical assertion (1), we have that \uD835\uDC40(\uD835\uDC451, \uD835\uDC452) = ℛ3 ⟺ \uD835\uDC40(\uD835\uDC452 −1, \uD835\uDC451 −1) = ℛ3 −1. That is, for predicates \uD835\uDC5D\uD835\uDC56, if \uD835\uDC5D1 ∧ \uD835\uDC5D2 ⇒ \uD835\uDC5D3 ∨ \uD835\uDC5D4 ∨ … ∨ \uD835\uDC5D\uD835\uDC5B and if \uD835\uDC5D\uD835\uDC56 ⇔ \uD835\uDC5E\uD835\uDC56 then \uD835\uDC5E1 ∧ \uD835\uDC5E2 ⇒ \uD835\uDC5E3 ∨ \uD835\uDC5E4 ∨ … ∨ \uD835\uDC5E\uD835\uDC5B, where here the predicates \uD835\uDC5D are the relations and the predicates \uD835\uDC5E, their inverses. Note also that since an edge set ℛ\uD835\uDC56\uD835\uDC57 is supported by ℛ\uD835\uDC56\uD835\uDC58 and ℛ\uD835\uDC58\uD835\uDC57 iff ℛ\uD835\uDC57\uD835\uDC56 is supported by ℛ\uD835\uDC57\uD835\uDC58 and ℛ\uD835\uDC58\uD835\uDC56, we can compute support by going either way around the clique.\nAxioms:\nA1. No element of \uD835\uDC40 is the empty set (every pair of edges has implications). A2. Every individual relation, including \uD835\uDC450, has a unique inverse. A3. Consistency conditions: let us assume that \uD835\uDC40(\uD835\uDC451, \uD835\uDC452) = ℛ3. From A1, ℛ3 is non-empty. Then:\na. ∀ \uD835\uDC45 ∈ ℛ3, \uD835\uDC451 ∈ \uD835\uDC40(\uD835\uDC45, \uD835\uDC452 −1) and \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC451 −1, \uD835\uDC45). b. ∀ \uD835\uDC45−1 ∈ ℛ3 −1, \uD835\uDC452 −1 ∈ \uD835\uDC40(\uD835\uDC45−1, \uD835\uDC451) and \uD835\uDC451 −1 ∈ \uD835\uDC40(\uD835\uDC452, \uD835\uDC45 −1).\nA3 (a) is a consistency condition because if it were not so, then given \uD835\uDC451 and \uD835\uDC452, the resulting set \uD835\uDC40(\uD835\uDC451, \uD835\uDC452) could be reduced to a single edge (for example, by the addition of new information) that implies the absence of \uD835\uDC451 or of \uD835\uDC452. Similarly, if A3 (b) were not so, then the edge set \uD835\uDC40(\uD835\uDC452 −1, \uD835\uDC451 −1) could be reduced to a single edge that implied the removal of \uD835\uDC451 −1 or \uD835\uDC452 −1.\nLemma 1: Joining nodes 1 and 3 by adding an edge set ℛ13, computed as ℛ12 ∧ ℛ23, does not have the consequence of reducing the existing edge sets ℛ12 and ℛ23. Proof: This follows directly from axiom A3. □\nLemma 2: For a given 3-clique, suppose that \uD835\uDC451 belongs to one edge set and \uD835\uDC452 to another. Then \uD835\uDC451 → \uD835\uDC452 if and only if \uD835\uDC452 → \uD835\uDC451. Proof: Clearly \uD835\uDC451 and \uD835\uDC452 belong to adjacent edge sets. Let their mutual node by \uD835\uDC34. There are three possible situations: \uD835\uDC451 and \uD835\uDC452 both end on \uD835\uDC34, \uD835\uDC451 and \uD835\uDC452 both start at \uD835\uDC34, or one starts and one ends on \uD835\uDC34 (these two are made equivalent by relabeling). If both end on \uD835\uDC34, then \uD835\uDC451 → \uD835\uDC452 means that there exists an \uD835\uDC453 on the remaining edge such that \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC453, \uD835\uDC451). By A3 we have that \uD835\uDC451 ∈ \uD835\uDC40(\uD835\uDC453 −1, \uD835\uDC452) so \uD835\uDC452 → \uD835\uDC451. Symmetry and swapping labels 1 ⟷ 2 shows that similarly, \uD835\uDC452 → \uD835\uDC451 implies \uD835\uDC451 → \uD835\uDC452. If both start on A, then (\uD835\uDC451 → \uD835\uDC452) ⇒ ∃\uD835\uDC453 ∶ \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC451, \uD835\uDC453) and by A3, \uD835\uDC451 ∈ \uD835\uDC40(\uD835\uDC452, \uD835\uDC453 −1) or \uD835\uDC452 → \uD835\uDC451. Symmetry again gives the converse result. Finally suppose that \uD835\uDC451 ends on \uD835\uDC34 and \uD835\uDC452 begins on \uD835\uDC34. Then (\uD835\uDC451 → \uD835\uDC452) ⇒ ∃\uD835\uDC453 ∶ \uD835\uDC452 ∈ \uD835\uDC40(\uD835\uDC451 −1, \uD835\uDC453) and by"
    }, {
      "heading" : "A3, \uD835\uDC451",
      "text" : "−1 ∈ \uD835\uDC40(\uD835\uDC452, \uD835\uDC453 −1) or \uD835\uDC452 → \uD835\uDC451 since \uD835\uDC451 has unique inverse that also holds. Similarly (\uD835\uDC452 → \uD835\uDC451) ⇒\n∃\uD835\uDC453 ∶ \uD835\uDC451 ∈ \uD835\uDC40(\uD835\uDC453, \uD835\uDC452 −1) and by A3, \uD835\uDC452 −1 ∈ \uD835\uDC40(\uD835\uDC453 −1, \uD835\uDC451) so \uD835\uDC451 → \uD835\uDC452 . □\nNote that Lemma 2 does not assume that the clique is stable.\nThe → relation is thus symmetric at the single edge level: support is mutual. A weaker (non-symmetric) condition holds for the mapping from an edge to an edge set:\nLemma 3: For a 3-clique with edge set ℛ\uD835\uDC56\uD835\uDC57, let \uD835\uDC45 ∈ ℛ\uD835\uDC56\uD835\uDC57. Then \uD835\uDC45 → ℛ implies ℛ → \uD835\uDC45. Proof: \uD835\uDC451 → ℛ means that ∀\uD835\uDC452 ∈ ℛ, \uD835\uDC451 → \uD835\uDC452. By lemma 2 we have that \uD835\uDC452 → \uD835\uDC451 ∀\uD835\uDC452 ∈ ℛ which is also written as ℛ → \uD835\uDC45. □\nThe assertions in Lemmas 2 and 3 do not extend to general subsets. For example, for edge \uD835\uDC45 and edge set ℛ, it is not necessarily true that ℛ → \uD835\uDC45 implies that \uD835\uDC45 → ℛ since ℛ may be a superset of the edges supported by \uD835\uDC45. A fortiori, for two edge sets ℛ and \uD835\uDCAE, ℛ → \uD835\uDCAE does not necessarily imply that \uD835\uDCAE → ℛ.\nThe lemmas and theorems below assume that we start with a stable 3-clique.\nLemma 4: Suppose that a 3-clique has some edge set ℛ with subset ℛ′, and another edge set \uD835\uDCAE with subset \uD835\uDCAE’. Then removal of ℛ’ implies removal of \uD835\uDCAE’ if and only if \uD835\uDCAE’ only supports edges in ℛ’. Proof: If \uD835\uDCAE’ supports only edges in ℛ’, then it does not support any edges in ℛ ∖ ℛ′ and hence, since support is mutual, \uD835\uDCAE’ is not supported by any edges in ℛ ∖ ℛ′; hence removal of ℛ’ implies removal of \uD835\uDCAE’. If on the other hand the removal of ℛ’ implies the removal of \uD835\uDCAE’, then there are no edges in ℛ ∖ ℛ′ that support \uD835\uDCAE’, and since support is mutual there are no edges in \uD835\uDCAE’ that support ℛ ∖ ℛ′, that is, \uD835\uDCAE’ only supports edges in ℛ’. □\nDenoting the removal of some set \uD835\uDCAE by \uD835\uDC5F\uD835\uDC52\uD835\uDC5A(\uD835\uDCAE), again the generalization to arbitrary sets does not hold for removal: that is, given \uD835\uDC5F\uD835\uDC52\uD835\uDC5A(\uD835\uDCAE) → \uD835\uDC5F\uD835\uDC52\uD835\uDC5A(\uD835\uDC451), it may not be the case that \uD835\uDC5F\uD835\uDC52\uD835\uDC5A(\uD835\uDC451) → \uD835\uDC5F\uD835\uDC52\uD835\uDC5A(\uD835\uDCAE) since \uD835\uDCAE may contain elements not implied by \uD835\uDC451.\nLemma 5: Suppose that removal of \uD835\uDC45 ∈ ℛ\uD835\uDC56\uD835\uDC57 implies the removal of \uD835\uDCAE: that is, ∀ \uD835\uDC46 ∈ \uD835\uDCAE, \uD835\uDC46 ∈ \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 , ℛ\uD835\uDC57\uD835\uDC58) and \uD835\uDC46 ∉ \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 ∖ \uD835\uDC45, ℛ\uD835\uDC57\uD835\uDC58). This alone cannot result in the removal of another edge \uD835\uDC45′ ∈ ℛ\uD835\uDC56\uD835\uDC57. Proof: By Lemma 4, removal of \uD835\uDCAE can result in the removal of \uD835\uDC45′ only if \uD835\uDC45′ supports some edges in \uD835\uDCAE. But if so\nthen ∃\uD835\uDC46 ∈ \uD835\uDCAE ∶ \uD835\uDC46 ∈ \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 ∖ \uD835\uDC45, ℛ\uD835\uDC57\uD835\uDC58). □\nLemma 6: Suppose that, for a given 3-clique \uD835\uDC36 with nodes {\uD835\uDC56, \uD835\uDC57, \uD835\uDC58}, and given arbitrary edge sets ℛ\uD835\uDC56\uD835\uDC57 and ℛ\uD835\uDC57\uD835\uDC58, we set ℛ\uD835\uDC56\uD835\uDC58 = \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57, ℛ\uD835\uDC57\uD835\uDC58). Then all resulting implications in \uD835\uDC36 result in no changes to any edge in \uD835\uDC36. Proof: Consider the set \uD835\uDCAE\uD835\uDC56\uD835\uDC57 ≔ \uD835\uDC40(\uD835\uDC45\uD835\uDC56\uD835\uDC58 , \uD835\uDC45\uD835\uDC58\uD835\uDC57). There can be no edge \uD835\uDC45 ∈ ℛ\uD835\uDC56\uD835\uDC57 such that \uD835\uDC45 ∉ \uD835\uDCAE\uD835\uDC56\uD835\uDC57 since by Axiom 1, such an \uD835\uDC45 would support at least one relation in ℛ\uD835\uDC56\uD835\uDC58, and by Lemma 2, that relation supports \uD835\uDC45; hence ℛ\uD835\uDC56\uD835\uDC57 ⊆ \uD835\uDC40(\uD835\uDC45\uD835\uDC56\uD835\uDC58 , \uD835\uDC45\uD835\uDC58\uD835\uDC57). Similarly consider \uD835\uDCAE\uD835\uDC57\uD835\uDC58 ≔ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56 , ℛ\uD835\uDC56\uD835\uDC58). There can be no edge \uD835\uDC45 ∈ ℛ\uD835\uDC57\uD835\uDC58 such that \uD835\uDC45 ∉ \uD835\uDCAE\uD835\uDC57\uD835\uDC58 because by Axioms 1 and 2, \uD835\uDC45−1 would support at least one relation in ℛ\uD835\uDC58\uD835\uDC56, and by Lemma 2, that relation would accept \uD835\uDC45−1; hence ℛ\uD835\uDC57\uD835\uDC58 ⊆ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56, ℛ\uD835\uDC56\uD835\uDC58). □\nWe now address the question of efficiently computing the full set of resultant edges in a clique when some edges are removed (due, for example, to the availability of new information). The figure below shows that reductions in one set of edges can induce reductions in another, which can then induce reductions in the third: can this process continue? (In other words, must we recurse to completion?) The following theorem shows that the answer is no.\nTheorem 1: Given a stable 3-clique, represent its edge sets by ℛ\uD835\uDC56\uD835\uDC57, ℛ\uD835\uDC57\uD835\uDC58, ℛ\uD835\uDC56\uD835\uDC58. Suppose that one or more edges are removed from ℛ\uD835\uDC56\uD835\uDC57 to give a new edge set ℛ\uD835\uDC56\uD835\uDC57 ′ . Suppose that ℛ\uD835\uDC56\uD835\uDC58 is updated via ℛ\uD835\uDC56\uD835\uDC58 ′ = \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 ′ , ℛ\uD835\uDC57\uD835\uDC58) ∩ ℛ\uD835\uDC56\uD835\uDC58, and that ℛ\uD835\uDC57\uD835\uDC58 is then updated via ℛ\uD835\uDC57\uD835\uDC58 ′ = \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56 ′ , ℛ\uD835\uDC56\uD835\uDC58 ′ ) ∩ ℛ\uD835\uDC57\uD835\uDC58. Then these changes in ℛ\uD835\uDC57\uD835\uDC58 and ℛ\uD835\uDC56\uD835\uDC58 do not induce any further changes in the clique, the resulting clique is stable, and the result does not depend on the order of operations (that is, the result is the same if ℛ\uD835\uDC57\uD835\uDC58 is updated first and ℛ\uD835\uDC56\uD835\uDC58 second).\nProof: Let \uD835\uDCAE\uD835\uDC56\uD835\uDC57 = ℛ\uD835\uDC56\uD835\uDC57 ∖ ℛ\uD835\uDC56\uD835\uDC57 ′ .denote the set of edges removed from ℛ\uD835\uDC56\uD835\uDC57. Let \uD835\uDCAE\uD835\uDC56\uD835\uDC58 denote the set of edges that are not supported by ℛ\uD835\uDC56\uD835\uDC57 ′ (that is, \uD835\uDCAE\uD835\uDC56\uD835\uDC58 is the maximal set such that \uD835\uDCAE\uD835\uDC56\uD835\uDC58 ⊂ ℛ\uD835\uDC56\uD835\uDC58 and \uD835\uDCAE\uD835\uDC56\uD835\uDC58 ∩ \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 ′ , ℛ\uD835\uDC57\uD835\uDC58) = ∅) so that the removal of \uD835\uDCAE\uD835\uDC56\uD835\uDC57 implies the removal of \uD835\uDCAE\uD835\uDC56\uD835\uDC58. Similarly let \uD835\uDCAE\uD835\uDC57\uD835\uDC58 denote the set of edges that are simultaneously not supported by ℛ\uD835\uDC56\uD835\uDC57 ′ (that is, \uD835\uDCAE\uD835\uDC57\uD835\uDC58 is the maximal set such that \uD835\uDCAE\uD835\uDC57\uD835\uDC58 ⊂ ℛ\uD835\uDC57\uD835\uDC58 and \uD835\uDCAE\uD835\uDC57\uD835\uDC58 ∩ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56 ′ , ℛ\uD835\uDC56\uD835\uDC58) = ∅) so that the removal of \uD835\uDCAE\uD835\uDC56\uD835\uDC57 implies the removal of \uD835\uDCAE\uD835\uDC57\uD835\uDC58. Also define ℛ\uD835\uDC57\uD835\uDC58 ′ ≔ ℛ\uD835\uDC57\uD835\uDC58 ∖ \uD835\uDCAE\uD835\uDC57\uD835\uDC58 and ℛ\uD835\uDC56\uD835\uDC58 ′ ≔ ℛ\uD835\uDC56\uD835\uDC58 ∖ \uD835\uDCAE\uD835\uDC56\uD835\uDC58. Now suppose that there were an edge \uD835\uDC45 ∈ ℛ\uD835\uDC57\uD835\uDC58 ′ whose removal is implied by the reduced set ℛ\uD835\uDC56\uD835\uDC58 ′ , that is, \uD835\uDC45 ∉ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56 ′ , ℛ\uD835\uDC56\uD835\uDC58 ′ ). Then since \uD835\uDC45 ∈ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56 ′ , ℛ\uD835\uDC56\uD835\uDC58) we must have that \uD835\uDC45 ∈ \uD835\uDC40(ℛ\uD835\uDC57\uD835\uDC56 ′ , \uD835\uDCAE\uD835\uDC56\uD835\uDC58), and by lemma 2, this means that ∃\uD835\uDC46 ∈ \uD835\uDCAE\uD835\uDC56\uD835\uDC58 such that \uD835\uDC45 supports \uD835\uDC46, that is, \uD835\uDC46 ∈ \uD835\uDC40(ℛ\uD835\uDC56\uD835\uDC57 ′ , \uD835\uDC45), which contradicts the assumption that ℛ\uD835\uDC56\uD835\uDC57 ′ does not support \uD835\uDCAE\uD835\uDC56\uD835\uDC58. A similar argument shows that the reduced set ℛ\uD835\uDC57\uD835\uDC58 ′ does not result in further removals from ℛ\uD835\uDC56\uD835\uDC58 ′ . Similarly there can be no unsupported edge \uD835\uDC45 in ℛ\uD835\uDC56\uD835\uDC57 ′ since if there were, one of the removed edges must have supported \uD835\uDC45, since the original clique was stable, and by lemma 4, that edge must have been supported by \uD835\uDC45 and would not have been removed. Hence the order of removals does not matter, every remaining edge is supported, and so the resulting clique is stable. □"
    }, {
      "heading" : "Natural Language Processing",
      "text" : "We turn now to briefly describe the NLP pipeline we use for our prototype, which currently forms a model of the user’s family relations through dialog, and uses pGMs to track uncertainty and to generate questions. We use three systems: SPLAT, a publically available NLP toolkit [7]; NLPLib, an internal NLP toolkit that uses the averaged perceptron algorithm [8] trained on the part of speech and constituency tree tags and data in OntoNotes Release 4.0 [9], which we used for entity detection [10]; and the Stanford natural language system for labeled dependency trees and coreference resolution [11]. Text is broken into sentences and tokenized. Part of speech tags are added, and the tokens lemmatized. The (labeled) dependency tree is computed. A parse into “chunks” is performed using SPLAT, and named entities are found using NLPLib. Finally the Stanford system is used to generate coreference chains based on the full passage. We then identify nouns, names, pronouns, mentions (which we define as names, pronouns or noun phrases that could be referred to elsewhere in the text), family relations (triggered by tokens such as father, daughter etc.), entities (whose name and gender may or may not be defined at this point), and relation triples, again using simple patterns such as “My father is named Sam”. The names are identified through combining the named entities identified by NLPLib, 1990 census data, and text patterns, such as [animate possessive] [is] [named/called] NAME. Gender identification is done using census data: if a name appears exclusively on the male or female list, it is identified as such; if it is ten times more frequent on one list, it is marked ”probably” male/female (this information is used solely to tune the dialog generation); and all other names are left unidentified.\nRelation mentions are used to find the relations, taking into account common synonyms. Hypothesized entities are formed from the mentions, and we use the Stanford coreference resolver to group mentions. A special entity is reserved for the narrator of the story, if there is one; gender, name and narrator state are assigned from the mentions, if available. Finally relation triples are formed from pairs of entities together with adjoining relations.\nZ3 The problem of modeling family relations is well suited for first-order logic solvers. We used Z3 to compare this process with using pGMs. Z3 is an open source, SMT-solving theorem prover created at Microsoft7. We wrote a set of assertions that governs family relations in general, for example:\n(and (CousinOf a b) (CousinOf b c)) => (or (SiblingOf a c) (SelfOf a c) (CousinOf a c) (OutOfGraph a c))\nWe then wrote a second set of assertions containing the relations that are asserted in the text. Z3 was then used to check that the union of the two sets of assertions is satisfiable. When a solution exists, Z3 returns a satisfying variable assignment; otherwise it declares that none exists.\nAs it stands, the “out of the box” solution returned by Z3 is not easily interpretable. Many assignments are returned which combine relations with logical operators. Only the first order positive relations [e.g. (SonOf Jack John)] are easily interpretable. Furthermore, often the extracted facts lead to multiple possible solutions, of which Z3 returns only one. Additional solutions can be obtained by explicitly excluding solutions found so far, and iteratively ask for another one; but Z3 does not give direct information as to where the uncertainties lie, and so the knowledge returned by the solver could not be used to drive dialog with the user, at least directly. However, Z3 is a powerful solver and we will continue to seek to incorporate it as part of the solution, especially if the logic involved becomes more complex than discussed here."
    }, {
      "heading" : "Error Correction and Language Learning",
      "text" : "Our prototype can correct upstream NLP errors and ambiguities both automatically and with the help of the user. For example, in the sentence My brother is named Bill and my father is named Bill, the Stanford systems incorrectly identifies the two Bills as referring to the same entity; our system automatically detects that this cannot be the case and corrects the error (note that this is a simple example of a world model being required for coreference resolution; in the sentence My father is named Bill and my mother’s husband is named Bill, the two Bills are coreferent, despite the similar sentence structure). Similar reasoning can be used to resolve ambiguities such as His in John's dad was named Carl. His wife was named Theresa. In terms of error correction through dialog, an example is as follows: when presented with the sentence I have a daughter. My daughter's name is Susan., the coreference fails to identify daughter with Susan; the system asks for the name of the daughter, and if told Susan, will ask if the two Susans are the same person, and if given the answer Yes (or equivalent, see below), it will correct the coreference error.\nSimilar ideas can be used to learn common paraphrases. For example, if the system asks a yes/no question and receives the answer Indeed!, then it tells the user that it does not understand Indeed!, and asks the same question again. If the user then answers Yes, the system has learnt both the answer to the question, and the fact that in the context of a yes/no question, Indeed! means the same thing as Yes. We have used this idea to gather paraphrase data for the answers to several different question types. It is important however that the context be tracked: for example, the user may write Susan is indeed my daughter when asked Is Susan your daughter?, which only is equivalent to Yes in the specific context of that question. Thus the system would log that if the question is Is X your daughter, and the answer is X is indeed my daughter, then the latter means Yes, for any X. Clearly this idea will enable powerful paraphrase learning when crowdsourced in a personal\n7 Available at: http://z3.codeplex.com/\nassistant. Some care will need to be taken to weed out spam, but this can likely be done by relying on the fact that most spammers do not collude.\nHowever, the system’s main goal is to reduce uncertainty through dialog. It accomplished this by finding which edge sets in the pGM have more than one element, and then asking the user which relation holds. Clearly this could be made more natural by asking about edge sets that are close in the graph to the narrator’s node, and could be made more efficient by finding that edge set whose reduction to a single edge would maximally reduce the collective cardinality of the edge sets throughout the graph."
    }, {
      "heading" : "Discussion",
      "text" : "The main goals of this work were twofold: first, to explore the issues of correctability and interpretability of learned models, using dialog as the main source of new information; and second, to embark on our exploration of using meaning projections in general, to model the semantics of text. The requirement of the explicit, efficient and actionable modeling of uncertainty led us to introduce possibilistic graphical models, which provide a simple way to track and update uncertainty to the finest granularity; and to adhere to these desiderata, we have so far avoided using statistical techniques. One very interesting research direction therefore is how to include statistical techniques as needed, in such a way as to maintain these desiderata. The meaning projections we used were low level entity detection, coreference resolution and name detection, and a high level family relations projection. We chose the latter as a first step because it is so well studied and because the relational structure is logical and clear. Of course we are not claiming that modeling family relations from text is itself of research interest (although it may be of practical interest, to automated personal assistants); but this task provided us with a clean test bed for the ideas, and we showed for example that indeed, the family relations projection could be used to correct NLP errors, either automatically or with the help of the user.\nMeaning projections can also be largely data driven. As an example, we have built a noun number projection, using Wiktionary. This is a surprisingly nontrivial task. For example, in the sentence My family is very large, and tonight they are all coming to dinner, the noun family is treated as singular in the first part of the sentence and plural in the second, yet the sentence is grammatically correct. Committing to family being either singular or plural can thus lead to coreference errors. We parsed Wiktionary to determine which nouns are definitely singular, which are definitely plural, and which are indefinite. For example, water, although non-countable, is singular and has the definite plural waters, but sheep and cannon are both indefinite; and there are plural nouns with no singular form (for example, People of Spain), and singular nouns with no plural (for example, Computer Graphics), which are also detected. This is a very simple projection, and there are many interesting ways in which large datasets can help with more complex projections. For a particularly elegant example of using the statistics of large datasets to solve what is otherwise a thorny coreference problem, see [12]. We plan to extend these ideas, using for example ClueWeb [13], to help meaning projections to find the patterns they need, automatically.\nThe main question facing us now is: how to extend the work to include more meaning projections, in such a way that the process is scalable? In fact family relations is one of the more complex examples; one might, for example, model spatial relations with ℝ = {\uD835\uDC65 < 10, 10 ≤ \uD835\uDC65 < 1\uD835\uDC522, 1\uD835\uDC522 ≤ \uD835\uDC65 < 1\uD835\uDC523, 1\uD835\uDC523 ≤ \uD835\uDC65 < 1\uD835\uDC524, \uD835\uDC65 ≥ 1\uD835\uDC524} where \uD835\uDC65 is the distance in feet between two entities and bounds are chosen to approximately model \uD835\uDC381 being within the {same room, same building, same block, same town, same universe} as \uD835\uDC382. Even simple\nprojections could benefit from these ideas: at first blush, the task that a Possession projection solves seems clear, but in fact there are many kinds of possession and the inferences one can make will depend on which type one is considering. If a man possesses a car, and that car possesses a wheel, then it is fair to claim that the man possesses the wheel. If a man possesses an aunt and the aunt possesses a son, then a similar chain of reasoning does not hold. It is our hope that the framework presented in this paper will provide a useful tool to help guide these developments. Eventually, to achieve scalability, the meaning projections themselves will have to be learned from data; perhaps higher level meaning projections could be built automatically from a set of fundamental projections. The use of meaning projections to automatically build higher level semantic constructs such as scripts and plans [14], which encapsulate typically observed sequences of events, is also an interesting direction for research."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We wish to thank Aitao Chen for generously helping us with his NLPLib package. We also wish to thank Nicolaj Bjørner for his generous help with Z3."
    } ],
    "references" : [ {
      "title" : "Towards the Machine Comprehension of Text: An Essay",
      "author" : [ "C.J.C. Burges" ],
      "venue" : "Microsoft Research Technical Report MSR-TR-2013-125",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "From machine learning to machine reasoning",
      "author" : [ "L. Bottou" ],
      "venue" : "arXiv abs/1102.1808",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Knowledge engineering for large belief networks",
      "author" : [ "M. Pradhan", "G. Provan", "B. Middleton", "M. Henrion" ],
      "venue" : "UAI 1994, as mentioned in D. Koller and N. Friedman, Probabilistic graphical models: principles and techniques, MIT Press",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Society of Mind",
      "author" : [ "M. Minsky" ],
      "venue" : "Simon and Schuster",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Machine Perception Of Three-Dimensional Solids",
      "author" : [ "L.G. Roberts" ],
      "venue" : "PhD thesis, MIT",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1963
    }, {
      "title" : "Introduction to Logic",
      "author" : [ "M. Genesereth", "E. Kao" ],
      "venue" : "2 edition, Synthesis Lectures on Compute Science",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "MSR SPLAT: a language analysis toolkit",
      "author" : [ "C. Quirk", "P. Choudhury", "J. Gao", "H. Suzuki", "K. Toutanova", "M. Gamon", "W. Yih", "L. Vanderwende", "C. Cherry" ],
      "venue" : "Proceedings of the NAACL-HLT 2012: Demonstration Session",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms",
      "author" : [ "M. Collins" ],
      "venue" : "Proceedings of the ACL conference on Empirical methods in natural language processing, 10:1 -8. Association for Computational Linguistics",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A",
      "author" : [ "R. Weischedel", "S. Pradhan", "L. Ramshaw", "J. Kaufman", "M. Franchini", "M. ElBachouti", "N. Xue", "M. Palmer", "M. Marcus" ],
      "venue" : "Taylor, OntoNotes Release 4.0, Technical Report, BBN Technologies, December 24",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Bootstrapping path-based pronoun resolution",
      "author" : [ "S. Bergsma", "D. Lin" ],
      "venue" : "Proceedings of the 21st International Conference on Computational Linguistics and the 44th annual meeting of the Association for Computational Linguistics, pp. 33—40",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Scripts",
      "author" : [ "R.C. Schank", "R.P Abelson" ],
      "venue" : "plans, goals, and understanding: An inquiry into human knowledge structures, Psychology Press",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1977
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "the machine comprehension of text [1].",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 1,
      "context" : "those modules, is a fundamental principle of software design but is also expected to be a key design principle for large semantic models [2].",
      "startOffset" : 137,
      "endOffset" : 140
    }, {
      "referenceID" : 2,
      "context" : "models (neural nets, trees, ensembles of these, and even moderately sized probabilistic graphical models) are not easily interpretable (see for example [3]): in general we do not understand why our statistical systems make",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 3,
      "context" : "The idea is roughly analogous to the “agents” in Minsky’s Society of Mind [4].",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 3,
      "context" : "The work can be viewed as a semantic modeling analog of Blocks World [4,5], in that it takes a simple task and uses it to explore the ideas.",
      "startOffset" : 69,
      "endOffset" : 74
    }, {
      "referenceID" : 4,
      "context" : "The work can be viewed as a semantic modeling analog of Blocks World [4,5], in that it takes a simple task and uses it to explore the ideas.",
      "startOffset" : 69,
      "endOffset" : 74
    }, {
      "referenceID" : 5,
      "context" : "[6], but with data structures chosen to meet the above desiderata.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "We emphasize that inference in this system is simply using relational logic [6].",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 6,
      "context" : "We use three systems: SPLAT, a publically available NLP toolkit [7]; NLPLib, an internal NLP toolkit that uses the averaged perceptron algorithm [8] trained on the part of speech and constituency tree tags and data in OntoNotes Release 4.",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 7,
      "context" : "We use three systems: SPLAT, a publically available NLP toolkit [7]; NLPLib, an internal NLP toolkit that uses the averaged perceptron algorithm [8] trained on the part of speech and constituency tree tags and data in OntoNotes Release 4.",
      "startOffset" : 145,
      "endOffset" : 148
    }, {
      "referenceID" : 8,
      "context" : "0 [9], which we used for entity detection [10]; and the Stanford natural language system for labeled dependency trees and coreference resolution [11].",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 9,
      "context" : "For a particularly elegant example of using the statistics of large datasets to solve what is otherwise a thorny coreference problem, see [12].",
      "startOffset" : 138,
      "endOffset" : 142
    }, {
      "referenceID" : 10,
      "context" : "The use of meaning projections to automatically build higher level semantic constructs such as scripts and plans [14], which encapsulate typically observed sequences of events, is also an interesting direction for research.",
      "startOffset" : 113,
      "endOffset" : 117
    } ],
    "year" : 2014,
    "abstractText" : "We explore the idea of using a possibilistic graphical model as the basis for a world model that drives a dialog system. As a first step we have developed a system that uses text-based dialog to derive a model of the user’s family relations. The system leverages its world model to infer relational triples, to learn to recover from upstream coreference resolution errors and ambiguities, and to learn context-dependent paraphrase models. We also explore some theoretical aspects of the underlying graphical model.",
    "creator" : "Microsoft® Word 2013"
  }
}