{
  "name" : "1307.1790.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Lifting Structural Tractability to CSP with Global Constraints",
    "authors" : [ "Evgenij Thorstensen" ],
    "emails" : [ "evgenij.thorstensen@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21]. Constraints can either be represented explicitly, by a table of allowed assignments, or implicitly, by specialized algorithms provided by the constraint solver. These algorithms may take as a parameter a description that specifies exactly which kinds of assignments a particular instance of a constraint should allow. Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].\nThe theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25]. In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of ? Work supported by EPSRC grant EP/G055114/1\nar X\niv :1\n30 7.\n17 90\nv1 [\ncs .A\nI] 6\nJ ul\n2 01\nCSP instances [17, 20, 25]. However, much of this theoretical work has focused on problems where each constraint is explicitly represented, and most known structural restrictions fail to yield tractable classes for problems with global constraints, even when the global constraints are fairly simple [23].\nTheoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local consistency for individual constraints. This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [4,29]. Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [5]. These techniques allow faster implementations of algorithms for individual constraints, but do not shed much light on the complexity of problems with multiple overlapping global constraints, which is something that practical problems frequently require.\nAs such, in this paper we investigate what properties of explicitly represented constraints structural restrictions rely on to guarantee tractability. Identifying such properties will allow us to find global constraints that also possess them, and lift well-known structural restrictions to instances with such constraints.\nAs discussed in [7], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity. Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation. In contrast, we will use a definition of global constraints that allows us to discuss different representations in a uniform manner. Furthermore, as the results we obtain will rely on a relationship between the size of a global constraint and the number of its satisfying assignments, we do not need to reference any specific representation.\nAs a running example, we will use the connected graph partition problem (CGP) [13, p. 209], defined below. The CGP is the problem of partitioning the vertices of a graph into bags of a given size while minimizing the number of edges that span bags. The vertices of the graph could represent components to be placed on circuit boards while minimizing the number of inter-board connections.\nProblem 1 (Connected graph partition (CGP)). We are given an undirected and connected graph 〈V,E〉, as well as α, β ∈ N. Can V be partitioned into disjoint sets V1, . . . , Vm with |Vi| ≤ α such that the set of broken edges E′ = {{u, v} ∈ E | u ∈ Vi, v ∈ Vj , i 6= j} has cardinality β or less?\nThis problem is NP-complete [13, p. 209], even for fixed α ≥ 3. We are going to use the results in this paper to show a new result, namely that the CGP is tractable for every fixed β."
    }, {
      "heading" : "2 Global Constraints",
      "text" : "In this section, we define the basic concepts that we will use throughout the paper. In particular, we give a precise definition of global constraints, and illustrate it with a few examples.\nDefinition 1 (Variables and assignments). Let V be a set of variables, each with an associated set of domain elements. We denote the set of domain elements (the domain) of a variable v by D(v). We extend this notation to arbitrary subsets of variables, W , by setting D(W ) =\n⋃ v∈W D(v).\nAn assignment of a set of variables V is a function θ : V → D(V ) that maps every v ∈ V to an element θ(v) ∈ D(v). We denote the restriction of θ to a set of variables W ⊆ V by θ|W . We also allow the special assignment ⊥ of the empty set of variables. In particular, for every assignment θ, we have θ|∅ = ⊥.\nDefinition 2 (Projection). Let Θ be a set of assignments of a set of variables V . The projection of Θ onto a set of variables X ⊆ V is the set of assignments πX(Θ) = {θ|X | θ ∈ Θ}.\nNote that when Θ = ∅ we have πX(Θ) = ∅, but when X = ∅ and Θ 6= ∅, we have πX(Θ) = {⊥}.\nDefinition 3 (Disjoint union of assignments). Let θ1 and θ2 be two assignments of disjoint sets of variables V1 and V2, respectively. The disjoint union of θ1 and θ2, denoted θ1⊕θ2, is the assignment of V1∪V2 such that (θ1⊕θ2)(v) = θ1(v) for all v ∈ V1, and (θ1 ⊕ θ2)(v) = θ2(v) for all v ∈ V2.\nGlobal constraints have traditionally been defined, somewhat vaguely, as constraints without a fixed arity, possibly also with a compact representation of the constraint relation. For example, in [22] a global constraint is defined as “a constraint that captures a relation between a non-fixed number of variables”.\nBelow, we offer a precise definition similar to the one in [4], where the authors define global constraints for a domain D over a list of variables σ as being given intensionally by a function D|σ| → {0, 1} computable in polynomial time. Our definition differs from this one in that we separate the general algorithm of a global constraint (which we call its type) from the specific description. This separation allows us a better way of measuring the size of a global constraint, which in turn helps us to establish new complexity results.\nDefinition 4 (Global constraints). A global constraint type is a parameterized polynomial-time algorithm that determines the acceptability of an assignment of a given set of variables.\nEach global constraint type, e, has an associated set of descriptions, ∆(e). Each description δ ∈ ∆(e) specifies appropriate parameter values for the algorithm e. In particular, each δ ∈ ∆(e) specifies a set of variables, denoted by V(δ).\nA global constraint e[δ], where δ ∈ ∆(e), is a function that maps assignments of V(δ) to the set {0, 1}. Each assignment that is allowed by e[δ] is mapped to 1, and each disallowed assignment is mapped to 0. The extension or constraint relation of e[δ] is the set of assignments, θ, of V(δ) such that e[δ](θ) = 1. We also say that such assignments satisfy the constraint, while all other assignments falsify it.\nWhen we are only interested in describing the set of assignments that satisfy a constraint, and not in the complexity of determining membership in this set, we will sometimes abuse notation by writing θ ∈ e[δ] to mean e[δ](θ) = 1.\nAs can be seen from the definition above, a global constraint is not usually explicitly represented by listing all the assignments that satisfy it. Instead, it is represented by some description δ and some algorithm e that allows us to check whether the constraint relation of e[δ] includes a given assignment. To stay within the complexity class NP, this algorithm is required to run in polynomial time. As the algorithms for many common global constraints are built into modern constraint solvers, we measure the size of a global constraint’s representation by the size of its description.\nExample 1 (EGC). A very general global constraint type is the extended global cardinality constraint type [29]. This form of global constraint is defined by specifying for every domain element a a finite set of natural numbersK(a), called the cardinality set of a. The constraint requires that the number of variables which are assigned the value a is in the set K(a), for each possible domain element a.\nUsing our notation, the description δ of an EGC global constraint specifies a function Kδ : D(V(δ)) → P(N) that maps each domain element to a set of natural numbers. The algorithm for the EGC constraint then maps an assignment θ to 1 if and only if, for every domain element a ∈ D(V(δ)), we have that |{v ∈ V(δ) | θ(v) = a}| ∈ Kδ(a).\nExample 2 (Table and negative constraints). A rather degenerate example of a a global constraint type is the table constraint.\nIn this case the description δ is simply a list of assignments of some fixed set of variables, V(δ). The algorithm for a table constraint then decides, for any assignment of V(δ), whether it is included in δ. This can be done in a time which is linear in the size of δ and so meets the polynomial time requirement.\nNegative constraints are complementary to table constraints, in that they are described by listing forbidden assignments. The algorithm for a negative constraint e[δ] decides, for any assignment of V(δ), whether whether it is not included in δ. Observe that disjunctive clauses, used to define propositional satisfiability problems, are a special case of the negative constraint type, as they have exactly one forbidden assignment.\nWe observe that any global constraint can be rewritten as a table or negative constraint. However, this rewriting will, in general, incur an exponential increase in the size of the description.\nAs can be seen from the definition above, a table global constraint is explicitly represented, and thus equivalent to the usual notion of an explicitly represented constraint.\nDefinition 5 (CSP instance). An instance of the constraint satisfaction problem (CSP) is a pair 〈V,C〉 where V is a finite set of variables, and C is a set of\nglobal constraints such that for every e[δ] ∈ C, V(δ) ⊆ V . In a CSP instance, we call V(δ) the scope of the constraint e[δ].\nA classic CSP instance is one where every constraint is a table constraint. A solution to a CSP instance P = 〈V,C〉 is an assignment θ of V which satisfies every global constraint, i.e., for every e[δ] ∈ C we have θ|V(δ) ∈ e[δ]. We denote the set of solutions to P by sol(P ).\nThe size of a CSP instance P = 〈V,C〉 is |P | = |V |+ ∑ v∈V |D(v)|+ ∑ e[δ]∈C |δ|.\nExample 3 (The CGP encoded with global constraints). Given a connected graph G = 〈V,E〉, α, and β, we build a CSP instance 〈A∪B,C〉 as follows. The set A will have a variable v for every v ∈ V with domain D(v) = {1, . . . , |V |}, while the set B will have a boolean variable e for every edge in E.\nThe set of constraints C will have an EGC constraint Cα on A with K(i) = {0, . . . , α} for every 1 ≤ i ≤ |V |. Likewise, C will have an EGC constraint Cβ on B with K(0) = {0, . . . , |E|} and K(1) = {1, . . . , β}.\nFinally, to connect A and B, the set C will have for every edge {u, v} ∈ E, with corresponding variable e ∈ B, a table constraint on {u, v, e} requiring u 6= v → e = 1.\nAs an example, Figure 1 shows this encoding for the CGP on the graph C5, that is, a simple cycle on five vertices.\nThis encoding follows the definition of Problem 1 quite closely, and can be done in polynomial time."
    }, {
      "heading" : "3 Structural Restrictions",
      "text" : "In recent years, there has been a flurry of research into identifying tractable classes of classic CSP instances based on restrictions on the hypergraphs of CSP instances, known as structural restrictions. Below, we present and discuss a few representative examples. To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].\nDefinition 6 (Hypergraph). A hypergraph 〈V,H〉 is a set of vertices V together with a set of hyperedges H ⊆ P(V ).\nGiven a CSP instance P = 〈V,C〉, the hypergraph of P , denoted hyp(P ), has vertex set V together with a hyperedge V(δ) for every e[δ] ∈ C.\nDefinition 7 (Tree decomposition). A tree decomposition of a hypergraph 〈V,H〉 is a pair 〈T, λ〉 where T is a tree and λ is a labelling function from nodes of T to subsets of V , such that\n1. for every v ∈ V , there exists a node t of T such that v ∈ λ(t), 2. for every hyperedge h ∈ H, there exists a node t of T such that h ⊆ λ(t),\nand 3. for every v ∈ V , the set of nodes {t | v ∈ λ(t)} induces a connected subtree\nof T .\nDefinition 8 (Width function). Let G = 〈V,H〉 be a hypergraph. A width function on G is a function f : P(V )→ R+ that assigns a positive real number to every nonempty subset of vertices of G. A width function f is monotone if f(X) ≤ f(Y ) whenever X ⊆ Y .\nLet 〈T, λ〉 be a tree decomposition of G, and f a width function on G. The f - width of 〈T, λ〉 is max({f(λ(t)) | t node of T}). The f -width of G is the minimal f -width over all its tree decompositions.\nIn other words, a width function on a hypergraph G tells us how to assign weights to nodes of tree decompositions of G.\nDefinition 9 (Treewidth). Let f(X) = |X| − 1. The treewidth tw(G) of a hypergraph G is the f -width of G.\nLet G = 〈V,H〉 be a hypergraph, and X ⊆ V . An edge cover for X is any set of hyperedges H ′ ⊆ H that satisfies X ⊆ ⋃ H ′. The edge cover number ρ(X) of X is the size of the smallest edge cover for X. It is clear that ρ is a width function.\nDefinition 10 ( [1, Chapter 2]). The generalized hypertree width hw(G) of a hypergraph G is the ρ-width of G.\nNext, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [20].\nDefinition 11 (Fractional edge cover). Let G = 〈V,H〉 be a hypergraph, and X ⊆ V . A fractional edge cover for X is a function γ : H → [0, 1] such that∑ v∈h∈H γ(h) ≥ 1 for every v ∈ X. We call ∑ h∈H γ(h) the weight of γ. The fractional edge cover number ρ∗(X) of X is the minimum weight over all fractional edge covers for X. It is known that this minimum is always rational [20].\nDefinition 12. The fractional hypertree width fhw(G) of a hypergraph G is the ρ∗-width of G.\nFor a class of hypergraphs H and a notion of width α, we write α(H) for the maximal α-width over the hypergraphs in H. If this is unbounded we write α(H) =∞; otherwise α(H) <∞.\nAll the above restrictions can be used to guarantee tractability for classes of CSP instances where all constraints are table constraints.\nTheorem 1 ( [10, 17, 20]). Let H be a class of hypergraphs. For every α ∈ {hw, fhw}, any class of classic CSP instances whose hypergraphs are in H is tractable if α(H) <∞.\nTo go beyond fractional hypertree width, Marx [24, 25] recently introduced the concept of submodular width. This concept uses a set of width functions satisfying a condition (submodularity), and considers the f -width of a hypergraph for every such function f .\nDefinition 13 (Submodular width function). Let G = 〈V,H〉 be a hypergraph. A width function f on G is submodular if for every set X,Y ⊆ V , we have f(X) + f(Y ) ≥ f(X ∩ Y ) + f(X ∪ Y ).\nDefinition 14 (Submodular width). Let G be a hypergraph. The submodular width subw(G) of G is the maximum f -width of G taken over all monotone submodular width functions f on G.\nFor a class of hypergraphs H, we write subw(H) for the maximal submodular width over the hypergraphs in H. If this is unbounded we write subw(H) = ∞; otherwise subw(H) <∞.\nUnlike for fractional hypertree width and every other structural restriction discussed so far, the running time of the algorithm given by Marx for classic CSP instances with bounded submodular width has an exponential dependence on the number of vertices in the hypergraph of the instance. The class of classic CSP instances with bounded submodular width is therefore not tractable. However, this class is what is called fixed-parameter tractable [11,12].\nDefinition 15 (Fixed-parameter tractable). A parameterized problem instance is a pair 〈k, P 〉, where P is a problem instance, such as a CSP instance, and k ∈ N a parameter.\nLet S be a class of parameterized problem instances. We say that S is fixedparameter tractable (in FPT) if there is a function f of one argument, as well as a constant c, such that every problem 〈k, P 〉 ∈ S can be solved in time O(f(k)× |P |c).\nThe function f can be arbitrary, but must only depend on the parameter k. For CSP instances, a natural parameterization is by the size of the hypergraph of an instance, measured by the number of vertices. Since the hypergraph of an instance has a vertex for every variable, for every CSP instance P = 〈V,C〉 we consider the parameterized instance 〈|V |, P 〉.\nTheorem 2 ( [24]). Let H be a class of hypergraphs. If subw(H) <∞, then a class of classic CSP instances whose hypergraphs are in H is in FPT.\nThe three structural restrictions that we have just presented form a hierarchy [20,24]: For every hypergraph G, subw(G) ≤ fhw(G) ≤ hw(G).\nAs the example below demonstrates, Theorem 1 does not hold for CSP instances with arbitrary global constraints, even if we have a fixed, finite domain.\nExample 4. The NP-complete problem of 3-colourability [13] is to decide, given a graph 〈V,E〉, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.\nWe may reduce this problem to a CSP with EGC constraints (cf. Example 1) as follows: Let V be the set of variables for our CSP instance, each with domain {r, g, b}. For every edge 〈v, w〉 ∈ E, we post an EGC constraint with scope {v, w}, parameterized by the function K such that K(r) = K(g) = K(b) = {0, 1}. Finally, we make the hypergraph of this CSP instance have low width by adding an EGC constraint with scope V parameterized by the function K ′ such that K ′(r) = K ′(g) = K ′(b) = {0, . . . , |V |}. This reduction clearly takes polynomial time, and the hypergraph G of the resulting instance has hw(G) = fhw(G) = subw(G) = 1.\nAs the constraint with scope V allows all possible assignments, any solution to this CSP is also a solution to the 3-colourability problem, and vice versa.\nLikewise, Theorem 2 does not hold for CSP instances with arbitrary global constraints if we allow the variables unbounded domain size, that is, change the above example to k-colourability. With that in mind, in the rest of the paper we will identify properties of extensionally represented constraints that these structural restrictions exploit to guarantee tractability. Then, we are going to look for restricted classes of global constraints that possess these properties. To do so, we will use the following definitions.\nDefinition 16 (Constraint catalogue). A constraint catalogue is a set of global constraints. A CSP instance 〈V,C〉 is said to be over a constraint catalogue Γ if for every e[δ] ∈ C we have e[δ] ∈ Γ .\nDefinition 17 (Restricted CSP class). Let Γ be a constraint catalogue, and let H be a class of hypergraphs. We define CSP(H, Γ ) to be the class of CSP instances over Γ whose hypergraphs are in H.\nDefinition 17 allows us to discuss classic CSP instances alongside instances with global constraints. Let Ext be the constraint catalogue containing all table global constraints. The classic CSP instances are then precisely those that are over Ext. In particular, we can now restate Theorems 1 and 2 as follows.\nTheorem 3. Let H be a class of hypergraphs. For every α ∈ {hw, fhw}, the class of CSP instances CSP(H,Ext) is tractable if α(H) < ∞. Furthermore, if subw(H) <∞ then CSP(H,Ext) is in FPT."
    }, {
      "heading" : "4 Properties of Extensional Representation",
      "text" : "We are going to start our investigation by considering fractional hypertree width in more detail. To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [20] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance. The following definition formalizes what we mean by “parts”, and is required to state the algorithm that Grohe and Marx use in their paper.\nDefinition 18 (Constraint projection). Let e[δ] be a constraint. The projection of e[δ] onto a set of variables X ⊆ V(δ) is the constraint pjX(e[δ]) such that µ ∈ pjX(e[δ]) if and only if there exists θ ∈ e[δ] with θ|X = µ.\nFor a CSP instance P = 〈V,C〉 and X ⊆ V we define pjX(P ) = 〈X,C ′〉, where C ′ is the least set containing for every e[δ] ∈ C such that X ∩ V(δ) 6= ∅ the constraint pjX∩V(δ)(e[δ]).\nTheir algorithm is given as Algorithm 1, and is essentially the usual recursive search algorithm for finding all solutions to a CSP instance by considering smaller and smaller sub-instances using constraint projections.\nAlgorithm 1 Enumerate all solutions of a CSP instance procedure EnumSolutions(CSP instance P = 〈V,C〉) . Returns sol(P )\nSolutions← ∅ if V = ∅ then\nreturn {⊥} . The empty assignment else\nw ← chooseVar(V ) . Pick a variable from V Θ = EnumSolutions(pjV−{w}(P )) for θ ∈ Θ do\nfor a ∈ D(w) do if θ ∪ 〈w, a〉 is a solution to P then\nSolutions.add(θ ∪ 〈w, a〉) end if\nend for end for\nend if return Solutions\nend procedure\nTo show that Algorithm 1 does indeed find all solutions, we will use the following property of constraint projections.\nLemma 1. Let P = 〈V,C〉 be a CSP instance. For every X ⊆ V , we have sol(pjX(P )) ⊇ πX(sol(P )).\nProof. Given P = 〈V,C〉, let X ⊆ V be arbitrary, and let C ′ = {e[δ] ∈ C | X ∩ V(δ) 6= ∅}. For every θ ∈ sol(P ) and constraint e[δ] ∈ C ′ we have that θ|V(δ) ∈ e[δ] since θ is a solution to P . By Definition 18, it follows that for every e[δ] ∈ C ′, θ|X∩V(δ) ∈ pjX∩V(δ)(e[δ]). Since the set of constraints of pjX(P ) is the least set containing for each e[δ] ∈ C ′ the constraint pjX∩V(δ)(e[δ]), we have θ|X ∈ sol(pjX(P )), and hence sol(pjX(P )) ⊇ πX(sol(P )). Since X was arbitrary, the claim follows.\nTheorem 4 (Correctness of Algorithm 1). Let P be a CSP instance. We have that EnumSolutions(P ) = sol(P ).\nProof. The proof is by induction on the set of variables V in P . For the base case, if V = ∅, the empty assignment is the only solution.\nOtherwise, choose a variable w ∈ V , and let X = V − {w}. By induction, we can assume that EnumSolutions(pjX(P )) = sol(pjX(P )). Since for every θ ∈ sol(P ) there exists a ∈ D(w) such that θ = θ|X ∪ 〈w, a〉, and furthermore θ|X ∈ πX(sol(P )), it follows by Lemma 1 that θ|X ∈ sol(pjX(P )). Since Algorithm 1 checks every assignment of the form µ ∪ 〈w, a〉 for every µ ∈ sol(pjX(P )) and a ∈ D(w), it follows that EnumSolutions(P ) = sol(P ).\nThe time required for this algorithm depends on three key factors, which we are going to enumerate and discuss below. Let\n1. s(P ) be the maximum of the number of solutions to each of the instances pjV−{w}(P ), 2. c(P ) be the maximum time required to check whether an assignment is a solution to P , and 3. b(P ) be the maximum time required to construct any instance pjV−{w}(P ).\nThere are |V | calls to EnumSolutions. For each call, we need b(P ) time to construct the projection, while the double loop takes at most s(P ) × |D(w)| × c(P ) time. Therefore, letting d = max({|D(w)| | w ∈ V }), the running time of Algorithm 1 is bounded by O ( |V | × (s(P )× d× c(P ) + b(P )) ) .\nSince constructing the projection of a classic CSP instance can be done in polynomial time, and likewise checking that an assignment is a solution, the whole algorithm runs in polynomial time if s(P ) is a polynomial in the size of P . For fractional hypertree width, Grohe and Marx show the following.\nLemma 2 ( [20]). A classic CSP instance P has at most |P |fhw(hyp(P )) solutions.\nSince fractional hypertree width is a monotone width function, it follows that for any instance P = 〈V,C〉 and X ⊆ V , fhw(hyp(pjX(P ))) ≤ fhw(hyp(P )). Therefore, for classic CSP instances of bounded fractional hypertree width s(P ) is indeed polynomial in |P |."
    }, {
      "heading" : "5 CSP Instances with Few Solutions in Key Places",
      "text" : "Having few solutions for every projection of a CSP instance is thus a property that makes fractional hypertree width yield tractable classes of classic CSP instances. More importantly, we have shown that this property allows us to find all solutions to a CSP instance P , even with global constraints, if we can build arbitrary projections of P in polynomial time. In other words, with these two conditions we should be able to reduce instances with global constraints to classic instances in polynomial time.\nHowever, on reflection there is no reason why we should need few solutions for every projection. Instead, consider the following reduction.\nDefinition 19 (Partial assignment checking). A global constraint catalogue Γ allows partial assignment checking if for any constraint e[δ] ∈ Γ we can decide in polynomial time whether a given assignment θ to a set of variables W ⊆ V(δ) is contained in an assignment that satisfies e[δ], i.e. whether there exists µ ∈ e[δ] such that θ = µ|W .\nAs an example, a catalogue that contains arbitrary EGC constraints (cf. Example 1) does not satisfy Definition 19, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [26]. On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 19 [27].\nIf a catalogue Γ satisfies Definition 19, we can for any constraint e[δ] ∈ Γ build arbitrary projections of it, that is, construct the global constraint pjX(e[δ]) for any X ⊆ V(δ), in polynomial time.\nDefinition 20 (Intersection variables). Let 〈V,C〉 be a CSP instance. The set of intersection variables of any constraint e[δ] ∈ P is iv(δ) = ⋃ {V(δ)∩V(δ′) | e′[δ′] ∈ C − {e[δ]}}.\nDefinition 21 (Table constraint induced by a global constraint). Let P = 〈V,C〉 be a CSP instance. For every e[δ] ∈ C, let µ∗ be the assignment to V(δ)− iv(δ) that assigns a special value ∗ to every variable. The table constraint induced by e[δ] is ic(e[δ]) = e′[δ′], where V(δ′) = V(δ), and δ′ contains for every assignment θ ∈ sol(pjiv(δ)(P )) the assignment θ ⊕ µ∗.\nIf every constraint in a CSP instance P = 〈V,C〉 allows partial assignment checking, then building ic(e[δ]) for any e[δ] ∈ C can be done in polynomial time when |sol(pjX(P ))| is itself polynomial in the size of P for every subsetX of iv(δ). To do so, we can invoke Algorithm 1 on the instance pjiv(δ)(P ). The definition below expresses this idea.\nDefinition 22 (Sparse intersections). A class of CSP instances P has sparse intersections if there exists a constant c such that for every constraint e[δ] in any instance P ∈ P, we have that for every X ⊆ iv(δ), |sol(pjX(P ))| ≤ |P |c.\nIf a class of instances P has sparse intersections, and the instances are all over a constraint catalogue that allows partial assignment checking, then we can for every constraint e[δ] of any instance from P construct ic(e[δ]) in polynomial time. While this definition considers the instance as a whole, one special case of it is the case where every constraint has few solutions in the size of its description, that is, there is a constant c and the constraints are drawn from a catalogue Γ such that for every e[δ] ∈ Γ , we have that |{µ | µ ∈ e[δ]}| ≤ |δ|c.\nTheorem 5. Let P be a class of CSP instances over a catalogue that allows partial assignment checking. If P has sparse intersections, then we can in polynomial time reduce any instance P ∈ P to a classic CSP instance PCL with hyp(P ) = hyp(PCL), such that PCL has a solution if and only if P does.\nProof. Let P = 〈V,C〉 be an instance from such a class P. For each e[δ] ∈ C, PCL will contain the table constraint ic(e[δ]) from Definition 21. Since P is over a catalogue that allows partial assignment checking, and P has sparse intersections, computing ic(e[δ]) can be done in polynomial time by invoking Algorithm 1 on pjiv(δ)(P ).\nIt is clear that hyp(P ) = hyp(PCL). All that is left to show is that PCL has a solution if and only if P does. Let θ be a solution to P = 〈V,C〉. For every e[δ] ∈ C, we have that θ|iv(δ) ∈ pjiv(δ)(P ) by Definitions 18 and 20, and the assignment µ that assigns the value θ(v) to each v ∈\n⋃ e[δ]∈C iv(δ), and ∗ to every\nother variable is therefore a solution to PCL. In the other direction, if θ is a solution to PCL, then θ satisfies ic(e[δ]) for every e[δ] ∈ C. By Definition 21, this means that θ|iv(δ) ∈ sol(pjiv(δ)(P )), and by Definition 18, there exists an assignment µe[δ] with µe[δ]|iv(δ) = θ|iv(δ) that satisfies e[δ]. By Definition 20, the variables not in iv(δ) do not occur in any other constraint in P , so we can combine all the assignments µe[δ] to form a solution µ to P such that for e[δ] ∈ C and v ∈ V(δ) we have µ(v) = µe[δ](v).\nFrom Theorem 5, we get tractable and fixed-parameter tractable classes of CSP instances with global constraints.\nCorollary 1. Let H be a class of hypergraphs, and Γ a catalogue that allows partial assignment checking. If CSP(H, Γ ) has sparse intersections, then CSP(H, Γ ) is tractable or in FPT if CSP(H,Ext) is.\nProof. Let H and Γ be given. By Theorem 5, we can reduce any P ∈ CSP(H, Γ ) to an instance PCL ∈ CSP(H,Ext) in polynomial time. Since PCL has a solution if and only if P does, tractability or fixed-parameter tractability of CSP(H,Ext) implies the same for CSP(H, Γ )."
    }, {
      "heading" : "5.1 Applying Corollary 1 to the CGP",
      "text" : "Recall the connected graph partition problem (Problem 1): Given a connected graph G, as well as natural numbers α and β, can the vertices of G be partitioned\ninto bags of size at most α, such that no more than β edges are broken. Using the CSP encoding we gave in Example 3, as well as Corollary 1, we will show a new result, that this problem is tractable if β is fixed. To simplify the analysis, we assume without loss of generality that α < |V |, which means that any solution has at least one broken edge.\nWe claim that if β is fixed, then the constraint Cβ = eβ [δβ ] allows partial assignment checking, and has only a polynomial number of satisfying assignments. The latter implies that for any instance P of the CGP, |sol(pjiv(δβ)(P ))| is polynomial in the size of P for every subset of iv(δβ). Furthermore, we will show that for the constraint Cα = eα[δα], we also have that |sol(pjiv(δα)(P ))| is polynomial in the size of P . That Cα allows partial assignment checking follows from a result by Régin [27], since the cardinality sets of Cα are intervals.\nFirst, we show that the number of satisfying assignments to Cβ is limited. Since Cβ limits the number of ones in any solution to β or fewer, the number of satisfying assignments to this constraint is the number of ways to choose up to\nβ variables to be assigned one. This is bounded by β∑ i=1 ( |E| i ) ≤ (|E|+ 1)β , and so we can generate them all in polynomial time.\nNow, let θ be such a solution. How many solutions to P contain θ? Well, every constraint on {u, v, e} with e = 1 allows at most |V |2 assignments, and there are at most β such constraints. So far we therefore have at most (|E|+ 1)β × |V |2β assignments.\nOn the other hand, a ternary constraint with e = 0 requires u = v. Consider the graph G0 containing for every constraint on {u, v, e} with e = 0 the vertices u and v as well as the edge {u, v}. Since the original graph was connected, every connected component of G0 contains at least one vertex which is in the scope of some constraint with e = 1. Therefore, since equality is transitive, each connected component of G0 allows at most one assignment for each of the (|E| + 1)β × |V |2β assignments to the other variables of P . We therefore get a total bound of (|E| + 1)β × |V |2β on the total number of solutions to P , and hence to pjiv(δα)(P ).\nThe hypergraph of any CSP instance P encoding the CGP has two hyperedges covering the whole problem, so the hypertree width of this hypergraph is two. Therefore, we may apply Corollary 1 and Theorem 1 to obtain tractability when β is fixed. As this problem is NP-complete for fixed α ≥ 3 [13, p. 209], β is a natural parameter to try and use.\nAs it happens, in this problem we can drop the requirement of partial assignment checking for the constraint Cα. All its variables are intersection variables, and the instance has few solutions even if we disregard Cα. Thus, we need only check whether any of those solutions satisfy Cα, and checking whether an assignment to the whole scope of a constraint satisfies it can always be done in polynomial time by Definition 4. In the next section, we turn this observation into a general result."
    }, {
      "heading" : "6 Back Doors",
      "text" : "If a class of CSP instances includes constraints from a catalogue that is not known to allow partial assignment checking, we may still obtain tractability in some cases by applying the notion of a back door set. A (strong) back door set [14,32] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve. Below, we are going to adapt this notion to individual constraints.\nDefinition 23 (Back door). Let Γ be a global constraint catalogue. A back door for a constraint e[δ] ∈ Γ is any set of variables W ⊆ V(δ) (called a back door set) such that we can decide in polynomial time whether a given assignment θ to a set of variables V(θ) ⊇W is contained in an assignment that satisfies e[δ], i.e. whether there exists µ ∈ e[δ] such that µ|V(θ) = θ.\nTrivially, for every constraint e[δ] the set of variables V(δ) is a back door set, since by Definition 4 we can always check in polynomial time if an assignment to V(δ) satisfies the constraint e[δ].\nThe key point about back doors is that given a catalogue Γ , adding to each e[δ] ∈ Γ with back door set W an arbitrary set of assignments to W produces a catalogue Γ ′ that allows partial assignment checking. Adding a set of assignments Θ means to add Θ to the description, and modify the algorithm e to only accept an assignment if it contains a member of Θ in addition to previous requirements. Furthermore, given a CSP instance P containing e[δ], as long as Θ ⊇ πW (sol(P )), adding Θ to e[δ] produces an instance that has exactly the same solutions. This point leads to the following definition.\nDefinition 24 (Sparse back door cover). Let ΓPAC be a catalogue that allows partial assignment checking and ΓBD a catalogue. For every instance P = 〈V,C〉 over ΓPAC ∪ ΓBD, let P ∩ ΓPAC be the instance with constraint set C ′ = C ∩ ΓPAC and set of variables ⋃ {V ∩ V(δ) | e[δ] ∈ C ′}.\nA class of CSP instances P over ΓPAC ∪ ΓBD has sparse back door cover if there exists a constant c such that for every instance P = 〈V,C〉 ∈ P and constraint e[δ] ∈ C, if e[δ] 6∈ ΓPAC , then there exists a back door set W for e[δ] with |sol(pjX(P ∩ ΓPAC))| ≤ |P |c for every X ⊆W .\nSparse back door cover means that for each constraint that is not from a catalogue that allows partial assignment checking, we can in polynomial time get a set of assignments Θ for its back door set using Algorithm 1, and so turn this constraint into one that does allow partial assignment checking. This operation preserves the solutions of the instance that contains this constraint.\nTheorem 6. If a class of CSP instance P has sparse back door cover, then we can in polynomial time reduce any instance P ∈ P to an instance P ′ such that hyp(P ) = hyp(P ′) and sol(P ) = sol(P ′). Furthermore, the class of instances {P ′ | P ∈ P} is over a catalogue that allows partial assignment checking.\nProof. Let P = 〈V,C〉 ∈ P. We construct P ′ by adding to every e[δ] ∈ C such that e[δ] 6∈ ΓPAC , with back door set W , the set of assignments sol(pjW (P ∩ ΓPAC)), which we can obtain using Algorithm 1. By Definition 24, we have for everyX ⊆W that |sol(pjW (P∩ΓPAC))| ≤ |P |c, so Algorithm 1 takes polynomial time since ΓPAC does allow partial assignment checking.\nIt is clear that hyp(P ′) = hyp(P ), and since sol(pjW (P∩ΓPAC)) ⊇ πW (sol(P )), the set of solutions stays the same, i.e. sol(P ′) = sol(P ). Finally, since we have replaced each constraint e[δ] in P that was not in ΓPAC by a constraint that does allow partial assignment checking, it follows that P ′ is over a catalogue that allows partial assignment checking.\nOne consequence of Theorem 6 is that we can sometimes apply Theorem 5 to a CSP instance that contains a constraint for which checking if a partial assignment can be extended to a satisfying one is hard. We can do so when the variables of that constraint are covered by the variables of other constraints that do allow partial assignment checking — but only if the instance given by those constraints has few solutions.\nAs a concrete example of this, consider again the encoding of the CGP that we gave in Example 3. The variables of constraint Cα are entirely covered by the instance P ′ obtained by removing Cα. As the entire set of variables of a constraint is a back door set for it, and the instance P ′ has few solutions (cf. Section 5.1), this class of instances has sparse back door cover. As such, the constraint Cα could, in fact, be arbitrary without affecting the tractability of this problem. In particular, the requirement that Cα allows partial assignment checking can be dropped."
    }, {
      "heading" : "7 Summary and Future Work",
      "text" : "In this paper, we have investigated properties that many structural restrictions rely on to yield tractable classes of CSP instances with explicitly represented constraints. In particular, we identify a relationship between the number of solutions and the size of a CSP instance as being one such property. Using this insight, we show that known structural restrictions yield tractability for any class of CSP instances with global constraints that satisfies this property. In particular, the above implies that the structural restrictions we consider yield tractability for classes of instances where every global constraint has few satisfying assignments relative to its size.\nTo illustrate our result, we apply it to a known problem, the connected graph partition problem, and use it to identify a new tractable case of this problem. We also demonstrate how the concept of back doors, subsets of variables that make a problem easy to solve once assigned, can be used to relax the conditions of our result in some cases.\nAs for future work, one obvious research direction to pursue is to find a complete characterization of tractable classes of CSP instances with sparse intersections. Another avenue of research would be to apply the results in this paper to various kinds of valued CSP."
    } ],
    "references" : [ {
      "title" : "Width Functions for Hypertree Decompositions",
      "author" : [ "I. Adler" ],
      "venue" : "Doctoral dissertation, Albert-Ludwigs-Universität Freiburg",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Optimization methods for the partner units problem",
      "author" : [ "M. Aschinger", "C. Drescher", "G. Friedrich", "G. Gottlob", "P. Jeavons", "A. Ryabokon", "E. Thorstensen" ],
      "venue" : "Proc. CPAIOR’11. LNCS, vol. 6697, pp. 4–19. Springer",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Structural decomposition methods and what they are good for",
      "author" : [ "M. Aschinger", "C. Drescher", "G. Gottlob", "P. Jeavons", "E. Thorstensen" ],
      "venue" : "Schwentick, T., Dürr, C. (eds.) Proc. STACS’11. LIPIcs, vol. 9, pp. 12–28",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The complexity of reasoning with global constraints",
      "author" : [ "C. Bessiere", "E. Hebrard", "B. Hnich", "T. Walsh" ],
      "venue" : "Constraints 12(2), 239–259",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Decomposition of the NValue constraint",
      "author" : [ "C. Bessiere", "G. Katsirelos", "N. Narodytska", "C.G. Quimper", "T. Walsh" ],
      "venue" : "Proc. CP’10. LNCS, vol. 6308, pp. 114–128. Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Classifying the complexity of constraints using finite algebras",
      "author" : [ "A. Bulatov", "P. Jeavons", "A. Krokhin" ],
      "venue" : "SIAM Journal on Computing 34(3), 720–742",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Constraint satisfaction with succinctly specified relations",
      "author" : [ "H. Chen", "M. Grohe" ],
      "venue" : "Journal of Computer and System Sciences 76(8), 847–860",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "A unified theory of structural tractability for constraint satisfaction problems",
      "author" : [ "D. Cohen", "P. Jeavons", "M. Gyssens" ],
      "venue" : "Journal of Computer and System Sciences 74(5), 721–743",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Constraint representations and structural tractability",
      "author" : [ "D.A. Cohen", "M.J. Green", "C. Houghton" ],
      "venue" : "Proc. CP’09. LNCS, vol. 5732, pp. 289–303. Springer",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Constraint satisfaction, bounded treewidth, and finite-variable logics",
      "author" : [ "V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi" ],
      "venue" : "Proc. CP’02. LNCS, vol. 2470, pp. 223–254. Springer",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Parameterized Complexity",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "Monographs in Computer Science, Springer",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Parameterized Complexity Theory",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "Texts in Theoretical Computer Science, Springer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : "W. H. Freeman",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Backdoors to satisfaction",
      "author" : [ "S. Gaspers", "S. Szeider" ],
      "venue" : "Bodlaender, H.L., Downey, R., Fomin, F.V., Marx, D. (eds.) The Multivariate Algorithmic Revolution and Beyond, LNCS, vol. 7370, pp. 287–317. Springer",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "MINION: A fast, scalable constraint solver",
      "author" : [ "I.P. Gent", "C. Jefferson", "I. Miguel" ],
      "venue" : "Proc. ECAI’06, pp. 98–102. IOS Press",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A comparison of structural CSP decomposition methods",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Artificial Intelligence 124(2), 243–282",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Hypertree decompositions and tractable queries",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Journal of Computer and System Sciences 64(3), 579–627",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Structural tractability of propagated constraints",
      "author" : [ "M.J. Green", "C. Jefferson" ],
      "venue" : "Proc. CP’08. LNCS, vol. 5202, pp. 372–386. Springer",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The complexity of homomorphism and constraint satisfaction problems seen from the other side",
      "author" : [ "M. Grohe" ],
      "venue" : "Journal of the ACM 54(1), 1–24",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Constraint solving via fractional edge covers",
      "author" : [ "M. Grohe", "D. Marx" ],
      "venue" : "Proc. SODA’06, pp. 289–298. ACM",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Bin repacking scheduling in virtualized datacenters",
      "author" : [ "F. Hermenier", "S. Demassey", "X. Lorca" ],
      "venue" : "Lee, J. (ed.) Proc. CP’11. LNCS, vol. 6876, pp. 27–41. Springer",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Global constraints",
      "author" : [ "W.J. van Hoeve", "I. Katriel" ],
      "venue" : "Rossi, F., van Beek, P., Walsh, T. (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, pp. 169–208. Elsevier",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Simultaneous matchings: Hardness and approximation",
      "author" : [ "M. Kutz", "K. Elbassioni", "I. Katriel", "M. Mahajan" ],
      "venue" : "Journal of Computer and System Sciences 74(5), 884–897",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Tractable hypergraph properties for constraint satisfaction and conjunctive queries",
      "author" : [ "D. Marx" ],
      "venue" : "CoRR abs/0911.0801",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Tractable hypergraph properties for constraint satisfaction and conjunctive queries",
      "author" : [ "D. Marx" ],
      "venue" : "Proc. STOC’10, pp. 735–744. ACM",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Improved algorithms for the global cardinality constraint",
      "author" : [ "C.G. Quimper", "A. López-Ortiz", "P. van Beek", "A. Golynski" ],
      "venue" : "Proc. CP’04. LNCS, vol. 3258, pp. 542–556. Springer",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Generalized Arc Consistency for Global Cardinality Constraint",
      "author" : [ "J.C. Régin" ],
      "venue" : "Proc. AAAI’96, pp. 209–215. AAAI Press",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "The Handbook of Constraint Programming",
      "author" : [ "F. Rossi", "P. van Beek", "Walsh", "T. (eds." ],
      "venue" : "Elsevier",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Tractable cases of the extended global cardinality constraint",
      "author" : [ "M. Samer", "S. Szeider" ],
      "venue" : "Constraints 16(1), 1–24",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Practical applications of constraint programming",
      "author" : [ "M. Wallace" ],
      "venue" : "Constraints 1, 139– 168",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "ECLiPSe: A platform for constraint logic programming",
      "author" : [ "M. Wallace", "S. Novello", "J. Schimpf" ],
      "venue" : "ICL Systems Journal 12(1), 137–158",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Backdoors to typical case complexity",
      "author" : [ "R. Williams", "C.P. Gomes", "B. Selman" ],
      "venue" : "Proc. IJCAI’03, pp. 1173–1178",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].",
      "startOffset" : 116,
      "endOffset" : 123
    }, {
      "referenceID" : 29,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].",
      "startOffset" : 116,
      "endOffset" : 123
    }, {
      "referenceID" : 1,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].",
      "startOffset" : 154,
      "endOffset" : 160
    }, {
      "referenceID" : 20,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [22,30], and industrial configuration [2,21].",
      "startOffset" : 154,
      "endOffset" : 160
    }, {
      "referenceID" : 14,
      "context" : "Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].",
      "startOffset" : 162,
      "endOffset" : 172
    }, {
      "referenceID" : 27,
      "context" : "Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].",
      "startOffset" : 162,
      "endOffset" : 172
    }, {
      "referenceID" : 30,
      "context" : "Such implicitly represented constraints are known as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing them [15,28,31].",
      "startOffset" : 162,
      "endOffset" : 172
    }, {
      "referenceID" : 2,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].",
      "startOffset" : 287,
      "endOffset" : 308
    }, {
      "referenceID" : 5,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].",
      "startOffset" : 287,
      "endOffset" : 308
    }, {
      "referenceID" : 7,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].",
      "startOffset" : 287,
      "endOffset" : 308
    }, {
      "referenceID" : 15,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].",
      "startOffset" : 287,
      "endOffset" : 308
    }, {
      "referenceID" : 18,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].",
      "startOffset" : 287,
      "endOffset" : 308
    }, {
      "referenceID" : 24,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [3, 6, 8, 16, 19, 25].",
      "startOffset" : 287,
      "endOffset" : 308
    }, {
      "referenceID" : 16,
      "context" : "CSP instances [17, 20, 25].",
      "startOffset" : 14,
      "endOffset" : 26
    }, {
      "referenceID" : 19,
      "context" : "CSP instances [17, 20, 25].",
      "startOffset" : 14,
      "endOffset" : 26
    }, {
      "referenceID" : 24,
      "context" : "CSP instances [17, 20, 25].",
      "startOffset" : 14,
      "endOffset" : 26
    }, {
      "referenceID" : 22,
      "context" : "However, much of this theoretical work has focused on problems where each constraint is explicitly represented, and most known structural restrictions fail to yield tractable classes for problems with global constraints, even when the global constraints are fairly simple [23].",
      "startOffset" : 272,
      "endOffset" : 276
    }, {
      "referenceID" : 3,
      "context" : "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [4,29].",
      "startOffset" : 121,
      "endOffset" : 127
    }, {
      "referenceID" : 28,
      "context" : "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [4,29].",
      "startOffset" : 121,
      "endOffset" : 127
    }, {
      "referenceID" : 4,
      "context" : "Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [5].",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 6,
      "context" : "As discussed in [7], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 17,
      "context" : "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 8,
      "context" : "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation.",
      "startOffset" : 145,
      "endOffset" : 148
    }, {
      "referenceID" : 6,
      "context" : "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [18], negative constraints [9], or GDNF/decision diagrams [7], and exploited properties particular to that representation.",
      "startOffset" : 176,
      "endOffset" : 179
    }, {
      "referenceID" : 21,
      "context" : "For example, in [22] a global constraint is defined as “a constraint that captures a relation between a non-fixed number of variables”.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 3,
      "context" : "Below, we offer a precise definition similar to the one in [4], where the authors define global constraints for a domain D over a list of variables σ as being given intensionally by a function D|σ| → {0, 1} computable in polynomial time.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 28,
      "context" : "A very general global constraint type is the extended global cardinality constraint type [29].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 0,
      "context" : "To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 19,
      "context" : "Next, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [20].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 0,
      "context" : "A fractional edge cover for X is a function γ : H → [0, 1] such that ∑",
      "startOffset" : 52,
      "endOffset" : 58
    }, {
      "referenceID" : 19,
      "context" : "It is known that this minimum is always rational [20].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 9,
      "context" : "Theorem 1 ( [10, 17, 20]).",
      "startOffset" : 12,
      "endOffset" : 24
    }, {
      "referenceID" : 16,
      "context" : "Theorem 1 ( [10, 17, 20]).",
      "startOffset" : 12,
      "endOffset" : 24
    }, {
      "referenceID" : 19,
      "context" : "Theorem 1 ( [10, 17, 20]).",
      "startOffset" : 12,
      "endOffset" : 24
    }, {
      "referenceID" : 23,
      "context" : "To go beyond fractional hypertree width, Marx [24, 25] recently introduced the concept of submodular width.",
      "startOffset" : 46,
      "endOffset" : 54
    }, {
      "referenceID" : 24,
      "context" : "To go beyond fractional hypertree width, Marx [24, 25] recently introduced the concept of submodular width.",
      "startOffset" : 46,
      "endOffset" : 54
    }, {
      "referenceID" : 10,
      "context" : "However, this class is what is called fixed-parameter tractable [11,12].",
      "startOffset" : 64,
      "endOffset" : 71
    }, {
      "referenceID" : 11,
      "context" : "However, this class is what is called fixed-parameter tractable [11,12].",
      "startOffset" : 64,
      "endOffset" : 71
    }, {
      "referenceID" : 23,
      "context" : "Theorem 2 ( [24]).",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 19,
      "context" : "The three structural restrictions that we have just presented form a hierarchy [20,24]: For every hypergraph G, subw(G) ≤ fhw(G) ≤ hw(G).",
      "startOffset" : 79,
      "endOffset" : 86
    }, {
      "referenceID" : 23,
      "context" : "The three structural restrictions that we have just presented form a hierarchy [20,24]: For every hypergraph G, subw(G) ≤ fhw(G) ≤ hw(G).",
      "startOffset" : 79,
      "endOffset" : 86
    }, {
      "referenceID" : 12,
      "context" : "The NP-complete problem of 3-colourability [13] is to decide, given a graph 〈V,E〉, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 19,
      "context" : "To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [20] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 19,
      "context" : "Lemma 2 ( [20]).",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 25,
      "context" : "Example 1) does not satisfy Definition 19, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [26].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 26,
      "context" : "On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 19 [27].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 26,
      "context" : "That C allows partial assignment checking follows from a result by Régin [27], since the cardinality sets of C are intervals.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 13,
      "context" : "A (strong) back door set [14,32] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.",
      "startOffset" : 25,
      "endOffset" : 32
    }, {
      "referenceID" : 31,
      "context" : "A (strong) back door set [14,32] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.",
      "startOffset" : 25,
      "endOffset" : 32
    } ],
    "year" : 2013,
    "abstractText" : "A wide range of problems can be modelled as constraint satisfaction problems (CSPs), that is, a set of constraints that must be satisfied simultaneously. Constraints can either be represented extensionally, by explicitly listing allowed combinations of values, or implicitly, by special-purpose algorithms provided by a solver. Such implicitly represented constraints, known as global constraints, are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. In recent years, a variety of restrictions on the structure of CSP instances that yield tractable classes have been identified. However, many such restrictions fail to guarantee tractability for CSPs with global constraints. In this paper, we investigate the properties of extensionally represented constraints that these restrictions exploit to achieve tractability, and show that there are large classes of global constraints that also possess these properties. This allows us to lift these restrictions to the global case, and identify new tractable classes of CSPs with global constraints.",
    "creator" : "LaTeX with hyperref package"
  }
}