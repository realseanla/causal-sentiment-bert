{
  "name" : "1610.01525.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Lifted Message Passing for the Generalized Belief Propagation",
    "authors" : [ "Udi Apsel" ],
    "emails" : [ "apsel@cs.bgu.ac.il" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n61 0.\n01 52\n5v 1\n[ cs\n.A I]\n5 O\nWe introduce the lifted Generalized Belief Propagation (GBP) message passing algorithm, for the computation of sum-product queries in Probabilistic Relational Models (e.g. Markov logic network). The algorithm forms a compact region graph and establishes a modified version of message passing, which mimics the GBP behavior in a corresponding ground model. The compact graph is obtained by exploiting a graphical representation of clusters, which reduces cluster symmetry detection to isomorphism tests on small local graphs. The framework is thus capable of handling complex models, while remaining domain-size independent."
    }, {
      "heading" : "1 Introduction",
      "text" : "Probabilistic Relational Models (PRM) (e.g. Markov logic network [13]) are compact and expressive representations of probabilistic models, which succinctly capture probabilistic rules using the language of first-order predicate logic. Albeit their compactness, inferring from these rules is a challenging task, which gave rise to a family of algorithms bundled under the name lifted inference, dedicated to exploiting the inherent symmetry exhibited by the compact representations. One of the popular lifted inference methods is an adaptation of the famous sum-product Belief-Propagation (BP) [21] algorithm to relational models [8, 16]. Based on a synchronous message passing schedule which exploits the symmetry of the relational model, lifted BP manages to compress huge probabilistic models into surprisingly small representations, while mimicking the BP behavior exactly.\nIn this paper we introduce the first domain-size independent framework which lifts the generalized BP algorithm (GBP) [21] in its classical message passing form, and thus allows the injection of more constraints on the marginals compared with non-generalized BP implementations. A related work by [18] introduced a method which produces similar approximations, by relaxing the relational model’s structure [4], compensating for the relaxation and finally performing exact inference. Their implementation shows good results on many instances, however the method’s execution time is still polynomial in the domain size. Our method, in contrast, is entirely domain-size independent (in case of no evidence), and does not rely on any external engine for inference.\nOur work heavily relies on a recently introduced graphical platform called Cluster Signature Graph (CSG) [2], which projects the relational structure of clusters of variables onto a graph, and allows symmetry detection via an isomorphism test. Based on this platform, we formulate a compact representation of the region graph, which is the graphical structure used for the GBP message passing. This lifted region graph is accompanied by a modified version of message passing, which mimics the GBP behavior in a respective ground model. The core reliance on a graphical representation enables us to frame most parts of this work in graphical terms, which are sometimes separate from terms used in similar lifted inference works. Nevertheless, this high-level perspective is what makes the framework capable of handling relational models of complex structure.\nWe begin with two background section, one introducing the GBP algorithm and related concepts, the other providing background on relational models and the CSG platform. The lifted GBP framework is presented next, starting with an overview, and continuing with the more formal parts of this work. We conclude with an empirical demonstration of the framework and a brief discussion."
    }, {
      "heading" : "2 Background",
      "text" : ""
    }, {
      "heading" : "2.1 Inference in Markov Random Field (MRF)",
      "text" : "A Markov Random Field (MRF) M is a probabilistic graphical model, consisting of a set of random variables x = {xi}i and a set of factors. A factor is a pair (φf , xf ), which represents a function φf : range(xf ) → R\n+, mapping from the joint assignment range of variables xf ⊆ x, to the non-negative reals. The joint distribution function of MRFs is given by\nPr(x = x̂) = 1\nZ\n∏\nf φf (x̂f ) (1)\nwhere x̂ is a joint assignment to all x variables, x̂f is the respective joint assignment to all xf variables under x̂, and Z denotes a normalization constant called the partition function. A common task in MRFs is that of marginalization, which is computing the probability of all possible states in a subset of variables x′ ⊆ x , as follows.\nPr(x′) ∝ ∑\nx\\x′\n∏\nf φf (xf ) (2)\nThe result of Equation 2 is a function, mapping from range(x′) to the non-negative reals."
    }, {
      "heading" : "2.2 Generalized Belief Propagation (GBP)",
      "text" : "The marginalization task is #P-complete [14], and it is therefore common to approximate its result, rather than to carry out exact computations. One such approximation method is the sum-product Belief Propagation (BP). The algorithm schedules messages between neighboring nodes in the graphical models, until messages converge, and thus simultaneously computes marginals on all random variables in the model. Although BP does not guarantee to converge in graphs that contain loops, the procedure often arrives at a reasonable set of approximations to the correct marginal distributions [7]. The result then corresponds to a stationary point of the Bethe free energy approximation.\nThe Generalized Belief Propagation (GBP) algorithm is, as its name suggests, a generalization of the BP algorithm. GBP messages are sent from one cluster of variables to another, in a graphical structure called a region graph. When the algorithm converges, the result corresponds to a stationary point of the Kikuchi free energy approximation [21], a tighter free energy approximation compared with Bethe. In this this work we focus on the parent to child message passing variation of GBP."
    }, {
      "heading" : "2.2.1 Regions and Region Graphs",
      "text" : "A region [20] is a tuple (xα, fα), which represents a node in the GBP message passing graph. xα is a cluster of MRF variables with a respective set of indices α, and fα is a set of MRF factors whose scope is a subset of xα (or xα entirely). For simplicity and notational convenience, we will assume that fα contains all factors under the ⊆ xα scope. Hence, the notation α will be sufficient to denote a region of a corresponding scope of variables.\nA region graph GR = (V,E) is a Directed Acyclic Graph, with nodes in V denoting regions, and directed edges in E denoting parent to child (source to target) relations. We define the conditions which a region graph must respect, as follows. (1) For every pair of distinct regions α1, α2 which are not subsets of one another, there exists an intersection region β = α1 ∩ α2. (2) For every pair of regions α, β, the proposition β ⊂ α is true iff β is a descendant of α; (3) The set of parent-less regions (called outer regions) must consist of all scopes of MRF factors.\nGenerating region graphs can be understood as an iterative process [21], where region intersections are applied, first on outer regions, which are given as input, and then on the resulting intersections. For example, given the set of outer regions {1, 2, 3, 4}, {1, 2, 5, 6}, {1, 3, 5, 7}, a region graph is generated such that intermediate intersections {1, 2}, {1, 3} and {1, 5} are added, and a subsequent intersection {1} is added as a child to all these intermediate intersections."
    }, {
      "heading" : "2.2.2 Parent-To-Child Message Passing",
      "text" : "Let (xα, fα) denote a region in the region graph GR. We define Par(α) as the set of all regions that are parents of α, and Desc(α) as the set of all its descendants. The algorithm starts by arbitrarily defining messages mα→β from all parent regions to their child regions. At each phase of the algorithm, messages are updated according to the following rules.\nbα(xα) ∝ ∏\nf∈fα\nφf (xf ) ∏\nρ∈Par(α)\nmρ→α(xα) ∏\nγ∈Desc(α)\n∏\nρ∈Par(γ)\\{α}\\Desc(α)\nmρ→γ(xγ) (3)\nmα→β(xβ) ←−\n∑\nxα\\xβ bα(xα)\nbβ(xβ) mα→β(xβ) (4)\nWhen the algorithm converges, the belief state of xα is obtained via the computation of bα(xα)."
    }, {
      "heading" : "3 Probabilistic Relational Models",
      "text" : "Probabilistic Relational Models (PRM) are representations of probabilistic models using the language of first-order predicate logic. Of the two most common models, Markov logic network [13] and the parfactor model [12], we choose the latter to represent a relational MRF. We thus include a brief introduction to the parfactor model, and refer to [5] for a more comprehensive overview."
    }, {
      "heading" : "3.1 Relational MRF",
      "text" : "A domain is a set of constants, called domain objects, that represent distinctive entities in the modeled world, e.g. {Alice, Bob, Carol, . . .}. A logical variable (lvar) is a variable whose assignment range is associated with some domain. An atom is an atomic formula of the form p(t1, . . . , tn), where the symbol p is called a predicate1, and each term ti is either a domain object or an lvar. A ground atom is an atom whose ti terms are all domain objects. Non-ground atoms are collections of ground atoms, all sharing the same assignment range, and describing a certain property of an individual (e.g. smoker) or some relation between individuals (e.g. friendship). A ground substitution {Xi/oi}i, is the replacement of each lvar Xi with a domain object oi.\nThe parfactor model Mr (aka relational MRF) is a collection of relational factors, called parfactors. A parfactor is a tuple (φ,A,R), consisting of a function φ : range(A) → R+, an ordered set of atoms A, and a set of constraints R imposed on A’s lvars. Grounding a parfactor is done by applying all ground substitutions that are consistent with R, resulting in a collection of factors. The ground atoms then serve as random variables in the ground MRF. A notation φ(A |R) is commonly used to denote a parfactor. For example, parfactor φ(sm(X), sm(Y ), fr(X,Y )|X 6= Y ), whose ground instances in the domain {Alice, Bob} are (i) φ ( sm(Alice), sm(Bob), fr(Alice, Bob) )\nand (ii) φ ( sm(Bob), sm(Alice), fr(Bob,Alice) ) .\nWe restrict our attention to shattered [5] models, consisting of inequality constraints of the form X 6= Y only. Additionally, such inequality constraints will be imposed on each pair of lvars X,Y where, in their absence, a ground factor with multiple entries of the same ground atom may be produced. For instance, φ(p(X), p(Y )) may produce a ground factor φ(p(o1), p(o1)), and will therefore be split into two parfactors: φ(p(X), p(Y )|X 6= Y ) and some φ′(p(X)). Finally, the notations r(i,j) and pi will be used to abbreviate r(oi, oj) and p(oi), respectively."
    }, {
      "heading" : "3.2 Symmetry Between Clusters",
      "text" : "The first-order representation of relational models introduces a substantial amount of symmetry, which can be exploited for either exact or approximate inference. In exact inference, computational operators must typically take into account the partitioning of the model into isomorphic components [17]. In comparison, approximate inference methods [11, 3, 10] are able to exploit a more relaxed form of symmetry, one that is exhibited between clusters of MRF variables.\n1Although the term predicate is used, atoms are not restricted to Boolean assignments.\nDefinition 1 Clusters xα and xα′ are said to be symmetrical if there exists a structure preserving permutation π on the MRF’s variables (i.e. a permutation belonging to the automorphism group of the graphical model), under which each xi ∈ xα is mapped onto a distinctive xj ∈ xα′ .\nIn [2], a platform based on graphical signatures of clusters is introduced, providing a principled way to incorporate clustering based methods in lifted inference."
    }, {
      "heading" : "3.2.1 Cluster Signatures and Canonical Clusters",
      "text" : "Let xα denote a cluster of ground atoms obtained from the relational MRF Mr. The Cluster Signature Graph (CSG) of xα is the projection of its content onto a graph, in a way that guarantees two important properties : (i) If the CSGs of xα and xα′ are isomorphic, then xα and xα′ are symmetrical. (ii) The mapping induced by such an isomorphism constitutes a structure preserving permutation in the relational MRF. For lack of space, we present a simpler definition of CSG than the one introduced by [2], which captures slightly less symmetry and pertains to shattered models.\nDefinition 2 The CSG of cluster xα is a directed colored multigraph G = (V,E,C), where V is a set of vertices, E is a set of directed edges and C is a coloring function, mapping each edge to a color. Edges and colors in the CSG are defined as follows. (1) For each member of xα originating from a unary ground atom pi, let G contain a node i and a self-edge carrying the color ’p’; (2) For each member of xα originating from a binary ground atom r(i,j), let G contain the nodes i and j and a directed edge i → j carrying the color ’r’.\nOne important feature of CSGs is that of canonical clusters. Canonical clusters are unique representatives for all clusters belonging to the same symmetry class. Each cluster xα corresponds to a canonical representative xα∗ , that can be obtained by applying canonical labeling to the CSG of xα using dedicated graph canonization tools (e.g. nauty [9]), and extracting the canonical cluster’s variable members from the edges of the canonically labeled graph.\nSince CSGs consist only of cluster members, all related tasks (canonization, isomorphism tests, etc.) which are derived from this graphical representation are, at worst, exponential in the cluster size. This locality property is what makes the framework efficient and domain-size independent. Although CSGs are also capable of detecting symmetry in presence of evidence, we avoid this more complicated representation in this work, and will simply resort to the shattering of the model."
    }, {
      "heading" : "4 Lifting the Generalized Belief Propagation",
      "text" : "Lifting the generalized belief propagation can be regarded as a two stage process. First, given a relational MRF and a set of outer regions, a compact region graph is formed, entirely comprised of regions corresponding to canonical clusters. Second, a message passing algorithm, specifically adapted to the lifted graph, is applied, producing the exact same result as would the ground GBP. We begin with a short overview of the lifted framework."
    }, {
      "heading" : "4.1 Lifted GBP – An Overview",
      "text" : "Consider obtaining a region graph for the relational MRF φ(p(X), q(Y )|X 6= Y ), where all pairs {pi, qj} (i 6= j) serve as outer regions. Such a graph can be obtained by finding all the intersections induced by the {pi, qj} pairs, and defining two edges from each pair to its members: {pi, qj} → pi and {pi, qj} → qj . However, the highly symmetric nature of the region graph allows to capture its structure much more succinctly, via a representation which simulates the description given above.\nWe first define symmetry in the context of region graphs. Regions α and α′ are said to be symmetrical if there exists a permutation π\nR on the region graph’s nodes which preserves its structure, and\nunder which π R (α) = α′. Somewhat unsurprisingly, symmetry of regions is directly derived from the symmetry of their respective clusters. Here, all pairs {pi, qj} are symmetrical in the relational model, and thus so are the corresponding regions. The same applies to all the atomic p and q regions.\nAt this point, we would like to utilize the canonical representation of clusters to form a compact (lifted) region graph, comprised entirely of such clusters. Consider the cluster {pi, qj}, whose region will serve as a canonical representative for all pairs. Similarly, let pk and qm denote the canonical\nrepresentatives for the single atom regions. The lifted region graph should then consist of two edges: {pi, qj} → pk and {pi, qj} → qm. To represent the flow of messages from parent to child, each edge is accompanied by a mapping, expressing which ”role” the child assumes w.r.t. the parent members. Here, the mapping pi 7→ pk will be associated with one edge, and qj 7→ qm will be associated with the other. Still, edges in the lifted graph must indicate how many symmetrical parents are connected to a single child, in the role specified by each edge. In our example, this cardinality is quite natural. If the domain size is N , then each pk is connected to N − 1 parents from the {pi, qj} symmetry class under then role of pi, and each qm is connected to N − 1 such parents under then role of qj .\nConsider now a slightly different model, consisting entirely of {pi, pj} pairs. Let all pairs {pi, pj} and all single pk instances be symmetrical. The lifted region graph must then consist of two nodes, {pi, pj} and pk, to denote the canonical representatives as before, but instead of two edges from {pi, pj} to pk, only one edge is required. The reason, which will be formalized in the next subsection, is that the special structure of the model forces messages being sent from each {pi, pj} to pi, to be entirely identical to those sent to pj . pk can then assume one of the roles pi or pj , arbitrarily, and still reflect correctly the message flow in the ground region graph.\nLastly, we wish to simulate message passing in the ground graph by sending messages in the lifted graph. Such simulation is possible if the messages in the ground graph are scheduled such that the graphical model’s symmetry is reflected in the messages. This is indeed the case with the flooding schedule where, at each iteration, all nodes send messages at the exact same time. Under an assumption of initial message symmetry, if regions α and β are mapped to α′ and β′ by a structure preserving permutation, then at any iteration of the algorithm, messages from α to β remain symmetrical to those sent from α′ to β′. Consequently, there is no need for an explicit representation of both α, β and α′, β′ in the lifted graph. We formalize this reasoning in the next subsection."
    }, {
      "heading" : "4.2 Symmetry-Preserving Properties",
      "text" : "The lifted GBP framework is based on two symmetry oriented properties. The first states that symmetry preserving permutations for the region graph are derived from the joint structure of the MRF and the set of chosen outer regions. The second property formalizes the symmetry preserving nature of the flooding schedule, allowing for a compact representation of the message flow. Formally,\nTheorem 1 Let Ω denote a set of outer regions for MRF M, and let GR denote a region graph obtained by iterative intersections. Then, any permutation π on M’s variables which preserves the structure of both Ω and M, induces a permutation π\nR which, when applied to the region graph’s\nnodes, preserves its structure.\nTheorem 2 Let G denote a graph, and let π R be a structure preserving permutation on the graph’s nodes. Let A denote a deterministic, graph structure based, message passing algorithm, applied to G with a flooding schedule, and initialized such that for any pair of nodes (u, v), the message from u to v (denoted by mu→v) is equal to mπ\nR (u)→π R (v) under the permutation πR . Then, mu→v\nremains equal to mπ R (u)→π R (v) under πR throughout the entire execution of A.\nCorollary 1 Let region α denote the parent of regions β1 and β2 in the region graph, and let πR denote a structure preserving permutation, mapping β1 to β2 and α to itself. Then, all messages sent from α to β1 are identical to those sent from α to β2, under the permutation πR ."
    }, {
      "heading" : "4.3 Generating the Lifted Region Graph",
      "text" : "Before generating the lifted graph, we must choose which outer regions the represent. A natural pick would be all regions with scopes corresponding to factors in the ground MRF. The added value for this pick is that, if carefully constructed, each ground instance of a parfactor corresponds to a scope of some canonical cluster. More specifically, if a X ! = Y constraint is injected for each pair of lvars X,Y in the model, and the model is shattered accordingly, the canonical outer regions can be picked without any computational effort. We continue with a formal definition of the lifted region graph.\nDefinition 3 A lifted region graph GR = (V,E, σ, κ) is a Directed Acyclic Multigraph, with nodes in V denoting regions, directed edges in E denoting parent to child relations, σ denoting a function which associates each edge with a mapping from the parent’s variables to those of the child, and κ\nAlgorithm 1: GENERATELIFTEDREGIONGRAPH\nInput: Canonical representations of outer regions Ω Output: A lifted region graph GR\n1 V = Ω, E = {}, σ = {}, κ = {} 2 GR ≡ (V,E, σ, κ)\n3 Let dmax denote the maximum size of any region in Ω 4 for d = dmax down to 2 do 5 Let D denote all regions of size d in V 6 for α ∈ D, β ∈ subsets of α of size d− 1 do 7 Let β∗ denote the canonical representation of β 8 Add region β∗ to V 9 Let Σ denote a set of mappings from β to β∗, derived from isomorphisms of their CSGs\n10 for ς ∈ Σ do 11 Let k denote the cardinality of the α → β∗ parent-child relation under the mapping ς 12 Let E consist of an edge e from α to β∗, with properties σ(e) = ς and κ(e) = k 13 return GR\ndenoting a function which associates each edge with a positive integer, representing the cardinality of the parent-child relation.\nA lifted region graph is obtained by identifying symmetrical intersections induced by the graph’s regions, and representing each set of symmetrical regions via a single (canonical) region. The method for identifying these lifted intersections is based on the following observation. Let the region graph consist of an edge α → β between regions α and β. Then, for each structure preserving permutation π\nR mapping α to α′, the region graph consists of an edge α′ → β′, where β′ is the image of β under\nπ R . Notably, intersections may exist between parent regions from different symmetry classes, or between parents of the same symmetry class. It is therefore convenient to approach this problem as a search over the canonical representations of all subsets in each of the regions.\nAlgorithm 1 depicts the generation of the lifted region graph2. The input of the algorithm is a set of indices of canonical clusters, which represent the outer regions. The output is the lifted region graph GR. The algorithm iterates over all subsets β of size d − 1 taken from regions of size d, starting with d as the size of the maximal outer region, and down to 2. A canonical representation β∗ for each such subset is obtained and added as a child region to the canonical parent, under (potentially) several distinct directed edges: one for each mapping from β to β∗, where the mappings are derived from all isomorphisms of their respective CSGs. See Figures 1a and 1b for illustration.\nHowever, some mappings from subsets of a canonical parent α to a canonical child β∗, must be filtered-out in order to maintain the lifted graph’s correctness. If (not necessarily distinct) subsets of α, denoted by β1 and β2, map onto the same β∗ and their mappings indicate the existence of a structure preserving permutation which maps β1 to β2 while mapping α to itself, then including both mappings as edges would result in over-counting the GBP messages. The existence of such a permutation can be detected via the following procedure. (i) Combine the mapping from β1 to β∗ with the opposite mapping from β2 to β∗, to produce a mapping from β1 from β2. (ii) The sought permutation exists iff the mapping from β1 to β2 is an automorphism of α’s CSG. pi and pj from the canonical pair {pi, pj} in Subsection 4.1, are an example for such β1 and β2."
    }, {
      "heading" : "4.4 Computing the Parent-Child Cardinality",
      "text" : "Let α → β∗ denote an edge from region α to β∗ in the lifted region graph. Let β denote the subset of α mapped to β∗ under the edge’s mapping. The cardinality of the edge, denote by κ(α → β∗), is the number of all clusters in the relational MRF mapped to xα in a structure preserving permutation, while mapping all members of β to themselves. Thus, for models with N domain objects, where nβ\n2We note that the procedure, under this chosen formulation, may produce a lifted region graph consisting of non-intersection regions, which serve as targets for only a single directed edge, and whose cardinality equals 1. Such regions can alternatively be removed from the graph, by connecting their parent directly to their children.\ndenotes the number of objects referenced in the cluster xβ and nα\\β is the number of domain objects in xα not referenced by xβ , the cardiniality is given by κ(α → β∗) = ∏nα\\β i=1 N − nβ − i+ 1."
    }, {
      "heading" : "4.5 Lifted Message Passing",
      "text" : "Messages in the lifted region graph are defined per a parent-to-child edge. Notably, pairs of parentchild, α and β, may be connected multiple times via distinct edges. The key to forming the messages is obtaining the belief states of both regions, bα and bβ . Each belief is derived from both the structure of the lifted graph and the region’s internal structure. The reason for this mixture is that different descendants of a region (e.g. region α), although might be members of the same symmetry class, may very well not be mapped one onto the other under any structure preserving permutation which maps α onto itself. Therefore, subsets of α which are symmetrical w.r.t. the global structure, may still affect α’s belief state in a non-symmetrical way. To overcome this obstacle, we define the notion of a local graph. The local graph of canonical region α is the set of all its (non-canonized) subsets, connected such as to form a region graph whose most top region is α (see Figure 1c).\nBefore introducing the lifted messages, we define some related notations. ∼ xα→β denotes all xα variables but those which take part in the mapping from α to β. inEdges(α) denotes all α’s incoming edges in the lifted region graph, where each such edge will be denoted by ρ → α. localDesc(α) denotes all non-canonized subsets of α, γ∗ denotes the canonical representation of a region γ, and localPar(α, γ, ρ∗ → γ∗) denotes all members of α’s local graph (includingα) that are parents of γ, and are connected via an edge in the local graph whose corresponding edge in the lifted region graph is ρ∗ → γ∗. Lastly, the notation σ(α→β) : χ denotes the result of applying the mapping associated with the lifted edge α → β, to the variables of function χ. The update rules of the lifted message passing are given by the following equations.\nbα(xα) ∝ ∏\nf∈fα\nφf (xf ) ∏\n(ρ→α)∈inEdges(α)\nmρ→α(xα) κ(ρ→α) (5)\n∏\nγ∈localDesc(α)\nσ(γ∗ 7→γ) : ∏\n(ρ∗→γ∗)∈inEdges(γ∗)\nmρ∗→γ∗(xγ∗) κ(ρ∗→γ∗)−|localPar(α,γ,ρ∗→γ∗)|\nmα→β(xβ) ←− σ(α→β) :\n∑\n∼xα→β bα(xα)\nbβ(xβ) mα→β(xβ) (6)\nFinding localPar(α, γ, ρ∗ → γ∗) can be non-trivial. One way to obtain this set of local regions is to ”reconstruct” the procedure that associated γ∗ with all its lifted parents, as follows. Let σ(γ∗ 7→γ) denote a mapping from γ∗ to γ, derived from an isomorphism of their CSGs. We will define two sets of graphs G and G∗ such that the combination of isomorphisms from members of G to G∗ guarantees adequate matchings from all edges in α’s local graph to those in the lifted graph. A distinct integer is associated with each member of γ, 1 through |γ|. Members of G are defined as the CSGs of all parents of γ in the local graph, modified such that edge colors of members of γ (e.g. ’r’,’p’), are augmented by the associated integer (e.g. ’r = 1’,’p = 3’).\nG∗ consists of one graph per each edge terminating in γ∗ in the lifted region graph. Each such graph is a CSG with modified colors. More specifically, let ρ∗ → γ∗ denote an edge in the lifted region graph whose associated mapping is σ(ρ∗→γ∗). G∗ should then consist of the CSG of ρ∗, with colors that are modified according to a matching from the members of ρ∗ to the members of γ. Matching from ρ∗ to γ is done by combining the mapping σ(ρ∗→γ∗) with σ(γ∗ 7→γ). If the mapped γ member consists of the color ’r = 1’, so will the corresponding ρ∗ member. Lastly, a graph in G that is isomorphic with a graph in G∗, will be associated with the latter’s edge. Figure 1c depicts the association of edges in a local graph obtained from the lifted region graph in Figure 1a."
    }, {
      "heading" : "5 Empirical Evaluation",
      "text" : "We conducted experiments on 4 structurally distinctive relational models. The first model is a friends smokers model (i.e. friends(X,Y ) ∧ smokes(X) =⇒ smokes(Y )), the second is a transitive model [2], the third is a transitive friends knows model [1], and the forth is the chain model whose region graphs are depicted in Figure 1. Graph isomorphism tests were conducted using the NetworkX package [6]. The time required to generate the lifted graphs turned out to be in the range of tens of milliseconds. In all experiments, we ran 500 iterations of lifted GBP message passing with a damping factor of 0.5 and normalization of both beliefs and messages. Message computations were carried in log space in order to maintain numerical stability. Time performance and query results were compared against the WFOMC [19] engine, which is capable of computing GBP queries (Lifted RCR), as well as lifted BP (LBP). Lifted RCR times were normalized by reducing the time of respective LBP computations, thereby eliminating engine overhead of parsing and preprocessing from the comparison. Since our implementation is lightweight and domain size independent, it significantly dominates in time performance. Results of probabilistic queries were practically identical for RCR and our implementation. Notably, non-generalized lifted BP computations for the transitive model, return very similar results to GBP, and were omitted. The chain model, which does not appear in any of the figures, did not converge neither in RCR nor in our implementation."
    }, {
      "heading" : "6 Conclusions",
      "text" : "We introduced a lifted GBP message passing algorithm which is domain-size independent in shattered models. Although the scope of this work is confined to sum-product queries, the compact formulation of the lifted region graph may serve other algorithms which rely on a similar structure. One aspect worth exploring is extending the scope of outer regions, not only to regions defined using first-order theory, but also to all regions of a given size, similarly to lift and project hierarchies [15]. Such attempts may lead to tightened results and improved convergence in highly complex models."
    } ],
    "references" : [ {
      "title" : "Exploiting uniform assignments in first-order MPE",
      "author" : [ "U. Apsel", "R.I. Brafman" ],
      "venue" : "N. de Freitas and K. P. Murphy, editors, UAI, pages 74–83. AUAI Press",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Lifting Relational MAP-LPs using Cluster Signatures",
      "author" : [ "U. Apsel", "K. Kersting", "M. Mladenov" ],
      "venue" : "In Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence (AAAI),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Automorphism groups of graphical models and lifted variational inference",
      "author" : [ "H. Bui", "T. Huynh", "S. Riedel" ],
      "venue" : "Proceedings of the Twenty-Ninth Conference Annual Conference on Uncertainty in Artificial Intelligence (UAI-13), pages 132–141, Corvallis, Oregon",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "An edge deletion semantics for belief propagation and its practical impact on approximation quality",
      "author" : [ "A. Choi", "A. Darwiche" ],
      "venue" : "AAAI, pages 1107–1114",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Lifted first-order probabilistic inference",
      "author" : [ "R. de Salvo Braz", "E. Amir", "D. Roth" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2005
    }, {
      "title" : "Exploring network structure",
      "author" : [ "A. Hagberg", "P. Swart", "D. S Chult" ],
      "venue" : "dynamics, and function using networkx. Technical report, Los Alamos National Laboratory (LANL)",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Loopy belief propagation: Convergence and effects of message errors",
      "author" : [ "A.T. Ihler", "J.W.F. III", "A.S. Willsky" ],
      "venue" : "Journal of Machine Learning Research, 6:905–936",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Counting Belief Propagation",
      "author" : [ "K. Kersting", "B. Ahmadi", "S. Natarajan" ],
      "venue" : "Proc. of the 25th Conf. on Uncertainty in Artificial Intelligence (UAI–09)",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Practical graph isomorphism",
      "author" : [ "B.D. McKay", "A. Piperno" ],
      "venue" : "{II}. Journal of Symbolic Computation, 60(0):94 – 112",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Efficient lifting of MAP LP relaxations using k-locality",
      "author" : [ "M. Mladenov", "A. Globerson", "K. Kersting" ],
      "venue" : "17th Int. Conf. on Artificial Intelligence and Statistics ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Markov chains on orbits of permutation groups",
      "author" : [ "M. Niepert" ],
      "venue" : "Proc. of the 28th Conf. on Uncertainty in Artificial Intelligence (UAI)",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "First-order probabilistic inference",
      "author" : [ "D. Poole" ],
      "venue" : "G. Gottlob and T. Walsh, editors, IJCAI, pages 985–991. Morgan Kaufmann",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Markov logic networks",
      "author" : [ "M. Richardson", "P. Domingos" ],
      "venue" : "Machine Learning, 62(1-2):107– 136",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "On the hardness of approximate reasoning",
      "author" : [ "D. Roth" ],
      "venue" : "Artif. Intell., 82(1-2):273–302",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "A hierarchy of relaxations between the continuous and convex hull representations for zero-one programming problems",
      "author" : [ "H.D. Sherali", "W.P. Adams" ],
      "venue" : "SIAM J. Discrete Math., 3(3):411– 430",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Lifted First-Order Belief Propagation",
      "author" : [ "P. Singla", "P. Domingos" ],
      "venue" : "In Proc. of the 23rd AAAI Conf. on Artificial Intelligence",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2008
    }, {
      "title" : "First-order decomposition trees",
      "author" : [ "N. Taghipour", "J. Davis", "H. Blockeel" ],
      "venue" : "NIPS, pages 1052–1060",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Lifted relax, compensate and then recover: From approximate to exact lifted probabilistic inference",
      "author" : [ "G. Van den Broeck", "A. Choi", "A. Darwiche" ],
      "venue" : "In UAI,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2012
    }, {
      "title" : "Lifted probabilistic inference by first-order knowledge compilation",
      "author" : [ "G. Van den Broeck", "N. Taghipour", "W. Meert", "J. Davis", "L.D. Raedt" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2011
    }, {
      "title" : "On the choice of regions for generalized belief propagation",
      "author" : [ "M. Welling" ],
      "venue" : "UAI, pages 585– 592",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Understanding belief propagation and its generalizations",
      "author" : [ "J.S. Yedidia", "W.T. Freeman", "Y. Weiss" ],
      "venue" : "Exploring artificial intelligence in the new millennium, 8:236–239",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "Markov logic network [13]) are compact and expressive representations of probabilistic models, which succinctly capture probabilistic rules using the language of first-order predicate logic.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 20,
      "context" : "One of the popular lifted inference methods is an adaptation of the famous sum-product Belief-Propagation (BP) [21] algorithm to relational models [8, 16].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 7,
      "context" : "One of the popular lifted inference methods is an adaptation of the famous sum-product Belief-Propagation (BP) [21] algorithm to relational models [8, 16].",
      "startOffset" : 147,
      "endOffset" : 154
    }, {
      "referenceID" : 15,
      "context" : "One of the popular lifted inference methods is an adaptation of the famous sum-product Belief-Propagation (BP) [21] algorithm to relational models [8, 16].",
      "startOffset" : 147,
      "endOffset" : 154
    }, {
      "referenceID" : 20,
      "context" : "In this paper we introduce the first domain-size independent framework which lifts the generalized BP algorithm (GBP) [21] in its classical message passing form, and thus allows the injection of more constraints on the marginals compared with non-generalized BP implementations.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 17,
      "context" : "A related work by [18] introduced a method which produces similar approximations, by relaxing the relational model’s structure [4], compensating for the relaxation and finally performing exact inference.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 3,
      "context" : "A related work by [18] introduced a method which produces similar approximations, by relaxing the relational model’s structure [4], compensating for the relaxation and finally performing exact inference.",
      "startOffset" : 127,
      "endOffset" : 130
    }, {
      "referenceID" : 1,
      "context" : "Our work heavily relies on a recently introduced graphical platform called Cluster Signature Graph (CSG) [2], which projects the relational structure of clusters of variables onto a graph, and allows symmetry detection via an isomorphism test.",
      "startOffset" : 105,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "The marginalization task is #P-complete [14], and it is therefore common to approximate its result, rather than to carry out exact computations.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 6,
      "context" : "Although BP does not guarantee to converge in graphs that contain loops, the procedure often arrives at a reasonable set of approximations to the correct marginal distributions [7].",
      "startOffset" : 177,
      "endOffset" : 180
    }, {
      "referenceID" : 20,
      "context" : "When the algorithm converges, the result corresponds to a stationary point of the Kikuchi free energy approximation [21], a tighter free energy approximation compared with Bethe.",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 19,
      "context" : "A region [20] is a tuple (xα, fα), which represents a node in the GBP message passing graph.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 20,
      "context" : "Generating region graphs can be understood as an iterative process [21], where region intersections are applied, first on outer regions, which are given as input, and then on the resulting intersections.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 12,
      "context" : "Of the two most common models, Markov logic network [13] and the parfactor model [12], we choose the latter to represent a relational MRF.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 11,
      "context" : "Of the two most common models, Markov logic network [13] and the parfactor model [12], we choose the latter to represent a relational MRF.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 4,
      "context" : "We thus include a brief introduction to the parfactor model, and refer to [5] for a more comprehensive overview.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 4,
      "context" : "We restrict our attention to shattered [5] models, consisting of inequality constraints of the form X 6= Y only.",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 16,
      "context" : "In exact inference, computational operators must typically take into account the partitioning of the model into isomorphic components [17].",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 10,
      "context" : "In comparison, approximate inference methods [11, 3, 10] are able to exploit a more relaxed form of symmetry, one that is exhibited between clusters of MRF variables.",
      "startOffset" : 45,
      "endOffset" : 56
    }, {
      "referenceID" : 2,
      "context" : "In comparison, approximate inference methods [11, 3, 10] are able to exploit a more relaxed form of symmetry, one that is exhibited between clusters of MRF variables.",
      "startOffset" : 45,
      "endOffset" : 56
    }, {
      "referenceID" : 9,
      "context" : "In comparison, approximate inference methods [11, 3, 10] are able to exploit a more relaxed form of symmetry, one that is exhibited between clusters of MRF variables.",
      "startOffset" : 45,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "In [2], a platform based on graphical signatures of clusters is introduced, providing a principled way to incorporate clustering based methods in lifted inference.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "For lack of space, we present a simpler definition of CSG than the one introduced by [2], which captures slightly less symmetry and pertains to shattered models.",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 8,
      "context" : "nauty [9]), and extracting the canonical cluster’s variable members from the edges of the canonically labeled graph.",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 1,
      "context" : "friends(X,Y ) ∧ smokes(X) =⇒ smokes(Y )), the second is a transitive model [2], the third is a transitive friends knows model [1], and the forth is the chain model whose region graphs are depicted in Figure 1.",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "friends(X,Y ) ∧ smokes(X) =⇒ smokes(Y )), the second is a transitive model [2], the third is a transitive friends knows model [1], and the forth is the chain model whose region graphs are depicted in Figure 1.",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 5,
      "context" : "Graph isomorphism tests were conducted using the NetworkX package [6].",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 18,
      "context" : "Time performance and query results were compared against the WFOMC [19] engine, which is capable of computing GBP queries (Lifted RCR), as well as lifted BP (LBP).",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 14,
      "context" : "One aspect worth exploring is extending the scope of outer regions, not only to regions defined using first-order theory, but also to all regions of a given size, similarly to lift and project hierarchies [15].",
      "startOffset" : 205,
      "endOffset" : 209
    } ],
    "year" : 2016,
    "abstractText" : "We introduce the lifted Generalized Belief Propagation (GBP) message passing algorithm, for the computation of sum-product queries in Probabilistic Relational Models (e.g. Markov logic network). The algorithm forms a compact region graph and establishes a modified version of message passing, which mimics the GBP behavior in a corresponding ground model. The compact graph is obtained by exploiting a graphical representation of clusters, which reduces cluster symmetry detection to isomorphism tests on small local graphs. The framework is thus capable of handling complex models, while remaining domain-size independent.",
    "creator" : "LaTeX with hyperref package"
  }
}