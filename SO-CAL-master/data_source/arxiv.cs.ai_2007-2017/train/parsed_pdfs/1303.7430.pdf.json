{
  "name" : "1303.7430.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Introducing Nominals to the Combined Query Answering Approaches for EL",
    "authors" : [ "Giorgio Stefanoni", "Boris Motik", "Ian Horrocks" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Introduction Description logics (DLs) (Baader et al. 2007) are a family of knowledge representation formalisms that underpin OWL 2 (Cuenca Grau et al. 2008)—an ontology language used in advanced information systems with many practical applications. Answering conjunctive queries (CQs) over ontologyenriched data sets is a core reasoning service in such systems, so the computational aspects of this problem have received a lot of interest lately. For expressive DLs, the problem is at least doubly exponential in query size (Glimm et al. 2008). The problem, however, becomes easier for the EL (Baader, Brandt, and Lutz 2005) and the DL-Lite (Calvanese et al. 2007) families of DLs, which provide the foundation for the OWL 2 EL and the OWL 2 QL profiles of OWL 2. An important goal of this research was to devise not only worstcase optimal, but also practical algorithms. The known approaches can be broadly classified as follows.\nThe first group consists of automata-based approaches for DLs such as OWL 2 EL (Krötzsch, Rudolph, and Hitzler 2007) and Horn-SHOIQ and Horn-SROIQ (Ortiz, Rudolph, and Simkus 2011). While worst-case optimal, these approaches are typically not suitable for practice since their best-case and worst-case performance often coincide.\nCopyright c© 2013, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nThe second group consists of rewriting-based approaches. Roughly speaking, these approaches rewrite the ontology and/or the query into another formalism, typically a union of conjunctive queries or a datalog program; the relevant answers can then be obtained by evaluating the rewriting over the data. Rewriting-based approaches were developed for members of the DL-Lite family (Calvanese et al. 2007; Artale et al. 2009), and the DLs ELHIO⊥ (Pérez-Urbina, Motik, and Horrocks 2010) and Horn-SHIQ (Eiter et al. 2012), to name just a few. A common problem, however, is that rewritings can be exponential in the ontology and/or query size. Although this is often not a problem in practice, such approaches are not worst-case optimal. An exception is the algorithm by Rosati (2007) that rewrites an ELH⊥ ontology into a datalog program of polynomial size; however, the algorithm also uses a nondeterministic step to transform the CQ into a tree-shaped one, and it is not clear how to implement this step in a goal-directed manner.\nThe third group consists of combined approaches, which use a three-step process: first, they augment the data with certain consequences of the ontology; second, they evaluate the CQ over the augmented data; and third, they filter the result of the second phase to eliminate unsound answers. The third step is necessary because, to ensure termination, the first step is unsound and may introduce facts that do not follow from the ontology; however, this is done in a way that makes the third step feasible. Such approaches have been developed for logics in the DL-Lite (Kontchakov et al. 2011) and the EL (Lutz, Toman, and Wolter 2009) families, and they are appealing because they are worst-case optimal and practical: only the second step is intractable (in query size), but it can be solved using well-known database techniques.\nNone of the combined approaches proposed thus far, however, handles nominals—concepts containing precisely one individual. Nominals are included in OWL 2 EL, and they are often used to state that all instances of a class have a certain property value, such as ‘the sex of all men is male’, or ‘each German city is located in Germany’. In this paper we present a combined approach for ELHOr⊥—the DL that covers all features of OWL 2 EL apart from transitive roles and complex role inclusions. To the best of our knowledge, this is the first combined approach that handles nominals. Our extension is nontrivial because nominals require equality reasoning, which increases the complexity of the first and\nar X\niv :1\n30 3.\n74 30\nv2 [\ncs .A\nI] 1\nA pr\n2 01\n3\nthe third step of the algorithm. In particular, nominals may introduce recursive dependencies in the filtering conditions used in the third phase; this is in contrast to the known combined approach for EL (Lutz, Toman, and Wolter 2009) in which filtering conditions are not recursive and can be incorporated into the input query. To solve this problem, our algorithm evaluates the original CQ and then uses a polynomial function to check the relevant conditions for each answer.\nFollowing Krötzsch, Rudolph, and Hitzler (2008), instead of directly materialising the relevant consequences of the ontology and the data, we transform the ontology into a datalog program that captures the relevant consequences. Although seemingly just a stylistic issue, a datalog-based specification may be beneficial in practice: one can either materialise all consequences of the program bottom-up in advance, or one can use a top-down technique to compute only the consequences relevant for the query at hand. The latter can be particularly useful in informations systems that have read-only access to the data, or where data changes frequently.\nWe have implemented a prototypical system using our algorithm, and we carried out a preliminary empirical evaluation of (i) the blowup in the number of facts introduced by the datalog program, and (ii) the number of unsound answers obtained in the second phase. Our experiments show both of these numbers to be manageable in typical cases, suggesting that our algorithm provides a practical basis for answering CQs in an expressive fragment of OWL 2 EL.\nThe proofs of our technical results are provided in this paper’s appendix.\nPreliminaries Logic Programming. We use the standard notions of variables, constants, function symbols, terms, atoms, formulas, and sentences (Fitting 1996). We often identify a conjunction with the set of its conjuncts. A substitution σ is a partial mapping of variables to terms; dom(σ) and rng(σ) are the domain and the range of σ, respectively; σ|S is the restriction of σ to a set of variables S; and, for α a term or a formula, σ(α) is the result of simultaneously replacing each free variable x occurring in α with σ(x). A Horn clause C is an expression of the form B1 ∧ . . . ∧Bm → H , where H and each Bi are atoms. Such C is a fact if m = 0, and it is commonly written as H . Furthermore, C is safe if each variable occurring inH also occurs in someBi. A logic program Σ is a finite set of safe Horn clauses; furthermore, Σ is a datalog program if each clause in Σ is function-free.\nIn this paper, we interpret a logic program Σ in a model that can be constructed bottom-up. The Herbrand universe of Σ is the set of all terms built from the constants and the function symbols occurring in Σ. Given an arbitrary set of facts B, let Σ(B) be the smallest superset of B such that, for each clause ϕ→ ψ ∈ Σ and each substitution σ mapping the variables occurring in the clause to the Herbrand universe of Σ, if σ(ϕ) ⊆ B, then σ(ψ) ⊆ Σ(B). Let I0 be the set of all facts occurring in Σ; for each i ∈ N, let Ii+1 = Σ(Ii); and let I = ⋃ i∈N Ii. Then I is the minimal Herbrand model of Σ, and it is well known that I satisfies ∀~x.C for each Horn clause C ∈ Σ and ~x the vector of all variables occurring in C.\nIn this paper we allow a logic program Σ to contain the equality predicate ≈. In first-order logic, ≈ is usually interpreted as the identity over the interpretation domain; however, ≈ can also be explicitly axiomatised (Fitting 1996). Let Σ≈ be the set containing clauses (1)–(3), an instance of clause (4) for each n-ary predicate R occurring in Σ and each 1 ≤ i ≤ n, and an instance of clause (5) for each n-ary function symbol f occurring in Σ and each 1 ≤ i ≤ n.\n→ x ≈ x (1) x1 ≈ x2 → x2 ≈ x1 (2)\nx1 ≈ x2 ∧ x2 ≈ x3 → x1 ≈ x3 (3) R(~x) ∧ xi ≈ x′i → R(x1, . . . , x′i, . . . , xn) (4)\nxi ≈ x′i → f(. . . , xi, . . .) ≈ f(. . . , x′i, . . .) (5)\nThe minimal Herbrand model of a logic program Σ that contains ≈ is the minimal Herbrand model of Σ ∪ Σ≈.\nConjunctive Queries. A conjunctive query (CQ) is a formula q = ∃~y.ψ(~x, ~y) with ψ a conjunction of functionfree atoms over variables ~x ∪ ~y. Variables ~x are the answer variables of q. Let NT (q) be the set of terms occurring in q.\nLet τ be a substitution such that rng(τ) contains only constants. Then, τ(q) = ∃~z.τ(ψ), where ~z is obtained from ~y by removing each variable y ∈ ~y for which τ(y) is defined. Note that, according to this definition, non-free variables can also be replaced; for example, given q = ∃y1, y2.R(y1, y2) and τ = {y2 7→ a}, we have τ(q) = ∃y1.R(y1, a).\nLet Σ be a logic program, let I be the minimal Herbrand model of Σ, and let q = ∃~y.ψ(~x, ~y) be a CQ that uses only the predicates occurring in Σ. A substitution π is a candidate answer for q in Σ if dom(π) = ~x and rng(π) contains only constants; furthermore, such a π is a certain answer to q over Σ, written Σ |= π(q), if a substitution τ exists such that dom(τ) = ~x ∪ ~y, π = τ |~x, and τ(q) ⊆ I .\nDescription Logic. DL ELHOr⊥ is defined w.r.t. a signature consisting of mutually disjoint and countably infinite sets NC , NR, and NI of atomic concepts (i.e., unary predicates), roles (i.e., binary predicates), and individuals (i.e., constants), respectively. Furthermore, for each individual a ∈ NI , expression {a} denotes a nominal—that is, a concept containing precisely the individual a. Also, we assume that > and ⊥ are unary predicates (without any predefined meaning) not occurring in NC . We consider only normalised knowledge bases, as it is well known (Baader, Brandt, and Lutz 2005) that each ELHOr⊥ knowledge base can be normalised in polynomial time without affecting the answers to CQs. An ELHOr⊥ TBox is a finite set of ax-\nioms of the form shown in the left-hand side of Table 1, where A(i) ∈ NC ∪ {>}, B ∈ NC ∪ {>,⊥}, R,S ∈ NR, and a ∈ NI . An ABox A is a finite set of facts constructed using the symbols fromNC ∪ {>,⊥},NR, andNI . Finally, an ELHOr⊥ knowledge base (KB) is a tuple K = 〈T ,A〉, where T is an ELHOr⊥ TBox T and an A is an ABox such that each predicate occurring in A also occurs in T .\nWe interpret K as a logic program. Table 1 shows how to translate a TBox T into a logic program Ξ(T ). Moreover, let >(T ) be the set of the following clauses instantiated for each atomic concept A and each role R occurring in T .\nA(x)→ >(x) R(x, y)→ >(x) R(x, y)→ >(y)\nA knowledge base K = 〈T ,A〉 is translated into the logic program Ξ(K) = Ξ(T ) ∪ >(T ) ∪ A. Then, K is unsatisfiable if Ξ(K) |= ∃y.⊥(y). Furthermore, given a conjunctive query q and a candidate answer π for q, we write K |= π(q) iff K is unsatisfiable or Ξ(K) |= π(q). Although somewhat nonstandard, our definitions of DLs are equivalent to the ones based on the standard denotational semantics (Baader et al. 2007). Given a candidate answer π for q, deciding whether Ξ(K) |= π(q) holds is NP-complete in combined complexity, and PTIME-complete in data complexity (Krötzsch, Rudolph, and Hitzler 2007).\nDatalog Rewriting of ELHOr⊥ TBoxes For the rest of this section, we fix an arbitrary ELHOr⊥ knowledge base K = 〈T ,A〉. We next show how to transform K into a datalog program D(K) that can be used to check the satisfiability of K. In the following section, we then show how to use D(K) to answer conjunctive queries.\nDue to axioms of type 6 (cf. Table 1), Ξ(K) may contain function symbols and is generally not a datalog program; thus, the evaluation of Ξ(K) may not terminate. To ensure termination, we eliminate function symbols from Ξ(K) using the technique by Krötzsch, Rudolph, and Hitzler (2008): for each A ∈ NC ∪ {>} and each R ∈ NR occurring in T , we introduce a globally fresh and unique auxiliary individual oR,A. Intuitively, oR,A represents all terms in the Herbrand universe of Ξ(K) needed to satisfy the existential concept ∃R.A. Krötzsch, Rudolph, and Hitzler (2008) used this technique to facilitate taxonomic reasoning, while we use it to obtain a practical CQ answering algorithm. Please note that oR,A depends on both R and A, whereas in the known approaches such individuals depend only onA (Lutz, Toman, and Wolter 2009) or R (Kontchakov et al. 2011). Definition 1. Datalog program D(T ) is obtained by translating each axiom of type other than 6 in the TBox T of K into a clause as shown in Table 1, and by translating each axiom A1 v ∃R.A in T into clauses A1(x)→ R(x, oR,A) and A1(x)→ A(oR,A). Furthermore, the translation of K into datalog is given by D(K) = D(T ) ∪ >(T ) ∪ A. Example 1. Let T be the following ELHOr⊥ TBox:\nKRC v ∃taught .JProf ∃taught .> v Course Course v ∃taught .Prof {kr} v KRC\nProf v ∃advisor .Prof KRC v Course JProf v {john} range(taught ,Prof )\nThen, D(T ) contains the following clauses:\nKRC (x)→ taught(x, oT,J) JProf (x)→ x ≈ john KRC (x)→ JProf (oT,J) taught(x, y)→ Course(x) Course(x)→ taught(x, oT,P ) KRC (kr) Course(x)→ Prof (oT,P ) KRC (x)→ Course(x) Prof (x)→ advisor(x, oA,P ) taught(x, y)→ Prof (y) Prof (x)→ Prof (oA,P ) ♦\nThe following result straightforwardly follows from the definition of Ξ(K) and D(K). Proposition 2. Program D(K) can be computed in time linear in the size of K.\nNext, we prove that the datalog program D(K) can be used to decide the satisfiability of K. To this end, we define a function δ that maps each term w in the Herbrand universe of Ξ(K) to the Herbrand universe of D(K) as follows:\nδ(w) = { w if w ∈ NI , oR,A if w is of the form w = fR,A(w′).\nLet I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively. Mapping δ establishes a tight relationship between I and J as illustrated in the following example. Example 2. Let A = {Course(ai)}, let T be as in Example 1, and letK = 〈T ,A〉. Figure 1 shows a graphical representation of the minimal Herbrand models I and J of Ξ(K) and D(K), respectively. The grey dotted lines show how δ relates the terms in I to the terms in J. For the sake of clarity, Figure 1 does not show the reflexivity of ≈. ♦\nMapping δ is a homomorphism from I to J. Lemma 3. Let I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively. Mapping δ satisfies the following three properties for all terms w′ and w, each B ∈ NC ∪ {>,⊥}, and each R ∈ NR. 1. B(w) ∈ I implies B(δ(w)) ∈ J."
    }, {
      "heading" : "2. R(w′, w) ∈ I implies R(δ(w′), δ(w)) ∈ J.",
      "text" : ""
    }, {
      "heading" : "3. w′ ≈ w ∈ I implies δ(w′) ≈ δ(w) ∈ J.",
      "text" : "For a similar result in the other direction, we need a couple of definitions. Let H be an arbitrary Herbrand model. Then,\ndom(H) is the set containing each term w that occurs in H in at least one fact with a predicate in NC ∪ {>,⊥} ∪NR; note that, by this definition, we havew 6∈ dom(H) whenever w occurs in H only in assertions involving the ≈ predicate. Furthermore, auxH is the set of all terms w ∈ dom(H) such that, for each term w′ with w ≈ w′ ∈ H , we have w′ 6∈ NI . We say that the terms in auxH are ‘true’ auxiliary terms— that is, they are not equal to an individual in NI . In Figure 1, bold terms are ‘true’ auxiliary terms in I and J. Lemma 4. Let I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively. Mapping δ satisfies the following five properties for all terms w1 and w2 in dom(I), each B ∈ NC ∪ {>,⊥}, and each R ∈ NR. 1. B(δ(w1)) ∈ J implies that B(w1) ∈ I. 2. R(δ(w1), δ(w2)) ∈ J and δ(w2) 6∈ auxJ imply that R(w1, w2) ∈ I. 3. R(δ(w1), δ(w2)) ∈ J and δ(w2) ∈ auxJ imply that δ(w2) is of the form oP,A, thatR(w1, fP,A(w1)) ∈ I, and that a term w′1 exists such that R(w ′ 1, w2) ∈ I. 4. δ(w1) ≈ δ(w2) ∈ J and δ(w2) 6∈ auxJ imply that w1 ≈ w2 ∈ I. 5. For each term u occurring in J, term w ∈ dom(I) exists such that δ(w) = u. Lemmas 3 and 4 allow us to decide the satisfiability of K by answering a simple query over D(K), as shown in Proposition 5. The complexity claim is due to the fact that each clause in D(K) contains a bounded number of variables (Dantsin et al. 2001). Proposition 5. For K an arbitrary ELHOr⊥ knowledge base, Ξ(K) |= ∃y.⊥(y) if and only if D(K) |= ∃y.⊥(y). Furthermore, the satisfiability of K can be checked in time polynomial in the size of K.\nAnswering Conjunctive Queries In this section, we fix a satisfiable ELHOr⊥ knowledge base K = 〈T ,A〉 and a conjunctive query q = ∃~y.ψ(~x, ~y). Furthermore, we fix I and J to be the minimal Herbrand models of Ξ(K) and D(K), respectively.\nWhile D(K) can be used to decide the satisfiability of K, the following example shows that D(K) cannot be used directly to compute the answers to q. Example 3. Let K be as in Example 2, and let q1, q2, and q3 be the following conjunctive queries:\nq1 = taught(x1, x2)\nq2 = ∃y1, y2, y3. taught(x1, y1) ∧ taught(x2, y2) ∧ advisor(y1, y3) ∧ advisor(y2, y3)\nq3 = ∃y. advisor(y, y)"
    }, {
      "heading" : "Furthermore, let τi be the following substitutions:",
      "text" : "τ1 = {x1 7→ kr , x2 7→ oT,P } τ2 = {x1 7→ kr , x2 7→ ai , y1 7→ oT,P , y2 7→ oT,P , y3 7→ oA,P } τ3 = {y 7→ oA,P }\nFinally, let each πi be the projection of τi to the answer variables of qi. Using Figure 1, one can readily check that D(K) |= τi(qi), but Ξ(K) 6|= πi(qi), for each 1 ≤ i ≤ 3. ♦\nThis can be explained by observing that J is a homomorphic image of I. Now homomorphisms preserve CQ answers (i.e., Ξ(K) |= π(q) implies D(K) |= π(q)), but they can also introduce unsound answers (i.e., D(K) |= π(q) does not necessarily imply Ξ(K) |= π(q)). This gives rise to the following notion of spurious answers. Definition 6. A substitution τ with dom(τ) = ~x ∪ ~y and D(K) |= τ(q) is a spurious answer to q if τ |~x is not a certain answer to q over Ξ(K).\nBased on these observations, we answer q over K in two steps: first, we evaluate q over D(K) and thus obtain an overestimation of the certain answers to q over Ξ(K); second, for each substitution τ obtained in the first step, we eliminate spurious answers using a special function isSpur. We next formally introduce this function. We first present all relevant definitions, after which we discuss the intuitions. As we shall see, each query in Example 3 illustrates a distinct source of spuriousness that our function needs to deal with. Definition 7. Let τ be a substitution s.t. dom(τ) = ~x ∪ ~y and D(K) |= τ(q). Relation ∼ ⊆ NT (q)×NT (q) for q, τ , and D(K) is the smallest reflexive, symmetric, and transitive relation closed under the fork rule, where auxD(K) is the set containing each individual u from D(K) for which no individual c ∈ NI exists such that D(K) |= u ≈ c.\ns′ ∼ t′(fork) R(s, s ′) and P (t, t′) occur in q, and\nτ(s′) ∈ auxD(K)s ∼ t Please note that the definition auxD(K) is actually a reformulation of the definition of auxJ , but based on the consequences of D(K) rather than the facts in J.\nRelation ∼ is reflexive, symmetric, and transitive, so it is an equivalence relation, which allows us to normalise each term t ∈ NT (q) to a representative of its equivalence class using the mapping γ defined below. We then construct a graphGaux that checks whether substitution τ matches ‘true’ auxiliary individuals in a way that cannot be converted to a match over ‘true’ auxiliary terms in I. Definition 8. Let τ and ∼ be as specified in Definition 7. Function γ : NT (q) 7→ NT (q) maps each term t ∈ NT (q) to an arbitrary, but fixed representative γ(t) of the equivalence class of ∼ that contains t. Furthermore, the directed graph Gaux = 〈Vaux, Eaux〉 is defined as follows. • Set Vaux contains a vertex γ(t) ∈ NT (q) for each term t ∈ NT (q) such that τ(t) ∈ auxD(K).\n• Set Eaux contains an edge 〈γ(s), γ(t)〉 for each atom of the form R(s, t) in q such that {γ(s), γ(t)} ⊆ Vaux.\nQuery q is aux-cyclic w.r.t. τ and D(K) if Gaux contains a cycle; otherwise, q is aux-acyclic w.r.t. τ and D(K).\nWe are now ready to define our function that checks whether a substitution τ is a spurious answer. Definition 9. Let τ and ∼ be as specified in Definition 7. Then, function isSpur(q,D(K), τ) returns t if and only if at least one of the following conditions hold. (a) Variable x ∈ ~x exists such that τ(x) 6∈ NI . (b) Terms s and t occurring in q exist such that s ∼ t and\nD(K) 6|= τ(s) ≈ τ(t).\n(c) Query q is aux-cyclic w.r.t. τ and D(K). We next discuss the intuition behind our definitions. We\nground our discussion in minimal Herbrand models I and J, but our technique does not depend on such models: all conditions are stated as entailments that can be checked using an arbitrary sound and complete technique. Since K is an ELHOr⊥ knowledge base, model I is forest-shaped: roughly speaking, the role assertions in I that involve at least one functional term are of the form R(w1, fR,A(w1)) or R(w1, a) for a ∈ NI ; thus, I can be viewed as a family of directed trees whose roots are the individuals in NI and whose edges point from parents to children or to the individuals in NI . This is illustrated in Figure 1, whose lower part shows the the forest-model of the knowledge base from Example 3. Note that assertions of the form R(w1, a) are introduced via equality reasoning.\nNow let τ be a substitution such that D(K) |= τ(q), and let π = τ |~x. If τ is not a spurious answer, it should be possible to convert τ into a substitution π∗ such that π = π∗|~x and π∗(q) ⊆ I. Using the queries from Example 3, we next identify three reasons why this may not be possible.\nFirst, τ may map an answer variable of q to an auxiliary individual, so by the definition π cannot be a certain answer to q; condition (a) of Definition 9 identifies such cases. Query q1 and substitution τ1 from Example 3 illustrate such a situation: τ2(x2) = oT ,P and oT ,P is a ‘true’ auxiliary individual, so π1 is not a certain answer to q1.\nThe remaining two problems arise because model J is not forest-shaped, so τ might map q into J in a way that cannot be converted into a substitution π∗ that maps q into I.\nThe second problem is best explained using substitution τ2 and query q2 from Example 3. Query q2 contains a ‘fork’ advisor(y1, y3) ∧ advisor(y2, y3). Now τ2(y3) = oA,P is a ‘true’ auxiliary individual, and so it represents ‘true’ auxiliary terms fA,P (fT,P (ai)), fA,P (fT,P (kr)), and so on. Since I is forest-shaped, a match π∗2 for q in I obtained from τ2 would need to map y3 to one of these terms; let us assume that π∗2(y3) = fA,P (fT,P (ai)). Since I is forestshaped and fA,P (fT,P (ai)) is a ‘true’ auxiliary term, this means that both y1 and y2 must be mapped to the same term (in both J and I). This is captured by the (fork) rule: in our example, the rule derives y1 ∼ y2, and condition (b) of Definition 9 checks whether τ2 maps y1 and y2 in a way that satisfies this constraint. Note that, due to role hierarchies, the rule needs to be applied to atoms R(s, s′) and P (t, t′) with R 6= P . Moreover, such constraints must be propagated further up the query. In our example, due to y1 ∼ y2, atoms taught(x1, y1) ∧ taught(x2, y2) in q2 also constitute a ‘fork’, so the rule derives x1 ∼ x2; now this allows condition (b) of Definition 9 to correctly identify τ2 as spurious.\nThe third problem is best explained using substitution τ3 and query q3 from Example 3. Model J contains a ‘loop’ on individual oA,P , which allows τ3 to map q3 into J. In contrast, model I is forest-shaped, and so the ‘true’ auxiliary terms that correspond to oA,P do not form loops. Condition (c) of Definition 9 detects such situations using the graph Gaux. The vertices of Gaux correspond to the terms of q that are matched to ‘true’ auxiliary individuals (mapping γ simply ensures that equal terms are represented as one vertex),\nand edges of Gaux correspond to the role atoms in q. Hence, if Gaux is cyclic, then the substitution π∗ obtained from τ would need to match the query q over a cycle of ‘true’ auxiliary terms, which is impossible since I is forest-shaped.\nUnlike the known combined approaches, our approach does not extend q with conditions that detect spurious answers. Due to nominals, the relevant equality constraints have a recursive nature, and they depend on both the substitution τ and on the previously derived constraints. Consequently, filtering in our approach is realised as postprocessing; furthermore, to ensure correctness of our filtering condition, auxiliary individuals must depend on both a role and an atomic concept. The following theorem proves the correctness of our approach.\nTheorem 10. LetK = 〈T ,A〉 be a satisfiable ELHOr⊥ KB, let q = ∃~y.ψ(~x, ~y) be a CQ, and let π : ~x 7→ NI be a candidate answer for q. Then, Ξ(K) |= π(q) iff a substitution τ exists such that dom(τ) = ~x ∪ ~y, τ |~x = π, D(K) |= τ(q), and isSpur(q,D(K), τ) = f.\nFurthermore, isSpur(q,D(K), τ) can be evaluated in polynomial time, so the main source of complexity in our approach is in deciding whether D(K) |= τ(q) holds. This gives rise to the following result.\nTheorem 11. Deciding whetherK |= π(q) holds can be implemented in nondeterministic polynomial time w.r.t. the size of K and q, and in polynomial time w.r.t. the size of A.\nEvaluation To gain insight into the practical applicability of our approach, we implemented our technique in a prototypical system. The system uses HermiT, a widely used ontology reasoner, as a datalog engine in order to materialise the consequences of D(K) and evaluate q. The system has been implemented in Java, and we ran our experiments on a MacBook Pro with 4GB of RAM and an Intel Core 2 Duo 2.4 Ghz processor. We used two ontologies in our evaluation, details of which are given below. The ontologies, queries, and the prototype system are all available online at http://www.cs.ox.ac.uk/isg/tools/KARMA/.\nThe LSTW benchmark (Lutz et al. 2012) consists of an OWL 2 QL version of the LUBM ontology (Guo, Pan, and Heflin 2005), queries ql1, . . . , q l 11, and a data generator. The LSTW ontology extends the standard LUBM ontology with several axioms of type 6 (see Table 1). To obtain an ELHOr⊥ ontology, we removed inverse roles and datatypes, added 11 axioms using 9 freshly introduced nominals, and added one\naxiom of type 4 (see Table 1). These additional axioms resemble the ones in Example 1, and they were designed to test equality reasoning. The resulting signature consists of 132 concepts, 32 roles, and 9 nominals, and the ontology contains 180 axioms. From the 11 LSTW queries, we did not consider queries ql4, q l 6, q l 7, and q l 11 because their result sets were empty: ql4 relies on existential quantification over inverse roles, and the other three are empty already w.r.t. the original LSTW ontology. Query ql2 is similar to query q2 from Example 3, and it was designed to produce only spurious answers and thus stress the system. We generated data sets with 5, 10 and 20 universities. For each data set, we denote with L-i the knowledge base consisting of our ELHOr⊥ ontology and the ABox for i universities (see Table 2).\nSEMINTEC is an ontology about financial services developed within the SEMINTEC project at the University of Poznan. To obtain an ELHOr⊥ ontology, we removed inverse roles, role functionality axioms, and universal restrictions, added nine axioms of type 6 (see Table 1), and added six axioms using 4 freshly introduced nominals. The resulting ontology signature consists of 60 concepts, 16 roles, and 4 nominals, and the ontology contains 173 axioms. Queries qs1–q s 5 are tree-shaped queries used in the SEMINTEC project, and we developed queries qs6–q s 9 ourselves. Query qs6 resembles query q l 2 from LSTW, and queries q s 8 and qs9 were designed to retrieve a large number of answers containing auxiliary individuals, thus stressing condition (a) of Definition 9. Finally, the SEMINTEC ontology comes with a data set consisting of approximately 65,000 facts concerning 18,000 individuals (see row SEM in Table 2).\nThe practicality of our approach, we believe, is determined mainly by the following two factors. First, the number of facts involving auxiliary individuals introduced during the materialisation phase should not be ‘too large’. Table 2 shows the materialisation results: the first column shows the number of individuals before and after materialisation and the percentage of ‘true’ auxiliary individuals, the second column shows the number of unary facts before and after materialisation and the percentage of facts involving a ‘true’ auxiliary individual, and the third column does the same for binary facts. As one can see, for each input data set, the materialisation step introduces few ‘true’ auxiliary individuals, and the number of facts at most doubles. The number of unary facts involving a ‘true’ auxiliary individual does not change with the size of the input data set, whereas the number of such binary facts increases by a constant factor. This is because, in clauses of type 6, atoms A(oR,A) do not contain a variable, whereas atoms R(x, oR,A) do.\nSecond, evaluating q over D(K) should not produce too\nmany spurious answers. Table 3 shows the total number of answers for each query—that is, the number of answers obtained by evaluating the query over D(K); furthermore, the table also shows what percentage of these answers are spurious. Queries ql2, q l 10, q s 6, and q s 8 retrieve a significant percentage of spurious answers. However, only query ql2 has proven to be challenging for our system due to the large number of retrieved answers, with an evaluation time of about 40 minutes over the largest knowledge base (L-20). Surprisingly, ql1 also performed rather poorly despite a low number of spurious answers, with an evaluation time of about 20 minutes for L-20. All other queries were evaluated in at most a few seconds, thus suggesting that queries ql1 and q l 2 are problematical mainly because HermiT does not implement query optimisation algorithms typically used in relational databases.\nConclusion We presented the first combined technique for answering conjunctive queries over DL ontologies that include nominals. A preliminary evaluation suggests the following. First, the number of materialised facts over ‘true’ anonymous individuals increases by a constant factor with the size of the data. Second, query evaluation results have shown that, while some cases may be challenging, in most cases the percentage of answers that are spurious is manageable. Hence, our technique provides a practical CQ answering algorithm for a large fragment of OWL 2 EL.\nWe anticipate several directions for our future work. First, we would like to investigate the use of top-down query evaluation techniques, such as magic sets (Abiteboul, Hull, and Vianu 1995) or SLG resolution (Chen and Warren 1993). Second, tighter integration of the detection of spurious answers with the query evaluation algorithms should make it possible to eagerly detect spurious answers (i.e., before the query is fully evaluated). Lutz et al. (2012) already implemented a filtering condition as a user-defined function in a database, but it is unclear to what extent such an implementation can be used to optimise query evaluation. Finally, we would like to extend our approach to all of OWL 2 EL.\nAcknowledgements This work was supported by the Royal Society; AlcatelLucent; the EU FP7 project OPTIQUE; and the EPSRC projects ExODA, MASI3, and QueRe.\nReferences Abiteboul, S.; Hull, R.; and Vianu, V. 1995. Foundations of Databases. Addison-Wesley. Artale, A.; Calvanese, D.; Kontchakov, R.; and Zakharyaschev, M. 2009. The DL-Lite Family and Relations."
    }, {
      "heading" : "Journal of Artificial Intelligence Research 36:1–69.",
      "text" : "Baader, F.; Calvanese, D.; McGuinness, D.; Nardi, D.; and Patel-Schneider, P. F., eds. 2007. The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press. ISBN 9780511717383. Baader, F.; Brandt, S.; and Lutz, C. 2005. Pushing the EL Envelope. In Kaelbling, L. P., and Saffiotti, A., eds., Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI 2005), 364–369. Edinburgh, UK: Morgan Kaufmann Publishers. Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.; and Rosati, R. 2007. Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family. Journal of Automated Reasoning 9(3):385–429. Chen, W., and Warren, D. S. 1993. Query evaluation under the well-founded semantics. In Proceedings of the 12th"
    }, {
      "heading" : "ACM SIGACT-SIGMOD-SIGART symposium on Principles",
      "text" : "of database systems, PODS ’93, 168–179. New York, NY,"
    }, {
      "heading" : "USA: ACM.",
      "text" : "Cormen, T. H.; Leiserson, C. E.; Rivest, R. L.; and Stein, C. 2009. Introduction to Algorithms (3. ed.). MIT Press. Cuenca Grau, B.; Horrocks, I.; Motik, B.; Parsia, B.; PatelSchneider, P.; and Sattler, U. 2008. OWL 2: The next step for OWL. Journal of Web Semantics 6(4):309–322. Dantsin, E.; Eiter, T.; Gottlob, G.; and Voronkov, A. 2001. Complexity and expressive power of logic programming. ACM Computing Surveys 33(3):374–425. Eiter, T.; Ortiz, M.; Simkus, M.; Tran, T.-K.; and Xiao, G. 2012. Query Rewriting for Horn-SHIQ Plus Rules. In Proceedings of the 26th AAAI Conference on Artificial Intelligence, (AAAI 2012). AAAI Press. Fitting, M. 1996. First-order logic and automated theorem proving (2nd ed.). Secaucus, NJ, USA: Springer-Verlag New York, Inc. Glimm, B.; Horrocks, I.; Lutz, C.; and Sattler, U. 2008. Conjunctive Query Answering for the Description Logic SHIQ. Journal of Artificial Intelligence Research 31:151– 198. Guo, Y.; Pan, Z.; and Heflin, J. 2005. LUBM: A benchmark for OWL knowledge base systems. Journal of Web Semantics 3(2–3):158–182. Kontchakov, R.; Lutz, C.; Toman, D.; Wolter, F.; and Zakharyaschev, M. 2011. The Combined Approach to Ontology-Based Data Access. In Walsh, T., ed., Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI 2011). AAAI Press. Krötzsch, M.; Rudolph, S.; and Hitzler, P. 2007. Conjunctive queries for a tractable fragment of OWL 1.1. In Aberer, K.; Choi, K.-S.; Noy, N.; Allemang, D.; Lee, K.-I.; Nixon, L.; Golbeck, J.; Mika, P.; Maynard, D.; Mizoguchi, R.;\nSchreiber, G.; and Cudré-Mauroux, P., eds., Proceedings of the 6th International Semantic Web Conference (ISWC’07), volume 4825 of LNCS, 310–323. Springer. Krötzsch, M.; Rudolph, S.; and Hitzler, P. 2008. ELP: Tractable rules for OWL 2. In Sheth, A.; Staab, S.; Dean, M.; Paolucci, M.; Maynard, D.; Finin, T.; and Thirunarayan, K., eds., Proceedings of the 7th International Semantic Web Conference (ISWC’08), volume 5318 of LNCS, 649–664. Springer. Lutz, C.; Seylan, I.; Toman, D.; and Wolter, F. 2012. The Combined Approach to OBDA: Taming Role Hierarchies using Filters. In Fokoue, A.; Liebig, T.; Goodman, E.; Weaver, J.; Urbani, J.; and Mizell, D., eds., Proceedings of the Joint Workshop on Scalable and High-Performance Semantic Web Systems (SSWS+HPCSW 2012), volume 943 of CEUR Workshop Proceedings, 16–31. CEUR-WS.org. Lutz, C.; Toman, D.; and Wolter, F. 2009. Conjunctive Query Answering in the Description Logic EL Using a Relational Database System. In Boutilier, C., ed., Proceedings of the 21st International Joint Conference on Artificial Intelligence, (IJCAI 2009), 2070–2075. AAAI Press. Ortiz, M.; Rudolph, S.; and Simkus, M. 2011. Query Answering in the Horn Fragments of the Description Logics SHOIQ and SROIQ. In Walsh, T., ed., Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI 2011), 1039–1044. Barcelona, Spain: AAAI Press. Pérez-Urbina, H.; Motik, B.; and Horrocks, I. 2010. Tractable Query Answering and Rewriting under Description Logic Constraints. Journal of Applied Logic 8(2):186– 209. Rosati, R. 2007. On Conjunctive Query Answering in EL. In Calvanese, D.; Franconi, E.; Haarslev, V.; Lembo, D.; Motik, B.; Turhan, A.-Y.; and Tessaris, S., eds., Proceedings of the 20th International Workshop on Description Logics (DL-2007), CEUR Workshop Proceedings. CEUR-WS.org.\nAdditional Proofs"
    }, {
      "heading" : "Proof of Lemma 3",
      "text" : "Lemma 3. Let I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively. Mapping δ satisfies the following three properties for all terms w′ and w, each B ∈ NC ∪ {>,⊥}, and each R ∈ NR. 1. B(w) ∈ I implies B(δ(w)) ∈ J."
    }, {
      "heading" : "2. R(w′, w) ∈ I implies R(δ(w′), δ(w)) ∈ J.",
      "text" : ""
    }, {
      "heading" : "3. w′ ≈ w ∈ I implies δ(w′) ≈ δ(w) ∈ J.",
      "text" : "Proof. Let I0, I1, . . . be the sequence of sets used to construct I . We show by induction on n that each In satisfies the properties. Base case. Consider I0 and an arbitrary fact H ∈ I0. Each term occurring in H is contained in NI . Moreover, H is a fact from Ξ(K) and, by definition, it is also a fact from D(K). Now δ is the identity over NI , and J satisfies H , so properties 1 and 2 hold. Property 3 holds vacuously since I0 does not contain facts with the equality predicate.\nInductive step. Consider an arbitrary n ∈ N and assume that In satisfies properties 1–3; we show that the same holds for In+1. Towards this goal, we consider the different clauses in Ξ(K) ∪ Ξ(K)≈ that can derive fresh facts from In. We distinguish the following two cases.\nFirst, consider an arbitrary datalog clause of the formϕ→ ψ from Ξ(K) ∪ Ξ(K)≈. Let σ be an arbitrary substitution mapping variables occurring in the clause to the terms in the Herbrand universe of Ξ(K) such that σ(ϕ) ⊆ In, so the clause derives σ(ψ) ∈ In+1. Let σ′ be the substitution defined such that σ′(x) = δ(σ(x)) for each variable x occurring in the clause. By the inductive hypothesis, we have σ′(ϕ) ⊆ J. Furthermore, by the definition of D(K), we have that D(K) ∪ D(K)≈ contains ϕ→ ψ. Finally, since J satisfies ϕ→ ψ, we have σ′(ψ) ∈ J, as required.\nSecond, consider arbitrary clauses from Ξ(K) of the form A1(x)→ R(x, fR,A(x)) and A1(x)→ A(fR,A(x)), and assume that A1(w) ∈ In; hence, these clauses derive {R(w, fR,A(w)), A(fR,A(w))} ⊆ In+1. By the inductive hypothesis, we have A1(δ(w)) ∈ J. Furthermore, by the definition of δ, we have that δ(fR,A(w)) = oR,A. Moreover, by the definition of program D(K), the program contains clauses A1(x)→ R(x, oR,A) and A1(x)→ A(oR,A). Finally, model J satisfies both of these clauses, so we have {R(δ(w), oR,A) A(oR,A)} ⊆ J, as required."
    }, {
      "heading" : "Proof of Lemma 4",
      "text" : "In order to prove Lemma 4, we use the properties from Lemmas 12 and 13. Lemma 12. For each term w2, each role R ∈ NR, and each concept A ∈ NC ∪ {>}, if fR,A(w2) ∈ dom(I), then {R(w2, fR,A(w2)), A(fR,A(w2))} ⊆ I.\nProof. Let I0, I1, . . . be the sequence used to construct I; we assume w.l.o.g. that each In+1 is obtained from In by applying just one clause type. We show by induction on n that each In satisfies the properties. For the base case, set I0 clearly satisfies the property since it does not contain functional terms. For the inductive step, assume that some In satisfies the property, and consider an arbitrary term w2, role R, and concept A ∈ NC ∪ {>}. By the construction of Ξ(K), there are only two types of clauses that may introduce new functional terms in dom(In+1). First, such a term may be introduced by clauses of type 6 (see Table 1), but then the term clearly satisfies the required property. Second, a clause of the form x ≈ y → fR,A(x) ≈ fR,A(y) may be applied w1 ≈ w2 ∈ In and derive fR,A(w1) ≈ fR,A(w2) ∈ In+1. If fR,A(w2) ∈ dom(In), then set In+1 satisfies the required property by the induction hypothesis. Otherwise, term fR,A(w2) occurs in In+1 only in equality assertions, so fR,A(w2) 6∈ dom(In+1), and the property holds vacuously.\nLet J0, J1, . . . be the sequence used to construct the minimal Herbrand model J of D(K). We assume w.l.o.g. that each Jn+1 is obtained from Jn by applying a single clause occurring in D(K), apart from the clause defining the symmetry of ≈ which is always applied so as to keep the relation ≈ in Jn symmetric. We next show that each Jn satisfies the following property. Lemma 13. For each n ∈ N and all terms u1 and u2, if u1 ≈ u2 ∈ Jn and u2 ∈ auxJn , then u1 = u2.\nProof. We prove the claim by the induction on n. For the base case, J0 satisfies the property since auxJ0 is empty. For the inductive step, assume that some Jn satisfies the property; we show that the same holds for Jn+1. We consider the various clauses that may derive an equality in Jn+1. The facts derived by a clause of the form A(x)→ x ≈ a vacuously satisfy the property since the derived fact involves terms that are not in auxJn+1 . Furthermore, a fact derived in Jn+1 by applying either the reflexivity or the symmetry clause satisfies the property by the inductive hypothesis. We are left to consider the transitivity clause. Let u1, u2, and u3 be arbitrary terms such that {u1 ≈ u2, u2 ≈ u3} ⊆ Jn, so the transitivity clause derives u1 ≈ u3 ∈ Jn+1. We consider the interesting case in which u3 ∈ auxJn+1 , so u3 ∈ auxJn . By the inductive hypothesis, we have u2 = u3; but then, u2 ∈ auxJn , and so again, by the inductive hypothesis, we have u1 = u2; finally, this implies that u1 = u3.\nLemma 4. Let I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively. Mapping δ satisfies the following five properties for all terms w1 and w2 in dom(I), each B ∈ NC ∪ {>,⊥}, and each R ∈ NR. 1. B(δ(w1)) ∈ J implies that B(w1) ∈ I.\n2. R(δ(w1), δ(w2)) ∈ J and δ(w2) 6∈ auxJ imply that R(w1, w2) ∈ I.\n3. R(δ(w1), δ(w2)) ∈ J and δ(w2) ∈ auxJ imply that δ(w2) is of the form oP,A, that R(w1, fP,A(w1)) ∈ I, and that a term w′1 exists such that R(w′1, w2) ∈ I. 4. δ(w1) ≈ δ(w2) ∈ J and δ(w2) 6∈ auxJ imply that w1 ≈ w2 ∈ I.\n5. For each term u occurring in J, term w ∈ dom(I) exists such that δ(w) = u.\nProof. Let J0, J1, . . . be the sequence as stated above. We prove the claim by induction on n. Base case. Consider J0. By definition, Ξ(K) ∪ Ξ(K)≈ and D(K) ∪ D(K)≈ contain the same facts, all of which only refer to the individuals in NI and the predicates in NC ∪NR ∪ {>, ⊥}. Since δ is the identity over NI , auxJ0 is empty and J0 = I0, so properties 1–5 are satisfied.\nInductive step. Assume that some Jn satisfies properties 1–5; we show that the same holds for Jn+1. To this end, let w1 and w2 be arbitrary terms in dom(I). We next consider the various clauses in D(K) ∪ D(K)≈ that may derive fresh assertions in Jn+1.\n• A(x)→ B(x). Assume that A(δ(w1)) ∈ Jn, and so the clause derives B(δ(w1)) ∈ Jn+1. By the inductive hypothesis, we have A(w1) ∈ I. Finally, since the same clause occurs in Ξ(K), we have B(w1) ∈ I.\n• A(x)→ x ≈ a. Assume thatA(δ(w1)) ∈ Jn, and so for δ(w2) = w2 = a the clause derives δ(w1) ≈ δ(w2) in Jn+1. Clearly, we have δ(w2) 6∈ auxJn+1 . By the inductive hypothesis, we have A(w1) ∈ I. Finally, since the same clause occurs in Ξ(K), we have w1 ≈ w2 ∈ I.\n• A1(x) ∧A2(x)→ A(x). Assume that A1(δ(w1)) ∈ Jn and A2(δ(w1)) ∈ Jn, and so the clause derives A(δ(w1)) ∈ Jn+1. By the inductive hypothesis, we have {A1(w1), A2(w1)} ⊆ I. Since the same clause occurs in Ξ(K), we have A(w1) ∈ I.\n• R(x, y) ∧A1(y)→ A(x). Assume that R(δ(w1), δ(w2)) and A1(δ(w2)) are in contained Jn, and so the clause derives A(δ(w1)) ∈ Jn+1. We have the following two cases. – δ(w2) 6∈ auxJn . By the inductive hypothesis, we then have {R(w1, w2), A1(w2)} ⊆ I. – δ(w2) ∈ auxJn and term δ(w2) is an auxiliary individual of the form oP,A. By the inductive hypothesis, we then have {R(w1, fP,A(w1)), A1(fP,A(w1))} ⊆ I.\nIn either case, since the same clause occurs in Ξ(K), we have A(w1) ∈ I. • R(x, y)→ A(y). Assume that R(δ(w1), δ(w2)) ∈ Jn, so the clause derives A(δ(w2)) ∈ Jn+1. We have the following two\ncases. – δ(w2) 6∈ auxJn . By the inductive hypothesis, we then have R(w1, w2) ∈ I. – δ(w2) ∈ auxJn . By the inductive hypothesis, then there exists a term w′1 such that R(w′1, w2) ∈ I. In either case, since the same clause occurs in Ξ(K), we have A(w2) ∈ I.\n• S(x, y)→ R(x, y). Assume that S(δ(w1), δ(w2)) ∈ Jn, and so the clause derives R(δ(w1), δ(w2)) ∈ Jn+1. We have the following two cases. – δ(w2) 6∈ auxJn . By the inductive hypothesis, we have that S(w1, w2) ∈ I. Since the same clause occurs in Ξ(K), we have R(w1, w2) ∈ I.\n– δ(w2) ∈ auxJn and δ(w2) is an auxiliary individual of the form oP,A. By the inductive hypothesis, then there exists a term w′1 such that {S(w1, fP,A(w1)), S(w′1, w2)} ⊆ I. Since the same clause occurs in Ξ(K), we have that {R(w1, fP,A(w1)), R(w′1, w2)} ⊆ I. • A1(x)→ R(x, oR,A). Assume that A1(δ(w1)) ∈ Jn, so for δ(w2) = oR,A the clause derives R(δ(w1), δ(w2)) in Jn+1. By the inductive hypothesis, we then have A(w1) ∈ I. Furthermore, by the definition of D(K), set Ξ(K) contains the clause A1(x)→ R(x, fR,A(x)), so we have R(w1, fR,A(w1)) ∈ I. We have the following cases. – δ(w2) 6∈ auxJn+1 . Thus, we also have δ(w2) 6∈ auxJn , and so there exists some c ∈ NI such that δ(w2) ≈ δ(c) ∈ Jn and δ(c) 6∈ auxJn . By the inductive hypothesis, we have w2 ≈ c ∈ I. Due to δ(w2) = δ(fR,A(w1)) and the inductive hypothesis, we have c ≈ fR,A(w1) ∈ I. Since ≈ is a congruence relation and {R(w1, fR,A(w1)), c ≈ fR,A(w1), c ≈ w2} ⊆ I, we have R(w1, w2) ∈ I, as required. By the inductive hypothesis, property 5 is also satisfied.\n– δ(w2) ∈ auxJn+1 . By the definition of δ, term w2 is of the form fR,A(w′2), and, by the induction hypothesis, we have that fR,A(w′2) ∈ dom(I). By Lemma 12, we have that R(w′2, fR,A(w′2)) ∈ I. As stated above, R(w1, fR,A(w1)) ∈ I, so property 3 is satisfied. Moreover, δ(fR,A(w1)) = oR,A, and so property 5 is satisfied as well.\n• A1(x)→ A(oR,A). Assume that A1(δ(w1)) ∈ Jn, so for δ(w2) = oR,A the clause derives A(δ(w2)) ∈ Jn+1. By the definition of δ, term w2 is of the form fR,A(w′2). By Lemma 12 and w2 ∈ dom(I), we have A(w2) ∈ I.\n• → x ≈ x. Assume that δ(w1) occurs in Jn, so the clause derives δ(w1) ≈ δ(w2) ∈ Jn+1 with δ(w1) = δ(w2). We consider the interesting case when δ(w2) 6∈ auxJn+1 , and so δ(w2) 6∈ auxJn . Then, an individual c ∈ NI exists such that {δ(w1) ≈ c, c ≈ δ(w2)} ⊆ Jn. By the inductive hypothesis, we have that {w1 ≈ c, c ≈ w2} ⊆ I. By the transitivity of ≈, we have w1 ≈ w2 ∈ I.\n• x1 ≈ x2 → x2 ≈ x1. Assume that δ(w1) ≈ δ(w2) ∈ Jn, so the clause derives δ(w2) ≈ δ(w1) ∈ Jn+1. We consider the interesting case when δ(w1) 6∈ auxJn+1 ; clearly, we have δ(w1) 6∈ auxJn as well. Since predicate ≈ is symmetric in Jn, we have δ(w2) ≈ δ(w1) ∈ Jn. By the inductive hypothesis, we have w2 ≈ w1 ∈ I.\n• x1 ≈ x3 ∧ x3 ≈ x2 → x1 ≈ x2. Assume that set Jn contains δ(w1) ≈ δ(w3) and δ(w3) ≈ δ(w2), so the clause derives δ(w1) ≈ δ(w2) ∈ Jn+1. The only interesting case is when δ(w2) 6∈ auxJn+1 ; clearly, then δ(w2) 6∈ auxJn . By Lemma 13, then δ(w3) 6∈ auxJn . Finally, by the inductive hypothesis, then {w1 ≈ w3, w3 ≈ w2} ⊆ I, which implies w1 ≈ w2 ∈ I. • A(x) ∧ x ≈ y → A(y). Assume that facts A(δ(w1)) and δ(w1) ≈ δ(w2) are contained in Jn, so the clause derives A(δ(w2)) ∈ Jn+1. By the inductive hypothesis, we have A(w1) ∈ I. We consider the following two cases. – δ(w2) 6∈ auxJn . By the inductive hypothesis, we have w1 ≈ w2 ∈ I, and so A(w2) ∈ I. – δ(w2) ∈ auxJn . By Lemma 13, then δ(w1) = δ(w2), so A(δ(w2)) ∈ Jn. Finally, by the inductive hypothesis, we then\nhave A(w2) ∈ I. • R(x, y) ∧ x ≈ z → R(z, y). Assume that set Jn contains R(δ(w1), δ(w2)) and δ(w1) ≈ δ(w3), so the clause derives R(δ(w3), δ(w2)) ∈ Jn+1. We consider the following two cases. – δ(w2) 6∈ auxJn . By the inductive hypothesis, we have R(w1, w2) ∈ I. We distinguish two additional cases. First, assume\nthat δ(w3) ∈ auxJn . By Lemma 13, we have δ(w1) = δ(w3), and so R(δ(w3), δ(w2)) ∈ Jn. By the inductive hypothesis, then R(w3, w2) ∈ I. Second, assume that δ(w3) 6∈ auxJn . By the inductive hypothesis, we have w1 ≈ w3 ∈ I, and so we have R(w3, w2) ∈ I as well. – δ(w2) ∈ auxJn and δ(w2) = oP,A. By the inductive hypothesis, some w′1 exists s.t. {R(w1, fP,A(w1)), R(w′1, w2)} ⊆ I. We distinguish two additional cases. First, assume that δ(w3) ∈ auxJn . By Lemma 13, we have δ(w1) = δ(w3), which further implies R(δ(w3), δ(w2)) ∈ Jn. By the inductive hypothesis, then we have {R(w3, fP,A(w3)), R(w′1, w2)} ⊆ I. Second, assume that δ(w3) 6∈ auxJn . By the inductive hypothesis, we have w1 ≈ w3 ∈ I. By the functional reflexivity clauses, then fR,B(w1) ≈ fR,B(w3) ∈ I, which again implies {R(w3, fR,B(w3)), R(w′1, w2)} ⊆ I. • R(x, y) ∧ y ≈ z → R(x, z). Assume that set Jn contains R(δ(w1), δ(w2)) and δ(w2) ≈ δ(w3), so the clause derives R(δ(w1), δ(w3)) ∈ Jn+1. We consider the following two cases. – δ(w2) 6∈ auxJn . By Lemma 13, then δ(w3) 6∈ auxJn , and so δ(w3) 6∈ auxJn+1 as well. By the inductive hypotheses, then R(w1, w2) and w2 ≈ w3 are in I, so R(w1, w3) ∈ I as well.\n– δ(w2) ∈ auxJn and δ(w2) is of the form oP,A. By Lemma 13, then δ(w3) = δ(w2), which implies R(δ(w1), δ(w3)) ∈ Jn. Finally, by the inductive hypothesis, then there exists a term w′1 such that {R(w1, fR,B(w1)), R(w′1, w3)} ⊆ I."
    }, {
      "heading" : "Proof of Proposition 5",
      "text" : "Proposition 5. For K an arbitrary ELHOr⊥ knowledge base, Ξ(K) |= ∃y.⊥(y) if and only if D(K) |= ∃y.⊥(y). Furthermore, the satisfiability of K can be checked in time polynomial in the size of K.\nProof. From Lemmas 3 and 4, we have ⊥(w) ∈ I if and only if ⊥(δ(w)) ∈ J. Thus, K is unsatisfiable if and only if individual u exists such that D(K) |= ⊥(u). Furthermore, to check the latter, we can compute J and check whether an individual u exists such that ⊥(u) 6∈ J. Since the number of variables occurring in each datalog clause is bounded by a constant, the computation of J can be implemented in polynomial time in the size of K (Dantsin et al. 2001)."
    }, {
      "heading" : "Proof of Theorem 10",
      "text" : "We first show that the minimal Herbrand model I of Ξ(K) resembles a forest structure. Let I0, I1, . . . be the sets used to generate I; for simplicity, in the rest of this section we assume w.l.o.g. that the clauses are applied in a way so that relation ≈ is symmetric in each In. Furthermore, for each term w, we define the size of w as follows.\n|w| = {\n0 if w ∈ NI , 1 + |w′| if w is of the form fT,A(w′).\nFinally, we define the depth of w in I as follows.\nd(w, I) = { 0 if w 6∈ auxI , 1 + d(w′, I) if w ∈ auxI and w = fT,A(w′).\nLemma 14. Interpretation I satisfies the following three properties for all terms w1, w′1, w2, and w′2, all roles R, S, and T , and each concept A ∈ NC ∪ {>}.\nP1. R(w′1, fT,A(w1)) ∈ I, S(w′2, fT,A(w2)) ∈ I, fT,A(w1) ≈ fT,A(w2) ∈ I, and fT,A(w2) ∈ auxI imply w′1 ≈ w′2 ∈ I.\nP2. w1 ≈ w2 ∈ I implies d(w1, I) = d(w2, I). P3. R(w′1, fT,A(w1)) ∈ I and fT,A(w1) ∈ auxI imply that d(fT,A(w1), I) = 1 + d(w′1, I).\nProof. To prove properties P1–P3, we first show by induction on n that each In satisfies the following two auxiliary properties for all terms w′, w, w1, and w2, all roles R, T , and T ′, and all concepts A and A′ in NC ∪ {>}.\nA1. fT ′,A′(w2) ∈ auxIn and fT,A(w1) ≈ fT ′,A′(w2) ∈ In imply that T = T ′, A = A′, and w1 ≈ w2 ∈ I. A2. fT,A(w) ∈ auxIn and R(w′, fT,A(w)) ∈ In imply that a term w′′ exists such that I contains T (w′′, fT,A(w′′)), w′ ≈ w′′,\nand fT,A(w) ≈ fT,A(w′′).\nBase case. By definition, I0 does not contain functional terms, so properties A1 and A2 are vacuously true. Inductive step. Assume that In satisfies properties A1 and A2; we show that the same holds for In+1 by considering in turn the various clauses that may introduce fresh assertions into In+1. We consider only the interesting cases in where an equality or a binary assertion is derived, since all other clauses trivially preserve A1 and A2. Let w′, w, w1, w′1, and w2 be arbitrary terms, let R, T , and T ′ be arbitrary roles, and let A and A′ be arbitrary concepts in NC ∪ {>}.\n• A1(x)→ x ≈ a. Assume that A1(w1) ∈ In, so the clause derives w1 ≈ a ∈ In+1. Since a 6∈ auxIn+1 , properties A1 and A2 are preserved.\n• → x ≈ x. Assume that fT,A(w1) occurs in In, so the clause derives fT,A(w1) ≈ fT,A(w1) ∈ In+1; the interesting case is when fT,A(w1) ∈ auxIn+1 . Since fT,A(w1) occurs in In, then w1 occurs in the Herbrand universe of Ξ(K). By reflexivity, then w1 ≈ w1 ∈ I, as required for A1. Furthermore, this derivation clearly preserves A2.\n• x ≈ y → fT,A(x) ≈ fT,A(y). Assume w1 ≈ w2 ∈ In, so the clause derives fT,A(w1) ≈ fT,A(w2) ∈ In+1; the interesting case is when fT,A(w2) ∈ auxIn+1 . By assumption, w1 ≈ w2 ∈ In, and so w1 ≈ w2 ∈ I, as required for property A1. Furthermore, this derivation clearly preserves A2.\n• x1 ≈ x2 → x2 ≈ x1. Assume that fT ′,A′(w2) ≈ fT,A(w1) ∈ In, so the clause derives fT,A(w1) ≈ fT ′,A′(w2) ∈ In+1; the interesting case is when fT ′,A′(w2) ∈ auxIn+1 , which clearly implies fT ′,A′(w2) ∈ auxIn . Since relation ≈ is symmetric in In, we have fT,A(w1) ≈ fT ′,A′(w2) ∈ In; but then, by the inductive hypothesis, we have T = T ′, A = A′, and w1 ≈ w2 ∈ I, as required for property A1. Furthermore, this derivation clearly preserves A2. • x1 ≈ x2 ∧ x2 ≈ x3 → x1 ≈ x3. Assume that In contains fT,A(w1) ≈ fT ′,A′(w′1) and fT ′,A′(w′1) ≈ fT ′′,A′′(w2), so the clause derives fT,A(w1) ≈ fT ′′,A′′(w2) ∈ In+1; the interesting case is when fT ′′,A′′(w2) ∈ auxIn+1 , which clearly implies fT ′′,A′′(w2) ∈ auxIn . Clearly, we then also have fT ′,A′(w′1) ∈ auxIn . By the inductive hypothesis, we have T = T ′ = T ′′, A = A′ = A′′, and {w1 ≈ w′1, w′1 ≈ w2} ⊆ I. Thus, we have w1 ≈ w2 ∈ I, as required for property A1. Furthermore, this derivation clearly preserves A2.\n• A1(x)→ T (x, fT,A(x)). Assume that A1(w′) ∈ In, so the clause derives T (w′, fT,A(w′)) ∈ In+1; the interesting case is when fT,A(w′) ∈ auxIn+1 and w′ = w. Then, for w′′ = w = w′, we have\n{T (w′′, fT,A(w′′)), w′′ ≈ w′′, fT,A(w′′) ≈ fT,A(w′′)} ⊆ I,\nas required for property A2. Furthermore, this derivation clearly preserves A1. • P (x, y)→ R(x, y). Assume that P (w′, fT,A(w)) ∈ In, so the clause derives R(w′, fT,A(w)) ∈ In+1; the interesting case\nis when fT,A(w) ∈ auxIn+1 , which implies fT,A(w) ∈ auxIn . By the inductive hypothesis, then a term w′′ exists such that {T (w′′, fT,A(w′′)), w′ ≈ w′′, fT,A(w) ≈ fT,A(w′′)} ⊆ I, as required for property A2. Furthermore, this derivation clearly preserves A1.\n• R(x, y) ∧ x ≈ z → R(z, y). Assume that {R(w′1, fT,A(w)), w′1 ≈ w′} ⊆ In, so the clause derivesR(w′, fT,A(w)) ∈ In+1; the interesting case is when fT,A(w) ∈ auxIn+1 , which implies fT,A(w) ∈ auxIn . By the inductive hypothesis, a term w′′ exists such that {T (w′′, fT,A(w′′)), w′1 ≈ w′′, fT,A(w) ≈ fT,A(w′′)} ⊆ I. By the transitivity of ≈, we have w′ ≈ w′′ ∈ I, as required for property A2. Furthermore, this derivation clearly preserves A1.\n• R(x, y) ∧ y ≈ z → R(x, z). Assume that {R(w′, fT,A(w1)), fT,A(w1) ≈ fT,A(w)} ⊆ In, and so the clause derives the fact R(w′, fT,A(w)) ∈ In+1; the interesting case is when fT,A(w) ∈ auxIn+1 , which implies fT,A(w) ∈ auxIn . Then, clearly fT,A(w1) ∈ auxIn . By the inductive hypothesis, a term w′′ exists such that\n{T (w′′, fT,A(w′′)), w′ ≈ w′′, fT,A(w1) ≈ fT,A(w′′)} ⊆ I.\nBy the transitivity of ≈, then fT,A(w) ≈ fT,A(w′′) ∈ I, as required for property A2. Furthermore, this derivation clearly preserves A1.\nWe are now ready to show properties P1–P3.\nPROPERTY P1. Let w′1, w1, w ′ 2, w2 be arbitrary terms, let R, S, and T be arbitrary roles, and let A be an arbitrary concept in NC ∪ {>}. Assume that {R(w′1, fT,A(w1)), S(w′2, fT,A(w2)), fT,A(w1) ≈ fT,A(w2)} ⊆ I and fT,A(w2) ∈ auxI . By applying property A2 to R(w′1, fT,A(w1)) and S(w ′ 2, fT,A(w2)), we have that two terms w ′′ 1 and w ′′ 2 exist such that\n{T (w′′1 , fT,A(w′′1 )), w′1 ≈ w′′1 , fT,A(w1) ≈ fT,A(w′′1 )} ⊆ I, and {T (w′′2 , fT,A(w′′2 )), w′2 ≈ w′′2 , fT,A(w2) ≈ fT,A(w′′2 )} ⊆ I.\nBy the transitivity of ≈, we have that fT,A(w′′1 ) ≈ fT,A(w′′2 ) ∈ I, and so by Property A1, we conclude that w′′1 ≈ w′′2 ∈ I. Finally, since {w′1 ≈ w′′1 , w′′1 ≈ w′′2 , w′′2 ≈ w′2} ⊆ I, by the transitivity of ≈, we get w′1 ≈ w′2 ∈ I, as required.\nPROPERTY P2. We show by induction on n ∈ N that, for all terms w1 and w2 such that |w1| ≤ |w2| ≤ n, if w1 ≈ w2 ∈ I, then d(w1, I) = d(w2, I).\nBase case. Let w1 and w2 be arbitrary terms such that |w1| = |w2| = 0 and w1 ≈ w2 ∈ I. By the definition of |·|, then {w1, w2} ⊆ NI , so d(w1, I) = d(w2, I) = 0.\nInductive step. Consider an arbitrary n ∈ N and assume that the required property holds for all terms w′1 and w′2 such that |w′1| ≤ |w′2| ≤ n; we show that the same holds for arbitrary terms w1 and w2 such that |w1| ≤ |w2| ≤ n+ 1. We consider the interesting case when w1 ≈ w2 ∈ I, for which we consider two cases. First, if w2 6∈ auxI , then d(w1, I) = d(w2, I) = 0. Second, if w2 ∈ auxI , then by property A1 there exist two terms w′1 and w′2, a role T , and a concept A ∈ NC ∪ {>} such that w1 is of the form fT,A(w′1), term w2 is of the form fT,A(w ′ 2), and w ′ 1 ≈ w′2 ∈ I. By the inductive hypothesis, then d(w′1, I) = d(w ′ 2, I). Finally, by definition, we have d(w1, I) = d(w2, I) = 1 + d(w ′ 2, I), as required.\nPROPERTY P3. Let w′1 and w1 be arbitrary terms, let R and T be arbitrary roles, let A ∈ NC ∪ {>} be an arbitrary concept, and assume that R(w′1, fT,A(w1)) ∈ I and fT,A(w1) ∈ auxI . By property A2, then there exists a term w′′1 such that {T (w′′1 , fT,A(w′′1 )), w′1 ≈ w′′1 , fT,A(w1) ≈ fT,A(w′′1 )} ⊆ I. By the definition of d(·), then d(fT,A(w′′1 ), I) = 1 + d(w′′1 , I). Furthermore, by property P2, then d(fT,A(w1), I) = d(fT,A(w′′1 ), I) and d(w ′ 1, I) = d(w ′′ 1 , I). Finally, these observations imply that d(fT,A(w1), I) = 1 + d(w′1, I), as required.\nWe now have all the ingredients required to prove Theorem 10. We start by showing completeness.\nLemma 15 (Completeness). LetK = 〈T ,A〉 be a satisfiable ELHOr⊥ KB, let q = ∃~y.ψ(~x, ~y) be a CQ, and let π : ~x 7→ NI be a candidate answer for q. Then, Ξ(K) |= π(q) implies that a substitution τ exists such dom(τ) = ~x ∪ ~y, τ |~x = π, D(K) |= τ(q), and isSpur(q,D(K), τ) = f.\nProof. Let I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively. Since Ξ(K) |= π(q), a substitution π∗ exists such that dom(π∗) = ~x ∪ ~y, π∗|~x = π, and π∗(q) ⊆ I. Let δ be the mapping from I to J defined in the section about the datalog rewriting of K. We define τ as the substitution such that, for each term t ∈ NT (q), we have τ(t) := δ(π∗(t)). Finally, let ∼ be the relation for τ , q, and D(K) as specified in Definition 7. Since δ is a homomorphism from I to J by Lemma 3, we have J |= τ(q). We next prove isSpur(q, τ,D(K)) = f by showing that all conditions of Definition 9 are satisfied.\n(Condition a) By the definition of τ , for each x ∈ ~x, we have τ(x) ∈ NI . (Condition b) We prove that, for each s ∼ t, we have τ(s) ≈ τ(t) ∈ J and π∗(s) ≈ π∗(t) ∈ I. We proceed by induction on the number of steps required to derive s ∼ t. For the base case, the empty relation ∼ clearly satisfies the two properties. For the inductive step, consider an arbitrary relation ∼ obtained in n steps that satisfies these constraints; we show that the same holds for all constraints derivable from ∼. Since relation ≈ in both J and I is reflexive, symmetric, and transitive, the derivation of s ∼ t due to reflexivity, symmetry, or transitivity clearly preserves the required properties; thus, we focus on the (fork) rule. Let s′, s, t′, and t be arbitrary terms in NT (q), and let R and P be arbitrary roles such that s′ ∼ t′ is obtained in n steps, atoms R(s, s′) and P (t, t′) occur in q, and τ(s′) ∈ auxD(K). By the inductive hypothesis, we have τ(s′) ≈ τ(t′) ∈ J and π∗(s′) ≈ π∗(t′) ∈ I. Since J is the minimal Herbrand model of D(K), we have τ(t′) ∈ auxJ , so no individual c ∈ NI exists such that τ(t′) ≈ c ∈ J. By Lemmas 3 and 4, τ(t′) 6∈ auxJ if and only if π∗(t′) 6∈ auxI ; hence, π∗(t′) ∈ auxI . Since {R(π∗(s), π∗(s′)), P (π∗(t), π∗(t′)), π∗(s′) ≈ π∗(t′)} ⊆ I and π∗(t′) ∈ auxI , by property P1 of Lemma 14 we have π∗(s) ≈ π∗(t) ∈ I. Finally, since δ is a homomorphism (see Lemma 3), by the construction of τ we have τ(s) ≈ τ(t) ∈ J, as required.\n(Condition c) To show that q is aux-acyclic w.r.t. τ and D(K), we assume the opposite; hence, there exists a sequence of vertices v0, . . . , vm ∈ Vaux such that m > 0, for each 0 ≤ i < m we have 〈vi, vi+1〉 ∈ Eaux, and vm = v0. Consider an arbitrary i ≤ m and the corresponding edge 〈vi, vi+1〉 ∈ Eaux. By the definition of Eaux, an atom Ri(si, si+1) exists in q such that γ(si) = vi and γ(si+1) = vi+1; hence, we have si ∼ vi and si+1 ∼ vi+1. Since τ satisfies all the constraints in ∼, by the definition of Gaux we have that {τ(si), τ(si+1)} ⊆ auxD(K). By Lemmas 3 and 4, then {π∗(si), π∗(si+1)} ⊆ auxI as well. In addition, since Ri(si, si+1) is an atom in q, we have Ri(π∗(si), π∗(si+1)) ∈ I. Also, since si ∼ vi, si+1 ∼ vi+1, and\nsubstitution π∗ satisfies the constraints in ∼, we have {π∗(si) ≈ π∗(vi), π∗(si+1) ≈ π∗(vi+1)} ⊆ I. Then, by property P2 of Lemma 14, we have\nd(π∗(si), I) = d(π ∗(vi), I) and\nd(π∗(si+1), I) = d(π ∗(vi+1), I).\nFinally, since R(π∗(si), π∗(si+1)) ∈ I, by property P3 of Lemma 14 we have d(π∗(vi+1), I) = 1 + d(π∗(vi), I). But then, since vm = v0, we also have d(π∗(vm), I) = d(π∗(v0), I), which is a contradiction.\nWe are left to prove the soundness of our approach. Let τ be an arbitrary substitution for q w.r.t. D(K) such that J |= τ(q) and isSpur(q, τ,D(K)) = f. Furthermore, let Gaux be the graph as specified in Definition 8. We next show that I |= τ |~x (q). In order to do so, we first define the graph Gq of the query q. Definition 16. Let γ and Vaux be as in Definition 8. The query graph Gq = 〈Vq, Eq〉 is the directed graph defined as follows. • Vq is the smallest set containing γ(t) for each t ∈ NT (q). • Eq is the smallest set containing 〈γ(s), γ(t)〉 for all terms {s, t} ⊆ NT (q) such that query q contains R(s, t) for some R. Vertex v ∈ Vq is a root if v 6∈ Vaux or, for each vertex v′ ∈ Vq , we have 〈v′, v〉 6∈ Eq .\nClearly, by the definition, Gaux is a subgraph Gq . We prove the soundness claim in three steps. First, we show that the graph Gq is a forest. Second, we define by structural induction on the forest Gq a substitution π for q w.r.t. Ξ(K) such that τ |~x = π|~x. Third, we prove that I |= π(q) holds. Lemma 17. If isSpur(q, τ,D(K)) = f, then Gq is a forest.\nProof. Due to isSpur(q, τ,D(K)) = f, we have that Gaux is a direct acyclic graph. Consider an arbitrary vertex v ∈ Vaux and arbitrary vertices v1, v2 ∈ Vq such that {〈v1, v〉, 〈v2, v〉} ⊆ Eq; we next show that v1 = v2. By the definition of Gq , we have that {s, s′, t, t′} ⊆ NT (q), and that roles R and P exist such that all of the following conditions are satisfied: • atoms R(s, s′) and P (t, t′) are in q; • γ(s′) = v = γ(t′), γ(s) = v1, and γ(t) = v2; and, • {τ(s′), τ(t′)} ⊆ auxJ . Due to the (fork) rule, we have s ∼ t. By the definition of γ, we have γ(s) = γ(t), which implies v1 = v2, as required.\nBy structural induction on the forest-shaped graph Gq , we next define the substitution π as follows; we will later show that Ξ(K) |= π(q). • For the base case, let v be an arbitrary root of Gq . For each term t ∈ NT (q) such that γ(t) = v, we define π(t) as an arbitrary\nterm w ∈ dom(I) such that δ(w) = τ(t). • For the inductive step, let v be an arbitrary vertex ofGq such that v ∈ Vaux, term τ(v) is of the form oR,A, the value of π(v) is\nundefined, v′ is the unique vertex of Gq such that 〈v′, v〉 ∈ Eq , and π(v′) has already been defined. For each term t ∈ NT (q) such that γ(t) = v, we define π(t) := fR,A(π(v′)).\nLemma 18. Substitution π satisfies the two following properties for each term v ∈ Vq and all terms s, t ∈ NT (q) such that γ(s) = v = γ(t):"
    }, {
      "heading" : "M1. δ(π(s)) = τ(s), and",
      "text" : ""
    }, {
      "heading" : "M2. π(s) ≈ π(t) ∈ I.",
      "text" : "Proof. We prove properties M1 and M2 by the structural induction on the forest Gq . Base case. Let v be an arbitrary root of Gq , and let s, t ∈ NT (q) be arbitrary terms such that γ(s) = v = γ(t). Property M1 follows from the fact that π(s) ∈ {w ∈ dom(I) | δ(w) = τ(s)}. We next prove property M2. By the definition of γ, we have that s ∼ t. Since isSpur(q, τ,D(K)) = f, we have τ(s) ≈ τ(t) ∈ J. We have the following two cases. • Assume that v ∈ Vaux. Clearly, {τ(s), τ(t)} ⊆ auxJ . By the construction of J, there exists n ∈ N such that τ(s) ≈ τ(t) ∈ Jn\nand τ(t) ∈ auxJn . By Lemma 13, we have τ(s) = τ(t). Thus, π(s) = π(t) and π(s) ≈ π(t) ∈ I, as required. • Assume that v 6∈ Vaux. Then, we have τ(t) 6∈ auxJ and, by Lemma 4, we have π(s) ≈ π(t) ∈ I.\nInductive step. Let v ∈ Vaux be an arbitrary vertex, let s, t ∈ NT (q) be arbitrary terms such that γ(s) = v = γ(t), and assume that τ(v) is of the form oR,A. By the definition of γ, we have that s ∼ t. Since isSpur(q, τ,D(K)) = f, we have τ(s) ≈ τ(t) ∈ J. Since v ∈ Vaux, we have {τ(v), τ(s), τ(t)} ⊆ auxJ . Then, by the construction of J, some n ∈ N exists such that {τ(v) ≈ τ(s), τ(s) ≈ τ(t)} ⊆ Jn and {τ(s), τ(t)} ⊆ auxJn . By Lemma 13, we have τ(v) = τ(s) and τ(s) = τ(t). Now let v′ be the unique vertex of Gq such that 〈v′, v〉 ∈ E. By definition, π(s) = fR,A(π(v′)) = π(t). Also, by the definition of δ, we have δ(fR,A(π(v′))) = oR,A, so property M1 holds. By the reflexivity of ≈, we have π(s) ≈ π(t) ∈ I, and so property M2 holds, as required.\nWe finally prove the soundness of our approach. Lemma 19 (Soundness). Let I and J be the minimal Herbrand models of Ξ(K) and D(K), respectively; let q = ∃~y.ψ(~x, ~y) be an arbitrary CQ; and let τ be an arbitrary substitution such that τ(q) ⊆ J and isSpur(q, τ,D(K)) = f. Then, τ |~x (q) ∈ I.\nProof. For q and τ as specified in the lemma, let π be the substitution defined as specified just before Lemma 18, and assume that isSpur(q,D(K), τ) = f. By definition, we have π|~x = τ |~x. We next show that π(q) ⊆ I.\nFirst, letA(t) be an arbitrary unary atom of q, we show thatA(π(t)) ∈ I. By assumption, we haveA(τ(t)) ∈ J. By Lemma 4, for each termw ∈ dom(I) such that δ(w) = τ(t), we have thatA(w) ∈ I. By property M1 of Lemma 18, we haveA(π(t)) ∈ I.\nSecond, let R(t′, t) be an arbitrary atom of q; we show that R(π(t′), π(t)) ∈ I. By assumption, we have R(τ(t′), τ(t)) ∈ J. We distinguish the following two cases.\n1. Assume that τ(t) 6∈ auxJ . By Lemma 4, for all terms w′, w ∈ dom(I) such that δ(w′) = τ(t′) and δ(w) = τ(t), we have R(w′, w) ∈ I. By property M1 of Lemma 18, we have R(π(t′), π(t)) ∈ I. 2. Assume that τ(t) ∈ auxJ , and assume that τ(t) is of the form oR,A. Furthermore, let v′ be the unique vertex of Gq such that 〈v′, γ(t)〉 ∈ Eq and γ(t′) = v′. By the definition of π, we have π(t) = fR,A(π(v′)). Since isSpur(q,D(K), τ) = f, we have τ(v′) ≈ τ(t′) ∈ J. Since ≈ is a congruence relation, we have R(τ(v′), τ(t)) ∈ J. By Lemma 4, for each term w′ ∈ dom(I) such that δ(w′) = τ(v′), we have R(w′, fR,A(w′)) ∈ I. By property M1 of Lemma 18, we have R(π(v′), fR,A(π(v′))) ∈ I, and by Property M2 of Lemma 18, we have π(t′) ≈ π(v′) ∈ I. Therefore, we have R(π(t′), fR,A(π(v′))) ∈ I."
    }, {
      "heading" : "Proof of Theorem 11",
      "text" : "Theorem 11. Deciding whether K |= π(q) holds can be implemented in nondeterministic polynomial time w.r.t. the size of K and q, and in polynomial time w.r.t. the size of A.\nProof. First, we argue that we can compute relation∼ in polynomial time. For each term u, we can decide whether u ∈ auxD(K) by checking whether, for each term u′, we have that D(K) |= u ≈ u′ implies u′ 6∈ NI . Since the number of variables occurring in each clause in D(K) is bounded by a constant, this check can be performed in polynomial time. Thus, we can evaluate in polynomial time the precondition of the (fork) rule. In addition, the size of relation ∼ is bounded by |NT (q)|2, the rules used to compute it are monotonic, and each inference can be applied in polynomial time, so we can compute ∼ in polynomial time.\nSecond, we show that we can decide whether q is aux-cyclic w.r.t. τ in polynomial time. Since ∼ can be computed in polynomial time and the size of Gaux is polynomially bounded by the number of terms occurring in q, we can compute Gaux in polynomial time. Also, we can check whether Gaux is a acyclic by searching for a topological ordering of its vertexes in linear time (Cormen et al. 2009).\nFor the NP upper bound, according to Theorem 10 checking whether K |= π(q) amounts to guessing a candidate answer τ for q in the minimal Herbrand model of D(K) such that τ |~x = π and to checking that isSpur(q,D(K), τ) = f. Since each clause in D(K) has a bounded number of variables, the minimal Herbrand model of D(K) can be computed in polynomial time. By the first two observations, we conclude that the whole process can be carried out in nondeterministic polynomial time in the combined size of D(K) and q.\nFor the PTIME upper bound, consider a fixed ELHOr⊥ TBox T and a fixed conjunctive query q. For an arbitrary ABox A, we can enumerate in polynomial time all possible answers to q in the minimal Herbrand model of D(T ) ∪ A. Also, we can filter out those answers that are spurious in polynomial time. Finally, we just check whether π occurs in the remaining (certain) answers."
    } ],
    "references" : [ {
      "title" : "Foundations of Databases",
      "author" : [ "S. Abiteboul", "R. Hull", "V. Vianu" ],
      "venue" : "Addison-Wesley.",
      "citeRegEx" : "Abiteboul et al\\.,? 1995",
      "shortCiteRegEx" : "Abiteboul et al\\.",
      "year" : 1995
    }, {
      "title" : "The DL-Lite Family and Relations",
      "author" : [ "A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "Journal of Artificial Intelligence Research 36:1–69.",
      "citeRegEx" : "Artale et al\\.,? 2009",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2009
    }, {
      "title" : "The Description Logic Handbook: Theory, Implementation, and Applications",
      "author" : [ "F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "Patel-Schneider", "P. F", "eds" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2007
    }, {
      "title" : "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Automated Reasoning 9(3):385–429.",
      "citeRegEx" : "Calvanese et al\\.,? 2007",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Query evaluation under the well-founded semantics",
      "author" : [ "W. Chen", "D.S. Warren" ],
      "venue" : "Proceedings of the 12th ACM SIGACT-SIGMOD-SIGART symposium on Principles of database systems, PODS ’93, 168–179. New York, NY, USA: ACM.",
      "citeRegEx" : "Chen and Warren,? 1993",
      "shortCiteRegEx" : "Chen and Warren",
      "year" : 1993
    }, {
      "title" : "Introduction to Algorithms (3",
      "author" : [ "T.H. Cormen", "C.E. Leiserson", "R.L. Rivest", "C. Stein" ],
      "venue" : "ed.). MIT Press.",
      "citeRegEx" : "Cormen et al\\.,? 2009",
      "shortCiteRegEx" : "Cormen et al\\.",
      "year" : 2009
    }, {
      "title" : "OWL 2: The next step for OWL",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. PatelSchneider", "U. Sattler" ],
      "venue" : "Journal of Web Semantics 6(4):309–322.",
      "citeRegEx" : "Grau et al\\.,? 2008",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov" ],
      "venue" : "ACM Computing Surveys 33(3):374–425.",
      "citeRegEx" : "Dantsin et al\\.,? 2001",
      "shortCiteRegEx" : "Dantsin et al\\.",
      "year" : 2001
    }, {
      "title" : "Query Rewriting for Horn-SHIQ Plus Rules",
      "author" : [ "T. Eiter", "M. Ortiz", "M. Simkus", "T.-K. Tran", "G. Xiao" ],
      "venue" : "Proceedings of the 26th AAAI Conference on Artificial Intelligence, (AAAI 2012). AAAI Press.",
      "citeRegEx" : "Eiter et al\\.,? 2012",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2012
    }, {
      "title" : "First-order logic and automated theorem proving (2nd ed.)",
      "author" : [ "M. Fitting" ],
      "venue" : null,
      "citeRegEx" : "Fitting,? \\Q1996\\E",
      "shortCiteRegEx" : "Fitting",
      "year" : 1996
    }, {
      "title" : "Conjunctive Query Answering for the Description Logic SHIQ",
      "author" : [ "B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler" ],
      "venue" : "Journal of Artificial Intelligence Research 31:151– 198.",
      "citeRegEx" : "Glimm et al\\.,? 2008",
      "shortCiteRegEx" : "Glimm et al\\.",
      "year" : 2008
    }, {
      "title" : "LUBM: A benchmark for OWL knowledge base systems",
      "author" : [ "Y. Guo", "Z. Pan", "J. Heflin" ],
      "venue" : "Journal of Web Semantics 3(2–3):158–182.",
      "citeRegEx" : "Guo et al\\.,? 2005",
      "shortCiteRegEx" : "Guo et al\\.",
      "year" : 2005
    }, {
      "title" : "The Combined Approach to Ontology-Based Data Access",
      "author" : [ "R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Walsh, T., ed., Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI 2011). AAAI Press.",
      "citeRegEx" : "Kontchakov et al\\.,? 2011",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2011
    }, {
      "title" : "Conjunctive queries for a tractable fragment of OWL",
      "author" : [ "M. Krötzsch", "S. Rudolph", "P. Hitzler" ],
      "venue" : null,
      "citeRegEx" : "Krötzsch et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2007
    }, {
      "title" : "ELP: Tractable rules for OWL",
      "author" : [ "M. Springer. Krötzsch", "S. Rudolph", "P. Hitzler" ],
      "venue" : "Proceedings of the 6th International Semantic Web Conference (ISWC’07),",
      "citeRegEx" : "Krötzsch et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2008
    }, {
      "title" : "Conjunctive Query Answering in the Description Logic EL Using a Relational Database System",
      "author" : [ "C. CEUR-WS.org. Lutz", "D. Toman", "F. Wolter" ],
      "venue" : "CEUR Workshop Proceedings,",
      "citeRegEx" : "Lutz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2009
    }, {
      "title" : "Query Answering in the Horn Fragments of the Description Logics SHOIQ and SROIQ",
      "author" : [ "M. Press. Ortiz", "S. Rudolph", "M. Simkus" ],
      "venue" : "Proceedings of the 22nd International Joint Conference on Artificial Intel-",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2009
    }, {
      "title" : "Tractable Query Answering and Rewriting under Description Logic Constraints",
      "author" : [ "H. Press. Pérez-Urbina", "B. Motik", "I. Horrocks" ],
      "venue" : "Journal of Applied Logic",
      "citeRegEx" : "Pérez.Urbina et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Pérez.Urbina et al\\.",
      "year" : 2011
    }, {
      "title" : "On Conjunctive Query Answering in EL",
      "author" : [ "R. Rosati" ],
      "venue" : "Proceedings of the 20th International Workshop on Description Logics",
      "citeRegEx" : "209",
      "shortCiteRegEx" : "209",
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "Description logics (DLs) (Baader et al. 2007) are a family of knowledge representation formalisms that underpin OWL 2 (Cuenca Grau et al.",
      "startOffset" : 25,
      "endOffset" : 45
    }, {
      "referenceID" : 10,
      "context" : "For expressive DLs, the problem is at least doubly exponential in query size (Glimm et al. 2008).",
      "startOffset" : 77,
      "endOffset" : 96
    }, {
      "referenceID" : 3,
      "context" : "The problem, however, becomes easier for the EL (Baader, Brandt, and Lutz 2005) and the DL-Lite (Calvanese et al. 2007) families of DLs, which provide the foundation for the OWL 2 EL and the OWL 2 QL profiles of OWL 2.",
      "startOffset" : 96,
      "endOffset" : 119
    }, {
      "referenceID" : 3,
      "context" : "Rewriting-based approaches were developed for members of the DL-Lite family (Calvanese et al. 2007; Artale et al. 2009), and the DLs ELHIO⊥ (Pérez-Urbina, Motik, and Horrocks 2010) and Horn-SHIQ (Eiter et al.",
      "startOffset" : 76,
      "endOffset" : 119
    }, {
      "referenceID" : 1,
      "context" : "Rewriting-based approaches were developed for members of the DL-Lite family (Calvanese et al. 2007; Artale et al. 2009), and the DLs ELHIO⊥ (Pérez-Urbina, Motik, and Horrocks 2010) and Horn-SHIQ (Eiter et al.",
      "startOffset" : 76,
      "endOffset" : 119
    }, {
      "referenceID" : 8,
      "context" : "2009), and the DLs ELHIO⊥ (Pérez-Urbina, Motik, and Horrocks 2010) and Horn-SHIQ (Eiter et al. 2012), to name just a few.",
      "startOffset" : 81,
      "endOffset" : 100
    }, {
      "referenceID" : 1,
      "context" : "2007; Artale et al. 2009), and the DLs ELHIO⊥ (Pérez-Urbina, Motik, and Horrocks 2010) and Horn-SHIQ (Eiter et al. 2012), to name just a few. A common problem, however, is that rewritings can be exponential in the ontology and/or query size. Although this is often not a problem in practice, such approaches are not worst-case optimal. An exception is the algorithm by Rosati (2007) that rewrites an ELH⊥ ontology into a datalog program of polynomial size; however, the algorithm also uses a nondeterministic step to transform the CQ into a tree-shaped one, and it is not clear how to implement this step in a goal-directed manner.",
      "startOffset" : 6,
      "endOffset" : 383
    }, {
      "referenceID" : 12,
      "context" : "Such approaches have been developed for logics in the DL-Lite (Kontchakov et al. 2011) and the EL (Lutz, Toman, and Wolter 2009) families, and they are appealing because they are worst-case optimal and practical: only the second step is intractable (in query size), but it can be solved using well-known database techniques.",
      "startOffset" : 62,
      "endOffset" : 86
    }, {
      "referenceID" : 9,
      "context" : "We use the standard notions of variables, constants, function symbols, terms, atoms, formulas, and sentences (Fitting 1996).",
      "startOffset" : 109,
      "endOffset" : 123
    }, {
      "referenceID" : 9,
      "context" : "In first-order logic, ≈ is usually interpreted as the identity over the interpretation domain; however, ≈ can also be explicitly axiomatised (Fitting 1996).",
      "startOffset" : 141,
      "endOffset" : 155
    }, {
      "referenceID" : 2,
      "context" : "Although somewhat nonstandard, our definitions of DLs are equivalent to the ones based on the standard denotational semantics (Baader et al. 2007).",
      "startOffset" : 126,
      "endOffset" : 146
    }, {
      "referenceID" : 12,
      "context" : "Please note that oR,A depends on both R and A, whereas in the known approaches such individuals depend only onA (Lutz, Toman, and Wolter 2009) or R (Kontchakov et al. 2011).",
      "startOffset" : 148,
      "endOffset" : 172
    }, {
      "referenceID" : 7,
      "context" : "The complexity claim is due to the fact that each clause in D(K) contains a bounded number of variables (Dantsin et al. 2001).",
      "startOffset" : 104,
      "endOffset" : 125
    }, {
      "referenceID" : 4,
      "context" : "First, we would like to investigate the use of top-down query evaluation techniques, such as magic sets (Abiteboul, Hull, and Vianu 1995) or SLG resolution (Chen and Warren 1993).",
      "startOffset" : 156,
      "endOffset" : 178
    }, {
      "referenceID" : 4,
      "context" : "First, we would like to investigate the use of top-down query evaluation techniques, such as magic sets (Abiteboul, Hull, and Vianu 1995) or SLG resolution (Chen and Warren 1993). Second, tighter integration of the detection of spurious answers with the query evaluation algorithms should make it possible to eagerly detect spurious answers (i.e., before the query is fully evaluated). Lutz et al. (2012) already implemented a filtering condition as a user-defined function in a database, but it is unclear to what extent such an implementation can be used to optimise query evaluation.",
      "startOffset" : 157,
      "endOffset" : 405
    } ],
    "year" : 2013,
    "abstractText" : "So-called combined approaches answer a conjunctive query over a description logic ontology in three steps: first, they materialise certain consequences of the ontology and the data; second, they evaluate the query over the data; and third, they filter the result of the second phase to eliminate unsound answers. Such approaches were developed for various members of the DL-Lite and the EL families of languages, but none of them can handle ontologies containing nominals. In our work, we bridge this gap and present a combined query answering approach for ELHO ⊥—a logic that contains all features of the OWL 2 EL standard apart from transitive roles and complex role inclusions. This extension is nontrivial because nominals require equality reasoning, which introduces complexity into the first and the third step. Our empirical evaluation suggests that our technique is suitable for practical application, and so it provides a practical basis for conjunctive query answering in a large fragment of OWL 2 EL.",
    "creator" : "TeX"
  }
}