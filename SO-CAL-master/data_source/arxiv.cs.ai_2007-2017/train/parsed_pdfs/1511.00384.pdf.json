{
  "name" : "1511.00384.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "arthur.ryman@gmail.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 1.\n00 38\n4v 1\n[ cs\n.D B\n] 2\nThis article provides a formalization of the W3C Draft Core SHACL Semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the draft. It has also established that the recursive definitions in the draft are well-founded. Further formal validation of the draft will require the use of an executable specification technology."
    }, {
      "heading" : "1 Introduction",
      "text" : "The W3C RDF Data Shapes Working Group [3] is developing SHACL, a new language for describing constraints on RDF graphs. A semantics for Core SHACL has been proposed [2], hereafter referred to as the semantics draft. The proposed semantics includes an abstract syntax, inference rules, and a definition of typing which allows for certain kinds of recursion. The semantics draft uses precise mathematical language, but is informal in the sense that it is not written in a formal specification language and therefore cannot benefit from tools such as type-checkers.\nThis document provides a formal translation of the semantics draft into Z Notation [6]. The LATEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.\nOur motive for formalizing and type-checking the semantics draft is to help to improve its quality and the ultimate design of SHACL."
    }, {
      "heading" : "1.1 Organization of this Article",
      "text" : "The remainder of this article is organized as follows.\n• Section 2 formalizes some basic RDF concepts.\n• Section 3 translates the abstract syntax of SHACL into Z notation.\n• Section 4 formalizes the evaluation semantics of SHACL.\n• Section 5 formalizes the declarative semantics of shape expression schemas.\n• Section 6 summarizes the quality issues found in the draft.\n• Section 7 concludes with some remarks about the benefits of the formalization exercise and possible next steps."
    }, {
      "heading" : "2 Basic RDF Concepts",
      "text" : "This section formalizes some basic RDF concepts. We reuse some formal definitions given in [5], modifying the identifiers to match those used in the semantics draft.\n2.1 TERM\nLet TERM be the set of all RDF terms.\n[TERM ]\n2.2 Iri , Blank , and Lit\nThe set of all RDF terms is partitioned into IRIs, blank nodes, and literals.\nIri ,Blank ,Lit : TERM\n〈Iri ,Blank ,Lit〉 partition TERM\n2.3 IRI\nThe semantics draft introduces the term Iri , but it uses the term IRI in the definitions of the abstract syntax. We treat IRI as a synonym for Iri .\nIRI == Iri\n2.4 Triple\nAn RDF triple is an ordered triple of RDF terms referred to as the subject, predicate, and object.\nTriple == { s , p, o : TERM | s /∈ Lit ∧ p ∈ IRI }\n• The subject is not a literal.\n• The predicate is an IRI.\n2.5 subject, predicate, and object\nIt is convenient to define generic functions that select the first, second, or third component of a Cartesian product of three sets.\nfst [X ,Y ,Z ] == (λ x : X ; y : Y ; z : Z • x )\nsnd [X ,Y ,Z ] == (λ x : X ; y : Y ; z : Z • y )\ntrd [X ,Y ,Z ] == (λ x : X ; y : Y ; z : Z • z )\nThe subject, predicate, and object of an RDF triple are the terms that appear in the corresponding positions.\nsubject == (λ t : Triple • fst(t) )\npredicate == (λ t : Triple • snd(t) )\nobject == (λ t : Triple • trd(t) )\n2.6 Graph\nAn RDF graph is a finite set of RDF triples.\nGraph == Triple\n2.7 subjects, predicates, and objects\nThe subjects, predicates, and objects of a graph are the sets of RDF terms that appear in the corresponding positions of its triples.\nsubjects == (λ g : Graph • { t : g • subject(t) } )\npredicates == (λ g : Graph • { t : g • predicate(t) } )\nobjects == (λ g : Graph • { t : g • object(t) } )\n2.8 nodes\nThe nodes of an RDF are its subjects and objects.\nnodes == (λ g : Graph • subjects(g) ∪ objects(g) )\n2.9 PointedGraph\nA pointed graph is a graph and a distinguished node in the graph. The distinguished node is variously referred to as the start, base, or focus node of the pointed graph, depending on the context.\nPointedGraph == { g : Graph; n : TERM | n ∈ nodes(g) }"
    }, {
      "heading" : "3 Abstract Syntax",
      "text" : "This section contains a translation of the abstract syntax of SHACL into Z. The semantics draft defines the abstract syntax using an informal Extended Backus-Naur Form (EBNF).\nThe approach used here is to interpret each term or expression that appears in the abstract syntax as a mathematical set that is isomorphic to the set of abstract syntax tree fragments denoted by the corresponding term or expression. Care has been taken to preserve the exact spelling and case of each abstract syntax term so that there is a direct correspondence between the abstract syntax and Z. For example, the term Schema is interpreted as the set Schema.\nWe give a Z definition for each abstract syntax term that appears on the left-hand side of the EBNF definition operator (::=). The order in which these terms appear in the semantics draft has been preserved in this document. If a Z term has a corresponding EBNF rule, we include it here for easy reference. Refer to [2] for the complete definition of the abstract syntax.\nA sequence of two or more abstract syntax terms is interpreted as the Cartesian product of the corresponding sets, i.e. A B is interpreted as A× B .\nThe abstract syntax Kleene star (*) and plus (+) operators are interpreted as sequence (seq) and non-empty sequence (seq1) operators on the corresponding sets, i.e. A+ is interpreted as seq1 A.\nThe abstract syntax optional operator (?) is interpreted as taking the union of the set of singletons and the empty set of the corresponding set using the generic function OPTIONAL (defined below), i.e. A? is interpreted as OPTIONAL[A].\nAbstract syntax terms that are defined as alternations (|) of two or more expressions are translated into either free types or unions of sets. A side effect of this process is that constructors may be required for each branch of the alternation. In some cases the name of the constructors can be derived from a corresponding element of the abstract syntax. For example, in ShapeDefinition, open and close are mapped to the constructors open and close. In the cases where there is no convenient element of the abstract syntax, we mint new constructor names.\nWe also introduce new Z identifiers when an element of the abstract syntax does not map to a valid alphanumeric Z identifier. For example the the shape label negation operator (!) is mapped to negate.\n3.1 OPTIONAL\nAn optional value is represented by a singleton set, if the value is present, or the empty set, if the value is absent.\nOPTIONAL[X ] == { v : X • {v} } ∪ { }\n3.2 Schema\nSchema ::= Rule+\nA schema is a sequence of one or more rules.\nSchema == seq1 Rule\n3.3 Rule"
    }, {
      "heading" : "Rule ::= ShapeLabel ShapeDefinition ExtensionCondition*",
      "text" : "A rule consists of a shape label, a shape definition, and a sequence of zero or more extension conditions.\nRule == ShapeLabel × ShapeDefinition × seqExtensionCondition\nIt is convenient to introduce functions that select the components of a rule.\nshapeLabel == (λ r : Rule • fst(r) ) shapeDef == (λ r : Rule • snd(r) ) extConds == (λ r : Rule • trd(r) )\n3.4 ShapeLabel"
    }, {
      "heading" : "ShapeLabel ::= an identifier",
      "text" : "A shape label is an identifier drawn from some given set.\n[ShapeLabel ]\n3.5 ShapeDefinition"
    }, {
      "heading" : "ShapeDefinition ::= ClosedShape | OpenShape",
      "text" : "A shape definition is either a closed shape or an open shape.\nShapeDefinition ::= close ShapeExpr | open OPTIONAL[InclPropSet ]× ShapeExpr\nNote that abstract syntax terms that are defined using alternation are naturally represented as free types in Z Notation.\n• close is the constructor for closed shapes.A closed shape consists of a shape expression.\n• open is the constructor for open shapes. An open shape consists of an optional included properties set and a shape expression. Given a shape definition d , let shapeExpr(d) be its shape expression.\nshapeExpr : ShapeDefinition\" ShapeExpr\n∀ x : ShapeExpr • shapeExpr(close(x )) = x\n∀ o : OPTIONAL[InclPropSet ]; x : ShapeExpr • shapeExpr(open(o, x )) = x\n3.6 ClosedShape"
    }, {
      "heading" : "ClosedShape ::= ’close’ ShapeExpr",
      "text" : "The set of closed shapes is the range of the close shape definition constructor.\nClosedShape == ran close\n3.7 OpenShape"
    }, {
      "heading" : "OpenShape ::= ’open’ InclPropSet? ShapeExpr",
      "text" : "The set of open shapes is the range of the open shape definition constructor.\nOpenShape == ran open\n3.8 InclPropSet"
    }, {
      "heading" : "InclPropSet ::= PropertiesSet",
      "text" : "An included properties set is a properties set.\nInclPropSet == PropertiesSet\nNote that there seems little motivation to introduce the term InclPropSet since it is identical to PropertiesSet .\n3.9 PropertiesSet"
    }, {
      "heading" : "PropertiesSet ::= set of IRI",
      "text" : "A properties set is a set of IRIs.\nPropertiesSet == IRI\n3.10 ShapeExpr\nShapeExpr ::= EmptyShape | TripleConstraint Cardinality | InverseTripleConstraint Cardinality | NegatedTripleConstraint | NegatedInverseTripleConstraint | SomeOfShape | OneOfShape | GroupShape | RepetitionShape\nA shape expression defines constraints on RDF graphs.\nShapeExpr ::= emptyshape | triple DirectedTripleConstraint × Cardinality | someOf seq1 ShapeExpr | oneOf seq1 ShapeExpr | group seq1 ShapeExpr | repetition ShapeExpr × Cardinality\n• emptyshape is the empty shape expression.\n• triple is the constructor for triple constraint shape expressions. A triple constraint shape expression consists of a directed triple constraint and a cardinality.\n• someOf is the constructor for some-of shape expressions. A some-of shape expression consists of a sequence of one or more shape expressions.\n• oneOf is the constructor for one-of shape expressions. A one-of shape expression consists of a sequence of one or more shape expressions.\n• group is the constructor for grouping shape expressions. A grouping shape expression consists of a sequence of one or more shape expressions.\n• repetition is the constructor for repetition shape expressions. A repetition shape expression consists of a shape expression and a cardinality.\n3.11 EmptyShape"
    }, {
      "heading" : "EmptyShape ::= ’emptyshape’",
      "text" : "The set of empty shape expressions is the singleton set that contains the empty shape.\nEmptyShape == {emptyshape}\n3.12 DirectedPredicate\nA directed predicate is an IRI with a direction that indicates its usage in a triple. nop indicates the normal direction, namely the predicate relates the subject node to the object node. inv indicates the inverse direction, namely the predicate relates the object node to the subject node.\nDirectedPredicate ::= nop IRI | inv IRI\nThe semantics draft uses the notation ^p for inv(p).\nLet predDF (dp) denote the predicate of a directed predicate dp.\npredDP : DirectedPredicate\" IRI\n∀ p : IRI • predDP(nop(p)) = predDP(inv(p)) = p\n3.13 DirectedTripleConstraint\nA directed triple constraint consists of a directed predicate and a constraint. The constraint is a value or shape constraint on the object of a triple if the direction is normal, or a shape constraint on the subject of a triple if the direction is inverted.\nDirectedTripleConstraint == { dp : DirectedPredicate; C : Constraint |\ndp ∈ ran inv ⇒ C ∈ ShapeConstr }\nThe semantics draft uses the notation p::C for (nop(p),C ) and ^p::C for (inv(p),C ).\nLet predDTC (dtc) denote the predicate of the directed triple constraint dtc.\npredDTC : DirectedTripleConstraint \" IRI\n∀ dp : DirectedPredicate; C : Constraint | (dp,C ) ∈ DirectedTripleConstraint •\npredDTC (dp,C ) = predDP(dp)\nLet constrDTC (dtc) denote the constraint of the directed triple constraint dtc.\nconstrDTC : DirectedTripleConstraint \" Constraint\n∀ dp : DirectedPredicate; C : Constraint | (dp,C ) ∈ DirectedTripleConstraint •\nconstrDTC (dp,C ) = C\n3.14 TripleConstraint"
    }, {
      "heading" : "TripleConstraint ::= IRI ValueConstr | IRI ShapeConstr",
      "text" : "A triple constraint places conditions on triples whose subject is a given focus node and whose predicate is a given IRI.\nTripleConstraint : DirectedTripleConstraint\nTripleConstraint = { p : IRI ; C : Constraint • (nop(p),C ) }\n3.15 InverseTripleConstraint"
    }, {
      "heading" : "InverseTripleConstraint ::= ’^’ IRI ShapeConstr",
      "text" : "An inverse triple constraint places conditions on triples whose object is a given focus node and whose predicate is a given IRI.\nInverseTripleConstraint : DirectedTripleConstraint\nInverseTripleConstraint = { p : IRI ; C : ShapeConstr • (inv(p),C ) }\n3.16 Constraint\nA constraint is a condition on the object node of a triple for normal predicates or the subject node of a triple for inverse predicates.\nConstraint ::= valueSet (Lit ∪ IRI ) | datatype LiteralDatatype ×OPTIONAL[XSFacet ] | kind NodeKind | or seq1 ShapeLabel | and seq1 ShapeLabel | nor seq1 ShapeLabel | nand seq1 ShapeLabel\n• valueSet is the constructor for value set value constraints. A value set value constraint consists of a set of literals and IRIs.\n• datatype is the constructor for literal datatype value constraints. A literal datatype value constraint consists of a literal datatype and an optional XML Schema facet.\n• kind is the constructor for node kind value constraints. A node kind value constraint consists of a specification for a subset of RDF terms.\n• or is the constructor for disjunction shape constraints. A node must satisfy at least one of the shapes.\n• and is the constructor for conjunction shape constraints. A node must satisfy all of the shapes.\n• nor is the constructor for negated disjunction shape constraints. A node must not satisfy any of the shapes.\n• nand is the constructor for negated conjunction shape constraints. A node must not satisfy all of the shapes.\n3.17 Cardinality"
    }, {
      "heading" : "Cardinality ::= ’[’ MinCardinality ’;’ MaxCardinality ’]’",
      "text" : "Cardinality defines a range for the number of elements in a set.\nCardinality == MinCardinality ×MaxCardinality\n• A cardinality consists of a minimum cardinality and a maximum cardinality.\n3.18 MinCardinality"
    }, {
      "heading" : "MinCardinality ::= a natural number",
      "text" : "Minimum cardinality is the minimum number of elements required to be in a set.\nMinCardinality ==\n3.19 MaxCardinality"
    }, {
      "heading" : "MaxCardinality ::= a natural number | ’unbound’",
      "text" : "Maximum cardinality is the maximum number of elements required to be in a set.\nMaxCardinality ::= maxCard | unbound\n• maxCard is the constructor for finite maximum cardinalities. A finite maximum cardinality is a natural number. Note that a maximum cardinality of 0 means that the set must be empty.\n• unbound indicates that the maximum number of elements in a set is unbounded.\n3.20 inBounds\nA natural number k is said to be in bounds of a cardinality when k is between the minimum and maximum limits of the cardinality.\ninBounds : # Cardinality\n∀ k , n : • k inBounds (n, unbound) ⇔ n ≤ k\n∀ k , n,m : • k inBounds (n,maxCard(m)) ⇔ n ≤ k ≤ m"
    }, {
      "heading" : "3.21 Notation",
      "text" : "Let a be an IRI, let C be a value or shape constraint, let n and m be nonnegative integers. The semantics draft uses the notation listed in Table 1 for some shape expressions.\n• If the cardinality is [1;1] it may be omitted.\n• The negated shape expressions are semantically equivalent to the corresponding non-negated shape expressions with cardinality [0;0].\n3.22 none, one\nIt is convenient to define some common cardinalities.\nnone == (0,maxCard(0))\none == (1,maxCard(1))\n• A cardinality of none = [0;0] is used to indicate a negated triple or inverse triple constraint.\n• A cardinality of one = [1;1] is the default cardinality of a triple or inverse triple constraint when no cardinality is explicitly given in the notations a::C and ^a::C.\n3.23 NegatedTripleConstraint"
    }, {
      "heading" : "NegatedTripleConstraint ::= ’!’ TripleConstraint",
      "text" : "A negated triple constraint shape expression is a triple constraint shape expression that has a cardinality of none.\nNegatedTripleConstraint == { tc : TripleConstraint • triple(tc, none) }\n3.24 NegatedInverseTripleConstraint"
    }, {
      "heading" : "NegatedInverseTripleConstraint ::= ’!’ InverseTripleConstraint",
      "text" : "A negated inverse triple constraint shape expression is an inverse triple constraint shape expression that has a cardinality of none.\nNegatedInverseTripleConstraint == { itc : InverseTripleConstraint • triple(itc, none) }\n3.25 ValueConstr"
    }, {
      "heading" : "ValueConstr ::= ValueSet | LiteralDatatype XSFacet? | NodeKind",
      "text" : "A value constraint places conditions on the object nodes of triples for normal predicates and on the subject nodes of triples for inverse predicates.\nValueConstr == ran valueSet ∪ ran datatype ∪ ran kind\n3.26 ValueSet"
    }, {
      "heading" : "ValueSet ::= set of literals and IRI",
      "text" : "The set of value set value constraints is the range of the valueSet constructor.\nValueSet == ran valueSet\n3.27 LiteralDatatype"
    }, {
      "heading" : "LiteralDatatype ::= an RDF literal datatype",
      "text" : "A literal datatype is an IRI that identifies a set of literal RDF terms. We assume that this subset of IRIs is given.\nLiteralDatatype : IRI\nWe also assume that we are given an interpretation of each literal datatype as a set of literals.\nliteralsOfDatatype : LiteralDatatype\" Lit\n3.28 NodeKind"
    }, {
      "heading" : "NodeKind ::= ’iri’ | ’blank’ | ’literal’ | ’nonliteral’",
      "text" : "A node kind identifies a subset of RDF terms.\nNodeKind ::= iri | blank | literal | nonliteral\n• iri identifies the set of IRIs.\n• blank identifies the set of blank nodes.\n• literal identifies the set of literals.\n• nonliteral identifies the complement of the set of literals, i.e. the union of IRIs and blank nodes.\nEach node kind corresponds to a set of RDF terms.\ntermsOfKind : NodeKind\" TERM\ntermsOfKind(iri) = IRI\ntermsOfKind(blank) = Blank\ntermsOfKind(literal) = Lit\ntermsOfKind(nonliteral) = TERM \\ Lit\n3.29 XSFacet"
    }, {
      "heading" : "XSFacet ::= an XSD restriction",
      "text" : "An XML Schema facet places restrictions on literals. We assume this is a given set.\n[XSFacet ]\nWe also assume that we are given an interpretation of facets as sets of literals.\nliteralsOfFacet : LiteralDatatype ×XSFacet\" Lit\n∀ d : LiteralDatatype; f : XSFacet • literalsOfFacet(d , f ) ⊆ literalsOfDatatype(d)\n• The literals that correspond to a facet of a datatype are a subset of the literals that correspond to the datatype.\n3.30 ShapeConstr"
    }, {
      "heading" : "ShapeConstr ::= (’!’)? DisjShapeConstr | ConjShapeConstraint",
      "text" : "A shape constraint requires that a node satisfy logical combinations of one or more other shapes which are identified by their shape labels.\nShapeConstr == ran or ∪ ran and ∪ rannor ∪ rannand\n3.31 DisjShapeConstr"
    }, {
      "heading" : "DisjShapeConstr ::= ShapeLabel (’or’ ShapeLabel)*",
      "text" : "The set of all disjunctive shape constraints is the range of the or constructor.\nDisjShapeConstr == ran or\n3.32 ConjShapeConstraint"
    }, {
      "heading" : "ConjShapeConstraint ::= ShapeLabel (’and’ ShapeLabel)*",
      "text" : "The set of all conjunctive shape constraints is the range of the and constructor.\nConjShapeConstraint == ran and\n3.33 SomeOfShape"
    }, {
      "heading" : "SomeOfShape ::= ShapeExpr (’|’ ShapeExpr)*",
      "text" : "The set of some-of shape expressions is the range of someOf .\nSomeOfShape == ran someOf\n3.34 OneOfShape"
    }, {
      "heading" : "OneOfShape ::= ShapeExpr (’@’ ShapeExpr)*",
      "text" : "The set of one-of shape expressions is the range of oneOf .\nOneOfShape == ran oneOf\n3.35 GroupShape"
    }, {
      "heading" : "GroupShape ::= ShapeExpr (’,’ ShapeExpr)*",
      "text" : "The set of grouping shape expressions is the range of group.\nGroupShape == ran group\n3.36 RepetitionShape"
    }, {
      "heading" : "RepetitionShape ::= ShapeExpr Cardinality",
      "text" : "The set of repetition shape expressions is the range of repetition.\nRepetitionShape == ran repetition\n3.37 ExtensionCondition"
    }, {
      "heading" : "ExtensionCondition ::= ExtLangName ExtDefinition",
      "text" : "An extension condition is the definition of a constraint written in an extension language\nExtensionCondition == ExtLangName × ExtDefinition\n3.38 ExtLangName"
    }, {
      "heading" : "ExtLangName ::= an identifier",
      "text" : "An extension language name is an identifier for an extension language, such as JavaScript. We assume this is a given set.\n[ExtLangName]\n3.39 ExtDefinition"
    }, {
      "heading" : "ExtDefinition ::= a string",
      "text" : "An extension definition is a program written in some extension language that implements a constraint check. We assume this is a given set.\n[ExtDefinition]\nAn extension condition represents a function that takes as input a pointed graph, and returns as output a boolean with the value true if the constraint is violated and false is satisfied. We assume we are given a mapping that associates each extension condition with the set of pointed graphs that violate it.\nviolatedBy : ExtensionCondition\" PointedGraph\n3.40 ShapeLabel Definitions\nGiven a schema S , let defs(S ) be the set of all shape labels defined in S .\ndefs == (λ S : Schema • { r : ranS • shapeLabel(r) } )\nEach rule in a schema must be identified by a unique shape label.\nSchemaUL == { S : Schema | #S = #(defs(S )) }\n• In a schema with unique rule labels there are as many rules as labels.\n3.41 rule\nGiven a schema S with unique rule labels, and a label T defined in S , let rule(T , S ) be the corresponding rule.\nrule : ShapeLabel × SchemaUL Rule\ndom rule = {T : ShapeLabel ; S : SchemaUL | T ∈ defs(S ) }\n∀S : SchemaUL • ∀ r : ran(S ) •\nlet T == shapeLabel(r) • rule(T , S ) = r\n3.42 ShapeLabel References\nGiven a schema S , let refs(S ) be the set of shape labels referenced in S .\nrefs == (λS : Schema • ⋃ { r : ranS • refsRule(r) } )\n• The set of references in a schema is the union of the sets of references in its rules.\nGiven a rule r , let refsRule(r) be the set of shape labels referenced in r .\nrefsRule == (λ r : Rule • refsShapeDefinition(shapeDef (r)) )\n• The set of references in a rule is the set of references in its shape definition.\nGiven a shape definition d , let refsShapeDefinition(d) be the set of shape labels referenced in d .\nrefsShapeDefinition : ShapeDefinition\" ShapeLabel\n∀ d : ShapeDefinition • refsShapeDefinition(d) = refsShapeExpr(shapeExpr(d))\n• The set of references in a shape definition is the set of references in its shape expression.\nGiven a shape expression x , let refsShapeExpr(x ) be the set of shape labels referenced in x .\nrefsShapeExpr : ShapeExpr \" ShapeLabel\nrefsShapeExpr(emptyshape) =\n∀ dtc : DirectedTripleConstraint ; c : Cardinality • refsShapeExpr(triple(dtc, c)) =\nrefsDirectedTripleConstraint(dtc)\n∀ xs : seq1 ShapeExpr • refsShapeExpr(someOf (xs)) = refsShapeExpr(oneOf (xs)) = refsShapeExpr(group(xs)) =⋃\n{ x : ran xs • refsShapeExpr(x ) }\n∀ x : ShapeExpr ; c : Cardinality • refsShapeExpr(repetition(x , c)) =\nrefsShapeExpr(x )\n• The empty shape expression references no labels.\n• A directed triple constraint shape expression references the labels referenced in the directed triple constraint.\n• A some-of or one-of or group shape expression references the union of the labels referenced in each component shape expression.\n• A repetition shape expression references the labels referenced in its unrepeated shape expression.\nGiven a directed triple constraint dtc, let refsDirectedTripleConstraint(dtc) be the set of shape labels referenced in dtc.\nrefsDirectedTripleConstraint : DirectedTripleConstraint\" ShapeLabel\n∀ a : IRI ; C : ValueConstr • refsDirectedTripleConstraint((nop(a),C )) =\n∀ a : IRI ; C : ShapeConstr • refsDirectedTripleConstraint((nop(a),C )) = refsDirectedTripleConstraint((inv(a),C )) =\nrefsShapeConstr(C )\n• A value triple constraint references no labels.\n• A shape triple constraint references the labels in its shape constraint.\nGiven a shape constraint C , let refsShapeConstr(C ) be the set of shape labels referenced in C .\nrefsShapeConstr : ShapeConstr\" ShapeLabel\n∀ ls : seq1 ShapeLabel • refsShapeConstr(or(ls)) = refsShapeConstr(and(ls)) = refsShapeConstr(nor(ls)) = refsShapeConstr(nand(ls)) =\nran ls\n• A shape constraint references the range of its sequence of shape labels. Every shape label referenced in a schema must be defined in the schema.\nSchemaRD == { s : Schema | refs(s) ⊆ defs(s) }\nA schema is well-formed if its rules have unique labels and all referenced shape labels are defined.\nSchemaWF == SchemaUL ∩ SchemaRD"
    }, {
      "heading" : "4 Evaluation",
      "text" : "This section defines the interpretation of shapes as constraints on RDF graphs. All functions that are defined in the semantics draft are given formal definitions here. We assume that from this point on whenever the semantics draft refers to schemas they are well-formed.\n4.1 shapes\nGiven a well-formed schema S , let shapes(S ) be the set of shape labels that appear in S .\nshapes == (λS : SchemaWF • defs(S ) )\n4.2 expr\nGiven a shape label T and a well-formed schema S , let expr(T , S ) be the shape expression in the rule with label T in S .\nexpr : ShapeLabel × SchemaWF ShapeExpr\ndom expr = {T : ShapeLabel ; S : SchemaWF | T ∈ shapes(S ) }\n∀T : ShapeLabel ; S : SchemaWF | T ∈ shapes(S ) • let r == rule(T , S ) •\nexpr(T , S ) = shapeExpr(shapeDef (r))\n• The shape expression for a shape label T is the shape expression in the shape definition of the rule r that has shape label T .\n4.3 incl\nGiven a shape label T defined in a well-formed schema S , let incl(T , S ) be the, possibly empty, set of included properties.\nincl : ShapeLabel × SchemaWF InclPropSet\ndom incl = {T : ShapeLabel ; S : SchemaWF | T ∈ shapes(S ) }\n∀T : ShapeLabel ; S : SchemaWF | T ∈ shapes(S ) • ∃ 1 r : ranS | T = shapeLabel(r) • incl(T , S ) = inclShapeDefinition(shapeDef (r))\n• The included properties set for a shape label T is the included properties set in the shape definition of the rule r that has shape label T .\nGiven a shape definition d , let inclShapeDefinition(d) be its included properties set.\ninclShapeDefinition : ShapeDefinition\" InclPropSet\n∀ x : ShapeExpr • inclShapeDefinition(close(x )) = inclShapeDefinition(open({ }, x ))\n=\n∀ ips : InclPropSet ; x : ShapeExpr • inclShapeDefinition(open({ips}, x )) = ips\n• The included property set of a closed shape definition or an open definition with no included property set is the empty set.\n• The included property set of an open shape definition with an included property set is that included property set.\n4.4 properties\nGiven a shape expression x , let properties(x ) be the set of properties that appear in some triple constraint in x .\nproperties : ShapeExpr\" PropertiesSet\nproperties(emptyshape) =\n∀ tc : TripleConstraint ; c : Cardinality • properties(triple(tc, c)) =\npropertiesTripleConstraint(tc)\n∀ itc : InverseTripleConstraint ; c : Cardinality • properties(triple(itc, c)) =\n∀ xs : seq1 ShapeExpr • properties(someOf (xs)) = properties(oneOf (xs)) = properties(group(xs)) =⋃\n{ x : ran xs • properties(x ) }\n∀ x : ShapeExpr ; c : Cardinality • properties(repetition(x , c)) = properties(x )\n• An empty shape expression has no properties.\n• The properties of a triple constraint shape expression are the properties of its triple constraint.\n• Inverse triple constraint shape expressions have no properties.\n• The properties of a some-of, one-of, or grouping shape expression are the union of the properties of their component shape expressions.\n• The properties of a repetition shape expression are the properties of the shape expression being repeated.\nGiven a triple constraint tc, let propertiesTripleConstraint(tc) be its set of properties.\npropertiesTripleConstraint : TripleConstraint \" PropertiesSet\n∀ a : IRI ; C : Constraint • propertiesTripleConstraint((nop(a),C )) = {a}\n• The properties of a triple constraint is the singleton set that contains its IRI.\n4.5 invproperties\nGiven a shape expression x , let invproperties(x ) be the set of properties that appear in some inverse triple constraint in x .\ninvproperties : ShapeExpr \" PropertiesSet\ninvproperties(emptyshape) =\n∀ tc : TripleConstraint ; c : Cardinality • invproperties(triple(tc, c)) =\n∀ itc : InverseTripleConstraint ; c : Cardinality • invproperties(triple(itc, c)) =\ninvpropertiesInverseTripleConstraint(itc)\n∀ xs : seq1 ShapeExpr • invproperties(someOf (xs)) = invproperties(oneOf (xs)) = invproperties(group(xs)) =⋃\n{ x : ran xs • invproperties(x ) }\n∀ x : ShapeExpr ; c : Cardinality • invproperties(repetition(x , c)) = invproperties(x )\n• An empty shape expression has no inverse properties.\n• A triple constraint shape expression has no inverse properties.\n• The inverse properties of an inverse triple constraint shape expression are the inverse properties in its inverse triple constraint.\n• The inverse properties of a some-of, one-of, or grouping shape expression is the union of the inverse properties of their component shape expressions.\n• The inverse properties of a repetition shape expression are the inverse properties of the shape expression being repeated.\nGiven an inverse triple constraint itc, let invpropertiesInverseTripleConstraint(tc) be its set of inverse properties.\ninvpropertiesInverseTripleConstraint : InverseTripleConstraint \" PropertiesSet\n∀ a : IRI ; C : ShapeConstr • invpropertiesInverseTripleConstraint((inv(a),C )) = {a}\n• The inverse properties of an inverse triple constraint is the singleton set that contains its IRI.\n4.6 dep graph\n4.6.1 DiGraph\nA directed graph consists of a set of nodes and a set of directed edges that connect the nodes.\nDiGraph[X ] nodes : X edges : X #X\nedges ∈ nodes# nodes\n• Each edge connects a pair of nodes in the graph.\n4.6.2 DepGraph\nGiven a well-formed schema S , let the shapes dependency graph be the directed graph whose nodes are the shape labels in S and whose edges connect label T1 to label T2 when the shape expression that defines T1 refers to T2.\nDepGraph S : SchemaWF DiGraph[ShapeLabel ]\nnodes = shapes(S )\nedges = {T1,T2 : nodes | T2 ∈ refsShapeExpr(expr(T1, S )) }\n• The nodes are the shapes of the schema.\n• There is an edge from T1 to T2 when the definition of T1 refers to T2.\n4.6.3 dep graph\nLet dep graph(S ) be the dependency graph of S .\ndep graph : SchemaWF \"DiGraph[ShapeLabel ]\ndep graph = {DepGraph • S 7→ θDiGraph }\n4.7 dep subgraph\n4.7.1 reachable\nGiven a directed graph g and a node T in g, a node U is reachable from T if there is a directed path of one or more edges that connects T to U .\n[X ] reachable : DiGraph[X ] ×X \" X\n∀ g : DiGraph[X ]; T : X • let edges == g.edges •\nreachable(g,T ) = {U : X | T 7→ U ∈ edges+ }\n4.7.2 DepSubgraph\nGiven a well-formed schema S and a shape label T in S , the shapes dependency graph is the subgraph induced by the nodes that are reachable from T .\nDepSubgraph S : SchemaWF T : ShapeLabel DiGraph[ShapeLabel ]\nT ∈ shapes(S )\nlet g == dep graph(S ) • nodes = reachable(g,T ) ∧ edges = g.edges ∩ (nodes × nodes)\n• The nodes of the subgraph consist of all the nodes reachable from T .\n• The edges of the subgraph consist of all edges of the graph whose nodes are in the subgraph.\nNote that the above formal definition of the dependency subgraph is a literal translation of the text in the semantics draft. In particular, this literal translation does not explicitly include the label T as a node. Therefore T will not be in the subgraph unless it is in a directed cycle of edges.\n4.7.3 dep subgraph\nLet dep subgraph(T , S ) be the dependency subgraph of T in S .\ndep subgraph : ShapeLabel × SchemaWF DiGraph[ShapeLabel ]\ndep subgraph = {DepSubgraph • (T , S ) 7→ θDiGraph }\n4.8 negshapes\nThe definition of negshapes makes use of several auxilliary definitions. In the following we assume that S is a well-formed schema and that T is a shape label in S .\n4.8.1 inNeg\nLet inNeg(S ) be the set of labels that appear in some negated shape constraint.\ninNeg : SchemaWF \" ShapeLabel\n∀S : SchemaWF • inNeg(S ) = ⋃ {T : shapes(S ) • inNegExpr(expr(T , S )) }\nGiven a shape expression x , let inNegExpr(x ) be the set of labels that appear in some negated shape constraint in x .\ninNegExpr : ShapeExpr \" ShapeLabel\ninNegExpr(emptyshape) =\n∀ tc : TripleConstraint ; c : Cardinality • inNegExpr(triple(tc, c)) =\ninNegTripleConstraint(tc)\n∀ itc : InverseTripleConstraint ; c : Cardinality • inNegExpr(triple(itc, c)) =\ninNegInverseTripleConstraint(itc)\n∀ xs : seq1 ShapeExpr • inNegExpr(someOf (xs)) = inNegExpr(oneOf (xs)) = inNegExpr(group(xs)) =⋃\n{ x : ran xs • inNegExpr(x ) }\n∀ x : ShapeExpr ; c : Cardinality • inNegExpr(repetition(x , c)) = inNegExpr(x )\nGiven a triple constraint tc, let inNegTripleConstraint(tc) be the set of labels that appear in some negated shape constraint in tc.\ninNegTripleConstraint : TripleConstraint \" ShapeLabel\n∀ a : IRI ; C : ValueConstr • inNegTripleConstraint((nop(a),C )) =\n∀ a : IRI ; C : ShapeConstr • inNegTripleConstraint((nop(a),C )) = inNegShapeConstr(C )\nGiven an inverse triple constraint itc, let inNegInverseTripleConstraint(tc) be the set of labels that appear in some negated shape constraint in itc.\ninNegInverseTripleConstraint : InverseTripleConstraint \" ShapeLabel\n∀ a : IRI ; C : ShapeConstr • inNegInverseTripleConstraint((inv(a),C )) = inNegShapeConstr(C )\nGiven a shape constraint C , let inNegShapeConstr(C ) be the set of labels that appear in C when it is negated, or the empty set otherwise.\ninNegShapeConstr : ShapeConstr\" ShapeLabel\n∀Ts : seq1 ShapeLabel • inNegShapeConstr(or(Ts)) = inNegShapeConstr(and(Ts)) =\n∀Ts : seq1 ShapeLabel • inNegShapeConstr(nor(Ts)) = inNegShapeConstr(nand(Ts)) =\nranTs\n4.8.2 underOneOf\nLet underOneOf (S ) be the set of labels that appear in some triple constraint or inverse triple constraint under a one-of constraint in S .\nunderOneOf : SchemaWF \" ShapeLabel\n∀S : SchemaWF • underOneOf (S ) =⋃\n{T : shapes(S ) • underOneOfExpr(expr(T , S )) }\nGiven a shape expression x , let underOneOfExpr(x ) be the set of labels that appear in some triple constraint or inverse triple constraint under a one-of constraint in x .\nunderOneOfExpr : ShapeExpr\" ShapeLabel\n∀ x : ShapeExpr • underOneOfExpr(x ) =\nif x ∈ ran someOf then refsShapeExpr(x ) else\n4.8.3 inTripleConstr\nLet inTripleConstr(S ) be the set of labels T such that there is a shape label T1 and a triple constraint p::C or an inverse shape triple constraint ^p::C in expr(T1, S ), and T appears in C .\nNote that this definition looks wrong since it does not involve negation of shapes. Nevertheless, a literal translation is given here. The only difference between inTripleConstr(S ) and refs(S ) seems to be that the cardinality on the triple and inverse triple constraints is [1,1] since it is not explicitly included in the notations p::C and ^p::C.\ninTripleConstr : SchemaWF \" ShapeLabel\n∀S : SchemaWF • inTripleConstr(S ) =⋃\n{T1 : shapes(S ) • inTripleConstrExpr(expr(T1, S )) }\nGiven a shape expression x , let inTripleConstrExpr(x ) be the set of labels T such that x contains a triple constraint p::C or an inverse shape triple constraint ^p::C and T appears in x .\ninTripleConstrExpr : ShapeExpr\" ShapeLabel\ninTripleConstrExpr(emptyshape) =\n∀ dtc : DirectedTripleConstraint ; c : Cardinality • inTripleConstrExpr(triple(dtc, c)) =\nif c = one then refsDirectedTripleConstraint(dtc) else\n∀ xs : seq1 ShapeExpr • inTripleConstrExpr(someOf (xs)) = inTripleConstrExpr(oneOf (xs)) = inTripleConstrExpr(group(xs)) =⋃\n{ x : ran xs • inTripleConstrExpr(x ) }\n∀ x : ShapeExpr ; c : Cardinality • inTripleConstrExpr(repetition(x , c)) = inTripleConstrExpr(x )\n4.8.4 negshapes\nThe semantics draft makes the following statement.\nIntuitively, negshapes(S) is the set of shapes labels for which one needs to check whether some nodes in a graph do not satisfy these shapes, in order to validate the graph against the schema S.\nLet negshapes(S ) be the set of negated shape labels that appear in S .\nnegshapes : SchemaWF \" ShapeLabel\n∀S : SchemaWF • negshapes(S ) = inNeg(S ) ∪ underOneOf (S ) ∪ inTripleConstr(S )\n• A negated shape label is a shape label that appears in a negated shape constraint, or in a triple or inverse triple constraint under a one-of shape expression, or in a triple or inverse triple constraint that has cardinality [1,1].\nNote that, as remarked above, the definition of inTripleConstr seems wrong.\n4.9 ShapeVerdict\nThe semantics draft defines the notation !T for shape labels T to indicate that T is negated. The semantics of a schema involves assigning sets of shape labels and negated shape labels to the nodes of a graph, which indicates which shapes must be satisfied or violated at each node.\nA shape verdict indicates if a shape must be satisfied or violated. An asserted label must be satisfied. A negated label must be violated.\nShapeVerdict ::= assert ShapeLabel | negate ShapeLabel\nThe notation !T corresponds to negate(T ).\n4.10 allowed\nGiven a value constraint V , let allowed(V ) be the set of all allowed values defined by V .\nallowed : ValueConstr\" (Lit ∪ IRI )\n∀ vs : (Lit ∪ IRI ) • allowed(valueSet(vs)) = vs\n∀ dt : LiteralDatatype • allowed(datatype(dt , )) = literalsOfDatatype(dt)\n∀ dt : LiteralDatatype; f : XSFacet • allowed(datatype(dt , {f })) = literalsOfFacet(dt , f )\n∀ k : NodeKind • allowed(kind(k)) = termsOfKind(k)"
    }, {
      "heading" : "4.10.1 DAG",
      "text" : "A directed, acyclic graph is a directed graph in which no node is reachable from itself.\nDAG[X ] DiGraph[X ]\nlet g == θDiGraph • ∀T : nodes • T /∈ reachable(g,T )\n4.11 ReplaceShape\nThe semantics draft introduces the notation Sri for a reduced schema where S is a schema, r is a rule-of-one node in a proof tree, and i corresponds to a premise of r . The reduced schema is constructed by replacing a shape with one\nin which the corresponding one-of component is eliminated. This replacement operation is described here. The full definition of Sri is given below following the definition of proof trees.\nGiven a schema S , a shape label T defined in S , and a shape expression Expr ′, the schema replaceShape(S ,T ,Expr ′) is the schema S ′ that is the same as S except that expr(T , S ′) = Expr ′.\nReplaceShape S , S ′ : SchemaWD T : ShapeLabel Expr ′ : ShapeExpr l : 1 d , d ′ : ShapeDefinition ecs : seqExtensionCondition\nl ∈ domS\nS (l) = (T , d , ecs)\n∀ o : OPTIONAL[InclPropSet ]; Expr : ShapeExpr | d = open(o,Expr) •\nd ′ = open(o,Expr ′)\n∀Expr : ShapeExpr | d = close(Expr) •\nd ′ = close(Expr ′)\nS ′ = S ⊕ {l 7→ (T , d ′, ecs)}\nreplaceShape : SchemaWF × ShapeLabel × ShapeExpr SchemaWF\nreplaceShape = {ReplaceShape • (S ,T ,Expr ′) 7→ S ′ }\n4.12 SchemaWD\nGiven a well-formed schema S , it is said to be well-defined if for each negated label T in negshapes(T ), the dependency subgraph dep subgraph(T , S ) is a directed, acyclic graph.\nSchemaWD == { S : SchemaWF |\n∀T : negshapes(S ) • dep subgraph(T , S ) ∈ DAG[ShapeLabel ] }\nThe semantics of shape expression schemas is sound only for well-defined schemas. Only well-defined schemas will be considered from this point forward."
    }, {
      "heading" : "5 Declarative semantics of shape expression schemas",
      "text" : "Recall that negated triple and inverse triple shape expressions are represented by the corresponding non-negated expressions with cardinality none = [0;0].\n5.1 LabelledTriple\nA labelled triple is either an incoming or outgoing edge in an RDF graph.\nLabelledTriple ::= out Triple | inc Triple\nSometimes labelled triples are referred to simply as triples.\n5.2 matches\nA labelled triple matches a directed triple constraint when they have the same direction and predicate.\nmatches : LabelledTriple#DirectedTripleConstraint\nmatches = matches out ∪matches inc\n5.2.1 matches out\nmatches out matches outgoing triples to triple constraints.\nmatches out == { s , p, o : TERM ; C : Constraint |\n(s , p, o) ∈ Triple • out(s , p, o) 7→ (nop(p),C ) }\nNote that this definition ignores any value constraints defined in C . The absence of restrictions imposed by value constraints makes matching weaker than it could be. This may be an error in the semantics draft.\nThe semantics drafts contains the following text.\nThe following definition introduces the notion of satisfiability of a shape constraint by a set of triples. Such satisfiability is going to be used for checking that the neighbourhood of a node satisfies locally the constraints defined by a shape expression, without taking into account whether the shapes required by the triple constraints and inverse triple constraints are satisfied.\nRead literally, only shape constraints should be ignored, so unless value constraints are handled elsewhere, the semantics draft has an error in the definition of matches .\n5.2.2 matches inc\nmatches inc matches incoming triples to inverse triple constraints.\nmatches inc == { s , p, o : TERM ; C : ShapeConstr |\n(s , p, o) ∈ Triple • inc(s , p, o) 7→ (inv(p),C ) }\n5.3 satifies\nA set of labelled triples Neigh is said to satisfy a shape expression Expr if the constraints, other than shape constraints, defined in Expr are satisfied.\nNote that the definition of matches ignores both value and shape constraints.\nsatisfies : LabelledTriple# ShapeExpr\nThis relation is defined recursively by inference rules for each type of shape expression.\nsatisfies = rule empty∪ rule triple constraint∪ rule inverse triple constraint∪ rule some of ∪ rule one of ∪ rule group∪ rule repeat\n5.3.1 InfRule\nAn inference rule defines a relation between a set of labelled triples and a shape expression. It is convenient to define a base schema for the inference rules.\nInfRule Neigh : LabelledTriple Expr : ShapeExpr\n5.3.2 rule empty\nAn empty set of triples satisfies the empty shape expression.\nRuleEmpty InfRule\nExpr = emptyshape\nNeigh =\nrule empty : LabelledTriple# ShapeExpr\nrule empty = {RuleEmpty • Neigh 7→ Expr }\n5.3.3 rule triple constraint\nA set of triples satisfies a triple constraint shape expression when each triple matches the constraint and the total number of constraints is within the bounds of the cardinality.\nRuleTripleConstraint InfRule k : p : IRI C : Constraint c : Cardinality\nExpr = triple((nop(p),C ), c)\nk = #Neigh\nk inBounds c\n∀ t : Neigh • t matches (nop(p),C )\nrule triple constraint : LabelledTriple# ShapeExpr\nrule triple constraint = {RuleTripleConstraint • Neigh 7→ Expr }\n5.3.4 rule inverse triple constraint\nA set of triples satisfies an inverse triple constraint shape expression when each triple matches the constraint and the total number of constraints is within the bounds of the cardinality.\nRuleInverseTripleConstraint InfRule k : p : IRI C : Constraint c : Cardinality\nExpr = triple((inv(p),C ), c)\nk = #Neigh\nk inBounds c\n∀ t : Neigh • t matches (inv(p),C )\nrule inverse triple constraint : LabelledTriple# ShapeExpr\nrule triple constraint = {RuleInverseTripleConstraint • Neigh 7→ Expr }\n5.3.5 rule some of\nA set of triples satisfies a some-of shape expression when the set of triples satisfies one of the component shape expressions.\nRuleSomeOf InfRule Exprs : seq1 ShapeExpr i :\nExpr = someOf (Exprs)\ni ∈ domExprs\nNeigh satisfies Exprs(i)\nrule some of : LabelledTriple# ShapeExpr\nrule some of = {RuleSomeOf • Neigh 7→ Expr }\n5.3.6 rule one of\nA set of triples satisfies a one-of shape expression when the set of triples satisfies one of the component shape expressions.\nRuleOneOf InfRule Exprs : seq1 ShapeExpr i :\nExpr = oneOf (Exprs)\ni ∈ domExprs\nNeigh satisfies Exprs(i)\nrule one of : LabelledTriple# ShapeExpr\nrule one of = {RuleOneOf • Neigh 7→ Expr }\nThe semantics draft contains the following text.\nNote that the conditions for some-of and one-of shapes are identical. The distinction between both will be made by taking into account also the non-local, shape constraints.\n5.3.7 rule group\nA set of triples satisfies a group shape expression when the set of triples can be partitioned into a sequence of subsets whose length is the same as the sequence of component shape expressions, and each subset satisfies the corresponding component shape expression.\nRuleGroup InfRule Neighs : seq1( LabelledTriple) Exprs : seq1 ShapeExpr Expr = group(Exprs)\nNeighs partition Neigh\n#Neighs = #Exprs\n∀ j : domNeighs • Neighs(j ) satisfies Exprs(j )\nrule group : LabelledTriple# ShapeExpr\nrule group = {RuleGroup • Neigh 7→ Expr }\n5.3.8 rule repeat\nA set of triples satisfies a repetition shape expression when the set of triples can be partitioned into a sequence of subsets whose length is in the bounds of the cardinality, and each subset satisfies the component shape expression of the repetition shape expression.\nRuleRepeat InfRule Expr1 : ShapeExpr Neighs : seq1( LabelledTriple) k : c : Cardinality\nExpr = repetition(Expr1, c)\nk = #Neighs\nk inBounds c\nNeighs partition Neigh\n∀ j : domNeighs • Neighs(j ) satisfies Expr1\nrule repeat : LabelledTriple# ShapeExpr\nrule repeat = {RuleRepeat • Neigh 7→ Expr }"
    }, {
      "heading" : "5.4 Proof Trees",
      "text" : "The preceding definition of satisfies is based on the existence of certain characteristics of the set of triples. For example, a set of triples satisfies one of a sequence of shape expressions when it satisfies exactly one of the them, but the satisfies relation forgets the actual shape expression that the set of triples satisfies. We can remember this type of information in a proof tree.\n5.4.1 RuleTree\nA rule tree is a tree of inference rules and optional child rule trees. Child rule trees occur in cases where the inference rule depends on other inference rules.\nRuleTree ::= ruleEmpty RuleEmpty | ruleTripleConstraint RuleTripleConstraint | ruleInverseTripleConstraint RuleInverseTripleConstraint | ruleSomeOf RuleSomeOf × RuleTree | ruleOneOf RuleOneOf × RuleTree | ruleGroup RuleGroup × seq1 RuleTree | ruleRepeat RuleRepeat × seq1 RuleTree\n5.4.2 baseRule\nEach node in a rule tree contains an inference rule and, therefore, a base inference rule.\nbaseRule : RuleTree\" InfRule\n∀RuleEmpty • let rule == θRuleEmpty;\nbase == θInfRule • baseRule(ruleEmpty(rule)) = base\n∀RuleTripleConstraint • let rule == θRuleTripleConstraint ;\nbase == θInfRule • baseRule(ruleTripleConstraint(rule)) = base\n∀RuleInverseTripleConstraint • let rule == θRuleInverseTripleConstraint ;\nbase == θInfRule • baseRule(ruleInverseTripleConstraint(rule)) = base\n∀RuleSomeOf ; tree : RuleTree • let rule == θRuleSomeOf ;\nbase == θInfRule • baseRule(ruleSomeOf (rule, tree)) = base\n∀RuleOneOf ; tree : RuleTree • let rule == θRuleOneOf ;\nbase == θInfRule • baseRule(ruleOneOf (rule, tree)) = base\n∀RuleGroup; trees : seq1 RuleTree • let rule == θRuleGroup;\nbase == θInfRule • baseRule(ruleGroup(rule, trees)) = base\n∀RuleRepeat ; trees : seq1 RuleTree • let rule == θRuleRepeat ;\nbase == θInfRule • baseRule(ruleRepeat(rule, trees)) = base\n5.4.3 baseNeigh\nEach node in a rule tree has a base set of labelled triples.\nbaseNeigh : RuleTree\" LabelledTriple\n∀ tree : RuleTree • baseNeigh(tree) = (baseRule(tree)).Neigh\n5.4.4 baseExpr\nEach node in a rule tree has a base shape expression.\nbaseExpr : RuleTree\" ShapeExpr\n∀ tree : RuleTree • baseExpr(tree) = (baseRule(tree)).Expr\n5.4.5 ProofTree\nA proof tree is a rule tree in which the child trees prove subgoals of their parent nodes.\nProofTree : RuleTree\nThe definition of proof tree is recursive so it is given by a set of constraints, one for each type of node.\nAny rule tree whose root node contains an empty shape expression is a proof tree since it has no subgoals.\nran ruleEmpty ⊂ ProofTree\nAny rule tree whose root node node contains a triple constraint shape expression is a proof tree since it has no subgoals.\nran ruleTripleConstraint ⊂ ProofTree\nAny rule tree whose root node node contains an inverse triple constraint shape expression is a proof tree since it has no subgoals.\nran ruleInverseTripleConstraint ⊂ ProofTree\nA rule tree whose root node contains a some-of shape expression is a proof tree if and only if its child rule tree correspond to the distinguished shape expression at index i and it is a proof tree.\n∀RuleSomeOf ; tree : RuleTree • ruleSomeOf (θRuleSomeOf , tree) ∈ ProofTree ⇔\nbaseNeigh(tree) = Neigh ∧ baseExpr(tree) = Exprs(i) ∧ tree ∈ ProofTree\nA rule tree whose root node contains a one-of shape expression is a proof tree if and only if its child rule tree correspond to the distinguished shape expression at index i and it is a proof tree.\n∀RuleOneOf ; tree : RuleTree • ruleOneOf (θRuleOneOf , tree) ∈ ProofTree ⇔\nbaseNeigh(tree) = Neigh ∧ baseExpr(tree) = Exprs(i) ∧ tree ∈ ProofTree\nA rule tree whose root node contains a group shape expression is a proof tree if and only if its sequence of child rule trees correspond to its sequence of component neighbourhood and shape expressions and each child rule tree is a proof tree.\n∀RuleGroup; trees : seq1 RuleTree • ruleGroup(θRuleGroup, trees) ∈ ProofTree ⇔\n#Exprs = #trees ∧ (∀ i : dom trees •\nbaseNeigh(trees(i)) = Neighs(i) ∧ baseExpr(trees(i)) = Exprs(i) ∧ trees(i) ∈ ProofTree)\nA rule tree whose root node contains a repetition shape expression is a proof tree if and only if its sequence of child rule trees correspond to its sequence of component neighbourhoods and each child rule tree is a proof tree.\n∀RuleRepeat ; trees : seq1 RuleTree • ruleRepeat(θRuleRepeat , trees) ∈ ProofTree ⇔\n#Neighs = #trees ∧ (∀ i : dom trees •\nbaseNeigh(trees(i)) = Neighs(i) ∧ baseExpr(trees(i)) = Expr1 ∧ trees(i) ∈ ProofTree)\nWe have the following relation between proof trees and the satisfies relation.\n⊢ satisfies = { tree : ProofTree • baseNeigh(tree) 7→ baseExpr(tree) }"
    }, {
      "heading" : "5.5 Reduced Schema for rule-one-of",
      "text" : "As mentioned above, inference rules and proof trees treat rule-one-of exactly the same as rule-some-of. The difference between these rules appears when considering valid typings, which are described in detail later.\nLet t be a valid typing of graph G under schema S . Let n be a node in G and let T be a shape label in t(n). Let Expr = expr(T , S ) be the shape expression for T . Let tree be a proof tree that the neighbourhood of n satisfies Expr . Let r be a node of the proof tree that contains an application of rule-one-of and let i be the index of the component expression used in the application of the rule. The intention of the one-of shape expression is that the triples match exactly one of the component expressions. Therefore, if the matched shape expression is removed from the one-of expression then there must not be any valid typings of G under the reduced schema Sri .\nNote that a one-of shape expression may have one or more components. The number of components is denoted by k in the inference rule. However, if it contains exactly one component then there no further semantic conditions\nthat must hold and there is no corresponding reduced schema. Therefore, the definition of the reduced schema only applies to the case where the number of components is greater than one, i.e. k > 1.\nRule trees are ordered trees. A child tree can be specified by giving its index among all the children. The maximum index of a child depends on the type of rule. For leaf trees, the maximum child index is 0.\nmaxChild : RuleTree\"\n∀ tree : ran ruleEmpty • maxChild(tree) = 0\n∀ tree : ran ruleTripleConstraint • maxChild(tree) = 0\n∀ tree : ran ruleInverseTripleConstraint • maxChild(tree) = 0\n∀ tree : ran ruleSomeOf • maxChild(tree) = 1\n∀ tree : ran ruleOneOf • maxChild(tree) = 1\n∀ r : RuleGroup; trees : seq1 RuleTree • maxChild(ruleGroup(r , trees)) = #trees\n∀ r : RuleRepeat ; trees : seq1 RuleTree • maxChild(ruleRepeat(r , trees)) = #trees\nGiven a tree tree and a valid child index j , the child tree at the index is childAt(tree, j ).\nchildAt : RuleTree × 1 RuleTree dom childAt = { tree : RuleTree; ci : 1 | ci ≤ maxChild(tree) } ∀ r : RuleSomeOf ; tree : RuleTree • childAt(ruleSomeOf (r , tree), 1) = tree\n∀ r : RuleOneOf ; tree : RuleTree • childAt(ruleOneOf (r , tree), 1) = tree\n∀ r : RuleGroup; trees : seq1 RuleTree • let tree == ruleGroup(r , trees) •\n∀ ci : 1 . .maxChild(tree) • childAt(tree, ci) = trees(ci)\n∀ r : RuleRepeat ; trees : seq1 RuleTree • let tree == ruleRepeat(r , trees) •\n∀ ci : 1 . .maxChild(tree) • childAt(tree, ci) = trees(ci)\nThe location of a node within a rule tree can be specified by giving a sequence of positive integers that specify the index of each child tree. The root of the tree is specified by the empty sequence. Such a sequence of integers is referred\nto as a rule path. Given a rule tree tree, the set of all of its rule paths is rulePaths(tree).\nrulePaths : RuleTree\" (seq 1) ∀ tree : RuleTree | maxChild(tree) = 0 • rulePaths(tree) = {〈〉}\n∀ tree : RuleTree | maxChild(tree) > 0 • rulePaths(tree) =⋃\n{ ci : 1 . .maxChild(tree) • { path : rulePaths(childAt(tree, ci)) • 〈ci〉 path } }\nGiven a rule tree tree and a rule path path, the tree node specified by the path is treeAt(tree, path),\ntreeAt : RuleTree × seq 1 RuleTree dom treeAt = { tree : RuleTree; path : seq 1 | path ∈ rulePaths(tree) } ∀ tree : RuleTree • treeAt(tree, 〈〉) = tree\n∀ tree : RuleTree; ci : 1; path : seq 1 | 〈ci〉 path ∈ rulePaths(tree) •\ntreeAt(tree, 〈ci〉 path) = treeAt(childAt(tree, ci), path)\nGiven a one-of shape expression Expr that has more than one component, and an index i of one component, elimExpr(Expr , i) is the reduced expression in which component i is eliminated.\nElimExpr Expr ,Expr ′ : ShapeExpr Exprs ,ExprsL,ExprsR : seq1 ShapeExpr i :\nExpr = oneOf (Exprs)\n#Exprs > 1\ni ∈ domExprs\nExprs = ExprsL 〈Exprs(i)〉 ExprsR Expr ′ = oneOf (ExprsL ExprsR)\nelimExpr : ShapeExpr × ShapeExpr\nelimExpr = {ElimExpr • (Expr , i) 7→ Expr ′ }\nGiven a proof tree tree with the shape expression Expr as its base, and a path path to some application r of rule-one-of in tree in which the rule-of expression has more than one component,\nRuleOneOfApplication tree : ProofTree path : seq 1 r , rChild : ProofTree R : RuleOneOf\npath ∈ rulePaths(tree)\nr = treeAt(tree, path) = ruleOneOf (R, rChild)\n#R.Exprs > 1\n• The path is a valid rule path in the proof tree.\n• The tree at the path is an application of rule-one-of.\n• There are more than one components in the one-of shape expression.\nreduceExpr(tree, path) is the reduced base shape expression with the corresponding one-of expression in Expr replaced by the reduced one-of expression.\nreduceExpr : ProofTree × seq 1 ShapeExpr dom reduceExpr = {RuleOneOfApplication • (tree, path) }\n∀RuleOneOfApplication | path = 〈〉 ∧ tree = r •\nreduceExpr(r , 〈〉) = elimExpr(R.Expr ,R.i)\n• The domain of this function requires that the path be a valid rule path in the proof tree.\n• In the case of an empty path, the tree must be a one-of tree and the branch taken is eliminated.\n• When the path is not empty, this function is defined recursively by additional constraints which follow. There are four possible cases in which the proof tree has children. These cases correspond to applications of rulesome-of, rule-one-of, rule-group, and rule-repeat. Each case is defined by a schema below.\nReduceSomeOf RuleOneOfApplication RuleSomeOf child : ProofTree tail : seq 1 ExprsL,ExprsR : seqShapeExpr Expr ′ : ShapeExpr\ntree = ruleSomeOf (θRuleSomeOf , child)\npath = 〈1〉 tail\nExprs = ExprsL 〈Exprs(i)〉 ExprsR\nExpr ′ = someOf (ExprsL 〈reduceExpr(child , tail)〉 ExprsL)\n∀ReduceSomeOf • reduceExpr(tree, path) = Expr ′\nReduceOneOf RuleOneOfApplication RuleOneOf child : ProofTree tail : seq 1 ExprsL,ExprsR : seqShapeExpr Expr ′ : ShapeExpr\ntree = ruleOneOf (θRuleOneOf , child)\npath = 〈1〉 tail\nExprs = ExprsL 〈Exprs(i)〉 ExprsR\nExpr ′ = oneOf (ExprsL 〈reduceExpr(child , tail)〉 ExprsL)\n∀ReduceOneOf • reduceExpr(tree, path) = Expr ′\nReduceGroup RuleOneOfApplication RuleGroup children : seq1 ProofTree ci : 1 tail : seq 1 ExprsL,ExprsR : seqShapeExpr Expr ′ : ShapeExpr\ntree = ruleGroup(θRuleGroup, children)\npath = 〈ci〉 tail\nExprs = ExprsL 〈Exprs(ci)〉 ExprsR Expr ′ = group(ExprsL 〈reduceExpr(children(ci), tail)〉 ExprsL)\n∀ReduceGroup • reduceExpr(tree, path) = Expr ′\nReduceRepeat RuleOneOfApplication RuleRepeat children : seq1 ProofTree ci : 1 tail : seq 1 Expr ′ : ShapeExpr\ntree = ruleRepeat(θRuleRepeat , children)\npath = 〈ci〉 tail Expr ′ = repetition(reduceExpr(children(ci), tail), c)\n∀ReduceRepeat • reduceExpr(tree, path) = Expr ′\n• Something looks wrong here because if a repetition expression has a one-of expression as a child then there is no way to associate the reduced one-of expression with just the path taken in the proof tree since all the children of a repetition expression share the same shape expression. However, a rule-repeat node in the proof tree has many children and there is no requirement that all children would use the same branch of the one-of expression. To make progress, I’ll assume that all children of the repeat will eliminate the same branch of the one-of. I will report this to the mailing list later, along with the observation that the reduction should only one done when a one-of expression has more than one component."
    }, {
      "heading" : "5.6 Witness Mappings",
      "text" : "Given a set of labelled triples Neigh, a shape expression Expr and a proof tree tree that proves Neigh satisfies Expr , each labelled triple triple appears in a unique leaf node of the proof tree whose rule matches triple with a directed triple constraint dtc. This association of triple with dtc is called a witness mapping, wm(triple) = dtc.\n5.7 WitnessMapping\nWitnessMapping == LabelledTriple DirectedTripleConstraint\n5.7.1 witness\nwitness : ProofTree\"WitnessMapping\n∀ r : RuleEmpty • let tree == ruleEmpty(r) •\nwitness(tree) =\n∀ r : RuleTripleConstraint ; dtc : DirectedTripleConstraint ; c : Cardinality | r .Expr = triple(dtc, c) •\nlet tree == ruleTripleConstraint(r) • witness(tree) = baseNeigh(tree) × {dtc}\n∀ r : RuleInverseTripleConstraint ; dtc : DirectedTripleConstraint ; c : Cardinality | r .Expr = triple(dtc, c) •\nlet tree == ruleInverseTripleConstraint(r) • witness(tree) = baseNeigh(tree) × {dtc}\n∀ r : RuleSomeOf ; subtree : ProofTree • let tree == ruleSomeOf (r , subtree) •\ntree ∈ ProofTree ⇒ witness(tree) = witness(subtree)\n∀ r : RuleOneOf ; subtree : ProofTree • let tree == ruleOneOf (r , subtree) •\ntree ∈ ProofTree ⇒ witness(tree) = witness(subtree)\n∀ r : RuleGroup; subtrees : seq1 ProofTree • let tree == ruleGroup(r , subtrees) •\ntree ∈ ProofTree ⇒ witness(tree) = ⋃ { subtree : ran subtrees • witness(subtree) }\n∀ r : RuleRepeat ; subtrees : seq1 ProofTree • let tree == ruleRepeat(r , subtrees) •\ntree ∈ ProofTree ⇒ witness(tree) = ⋃ { subtree : ran subtrees • witness(subtree) }\n5.8 outNeigh\nThe outgoing neighbourhood of a node n in an RDF graph G is the set of outgoing labelled triples that correspond to triples in G with subject n.\noutNeigh : Graph × TERM \" LabelledTriple\n∀G : Graph; n : TERM • outNeigh(G, n) = { p, o : TERM | (n, p, o) ∈ G • out(n, p, o) }\n5.9 incNeigh\nThe ingoing neighbourhood of a node n in an RDF graph G is the set of ingoing labelled triples that correspond to triples in G with object n.\nincNeigh : Graph × TERM \" LabelledTriple\n∀G : Graph; n : TERM • incNeigh(G, n) = { p, s : TERM | (s , p, n) ∈ G • inc(n, p, s) }\n5.10 Typing\nGiven a schema S and a graph G, a typing t is a map that associates to each node n of G a, possibly empty, set t(n) of shape labels and negated shape labels such that if T is a negated shape label then either T or !T is in t(n). Here I infer that T and !T are mutually exclusive.\nA typing map associates a finite, possibly empty, set of shape verdicts to nodes.\nTyping == TERM ShapeVerdict\nTypingMap G : Graph S : SchemaWD t : Typing\ndom t = nodes(G)\n∀n : nodes(G); T : ShapeLabel | assert(T ) ∈ t(n) • T ∈ shapes(S )\n∀n : nodes(G); T : ShapeLabel | negate(T ) ∈ t(n) • T ∈ negshapes(S )\n∀n : nodes(G); T : negshapes(S ) • assert(T ) ∈ t(n) ∨ negate(T ) ∈ t(n)\n∀n : nodes(G); T : shapes(S ) • assert(T ) /∈ t(n) ∨ negate(T ) /∈ t(n)\n• The typing associates a set of shape verdicts to each node in the graph.\n• If a node is required to satisfy T then T must be a shape label of the schema.\n• If a node is required to violate T then T must be a negated shape label of the schema.\n• If T is a negated shape label of the schema then each node must be required to either satisfy or violate it.\n• No node must be required to both satisfy and violate the same shape.\ntypings : Graph × SchemaWD\" Typing\n∀G : Graph; S : SchemaWD • typings(G, S ) = {m : TypingMap | m.G = G ∧ m.S = S • m.t }\n5.11 TypingSatisfies\nGiven a typing t , a node u, and a shape constraint C , the typing satisfies the constraint at the node if the boolean conditions implied by the shape constraint hold.\nTypingSatisfies TypingMap u : TERM C : ShapeConstr Ts : seq1 ShapeLabel u ∈ nodes(G)\nC = and(Ts) ⇒ (∀T : ranTs • assert(T ) ∈ t(u))\nC = or(Ts) ⇒ (∃T : ranTs • assert(T ) ∈ t(u))\nC = nand(Ts) ⇒ (∃T : ranTs • negate(T ) ∈ t(u))\nC = nor(Ts) ⇒ (∀T : ranTs • negate(T ) ∈ t(u))\n• The node is in the graph.\n• The node is required to satisfy every shape in an and shape constraint.\n• The node is required to satisfy some shape in an or shape constraint.\n• The node is required to violate some shape in a nand shape constraint.\n• The node is required to violate every shape in a nor shape constraint.\ntypingSatisfies : Typing × TERM # ShapeConstr\ntypingSatisfies = {TypingSatisfies • (t , u) 7→ C }\n5.12 Matching\nGiven a node n in graph G, a typing t , and a directed triple constraint X , let Matching(G, n, t ,X ) be the set of triples in the graph with focus node n that match X under t .\nMatchingTriples TypingMap n, p : TERM X : DirectedTripleConstraint C : Constraint triples : LabelledTriple\nC ∈ ValueConstr ∧ X = (nop(p),C ) ⇒ triples = { u : TERM | (n, p, u) ∈ G ∧\nu ∈ allowed(C ) • out(n, p, u) }\nC ∈ ShapeConstr ∧ X = (nop(p),C ) ⇒ triples = { u : TERM | (n, p, u) ∈ G ∧\n(t , u) typingSatisfies C • out(n, p, u) }\nC ∈ ShapeConstr ∧ X = (inv(p),C ) ⇒ triples = { u : TERM | (u, p, n) ∈ G ∧\n(t , u) typingSatisfies C • inc(u, p, n) }\n• An outgoing triple matches a value constraint if its object is an allowed value.\n• An outgoing triple matches a shape constraint if the typing of its object satisfies the constraint.\n• An incoming triple matches a shape constraint if the typing of its subject satisfies the constraint.\nMatching : Graph × TERM × Typing ×DirectedTripleConstraint\" LabelledTriple\nMatching = {MatchingTriples • (G, n, t ,X ) 7→ triples }\n5.13 validTypings\nThe definition of what it means for a graph to satisfy a shape schema is given in terms of the existence of a valid typing. Given a graph G and a schema S , a valid typing of G by S is a typing that satisfies certain additional conditions at each node n in G.\nvalidTypings : Graph × SchemaWD\" Typing\n∀G : Graph; S : SchemaWD • validTypings(G, S ) ⊆ typings(G, S )\n5.13.1 ValidTypingNodeLabel\nThe definition of a valid typing is given in terms of a series of conditions that must hold at each node and for each shape verdict at that node. It is convenient to introduce the following base schema for conditions.\nValidTypingNodeLabel TypingMap n : TERM T : ShapeLabel ruleT : Rule defT : ShapeDefinition Expr : ShapeExpr Xs : DirectedTripleConstraint\nt ∈ validTypings(G, S )\nn ∈ nodes(G)\nassert(T ) ∈ t(n) ∨ negate(T ) ∈ t(n)\nruleT = rule(T , S ) defT = shapeDef (ruleT )\nExpr = expr(T , S ) Xs = tripleConstraints(Expr)\n5.13.2 tripleConstraints\nGiven a shape expression Expr let tripleConstraints(Expr) be the set of all triple or inverse triple constraints contained in it.\ntripleConstraints : ShapeExpr \" DirectedTripleConstraint\ntripleConstraints(emptyshape) =\n∀ dtc : DirectedTripleConstraint ; c : Cardinality • tripleConstraints(triple(dtc, c)) = {dtc}\n∀Exprs : seq1 ShapeExpr • tripleConstraints(someOf (Exprs)) = tripleConstraints(oneOf (Exprs)) = tripleConstraints(group(Exprs)) =⋃\n{Expr : ranExprs • tripleConstraints(Expr) }\n∀Expr : ShapeExpr ; c : Cardinality • tripleConstraints(repetition(Expr , c)) = tripleConstraints(Expr)\n5.13.3 NegatedShapeLabel\nThe semantics draft states:\nfor all negated shape label !T, if !T ∈ t(n), then t1 is not a valid typing, where t1 is the typing that agrees with t everywhere, except for T ∈ t1(n)\nNegatedShapeLabel ValidTypingNodeLabel\nnegate(T ) ∈ t(n)\n• The shape T is negated at node n.\n5.13.4 AssertShape\nAssertShape NegatedShapeLabel t1 : Typing\nt1 = t ⊕ {n 7→ (t(n) \\ {negate(T )} ∪ {assert(T )})}\n• The typing t1 is the same as t except that at node n the shape label T is asserted instead of negated.\nIn a valid typing if any node has a negated shape, then the related typing with this shape asserted is invalid.\n∀AssertShape • t1 /∈ validTypings(G, S )\nAlthough this condition on t(n) is recursive in terms of the definition of validTypings , it is well-founded since t1(n) has one fewer negated shapes than t(n). Therefore it remains to define the meaning of validTypings for typings that contain no negated shapes.\n5.13.5 assertShape\nGiven a typing t , node n, and shape label T such that negate(T ) ∈ t(n), define assertShape(t , n,T ) to be the typing t1 that is the same as t except that assert(T ) ∈ t1(n).\nassertShape : Typing × TERM × ShapeLabel Typing\nassertShape = {AssertShape •\n(t , n,T ) 7→ t1 }\n5.13.6 AssertedShapeLabel\nThe semantics draft defines the meaning of valid typings t by imposing several conditions that must hold for all nodes n and all asserted shape labels assert(T ) ∈ t(n).\nAssertedShapeLabel ValidTypingNodeLabel\nassert(T ) ∈ t(n)\n• The shape label T is asserted at node n.\nThe semantics draft states that the following conditions must hold for all valid typings t and all nodes n such that T is asserted at n:\nfor all shape label T , if T ∈ t(n), then there exist three mutually disjoint sets Matching,OpenProp,Rest such that\n1. out(G, n) ∪ inc(G, n) = Matching ∪OpenProp ∪Rest , and 2. Rest = Restout ∪Restinc , where\n• Restout = {(out , n, p, u) ∈ out(G, n) | p /∈ properties(expr(T , S ))}, and • Restinc = {(inc, u, p, n) ∈ inc(G, n) | p /∈ invproperties(expr(T , S ))}, and\n3. Matching is the union of the sets Matching(n, t ,X ) for all triple constraint or inverse triple constraint X that appears in expr(T , S ), and 4. if T is a closed shape, then Restout = and OpenProp = 5. if T is an open shape, then OpenProp ⊆ {(out , n, p, u) ∈ out(G, n) | p ∈ incl(T , S )} 6. there exists a proof tree with corresponding witness mapping wm for the fact that Matching satisfies expr(T , S ), and s.t.\n• for all outgoing triple (out , n, p, u), it holds (out , n, p, u) ∈ Matching(n, t ,wm((out , n, p, u))), and moreover if wm((out , n, p, u)) is a shape triple constraint, then there is no value triple constraint p::C in expr(T , S )s .t .(out , n, p, u) ∈ Matching(n, t , p :: C ), and • for all incoming triple (inc, u, p, n) ∈ G, it holds (inc, u, p, n) ∈ Matching(n, t ,wm((inc, u, p, n))), and • for all node r that corresponds to an application of ruleone-of in the proof tree, there does not exist a valid typing t1 of G by Sri s.t. T ∈ t1(n), and\n7. for all extension condition (lang, cond), associated with the type T , flang (G, n, cond) returns true or undefined.\n5.13.7 MatchingOpenRest\nfor all shape label T , if T ∈ t(n), then there exist three mutually disjoint sets Matching,OpenProp,Rest\nMatchingOpenRest AssertedShapeLabel MatchingNeigh,OpenProp,Rest : LabelledTriple\ndisjoint 〈MatchingNeigh,OpenProp,Rest〉\n• There are three mutually disjoint sets of labelled triples.\n• Note that the name MatchingNeigh is used to avoid conflict with the previously defined Matching function.\n∀AssertedShapeLabel • ∃MatchingNeigh,OpenProp,Rest : LabelledTriple •\nMatchingOpenRest\n5.13.8 PartitionNeigh\nout(G, n) ∪ inc(G, n) = Matching ∪OpenProp ∪ Rest\nPartitionNeigh MatchingOpenRest\n〈MatchingNeigh,OpenProp,Rest〉 partition outNeigh(G, n) ∪ incNeigh(G, n)\n∀AssertedShapeLabel • ∃MatchingNeigh,OpenProp,Rest : LabelledTriple •\nPartitionNeigh\n5.13.9 RestDef\nRest = Restout ∪ Restinc, where\n• Restout = {(out , n, p, u) ∈ out(G, n) | p /∈ properties(expr(T , S ))}, and • Restinc = {(inc, u, p, n) ∈ inc(G, n) | p /∈ invproperties(expr(T , S ))}, and\nRestDef MatchingOpenRest Rest out ,Rest inc : LabelledTriple\nRest = Rest out ∪Rest inc\nRest out = { p, u : TERM |\nout(n, p, u) ∈ outNeigh(G, n) ∧ p /∈ properties(expr(T , S )) •\nout(n, p, u) }\nRest inc = { p, u : TERM |\ninc(u, p, n) ∈ incNeigh(G, n) ∧ p /∈ invproperties(expr(T , S )) •\ninc(u, p, n) }\n∀MatchingOpenRest • ∃ 1 Rest out ,Rest inc : LabelledTriple • RestDef\n5.13.10 MatchingDef\nMatching is the union of the sets Matching(n, t ,X ) for all triple constraint or inverse triple constraint X that appears in expr(T , S )\nMatchingDef MatchingOpenRest\nMatchingNeigh =⋃ {X : Xs • Matching(G, n, t ,X ) }\n∀MatchingOpenRest • MatchingDef\n5.13.11 ClosedShapes\nif T is a closed shape, then Restout = and OpenProp =\nClosedShapes RestDef\ndefT ∈ ran close ⇒ Rest out = ∧ OpenProp =\n∀RestDef • ClosedShapes\n5.13.12 OpenShapes\nif T is an open shape, then\nOpenProp ⊆ {(out , n, p, u) ∈ out(G, n) | p ∈ incl(T , S )}\nOpenShapes MatchingOpenRest\ndefT ∈ ran open ⇒ OpenProp ⊆\n{ p, u : TERM | out(n, p, u) ∈ outNeigh(G, n) ∧ p ∈ incl(T , S ) •\nout(n, p, u) }\n∀MatchingOpenRest • OpenShapes\n5.13.13 ProofWitness\nthere exists a proof tree with corresponding witness mapping wm for the fact that Matching satisfies expr(T , S ), and s.t.\n• for all outgoing triple (out , n, p, u), it holds (out , n, p, u) ∈ Matching(n, t ,wm((out , n, p, u))), and moreover if wm((out , n, p, u)) is a shape triple constraint, then there is no value triple constraint p::C in expr(T , S )s .t .(out , n, p, u) ∈ Matching(n, t , p :: C ), and • for all incoming triple (inc, u, p, n) ∈ G, it holds (inc, u, p, n) ∈ Matching(n, t ,wm((inc, u, p, n))), and\n• for all node r that corresponds to an application of rule-one-of in the proof tree, there does not exist a valid typing t1 of G by Sri s.t. T ∈ t1(n), and\nProofWitness MatchingDef tree : ProofTree wm : WitnessMapping\nbaseNeigh(tree) = MatchingNeigh baseExpr(tree) = Expr\nwm = witness(tree)\n∀MatchingDef • ∃ tree : ProofTree; wm : WitnessMapping •\nProofWitness\n5.13.14 OutgoingTriples\nfor all outgoing triple (out , n, p, u), it holds\n(out , n, p, u) ∈ Matching(n, t ,wm((out , n, p, u))),\nand moreover if wm((out , n, p, u)) is a shape triple constraint, then there is no value triple constraint p::C in expr(T , S ) s.t.\n(out , n, p, u) ∈ Matching(n, t , p :: C )\nOutgoingTriples ProofWitness\n∀ triple : outNeigh(G, n); p, u : TERM | triple = out(n, p, u) •\nlet X == wm(triple) • triple ∈ Matching(G, n, t ,X ) ∧ (constrDTC (X ) ∈ ShapeConstr ⇒\n¬ (∃C : ValueConstr | (nop(p),C ) ∈ Xs • triple ∈ Matching(G, n, t , (nop(p),C ))))\n∀ProofWitness • OutgoingTriples\n5.13.15 IncomingTriples\nfor all incoming triple (inc, u, p, n) ∈ G, it holds\n(inc, u, p, n) ∈ Matching(n, t ,wm((inc, u, p, n)))\nIncomingTriples ProofWitness\n∀ triple : incNeigh(G, n) • let X == wm(triple) •\ntriple ∈ Matching(G, n, t ,X )\n∀ProofWitness • IncomingTriples\n5.13.16 OneOfNodes\nfor all node r that corresponds to an application of rule-one-of in the proof tree, there does not exist a valid typing t1 of G by Sri s.t. T ∈ t1(n)\nLet OneOfNodes describe the situation where we are given a graph G, a schema S , a typing t of G under S , a node n in G, a shape label T in t(n), a proof tree tree for the triples MatchNeigh and the expression Expr = expr(T , S ) and an application of rule-one-of r in the proof tree.\nOneOfNodes ProofWitness RuleOneOfApplication Expr ri : ShapeExpr S ri : SchemaWD\nExpr ri = reduceExpr(tree, path)\nS ri = replaceShape(S ,T ,Expr ri)\nWhenever rule-one-of is applied in the proof tree, there must not be any valid typings t1 for the reduced schema S ri in which the selected component of the one-of shape expression is eliminated.\n∀OneOfNodes • ¬ (∃ t1 : validTypings(G, S ri) •\nassert(T ) ∈ t1(n))\n5.13.17 ExtensionConditions\nfor all extension condition (lang, cond), associated with the type T , flang (G, n, cond) returns true or undefined\nThe semantics of an extension condition is given by a language oracle function that evaluates the extension condition cond on a pointed graph (G, n) and returns a code indicating whether the pointed graph satisfies the extension condition, or if an error condition holds, or if the extension condition is undefined.\nf : ExtLangName ×Graph × TERM × ExtDefinition\"ReturnCode\n∀G : Graph; n : TERM | (G, n) ∈ PointedGraph • ∀ lang : ExtLangName; cond : ExtDefinition •\nlet returnCode == f (lang,G, n, cond) • returnCode = trueRC ⇒ (G, n) /∈ violatedBy(lang, cond) ∧ returnCode = falseRC ⇒ (G, n) ∈ violatedBy(lang, cond)\n• If the oracle returns true then the pointed graph satisfies the extension condition.\n• If the oracle returns false then the pointed graph violates the extension condition.\nLet the return codes for the language oracles be ReturnCode.\nReturnCode ::= trueRC | falseRC | errorRC | undefinedRC\n• true means the extension condition is satisfied.\n• false means the extension condition is violated.\n• error means an error occurred.\n• undefined means the extension condition is undefined.\nExtensionConditions MatchingOpenRest lang : ExtLangName cond : ExtDefinition\nlet ecs == extConds(ruleT ) • (lang, cond) ∈ ran ecs\n• (lang, cond) is an extension condition for T .\n∀ExtensionConditions • f (lang,G, n, cond) ∈ {trueRC , undefinedRC}"
    }, {
      "heading" : "6 Issues",
      "text" : "Some areas of the semantics draft have multiple interpretations or appear to be wrong and therefore require further clarification. These areas are discussed below.\n6.1 dep-subgraph(T,S)\nIn the definition of dep-subgraph(T,S), is the shape T considered to be reachable from itself?\n6.2 negshapes(S)\nIn the definition of negshapes(S), the third bullet states:\nthere is a shape label T1 and a shape triple constraint p::C, or an inverse shape triple constraints ^p::C in expr(T1, S), and T appears in C.\nThis statement looks wrong because it omits mention of negation. If there is no negation involved, why would T be in negshapes(S)?\nDoes this definition only select directed triple constraints that have cardinality [1,1] because that is the default? If not then negshapes(S) is the set of all labels that are referenced in any shape definition (refs(S )), which seems wrong."
    }, {
      "heading" : "6.3 Triple matches constraint",
      "text" : "The definition of matching p:C and ^p:C omits consideration of C. The explanation is as follows.\nThe following definition introduces the notion of satisfiability of a shape constraint by a set of triples. Such satisfiability is going to be used for checking that the neighborhood of a node satisfies locally the constraints defined by a shape expression, without taking into account whether the shapes required by the triple constraints and inverse triple constraints are satisfied.\nThis statement implies that only shape constraints should be ignored here. However, the definition ignores the value set constraints too. This looks wrong.\n6.4 rule-triple-constraint\nAdd the condition that all the outgoing triples must be distinct.\n6.5 rule-inverse-triple-constraint\nAdd the condition that all the incoming triples must be distinct.\n6.6 rule-group\nAdd the condition that i and j must be different.\n6.7 rule-repeat\nAdd the condition that i and j must be different.\n6.8 Reduced Schema for rule-one-of\nThis is an edge case. It only makes sense to reduce the schema if there are more than one components. Applying rule-one-of to a sequence of one shape is equivalent to requiring that shape. Add this condition to the definition.\n6.9 Reduced Schema for rule-one-of under a repetition\nexpression\nSomething looks wrong here because if a repetition expression has a one-of expression as a child then there is no way to associate the reduced one-of expression with just the path taken in the proof tree since all the children of a repetition expression share the same shape expression. However, a rule-repeat node in the proof tree has many children and there is no requirement that all children would use the same branch of the one-of expression."
    }, {
      "heading" : "7 Conclusion",
      "text" : "The exercise of formalizing the semantics draft has resulted in a considerable expansion in the size of the document. The result has been the identification of a number of quality issues. This exercise has also established that the recursive definitions in the semantics draft are well-founded. However, it is not clear that these definitions produce results that agree with our intuition, or that they can be computed efficiently.\nOne possible way to further validate the semantics draft is to translate it into an executable formal specification system such as Coq [1] and test it on a set of examples, including both typical documents and corner cases."
    } ],
    "references" : [ {
      "title" : "RDF Data Shapes",
      "author" : [ "A. Le Hors" ],
      "venue" : "Working Group. wiki page, World Wide Web Consortium,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "agryman/z-core-shacl-semantics. source code repository, GitHub",
      "author" : [ "A. Ryman" ],
      "venue" : "https://github.com/agryman/z-core-shacl-semantics",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Recursion in RDF Data Shape Languages. Article",
      "author" : [ "A. Ryman" ],
      "venue" : "World Wide Web Consortium,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2015
    }, {
      "title" : "The Z Notation: a reference manual",
      "author" : [ "M. Spivey" ],
      "venue" : "https://spivey.oriel.ox.ac.uk/mike/zrm/index.html",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2001
    }, {
      "title" : "The fuzz type-checker for Z. web",
      "author" : [ "M. Spivey" ],
      "venue" : "page, Oxford University,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "The W3C RDF Data Shapes Working Group [3] is developing SHACL, a new language for describing constraints on RDF graphs.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 3,
      "context" : "This document provides a formal translation of the semantics draft into Z Notation [6].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 4,
      "context" : "The LTEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 1,
      "context" : "The LTEX source for this article has been type-checked using the fuzz type-checker [7] and is available in the GitHub repository [4] agryman/z-core-shacl-semantics.",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 2,
      "context" : "We reuse some formal definitions given in [5], modifying the identifiers to match those used in the semantics draft.",
      "startOffset" : 42,
      "endOffset" : 45
    } ],
    "year" : 2015,
    "abstractText" : "This article provides a formalization of the W3C Draft Core SHACL Semantics specification using Z notation. This formalization exercise has identified a number of quality issues in the draft. It has also established that the recursive definitions in the draft are well-founded. Further formal validation of the draft will require the use of an executable specification technology.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}