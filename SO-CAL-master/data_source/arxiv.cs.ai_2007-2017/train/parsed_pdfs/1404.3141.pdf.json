{
  "name" : "1404.3141.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Datalog Rewritability of Disjunctive Datalog Programs and its Applications to Ontology Reasoning",
    "authors" : [ "Mark Kaminski", "Yavor Nenov", "Bernardo Cuenca Grau" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction Disjunctive datalog, which extends plain datalog by allowing disjunction in the head of rules, is a prominent KR formalism that has found many applications in the areas of deductive databases, information integration and ontological reasoning (Eiter, Gottlob, and Mannila 1997; Dantsin et al. 2001).1 Disjunctive datalog is a powerful language, which can model incomplete information. Expressiveness comes, however, at the expense of computational cost: fact entailment is co-NEXPTIME-complete in combined complexity and co-NP-complete w.r.t. data (Eiter, Gottlob, and Mannila 1997). Thus, even with the development of optimised implementations (Leone et al. 2006), robust behaviour of reasoners in data-intensive applications cannot be guaranteed.\nPlain datalog offers more favourable computational properties (EXPTIME-completeness in combined complexity and PTIME-completeness w.r.t. data) at the expense of a loss in expressive power (Dantsin et al. 2001). Tractability in data complexity is an appealing property for data-intensive KR; in particular, the RL profile of the ontology language OWL 2 was designed such that each ontology corresponds to a datalog program (Motik et al. 2009). Furthermore, datalog programs obtained from RL ontologies contain rules of a restricted shape, and they can be evaluated in polynomial time also in combined complexity, thus providing the ground\n1 Disjunctive datalog typically allows for negation-as-failure, which we don’t consider since we focus on monotonic reasoning.\nfor robust implementations. The standardisation of OWL 2 RL has spurred the development of reasoning engines within industry and academia, such as OWLim (Bishop et al. 2011), Oracle’s Semantic Data Store (Wu et al. 2008), and RDFox (Motik et al. 2014).\nWe study the problem of rewriting a disjunctive datalog program into an equivalent datalog program (i.e., one that entails the same facts for every dataset). By computing such rewritings, we can ensure tractability w.r.t. data and exploit reasoning infrastructure available for datalog. Not every disjunctive datalog program is, however, datalog rewritable (Afrati, Cosmadakis, and Yannakakis 1995).\nOur first contribution is a novel characterisation of datalog rewritability based on linearity: a restriction that requires each rule to contain at most one body atom with an IDB predicate (i.e., a predicate occurring in head position). For plain datalog, linearity is known to limit the effect of recursion and lead to reduced data and combined complexity (Dantsin et al. 2001). For disjunctive programs the effects of the linearity restriction are, to the best of our knowledge, unknown. In Section 3, we show that every linear disjunctive program can be polynomially transformed into an equivalent datalog program; conversely, we also provide a polynomial transformation from datalog into linear disjunctive datalog. Thus, linear disjunctive datalog and datalog have the same computational properties, and linearisability of disjunctive programs is equivalent to rewritability into datalog.\nMotivated by our characterisation, in Section 4 we propose weakly linear disjunctive datalog: a rule language that extends both datalog and linear disjunctive datalog. In a weakly linear (WL for short) program, the linearity requirement is relaxed: instead of applying to all IDB predicates, it applies only to those that “depend” on a disjunctive rule. Analogously to linear disjunctive programs, WL programs can be polynomially rewritten into datalog. Thus, our language captures disjunctive information while leaving the favourable computational properties of datalog intact.\nIn Section 5, we propose a linearisation procedure based on unfolding transformations. Our procedure picks a nonWL rule and a “culprit” body atom and replaces it with WL rules by “unfolding” the selected atom. Our procedure is incomplete: if it succeeds, it outputs a WL program, which is rewritten into datalog; if it fails, no conclusion can be drawn.\nIn Section 6, we focus on ontology reasoning. We pro-\nar X\niv :1\n40 4.\n31 41\nv1 [\ncs .A\nI] 1\n1 A\npr 2\n01 4\npose an extension of OWL 2 RL with disjunctive axioms such that each ontology in our extended profile maps to a WL program. We show that the resulting programs can be evaluated in polynomial time in combined complexity; thus, fact entailment in our language is no harder than in OWL 2 RL. Finally, we argue that the algorithm in (Hustadt, Motik, and Sattler 2007) can be combined with our techniques to rewrite a SHIQ ontology into a plain datalog program.\nWe have evaluated our techniques on a large ontology repository. Our results show that many non-Horn ontologies can be rewritten into WL programs, and thus into datalog. We have tested the scalability of query answering using our approach, with promising results. Proofs of our technical results are delegated to the appendix.\n2 Preliminaries We use standard first-order syntax and semantics and assume all formulae to be function-free. We assume that equality ≈ is an ordinary predicate and that every set of set of formulae contains the standard explicit axiomatisation of ≈ as a congruence relation for its signature.\nA fact is a ground atom and a dataset is a finite set of facts. A rule r is a sentence of the form ∀~x∀~z.[ϕ(~x, ~z)→ ψ(~x)], where tuples of variables ~x and ~z are disjoint, ϕ(~x, ~z) is a conjunction of distinct equality-free atoms, and ψ(~x) is a disjunction of distinct atoms. Formula ϕ is the body of r, and ψ is the head. Quantifiers in rules are omitted. We assume that rules are safe, i.e., all variables in the head occur in the body. A rule is datalog if ψ(~x) has at most one atom, and it is disjunctive otherwise. A program P is a finite set of rules; it is datalog if it consists only of datalog rules, and disjunctive otherwise. We assume that rules in P do not share variables.\nFor convenience, we treat > and⊥ in a non-standard way as a unary and a nullary predicate, respectively. Given a program P , P> is the program with a rule Q(x1, . . . , xn) → >(xi) for each predicate Q in P and each 1 ≤ i ≤ n, and a rule → >(a) for each constant a in P . We assume that P> ⊆ P and > does not occur in head position in P \\ P>. We define P⊥ as consisting of a rule with ⊥ as body and empty head. We assume P⊥ ⊆ P and no rule in P \\ P⊥ has an empty head or ⊥ in the body. Thus, P ∪ D |= >(a) for every a in P ∪D, and P ∪D is unsatisfiable iff P ∪D |= ⊥.\nHead predicates in P \\ P> are intensional (or IDB) in P . All other predicates (including >) are extensional (EDB). An atom is intensional (extensional) if so is its predicate. A rule is linear if it has at most one IDB body atom. A program P is linear if all its rules are. In contrast to KR, in logic programming it is often assumed that IDB predicates do not occur in datasets. This assumption can be lifted (see, e.g., (Bry et al. 2007)): for every P and IDB predicate Q in P , let Q′ be a fresh predicate; the IDB expansion Pe of P is obtained from P by renaming each IDB predicate Q in P with Q′ and adding a rule Q(~x) → Q′(~x), with ~x distinct variables. Then, for each D and each fact α over the signature of P we have P ∪D |= α iff Pe ∪D |= αθ, where θ is the predicate substitution mapping each IDB predicate Q to Q′.\nThe evaluation ofP over a datasetD is the set Eval(P,D) which comprises ⊥ if P ∪ D is unsatisfiable and all facts entailed by P ∪ D otherwise. For a set of predicates S,\nEval(P,D)|S consists of those facts in Eval(P,D) involving predicates in S ∪ {⊥}. Program P ′ is a rewriting of P w.r.t. a set of predicates S if there is an injective predicate renaming θ such that (Eval(P,D)|S)θ = Eval(P ′,D)|Sθ for every dataset D over the signature of P . The program P ′ is a rewriting of P if P ′ is a rewriting of P w.r.t. the set of all predicates in P . Clearly, Pe is a rewriting of P .\n3 Characterisation of Datalog Rewritability In this section, we establish a strong correspondence between linear disjunctive datalog and plain datalog. We show that every linear disjunctive program can be polynomially rewritten into datalog and, conversely, every datalog program is polynomially rewritable to a linear disjunctive program. Consequently, we not only can conclude that fact entailment over linear programs has exactly the same data and combined complexity as over plain datalog programs, but also that a disjunctive program is datalog rewritable if and only if it is linearisable. Thus, datalog rewritability and linearisability of disjunctive programs are equivalent problems.\nFrom Linear Programs to Datalog We first show that linear disjunctive programs can be polynomially rewritten into datalog. Let us consider the following program P1, which we want to rewrite into a datalog program Ξ(P1):\nP1 = {V (x)→ B(x) ∨G(x) (1) G(y) ∧ E(x, y)→ B(x) (2) B(y) ∧ E(x, y)→ G(x) } (3)\nPredicates V and E are EDB, so their extension depends solely on D. To prove facts about IDB predicates G and B we introduce fresh binary predicates BG, BB , GB , and GG. Intuitively, if a fact BG(c, d) holds in Ξ(P1) ∪ D then proving B(c) suffices for proving G(d) in P1 ∪ D. To “initialise” the extension of these fresh predicates we need rules >(x) → XX(x, x) with X ∈ {G,B}. The key step is then to “flip” the direction of all rules in P1 involving G or B by moving all IDB atoms from the head to the body and viceversa while at the same time replacing their predicates with the relevant auxiliary predicates. Thus, Rule (2) leads to the following rules in Ξ(P1) for each IDB predicate X:\nBX(x, z) ∧ E(x, y)→ GX(y, z) These rules are natural consequences of Rule (2) under the intended meaning of the auxiliary predicates: if we can prove a goal X(z) by proving first B(x), and E(x, y) holds, then by Rule (2) we deduce that proving G(y) suffices to prove X(z). In contrast to (2), Rule (1) contains no IDB body atoms. We “flip” this rule as follows, with X IDB:\nV (x) ∧BX(x, z) ∧GX(x, z)→ X(z) Similarly to the previous case, this rule follows from Rule (1): if V (x) holds and we can establish that X(z) can be proved from B(x) and also from G(x), then X(z) must hold. Finally, we introduce rules that allow us to derive facts about the IDB predicates G and B from facts derived about the auxiliary predicates. For example, the rule B(x) ∧ BX(x, z) → X(z) states that if B(x) holds and is sufficient to prove X(z), then X(z) must also hold.\nDefinition 1. Let P be a linear program and let Σ be the set of IDB predicates in P \\ P>. For each (P,Q) ∈ Σ2, let PQ be a fresh predicate unique to (P,Q) where arity(PQ) = arity(P )+arity(Q). Then Ξ(P) is the datalog program containing the rules given next, where ϕ is the conjunction of all EDB atoms in a rule, ϕ> is the least conjunction of>-atoms needed to make a rule safe, all predicates Pi are in Σ, and ~y, ~z are disjoint vectors of distinct fresh variables: 1. a rule ϕ> → RR(~y, ~y) for every R ∈ Σ; 2. a rule ϕ>∧ϕ∧ ∧n i=1 P R i (~si, ~y)→ QR(~t, ~y) for every rule\nϕ ∧Q(~t)→ ∨n i=1 Pi(~si) ∈ P \\ P> and every R ∈ Σ;\n3. a rule ϕ ∧ ∧n i=1 P R i (~si, ~y) → R(~y) for every rule ϕ →∨n i=1 Pi(~si) ∈ P \\ P> and every R ∈ Σ; 4. a rule Q(~z)∧QR(~z, ~y)→R(~y) for every (Q,R)∈Σ2.\nThis transformation is quadratic and the arity of predicates is at most doubled. For P1, we obtain the following datalog program, where each rule mentioning X stands for one rule where X = B and one where X = G:\nΞ(P1) = {V (x) ∧BX(x, z) ∧GX(x, z)→ X(z) (1’) BX(x, z) ∧ E(x, y)→ GX(y, z) (2’) GX(x, z) ∧ E(x, y)→ BX(y, z) (3’) >(x)→ XX(x, x) (4) B(x) ∧BX(x, z)→ X(z) (5) G(x) ∧GX(x, z)→ X(z) } (6)\nCorrectness of Ξ is established by the following theorem. Theorem 2. If P is linear, then Ξ(P) is a polynomial datalog rewriting of P .\nThus, fact entailment over linear programs is no harder than in datalog: PTIME w.r.t. data and EXPTIME in combined complexity. Formally, Theorem 2 is shown by induction on hyperresolution derivations of facts entailed by the rules in P from a given dataset D (see Appendix). We next sketch the intuitions on P1 and D1 = {V (a), V (b), V (c), E(a, b), E(b, c), E(a, c)}.\nFigure 1, Part (a) shows a linear (hyperresolution) derivation ρ1 of B(a) from P1∪D1 while Part (b) shows a derivation ρ2 of the same fact from Ξ(P1) ∪ D1. We represent derivations as trees whose nodes are labeled with disjunctions of facts and where every inner node is derived from its children using a rule of the program (initialisation rules in ρ2 are omitted for brevity). We first show that if B(a) is provable in P1 ∪ D1, then it is entailed by Ξ(P1) ∪ D1. From the premise, a linear derivation such as ρ1 exists. The crux of the proof is to show that each disjunction of facts in ρ1 corresponds to a set of facts over the auxiliary predicates entailed by Ξ(P1)∪D1. Furthermore, these facts must be of the form XB(u, a), where B(a) is the goal, u is a constant, and X ∈ {B,G}. For example, B(c) ∨ G(c) in ρ1 corresponds to facts BB(c, a) and GB(c, a), which are provable from Ξ(P1) ∪ D1, as witnessed by ρ2. Since ρ1 is linear, it has a unique rule application that has only EDB atoms as premises, i.e., the application of (1), which generatesB(c)∨G(c). SinceBB(c, a) andGB(c, a) are provable from Ξ(P1) ∪ D1, we can apply (1’) to derive B(a).\nFinally, we show the converse: if B(a) is provable from Ξ(P1) ∪D1 then it follows from P1 ∪D1. For this, we take a derivation such as ρ2, and show that each fact in ρ2 about an auxiliary predicate carries the intended meaning, e.g., for GB(b, a) we must have P1 ∪ D1 |= G(b)→ B(a). From Datalog to Linear Programs The transformation from datalog to linear disjunctive datalog is based on the same ideas, but it is simpler in that we no longer distinguish between EDB and IDB atoms: a rule in P is now “flipped” by moving all its atoms from the head to the body and viceversa. Moreover, we make use of the IDB expansion Pe of P to ensure linearity of the resulting disjunctive program. Definition 3. Let P be a datalog program. For each pair (P,Q) of predicates in P , let PQ be a fresh predicate unique to (P,Q) where arity(PQ) = arity(P ) + arity(Q). Furthermore, let Pe be the IDB expansion of P . Then, Ψ(P) is the linear disjunctive program containing, for each IDB predicate R in Pe the rules given next, where ϕ> is the least conjunction of >-atoms making a rule safe and ~y = y1 . . . yarity(R) is a vector of distinct fresh variables:\n1. a rule ϕ> ∧ QR(~t, ~y) → ∨n i=1 P\nR i (~si, ~y) for every rule∧n\ni=1 Pi(~si) → Q(~t) ∈ Pe \\ Pe>, where Q(~t) 6= ⊥ and∨n i=1 P R i (~si, ~y) is interpreted as ⊥ if n = 0;\n2. a rule ϕ> → ∨n i=1 P R i (~si, ~y) for every ∧n i=1 Pi(~si) →\n⊥ ∈ Pe \\ Pe>; 3. a rule ϕ> → RR(~y, ~y); 4. a rule Q(~z)∧QR(~z, ~y)→ R(~y) for every EDB predicate Q inPe, where ~z is a vector of distinct fresh variables. Again, the transformation is quadratic and the arity of\npredicates is at most doubled. Example 4. Consider P2, which encodes path system accessibility (a canonical PTIME-complete problem):\nP2 = {R(x, y, z) ∧A(y) ∧A(z)→ A(x) } (7) Linear datalog is NLOGSPACE, and cannot capture P2. However, we can rewrite P2 into linear disjunctive datalog:\nΨ(P2) = {>(y) ∧ >(z) ∧A′ A′ (x, u) (7’)\n→ RA ′ (x, y, z, u) ∨A′A\n′ (y, u) ∨A′A ′ (z, u)\nA′ A′ (x, y)→ AA ′ (x, y) (8)\n>(x)→ A′A ′ (x, x) (9)\nA(x) ∧AA ′ (x, y)→ A′(y) (10)\nR(x, y, z) ∧RA ′ (x, y, z, u)→ A′(u) } (11)\nRule (7) yields Rule (7’) in Ψ(P2). Rule (8) is obtained from A(x) → A′(x) ∈ Pe. To see why we need the IDB expansion Pe, suppose we replaced Pe by P in Definition 3. Rule (8) would not be produced and A′ would be replaced by A elsewhere. Then the rule A(x) ∧ AA(x, y) → A(y) would not be linear since both A and AA would be IDB.\nCorrectness of Ψ is established by the following theorem. Theorem 5. If P is datalog, then Ψ(P) is a polynomial rewriting of P into a linear disjunctive program.\nFrom Theorems 2 and 5 we obtain the following results. Corollary 6. A disjunctive program P is datalog rewritable iff it is rewritable into a linear disjunctive program. Corollary 7. Checking P ∪D |= α for P a linear program, D a dataset and α a fact is PTIME-complete w.r.t. data complexity and EXPTIME-complete w.r.t. combined complexity.\n4 Weakly Linear Disjunctive Datalog In this section, we introduce weakly linear programs: a new class of disjunctive datalog programs that extends both datalog and linear disjunctive datalog. The main idea is simple: instead of requiring the body of each rule to contain at most one occurrence of an IDB predicate, we require at most one occurrence of a disjunctive predicate—a predicate whose extension for some dataset could depend on the application of a disjunctive rule. This intuition is formalised as given next. Definition 8. The dependency graph GP = (V,E, µ) of a program P is the smallest edge-labeled digraph such that:\n1. V contains every predicate occurring in P; 2. r ∈ µ(P,Q) whenever P,Q ∈ V , r ∈ P \\ P>, P occurs\nin the body of r, and Q occurs in the head of r; and 3. (P,Q) ∈ E whenever µ(P,Q) is nonempty. A predicate Q depends on a rule r ∈ P if GP has a path that ends in Q and involves an r-labeled edge. Predicate Q is datalog if it only depends on datalog rules; otherwise, Q is disjunctive. Program P is weakly linear (WL for short) if every rule in P has at most one occurrence of a disjunctive predicate in the body.\nChecking whether P is WL is clearly feasible in polynomial time. If P is datalog, then all its predicates are datalog and P is WL. Furthermore, every disjunctive predicate is IDB and hence every linear program is also WL. There are, however, WL programs that are neither datalog nor linear. Consider P3, which extends P1 with the following rule:\nE(y, x)→ E(x, y) (12) SinceE is IDB inP3, Rules (2) and (3) have two IDB atoms. Thus, P3 is not linear. The graph GP3 looks as follows.\nB\n> V E ⊥\nG\n(1)\n(1)\n(2)\n(3)\n(3)(2) (12)\nPredicate V is EDB and hence does not depend on any rule. Predicates B and G depend on Rule (1) and hence are disjunctive. Finally, predicateE depends only on Rule (12) and hence it is a datalog predicate. Thus, P3 is WL. Definition 9. For P WL, let Ξ′(P) be defined as Ξ(P) in Definition 1 but where: (i) Σ is the set of all disjunctive predicates in P\\P>; (ii) ϕ denotes the conjunction of all datalog atoms in a rule; and (iii) in addition to rules (1)–(4), Ξ′(P) contains every rule in P with no disjunctive predicates.\nBy adapting the proof of Theorem 2 we obtain: Theorem 10. If P is WL, then Ξ′(P) is a polynomial datalog rewriting of P .\nThus, fact entailment over WL programs has the same data and combined complexity as for datalog. Furthermore, Ξ′(P) is a rewriting of P and hence it preserves the extension of all predicates. If, however, we want to query a specific predicate Q, we can compute a smaller program, which is linear in the size of P and preserves the extension of Q. Indeed, if Q is datalog, each proof in P of a fact about Q involves only datalog rules, and if Q is disjunctive, each such proof involves only auxiliary predicates XQ. Thus, in Ξ′ we can dispense with all rules involving auxiliary predicates XR for R 6= Q. In particular, if Q is datalog, the rewriting contains no auxiliary predicates. Theorem 11. Let P be WL, S a set of predicates in P , and P ′ obtained from Ξ′(P) by removing all rules with a predicate XR for R 6∈ S. Then P ′ is a rewriting of P w.r.t. S.\n5 Rewriting Programs via Unfolding Although WL programs can be rewritten into datalog, not all datalog rewritable programs are WL. Let P4 be as follows:\nP4 = {A(x) ∧B(x)→ C(x) ∨D(x) (13) E(x)→ A(x) ∨ F (x) (14) C(x) ∧R(x, y)→ B(y) } (15)\nProgram P4 is not WL since both body atoms in (13) are disjunctive. However, P4 is datalog rewritable.\nWe now present a rewriting procedure that combines our results in Section 4 with the work of Gergatsoulis (1997) on program transformation for disjunctive logic programs. Our procedure iteratively eliminates non-WL rules by “unfolding” the culprit atoms w.r.t. the other rules in the program. It stops when the program becomes WL, and outputs a datalog program as in Section 4. The procedure is sound: if it\nProcedure 1 Rewrite Input: P: a disjunctive program Output: a datalog rewriting of P 1: P ′ := Pe 2: while P ′ not WL do 3: select r∈P ′ with more than one disjunctive body atom 4: select a disjunctive body atom α ∈ r 5: P ′ := Unfold(P ′, r, α) 6: return Ξ′(P ′)\nsucceeds, the output is a datalog rewriting. It is, however, both incomplete (linearisability cannot be semi-decided just by unfolding) and non-terminating. Nevertheless, our experiments suggest that unfolding can be effective in practice since some programs obtained from realistic ontologies can be rewritten into datalog after a few unfolding steps.\nUnfolding We start by recapitulating (Gergatsoulis 1997). Given a disjunctive program P , a rule r in P , and a body atom α of r, Gergatsoulis defines the unfolding of r at α in P as a transformation of P that replaces r with a set of resolvents of r with rules in P at α (see Appendix). We denote the resulting program by Unfold(P, r, α). Unfolding preserves all entailed disjunctions ϕ of facts: P |= ϕ iff Unfold(P, r, α) |= ϕ for all P , r, α, and ϕ. However, to ensure that unfolding produces a rewriting we need a stronger correctness result that is dataset independent. Theorem 12. Let P0 be a disjunctive program and let P be a rewriting of P0 such that no IDB predicate in P occurs in P0. Let r be a rule in P and α be an IDB body atom of r. Then Unfold(P, r, α) is a rewriting of P0. Moreover, no IDB predicate in Unfold(P, r, α) occurs in P0. The Rewriting Procedure Procedure 1 attempts to eliminate rules with several disjunctive body atoms by unfolding one such atom. Note that to satisfy the premise of Theorem 12, unfolding is applied to Pe rather than P . Correctness of Procedure 1 is established by the following theorem. Theorem 13. Let P be a disjunctive program. If Rewrite terminates on P with output P ′, then P ′ is a rewriting of P . Rewrite first transforms our example program P4 to P ′4 = {A′(x) ∧B′(x)→ C ′(x) ∨D′(x) (16)\nE(x)→ A′(x) ∨ F ′(x) (17) C ′(x) ∧R(x, y)→ B′(y) } ∪ Paux (18)\nwhere Paux = {P (x) → P ′(x) | P ∈ {A,B,C,D, F} } and A′, B′, C ′, D′, F ′ are fresh. Rule (16) is not WL in P ′4, and needs to be unfolded. We choose to unfold (16) on A′(x). Thus, in Step 5, Rule (16) is replaced by the rules\nA(x) ∧B′(x)→ C ′(x) ∨D′(x) (19) E(x) ∧B′(x)→ C ′(x) ∨D′(x) ∨ F ′(x) (20)\nThe resulting P ′′4 is WL, and Rewrite returns Ξ′(P ′′4 ).\n6 Application to OWL Ontologies The RL profile is a fragment of OWL 2 for which reasoning is tractable and practically realisable by means of rule-based\ntechnologies. RL is also a fragment of datalog: each RL ontology can be normalised to a datalog program.\nWe next show how to extend RL with disjunctions while retaining tractability of consistency checking and fact entailment in combined complexity. We first recapitulate the kinds of normalised axioms that can occur in an RL ontology. We assume familiarity with Description Logic (DL) notation.\nA (normalised) RL ontology is a finite set of DL axioms of the form 1-10 in Table 1. The table also provides the translation of DL axioms into rules. We define RLt as the extension of RL with axioms capturing disjunctive knowledge.\nDefinition 14. An RLt ontology is a finite set of DL axioms of the form 1-11 in Table 1.\nFact entailment in RLt is co-NP-hard since RLt can encode non-3-colourability. Membership in co-NP holds since rules have bounded number of variables, and hence programs can be grounded in polynomial time (see Appendix). Tractability can be regained if we restrict ourselves to RLt ontologies corresponding to WL programs. WL programs P obtained from RLt ontologies have bounded number of variables, and thus variables in Ξ′(P) are also bounded. Theorem 15. CheckingO∪D |= α, for O an RLt ontology that corresponds to a WL program, is PTIME-complete.\nThus, fact entailment in RLt is no harder than in RL, and one can use scalable engines such as RDFox. Our experiments indicate that many ontologies captured by RLt are either WL or can be made WL via unfolding, which makes data reasoning over such ontologies feasible.2\nDealing with Expressive Ontology Languages Hustadt, Motik, and Sattler (2007) developed an algorithm for transforming SHIQ ontologies into an equivalent disjunctive datalog program. Cuenca Grau et al. (2013) combined this algorithm with a knowledge compilation procedure (called Compile-Horn) obtaining a sound but incomplete and nonterminating datalog rewriting procedure for SHIQ. Our procedure Rewrite provides an alternative to Compile-Horn\n2For CQ answering, our language becomes co-NP-hard w.r.t. data, whereas RL is tractable. This follows from (Lutz and Wolter 2012) already for a single axiom of type 11.\nfor SHIQ. The classes of ontologies rewritable by the two procedures can be shown incomparable (e.g., Compile-Horn may not terminate on WL programs).\n7 Related Work Complexity of disjunctive datalog with negation as failure has been extensively studied (Ben-Eliyahu-Zohary and Palopoli 1997; Eiter, Gottlob, and Mannila 1997). The class of head-cycle free programs was studied in Ben-EliyahuZohary and Palopoli; Ben-Eliyahu-Zohary, Palopoli, and Zemlyanker (1997; 2000), where it was shown that certain reasoning problems are tractable for such programs (fact entailment, however, remains intractable w.r.t. data).\nGottlob et al. (2012) investigated complexity of disjunctive TGDs and showed tractability (w.r.t. data complexity) of fact entailment for a class of linear disjunctive TGDs. Such rules allow for existential quantifiers in the head, but require single-atom bodies; thus, they are incomparable to WL rules. Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013).\nLutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI.\nThe procedure in (Cuenca Grau et al. 2013), mentioned in Section 6, is used by Kaminski and Cuenca Grau (2013) to show first-order/datalog rewritability of two fragments of ELU . Notably, both fragments yield linear programs. Finally, our unfolding-based rewriting procedure is motivated by the work of Afrati, Gergatsoulis, and Toni (2003) on linearisation of plain datalog programs by means of program transformation techniques (Tamaki and Sato 1984; Proietti and Pettorossi 1993; Gergatsoulis 1997).\n8 Evaluation Rewritability Experiments. We have evaluated whether realistic ontologies can be rewritten to WL (and hence to datalog) programs. We analysed 118 non-Horn ontologies from BioPortal, the Protégé library, and the corpus in (Gardiner, Tsarkov, and Horrocks 2006). To transform ontologies into disjunctive datalog we used KAON2 (Motik 2006).3 KAON2 succeeded to compute disjunctive programs for 103 ontologies. On these, Rewrite succeeded in 35 cases: 8 programs were already datalog after CNF normalisation, 12 were linear, 12 were WL, and 3 required unfolding. Rewrite was limited to 1,000 unfolding steps, but all successful cases required at most 11 steps. On average, 73% of the predicates in ontologies were datalog, and so could be queried using a datalog engine (even if the disjunctive program could not\n3We doctored the ontologies to remove constructs outside SHIQ, and hence not supported by KAON2. The modified ontologies can be found on http://csu6325.cs.ox.ac.uk/WeakLinearity/\nbe rewritten). We identified 15 RLt ontologies and obtained WL programs for 13 of them. For comparison, we implemented the procedure Compile-Horn in (Cuenca Grau et al. 2013), which succeeded on 18 ontologies, only one of which could not be rewritten by our approach. Query Answering. We tested scalability of instance query answering using datalog programs obtained by our approach. For this, we used UOBM and DBpedia, which come with large datasets. UOBM (Ma et al. 2006) is a standard benchmark for which synthetic data is available (Zhou et al. 2013). We denote the dataset for k universities by Uk. We considered the RLt subset of UOBM (which is rewritable using Rewrite but not using Compile-Horn), and generated datasets U01, U04, U07, U10. DBpedia4 is a realistic ontology with a large dataset from Wikipedia. Since DBpedia is Horn, we extended it with reasonable disjunctive axioms. We used RDFox as a datalog engine. Performance was measured against HermiT (Motik, Shearer, and Horrocks 2009) and Pellet (Sirin et al. 2007). We used a server with two Intel Xeon E5-2643 processors and 128GB RAM. Timeouts were 10min for one query and 30min for all queries; a limit of 100GB was allocated to each task. We ran RDFox on 16 threads. Systems were compared on individual queries, and on precomputing answers to all queries. All systems succeeded to answer all queries for U01: HermiT required 890s, Pellet 505s, and we 52s. Table 2 depicts average times for datalog and disjunctive predicates, and number of queries on which a system failed.5 Pellet only succeeded to answer queries on U01. HermiT’s performance was similar for datalog and disjunctive predicates. In our case, queries over the 130 datalog predicates in UOBM (88% of all predicates) were answered instantaneously (<1s); queries over disjunctive predicates were harder, since the rewritings expanded the dataset quadratically in some cases. Finally, due to its size, DBpedia’s dataset cannot even be loaded by HermiT or Pellet. Using RDFox, our rewriting precomputed the answers for all DBpedia predicates in 48s.\n9 Conclusion We have proposed a characterisation of datalog rewritability for disjunctive datalog programs, as well as tractable fragments of disjunctive datalog. Our techniques can be applied to rewrite OWL ontologies into datalog, which enables the use of scalable datalog engines for data reasoning. Furthermore, our approach is not “all or nothing”: even if an ontology cannot be rewritten, we can still answer queries over most (i.e., datalog) predicates using a datalog reasoner.\n4http://dbpedia.org/About 5Average times do not reflect queries on which a system failed.\nAcknowledgements This work was supported by the Royal Society, the EPSRC projects Score!, Exoda, and MaSI3, and the FP7 project OPTIQUE.\nReferences [Afrati, Cosmadakis, and Yannakakis 1995] Afrati, F.; Cosmadakis, S. S.; and Yannakakis, M. 1995. On datalog vs. polynomial time. J. Comput. System Sci. 51(2):177–196.\n[Afrati, Gergatsoulis, and Toni 2003] Afrati, F.; Gergatsoulis, M.; and Toni, F. 2003. Linearisability of datalog programs. Theor. Comput. Sci. 308(1-3):199– 226.\n[Artale et al. 2009] Artale, A.; Calvanese, D.; Kontchakov, R.; and Zakharyaschev, M. 2009. The DL-Lite family and relations. J. Artif. Intell. Res. 36:1–69.\n[Ben-Eliyahu-Zohary and Palopoli 1997] Ben-EliyahuZohary, R., and Palopoli, L. 1997. Reasoning with minimal models: Efficient algorithms and applications. Artif. Intell. 96(2):421–449.\n[Ben-Eliyahu-Zohary, Palopoli, and Zemlyanker 2000] Ben-Eliyahu-Zohary, R.; Palopoli, L.; and Zemlyanker, V. 2000. More on tractable disjunctive datalog. J. Log. Programming 46(1-2):61–101.\n[Bienvenu et al. 2013] Bienvenu, M.; ten Cate, B.; Lutz, C.; and Wolter, F. 2013. Ontology-based data access: A study through disjunctive datalog, CSP, and MMSNP. In PODS, 213–224. arXiv:1301.6479.\n[Bishop et al. 2011] Bishop, B.; Kiryakov, A.; Ognyanoff, D.; Peikov, I.; Tashev, Z.; and Velkov, R. 2011. OWLim: A family of scalable semantic repositories. Semantic Web J. 2(1):33–42.\n[Bourhis, Morak, and Pieris 2013] Bourhis, P.; Morak, M.; and Pieris, A. 2013. The impact of disjunction on query answering under guarded-based existential rules. In IJCAI.\n[Bry et al. 2007] Bry, F.; Eisinger, N.; Eiter, T.; Furche, T.; Gottlob, G.; Ley, C.; Linse, B.; Pichler, R.; and Wei, F. 2007. Foundations of rule-based query answering. In Reasoning Web, 1–153.\n[Cuenca Grau et al. 2013] Cuenca Grau, B.; Motik, B.; Stoilos, G.; and Horrocks, I. 2013. Computing datalog rewritings beyond Horn ontologies. In IJCAI. arXiv:1304.1402.\n[Dantsin et al. 2001] Dantsin, E.; Eiter, T.; Gottlob, G.; and Voronkov, A. 2001. Complexity and expressive power of logic programming. ACM Comput. Surv. 33(3):374–425.\n[Eiter, Gottlob, and Mannila 1997] Eiter, T.; Gottlob, G.; and Mannila, H. 1997. Disjunctive datalog. ACM Trans. Database Syst. 22(3):364–418.\n[Gardiner, Tsarkov, and Horrocks 2006] Gardiner, T.; Tsarkov, D.; and Horrocks, I. 2006. Framework for an automated comparison of description logic reasoners. In ISWC, 654–667.\n[Gergatsoulis 1997] Gergatsoulis, M. 1997. Unfold/fold transformations for disjunctive logic programs. Inf. Process. Lett. 62(1):23–29.\n[Gottlob et al. 2012] Gottlob, G.; Manna, M.; Morak, M.; and Pieris, A. 2012. On the complexity of ontological reasoning under disjunctive existential rules. In MFCS, 1–18.\n[Hustadt, Motik, and Sattler 2007] Hustadt, U.; Motik, B.; and Sattler, U. 2007. Reasoning in Description Logics by a Reduction to Disjunctive Datalog. J. Autom. Reasoning 39(3):351–384.\n[Kaminski and Cuenca Grau 2013] Kaminski, M., and Cuenca Grau, B. 2013. Sufficient conditions for first-order and datalog rewritability in ELU. In DL, 271–293.\n[Leone et al. 2006] Leone, N.; Pfeifer, G.; Faber, W.; Eiter, T.; Gottlob, G.; Perri, S.; and Scarcello, F. 2006. The DLV system for knowledge representation and reasoning. ACM Trans. Comput. Log. 7(3):499–562.\n[Lutz and Wolter 2012] Lutz, C., and Wolter, F. 2012. Nonuniform data complexity of query answering in description logics. In KR.\n[Ma et al. 2006] Ma, L.; Yang, Y.; Qiu, Z.; Xie, G. T.; Pan, Y.; and Liu, S. 2006. Towards a complete OWL ontology benchmark. In ESWC, 125–139.\n[Motik et al. 2009] Motik, B.; Cuenca Grau, B.; Horrocks, I.; Wu, Z.; Fokoue, A.; and Lutz, C. 2009. OWL 2 Web Ontology Language Profiles. W3C Recommendation.\n[Motik et al. 2014] Motik, B.; Nenov, Y.; Piro, R.; Horrocks, I.; and Olteanu, D. 2014. Parallel materialisation of datalog programs in centralised, main-memory rdf systems. In AAAI.\n[Motik, Shearer, and Horrocks 2009] Motik, B.; Shearer, R.; and Horrocks, I. 2009. Hypertableau Reasoning for Description Logics. J. Artif. Intell. Res. 36:165–228.\n[Motik 2006] Motik, B. 2006. Reasoning in Description Logics using Resolution and Deductive Databases. Ph.D. Dissertation, Univesität Karlsruhe (TH), Karlsruhe, Germany.\n[Proietti and Pettorossi 1993] Proietti, M., and Pettorossi, A. 1993. The loop absorption and the generalization strategies for the development of logic programs and partial deduction. J. Log. Programming 16(1):123–161.\n[Sirin et al. 2007] Sirin, E.; Parsia, B.; Cuenca Grau, B.; Kalyanpur, A.; and Katz, Y. 2007. Pellet: A practical OWLDL reasoner. J. Web Sem. 5(2):51–53.\n[Tamaki and Sato 1984] Tamaki, H., and Sato, T. 1984. Unfold/fold transformation of logic programs. In ICLP, 127– 138.\n[Wu et al. 2008] Wu, Z.; Eadon, G.; Das, S.; Chong, E. I.; Kolovski, V.; Annamalai, M.; and Srinivasan, J. 2008. Implementing an inference engine for RDFS/OWL constructs and user-defined rules in Oracle. In ICDE, 1239–1248.\n[Zhou et al. 2013] Zhou, Y.; Cuenca Grau, B.; Horrocks, I.; Wu, Z.; and Banerjee, J. 2013. Making the most of your triple store: query answering in OWL 2 using an RL reasoner. In WWW, 1569–1580.\nA Proofs for Section 3 Definition 16. Let r = ∧n i=1 βi → ϕ be a rule and, for each 1 ≤ i ≤ n, let ψi be a disjunction of facts ψi = χi ∨ αi with αi a single fact. Let σ be an MGU of each βi, αi. Then the following disjunction of facts ϕ′ is a hyperresolvent of r and ψ1, . . . , ψn: ϕ′ = ϕσ ∨ χ1 ∨ · · · ∨ χn.6 Definition 17. Let P be a program, let D be a dataset, and let ϕ be a disjunction of facts. A (hyperresolution) derivation of ϕ from P ∪ D is a pair ρ = (T, λ) where T is a tree, λ a labeling function mapping each node in T to a disjunction of facts, and the following properties hold for each v ∈ T :\n1. λ(v) = ϕ if v is the root; 2. λ(v) ∈ P ∪ D if v is a leaf; and 3. if v has children w1, . . . , wn, then λ(v) is a hyperresolvent of a rule r ∈ P and λ(w1), . . . , λ(wn).\nWe write P ∪ D ` ϕ to denote that ϕ has a derivation from P ∪ D. Hyperresolution is sound and complete in the following sense: If P ∪ D is unsatisfiable, then P ∪ D ` ⊥, and otherwise P ∪ D ` α iff α ∈ Eval(P,D).7\nDefinition 18. Let P be a (disjunctive) program and D be a dataset. A >-stub is a one-step derivation of a fact >(a) (for some a) from D using a rule in P>. A derivation ρ = (T, λ) from P ∪D is normal if every node whose label involves > is the root of a >-stub. Proposition 19. Let P be a disjunctive program, let D be a dataset, and let ϕ be a nonempty disjunction of facts. For every derivation of ϕ from P ∪ D there is a normal derivation of a nonempty subset of ϕ from P ∪ D or a normal derivation of ⊥ from P ∪ D.\nProof. Let ρ = (T, λ) be a derivation of ϕ from P ∪ D and let v be the root of T . We proceed by induction on the size of T . If >(a) ∈ λ(v) for some a, then a must occur in P ∪ D, and hence we can derive >(a) in one step with a rule P (x1, . . . , xn)→ >(xi) ∈ P> (if P (a1, . . . , ai−1, a, ai+1, . . . , an) ∈ D) or with the rule (→ >(a)) ∈ P> (if a occurs in P).\nIf > does not occur in λ(v), we proceed as follows. Let v1, . . . , vn be the successors of v in T (n = 0 if v is a leaf in T ), let r ∈ P be the rule used to derive λ(v) from λ(v1), . . . , λ(vn), and let σ be the substitution used in the corresponding hyperresolution step. By the inductive hypothesis, for every i ∈ [1, n] there is some ψi such that ψi is a nonempty subset of λ(vi) or ψi = ⊥ and ψi has a normal derivation from P ∪ D. W.l.o.g., let ψi 6= ⊥ for every i ∈ [1, n] (otherwise, the claim is immediate). We then distinguish two cases. If r applies to ψ1, . . . , ψn with substitution σ, then the hyperresolvent ϕ′ of r and ψ1, . . . , ψn is a nonempty subset of ϕ (ϕ′ is nonempty since the only rule inP with an empty head is (⊥ →) but, by assumption, ϕ1 6= ⊥). If r does not apply to ψ1, . . . , ψn with substitution σ, the claim follows since, for some i, we have ψi ⊆ ϕ.\nProposition 19 allows us to consider only normal derivations. In the following, without loss of generality, we assume every derivation to be normal.\nProposition 20. Let P be a disjunctive program, let D be a dataset, let ρ = (T, λ) be a derivation from P ∪ D, and let v be a node in T . If λ(v) contains an EDB atom, then λ(v) is a singleton.\nProof. The claim follows since whenever λ(v) contains an EDB atom, we either have that v is a leaf in T , and thus λ(v) ∈ D, or that v is the root of a >-stub (since ρ is implicitly assumed to be normal), and thus λ(v) = >(a) for some individual a.\nDefinition 21. A nonempty tree T ′ = (V ′, E′) is an upper portion of a tree T = (V,E) if the following conditions hold: • V ′ ⊆ V and E′ is the restriction of E to V ′. • T and T ′ have the same root. • If v is an internal node in T ′, then every child of v in T is contained in V ′. Let P be a (disjunctive) datalog program, D a dataset, and ρ = (T, λ) a derivation of a fact P (~a) from P ∪ D where P 6= >. An upper portion of ρ is a pair ρ′ = (T ′, λ′) such that:\n• T ′ is an upper portion of T ; • λ′ is the restriction of λ to the nodes in T ′; • If λ′(v) = >(b) for some v ∈ T ′ and some individual b, then v is a leaf in T ′. Theorem 2. If P is linear, then Ξ(P) is a polynomial datalog rewriting of P .\nProof. Analogous to the proof of Theorem 10 in Appendix B (but simpler).\n6We view disjunctions as sets of formulae. 7This implies that P ∪ D ` ⊥ iff Eval(P,D) = {⊥}.\nLemma 22. Let P be a datalog program, let D be a dataset, let P be an IDB predicate in Pe, and let ρ = (T, λ) be a derivation of a fact P (~a) from Pe ∪D. Given a tree T ′, let leaves(T ′) be the set of leaves of T ′ and, given a set of nodes S, let λ(S) = ⋃ {λ(t) | t ∈ S }. For every upper portion ρ′ = (T ′, λ′) of ρ we have Ψ(P) ∪ D |= ∨ Q(~b)∈λ(leaves(T ′))Q P (~b,~a).\nProof. Let ρ′ = (T ′, λ′) be an upper portion of ρ and let v be the root of T ′. In particular, we have λ(v) = P (~a). We proceed by induction on the size of T ′. If v is the only node in T ′, the claim reduces to Ψ(P) ∪ D |= PP (~a,~a). This follows since ϕ> → PP (~x, ~x) ∈ Ψ(P) and Ψ(P)> ∪ D |= ϕ>(~a).\nNow suppose T ′ contains more than one node and let leaves(T ′) = {v1, . . . , vn}. Since T ′ is a tree, it has a node w of height 1. W.l.o.g., let v1, . . . , vk (1 ≤ k ≤ n) be the children of w in T ′, let r = ∧k i=1Qi(~si)→ R(~t) ∈ Pe be the rule used to derive λ(w) from λ(s1), . . . , λ(sk), and let σ be the substitution used in the corresponding hyperresolution step. Since w is an internal node in T ′, we have R 6= >, and hence r /∈ Pe>. Then:\n1. S = {w, vk+1, . . . , vn} is the set of leaves of an upper portion of ρ that is strictly smaller than ρ′; 2. λ(w) = R(~tσ) and λ(vi) = Q(~siσ) for every i ∈ [1, k]; 3. (λ(S) \\ {R(~tσ)}) ∪ {Q1(~s1σ), . . . , Qk(~skσ)} ⊆ λ(leaves(T ′)); 4. RP (~t, ~y)→ ∨k i=1Q P i (~si, ~y) ∈ Ψ(P).\nBy (1), (2), and the inductive hypothesis, Ψ(P) ∪ D |= RP (~tσ,~a) ∨ ∨ Q(~b)∈λ({vk+1,...,vn})Q P (~b,~a). Hence by (3), it suffices\nto show Ψ(P) ∪ D |= RP (~tσ,~a)→ ∨k i=1Q P i (~siσ,~a), which follows by (4).\nLemma 23. Let P be a datalog program. For every dataset D over the signature of P and every fact α such that Pe ∪D |= α we have Ψ(P) ∪ D |= α.\nProof. LetD be a dataset and P (~a) a fact such that Pe∪D |= P (~a). W.l.o.g., let P be IDB in Pe. We show Ψ(P)∪D |= P (~a). By completeness of hyperresolution, P (~a) has a derivation ρ = (T, λ) from Pe ∪ D. Let ρ′ = (T ′, λ′) be the largest upper portion of ρ. By Lemma 22, Ψ(P) ∪ D |= ∨ Q(~b)∈λ(leaves(T ′))Q\nP (~b,~a). Therefore, it suffices to show that Ψ(P) ∪ D ∪ {QP (~b,~a)} |= P (~a) for every Q(~b) ∈ λ(leaves(T ′)). Since ρ′ is maximal, we distinguish the following three cases for Q(~b):\n• Q(~b) ∈ D. Then Q is EDB in Pe (since D only contains facts about predicates in P and every predicate in P is EDB in Pe). Hence Q(~z) ∧QP (~z, ~y)→ P (~y) ∈ Ψ(P). The claim follows.\n• Q(~b) is ground and (→ Q(~b)) ∈ Pe \\ Pe>. Hence QP (~b, ~y)→ ⊥ ∈ Ψ(P), and consequently Ψ(P) ∪D ∪ {QP (~b,~a)} |= ⊥. The claim follows.\n• Q(~b) = >(b). Then the claim follows since >(z) ∧ >P (z, ~y)→ P (~y) ∈ Ψ(P) and Ψ(P) ∪ D |= >(b).\nDefinition 24. Let P be a datalog program and let Q(~b) be a fact where Q is IDB in P . A disjunction ϕ of facts is focused on Q(~b) w.r.t. P if every disjunct α ∈ ϕ has one of the following forms: • α = P (~a) where P is EDB in P; • α = ⊥; • α = Q(~b); • α = PQ(~a,~b) for some P and ~a.\nLet ρ = (T, λ) be a derivation (not necessarily from P). We call ρ focused on Q(~b) w.r.t. P if so is the label of every node in T . Given a node v ∈ T , we define λbase(v) := {P (~a) | PQ(~a,~b) ∈ λ(v) }. Lemma 25. Let P be a datalog program and let D be a dataset over the signature of P . Every derivation from Ψ(P) ∪ D is focused on some fact α w.r.t. Pe.\nProof. Let ρ = (T, λ) be a derivation from Ψ(P) ∪ D and let v be the root of T . We show that ρ is focused on some α by induction on the size of T . If v is the only node in T , we distinguish the following cases:\n• λ(v) ∈ D. Then λ(v) = P (~a) where P is EDB in Pe, and thus ρ is focused on every IDB predicate in Pe. • arity(Q) = 0 and λ(v) is obtained by a rule of the form (→ ∨n i=1 P Q i (~si)) ∈ Ψ(P) for some IDB predicate Q in Pe. Then\nλ(v) = ∨n i=1 P Q i (~si), meaning ρ is focused on Q.\nIf v has successors v1, . . . , vm, we distinguish the following cases depending on the shape of the rule r ∈ Ψ(P) used to obtain λ(v) from λ(v1), . . . , λ(vm).\n• r ∈ Ψ(P)>. Then m = 1 and λ(v) = >(a) for some a. By the inductive hypothesis, λ(v1) is focused on a fact w.r.t. Pe. The claim follows since > is EDB in Pe.\n• r = ϕ>∧PQ(~t, ~y)→ ∨n i=1R\nQ(~si, ~y). Let σ be the substitution used in the hyperresolution step. W.l.o.g., let PQ(~tσ, ~yσ) ∈ λ(v1). Then, by Proposition 20, λ(vj) ∈ ϕ> for j ∈ [2,m]. Hence, λ(v) ⊆ λ(v1) ∪ {⊥}. The claim follows since, by the inductive hypothesis, the subderivation rooted at v1 is focused onQ(~b) (so, in particular, ~yσ = ~b), and v2, . . . , vm are focused on every IDB predicate in Pe.\n• r = (⊥ →) or r = ϕ> → ∨n i=1R Q i (~si,\n~b) for some R and ~s1, . . . , ~sn. In both cases, the argument proceeds analogously to the preceding case (but simpler).\n• r = P (~z) ∧ PQ(~z, ~y) → Q(~y). Then m = 2. Let σ be the substitution used in the hyperresolution step and, w.l.o.g., let PQ(~zσ, ~yσ) ∈ λ(v1). Then, by Proposition 20, λ(v2) = P (~zσ). Hence, λ(v) ⊆ λ(v1) ∪ {Q(~yσ)}. The claim follows since, by the inductive hypothesis, the subderivation rooted at v1 is focused on Q(~b) and λ(v2) is focused on every IDB predicate in Pe.\nSince the root of a derivation of a fact α has to be labeled with α, Lemma 25 implies the following corollary.\nCorollary 26. Let P be a datalog program, let D be a dataset over the signature of P , and let Q(~b) be a fact where Q is IDB in Pe. Every derivation of Q(~b) from Ψ(P) ∪ D is focused on Q(~b) w.r.t. Pe.\nLemma 27. Let P be a datalog program, let D be a dataset over the signature of P , and let ρ = (T, λ) be a derivation of a fact Q(~b) from Ψ(P) ∪ D, where Q is IDB in Pe. For every node v in T whose label contains an IDB atom in Ψ(P), we have Pe ∪ D |= ( ∧ α∈λbase(v) α)→ Q(~b).\nProof. We proceed by induction on the height of v in T . Let v1, . . . , vm be the successors of v in T (where m = 0 if v is a leaf in T ). If Q(~b) ∈ D, the claim is vacuous since D contains only facts about predicates in P , every predicate in P is EDB in Pe, and every EDB predicate in Pe is EDB in Ψ(P). Otherwise, we distinguish the following cases depending on the shape of the rule r ∈ Ψ(P) \\Ψ(P)> used to obtain λ(v) from λ(v1), . . . , λ(vm) (by Corollary 26, we only need to consider cases that can occur in a derivation focused on Q(~b) w.r.t. Pe): • r = ϕ> ∧ PQ(~t, ~y) → ∨n i=1R Q i (~si, ~y) such that r ′ = ∧n i=1Ri(~si) → P (~t) ∈ Pe. Let σ be the substitution used in the\ncorresponding hyperresolution step and let, w.l.o.g., PQ(~tσ, ~yσ) ∈ λ(v1). Then, by the inductive hypothesis, Pe ∪ D |= ( ∧ α∈λbase(v1) α)→ Q(~b). Moreover, (λ(v1) \\ {P Q(~tσ, ~yσ)}) ∪ ⋃n i=1R Q i (~siσ, ~yσ) ⊆ λ(v). The claim follows since, by r′,\nPe |= ( ∧ α∈λbase(v) α)→ P (~tσ).\n• r = ϕ> → ∨n i=1R Q i (~si, ~y) such that r ′ = ∧n i=1Ri(~si) → ⊥ ∈ Pe. Let σ be the substitution used in the corresponding\nhyperresolution step. Then ⋃n i=1R Q i (~siσ, ~yσ) ⊆ λ(v), and hence, by r′, Pe |= ( ∧ α∈λbase(v) α)→ ⊥. The claim follows.\n• r = ϕ> → QQ(~y, ~y). Since ρ is focused on Q(~b), we have λ(v) = QQ(~b,~b), and the claim (Pe ∪ D |= Q(~b) → Q(~b)) is immediate.\n• r = P (~z) ∧ PQ(~z, ~y) → Q(~y) for some EDB predicate P in Pe. Let σ be the substitution used in the corresponding hyperresolution step (in particular, ~yσ = ~b). Let, w.l.o.g., PQ(~zσ,~b) ∈ λ(v1) and λ(v2) = P (~zσ) (Proposition 20). Since P is EDB in Pe and hence in Ψ(P), we have P (~zσ) ∈ D. By the inductive hypothesis, Pe ∪ D |= ( ∧ α∈λbase(v1) α) → Q(~b),\nand therefore Pe ∪ D |= ( ∧ α∈λbase(v1)\\{P (~zσ)} α)→ Q(~b). The claim follows since λ(v1) \\ {P Q(~zσ,~b)} ⊆ λ(v).\nBy completeness of hyperresolution and the observation that λbase(v) = ∅ whenever λ(v) contains no facts of the form PQ(~a), we obtain the following corollary.\nCorollary 28. Let P be a datalog program. For every dataset D over the signature of P and every atom α over the signature of Pe such that Ψ(P) ∪ D |= α we have Pe ∪ D |= α. Theorem 5. If P is datalog, then Ψ(P) is a polynomial rewriting of P into a linear disjunctive program.\nProof. By construction, Ψ(P) is a linear disjunctive program of size quadratic in the size of P . Since Pe is a rewriting of P , to prove that Ψ(P) is a rewriting of P it suffices to show that Eval(Pe,D)|S = Eval(Ψ(P),D)|S for every dataset D over the signature of P and every set S of predicates in Pe. This follows by Lemma 23 and Corollary 28.\nB Proofs for Section 4 We begin by generalising Proposition 20 as follows. Proposition 29. Let P be a disjunctive program, let D be a dataset, let ρ = (T, λ) be a derivation from P ∪ D, and let v be a node in T . If λ(v) contains a datalog atom, then λ(v) is a singleton.\nProof. Straightforward induction on the height of v in ρ. The case where λ(v) contains an atom of the form >(a) follows by the implicit assumption that ρ is normal.\nProposition 30. Let P be a disjunctive program, let Q be a datalog predicate in P , and let PQ be the set of all rules in P on which Q depends. For every dataset D and vector of individuals ~a = a1 . . . aarity(Q): P ∪ D ` Q(~a) iff PQ ∪ D ` Q(~a).\nProof. The inclusion from right to left is immediate. The inclusion from left to right follows by a straightforward induction on the derivation of a fact Q(~a) from P ∪ D exploiting the implicit normality assumption.\nSince datalog predicates only depend on rules that contain no disjunctive predicates, and a WL program P coincides with Ξ′(P) on rules that contain no disjunctive predicates, we obtain (by correctness of hyperresolution): Corollary 31. Let P be a WL program and let Q be a datalog predicate in P . For every dataset D and vector of individuals ~a = a1 . . . aarity(Q): P ∪ D |= Q(~a) iff Ξ′(P) ∪ D |= Q(~a).\nLemma 32. LetP be a WL program, letD be a dataset, let P be a disjunctive predicate inP , and let ρ = (T, λ) be a derivation of a fact P (~a) from P ∪ D. Then for every node v ∈ T in an upper portion of ρ and every disjunct Q(~b) ∈ λ(v) where Q is disjunctive in P , we have Ξ′(P) ∪ D |= QP (~b,~a).\nProof. Let v ∈ T and Q(~b) ∈ λ(v) be as required. We show the claim by induction on the distance of v from the root of T . If v is the root of T , then Q(~b) = P (~a) and the claim (Ξ′(P) ∪ D |= PP (~a,~a)) follows since >(y1) ∧ · · · ∧ >(yarity(P )) → PP (~y, ~y) ∈ Ξ′(P) and Ξ′(P)> ∪ D |= >(ai) for every ai ∈ ~a.\nIf v is not the root of T , then it must have a predecessor w and siblings v1, . . . , vn (n ≥ 0) in T such that either (a) Q(~b) ∈ λ(w) or (b) λ(w) is a hyperresolvent of λ(v), λ(v1), . . . , λ(vn) and some rule Q(~s) ∧ ∧n i=1Ri(~si)→ ∨m j=1 Sj(~tj) ∈ P \\ P>, where the atom Q(~s) is resolved with λ(v) and the atoms Ri(~si) are resolved with λ(vi). If Q(~b) ∈ λ(w), the claim follows by the inductive hypothesis so, w.l.o.g., suppose we are in Case (b). Since, by assumption, Q is disjunctive and P is WL, all Ri are datalog. Hence, Ξ′(P) contains a rule r = ϕ> ∧ ( ∧m j=1 S P j (~tj , ~y)) ∧ ∧n i=1Ri(~si) → QP (~s, ~y). Let σ be the substitution used in the hyperresolution step deriving λ(w). Then ~sσ = ~b, λ(vi) = Ri(~siσ) for every i ∈ [1, n] (by Proposition 29), and∨m j=1 Sj(~tjσ) ⊆ λ(w). By the inductive hypothesis, we then have Ξ′(P)∪D |= SPj (~tjσ,~a) for every j ∈ [1,m]. Moreover, by Corollary 31, Ξ′(P)∪D |= Ri(~siσ) for every i ∈ [1, n]. Finally, we have Ξ′(P)> ∪D |= ϕ>σ. The claim follows with r.\nLemma 33. Let P be a WL program. For every dataset D and every fact α such that P ∪ D |= α we have Ξ′(P) ∪ D |= α.\nProof. Let P ∪ D |= P (~a). We show that Ξ′(P) ∪ D |= P (~a). W.l.o.g., P (~a) /∈ D (otherwise, the claim is trivial) and P is disjunctive (otherwise, the claim follows by Corollary 31). By completeness of hyperresolution, there is a derivation ρ = (T, λ) of P (~a) from P ∪ D. Since P (~a) /∈ D and P is disjunctive, there is an upper portion ρ′ of ρ and a node v in ρ′ such that:\n1. λ(v) contains a disjunctive predicate; 2. v has no successor w in T such that λ(w) contains a disjunctive predicate.\nWe distinguish two cases. If λ(v) ∈ D, then λ(v) = Q(~b) for some Q and~b. By Lemma 32, we have Ξ′(P) ∪ D |= QP (~b,~a). The claim follows since Q(~z) ∧QP (~z, ~y)→ P (~y) ∈ Ξ′(P).\nIf λ(v) /∈ D, then v has successors v1, . . . , vn (n ≥ 0) in T such that λ(v) is a hyperresolvent of λ(v1), . . . , λ(vn) and a rule in P \\ P> of the form ∧n i=1Ri(~si) → ∨m j=1 Sj(~tj), where the atoms Ri(~si) are resolved with λ(vi). Since, by assumption,\nall Ri are datalog, Ξ′(P) contains a rule r = ( ∧m j=1 S P j (~tj , ~y)) ∧ ∧n i=1Ri(~si) → P (~y). Let σ be the substitution used in the hyperresolution step deriving λ(v). By Lemma 32, we then have Ξ′(P) ∪ D |= SPj (~tjσ,~a) for every j ∈ [1,m]. By Proposition 29, we have λ(vi) = Ri(~siσ), and hence, by Corollary 31, Ξ′(P) ∪ D |= Ri(~siσ) for every i ∈ [1, n]. The claim follows with r.\nLemma 34. Let P be a WL program, let D be a dataset over the signature of P , and let ρ = (T, λ) be a derivation of a fact α from Ξ′(P) ∪ D where α is not of the form >(a). Then:\n1. For every v ∈ T , λ(v) = P (~a) where P occurs in P , or λ(v) = PQ(~a,~b) where P,Q are disjunctive in P . 2. If α = P (~a) where P occurs in P , then P ∪ D |= P (~a).\n3. If α = PQ(~a,~b), then P ∪ D |= P (~a)→ Q(~b).\nProof. We begin by showing (1). Since Ξ′(P) is datalog, λ(v) contains only one atom for every v ∈ T . The claim follows since D contains only predicates in P and the rules of Ξ′(P) can only infer facts of the form P (~a) where P occurs in P or PQ(~a,~b) where P,Q are disjunctive in P .\nWe now show (2) and (3) by simultaneous induction on the height n of T . If n = 0, we distinguish three cases:\n• α ∈ D. Then D |= α and the claim is immediate. • α = P (~a) where P is datalog in P and r = (→ P (~a)) ∈ Ξ′(P). Then r ∈ P and the claim is immediate. • α = ⊥Q, arity(Q) = 0, and (→ ⊥Q) ∈ Ξ′(P). Then, since (⊥ →) ∈ P , we have P |= ⊥ → Q for every predicate Q. • α = PP where P is disjunctive in P and arity(P ) = 0. The claim (P ∪ D |= P → P ) is immediate.\nIf n > 0, the root v of T has children v1, . . . , vn and α is a hyperresolvent of λ(v1), . . . , λ(vn) and a rule r ∈ Ξ′(P) \\Ξ′(P)>. We distinguish five cases:\n• r contains no disjunctive predicates. Then α is a datalog atom and the claim follows by Corollary 31. • r = ϕ> → PP (~y, ~y) where P is disjunctive in P . Then α = PP (~a,~a) for some ~a, and the claim (P ∪ D |= P (~a)→ P (~a))\nis immediate. • r = Q(~z) ∧ QP (~z, ~y) → P (~y). Then α = P (~a) for some ~a. By the Corollary 31, we have P ∪ D |= Q(~b), and by the\ninductive hypothesis, P ∪ D |= Q(~b)→ P (~a) for some~b. Hence P ∪ D |= P (~a). • r = ϕ> ∧ ϕ ∧ ∧n i=1R\nQ i (~si, ~y) → PQ(~t, ~y) where ϕ is the conjunction of all datalog atoms in r and r′ = ϕ ∧ P (~t) →∨n\ni=1Ri(~si) ∈ P . Then α = PQ(~a,~b) for some ~a and ~b. By Corollary 31, for every i ∈ [1, n] there is some ~ci such that P ∪D |= ϕ|~a~b~c1...~cn~t~y~s1...~sn , and by the inductive hypothesis, P ∪D |= Ri(~ci)→ Q( ~b). With r′, we obtain P ∪D |= P (~a)→ Q(~b).\n• r = ϕ ∧ ∧n i=1R P i (~si, ~y) → P (~y) where ϕ is the conjunction of all datalog atoms in r and r′ = ϕ → ∨n i=1Ri(~si) ∈ P .\nThen α = P (~a) for some ~a. By Corollary 31, for every i ∈ [1, n] there is some ~bi such that P ∪ D |= ϕ|~a ~b1...~bn ~y~s1...~sn , and by the inductive hypothesis, P ∪ D |= Ri(~bi)→ P (~a). With r′, we obtain P ∪ D |= P (~a).\nBy completeness of hyperresolution (and Corollary 31 for facts of the form >(a)), Lemma 34(2) implies: Corollary 35. Let P be a WL program. For every dataset D and atom α over the signature of P such that Ξ′(P) ∪ D |= α we have P ∪ D |= α. Theorem 10. If P is WL, then Ξ′(P) is a polynomial datalog rewriting of P .\nProof. By construction, Ξ′(P) is a datalog program of size quadratic in the size of P . Correctness of the transformation (i.e., Ξ′(P) being a rewriting of P) follows with Lemma 33 and Corollary 35.\nTheorem 11. Let P be WL, S a set of predicates in P , and P ′ obtained from Ξ′(P) by removing all rules with a predicate XR for R 6∈ S. Then P ′ is a rewriting of P w.r.t. S.\nProof. Follows analogously to Theorem 10 with minor adaptations of the relevant lemmas.\nC Proofs for Section 5 Definition 36. Let r = α ∧ ϕr → ψr and s = ϕs → β ∨ ψs be rules such that atom α is unifiable with β with MGU θ. The elementary unfolding ElemUnfold(r, α, s, β) of r at α using s at β is the pair ((ϕr ∧ ϕs → ψr ∨ ψs)θ, θ).\nAn elementary unfolding step thus amounts to resolving the relevant rules over the given predicates. Unfolding is then a transformation that allows us to replace a rule in a program with a sequence of elementary unfoldings in such a way that equivalence is preserved.\nDefinition 37. Let P be a disjunctive program, let r ∈ P and let α be a body atom in r; then, the unfolding of r at α in P , denoted Unfold(P, r, α), is the result of applying Procedure 2 to P , r, and α.\nProposition 38. Let P be a disjunctive program, r a rule in P , and α a body atom of r. Then P |= Unfold(P, r, α).\nProof. The claim follows by soundness of resolution since every clause in Unfold(P, r, α) \\ P is obtained by resolution from clauses in P .\nLemma 39. Let P be a disjunctive program, let r = ∧n i=1 αi → ψ (n ≥ 1) be a rule in P where α1 is IDB in P , let D be a dataset containing no occurrences of IDB predicates in P , and let σ be a ground substitution. If Unfold(P, r, α1) ∪ D |= αiσ∨χαi for every i ∈ [1, n] (where each χαi is a ground disjunction of facts), then Unfold(P, r, α1)∪D |= ψσ∨χα1∨· · ·∨χαn .\nProcedure 2 Unfold Input: P: a disjunctive program; r: a rule; α: a body atom of r Output: the unfolding of r at α by P 1: S0 := { (s, β) | s ∈ P, β a head atom in s unifiable with α } 2: i := 0 3: repeat 4: Si+1 := ∅ 5: for each (s, β) ∈ Si do 6: (s′, θ) := ElemUnfold(r, α, s, β) 7: Si+1 := Si+1 ∪ { (s′, β′θ) | (s, β′) ∈ Si, β 6= β′ } 8: i := i+ 1 9: until Si 6= ∅ 10: return (P \\ {r}) ∪ { s | (s, β) ∈ Sj , for 1 ≤ j < i }\nProof. For every i ∈ [1, n], let Unfold(P, r, α1) ∪ D |= αiσ ∨ χαi . Let ρ = (T, λ) be a derivation of α1σ ∨ χ′α1 from Unfold(P, r, α1) ∪ D for some χ′α1 ⊆ χα1 (existence of ρ follows by completeness of hyperresolution). Let s be the rule used to derive the label of the root v of ρ (i.e., α1σ ∨ χ′α1 ) from the labels of its children v1, . . . , vm (s must exist since α1 is an IDB predicate and hence, by assumption, α1 /∈ D), and let τ be substitution used in the corresponding hyperresolution step. Then s = ∧m j=1 βj → α′1 ∨ · · · ∨ α′l ∨ ψα′ such that λ(vj) = βjτ ∨ χβj for every j ∈ [1,m], α1σ = α′1τ = · · · = α′lτ and χ′α1 = ψα′τ ∨ χβ1 ∨ · · · ∨ χβm . Let r1 be the rule obtained by elementary unfolding of r at α1 using s at α ′ 1, and let rk\n(2 ≤ k ≤ l) be the rule obtained by elementary unfolding of r at α1 using rk−1 at α′k. Then ( ∧m j=1 βjτ) ∧ ( ∧n i=2 αiσ) is a substitution instance of the body of rl and ψα′τ ∨ ψσ is the corresponding instance of the head of rl. Hence, the claim follows from the assumption (Unfold(P, r, α1)∪D |= αiσ∨χαi for every i ∈ [2, n]) and soundness of hyperresolution (which implies Unfold(P, r, α1) ∪D |= βjτ ∨ χβj for every j ∈ [1,m]) with rl: we obtain Unfold(P, r, α1) ∪D |= ψα′τ ∨ ψσ ∨ χβ1 ∨ · · · ∨ χβm ∨ χα2 ∨ · · · ∨ χαn = ψσ ∨ χ′α1 ∨ χα2 ∨ · · · ∨ χαn ⊆ ψσ ∨ χα1 ∨ · · · ∨ χαn .\nLemma 40. LetP be a disjunctive program, letD be a dataset containing no occurrences of IDB predicates inP , let r be a rule inP , and let α be an IDB body atom of r. For every disjunction of facts ϕ such thatP∪D ` ϕwe have Unfold(P, r, α)∪D |= ϕ.\nProof. Let ρ = (T, λ) be a derivation of ϕ from P ∪ D and let v be the root of T . We proceed by induction on the size of T . If λ(v) ∈ D, the claim is immediate. Otherwise, let v1, . . . , vn be the successors of v in T (n = 0 if v is a leaf in T ). By the inductive hypothesis, we have Unfold(P, r, α) ∪ D |= λ(vi) for every i ∈ [1, n]. We distinguish two cases, depending on the rule s ∈ P used to derive λ(v) from λ(v1), . . . , λ(vn). If s 6= r, we have s ∈ Unfold(P, r, α), and the claim follows with s. If s = r, the claim follows by Lemma 39.\nTheorem 12. Let P0 be a disjunctive program and let P be a rewriting of P0 such that no IDB predicate in P occurs in P0. Let r be a rule in P and α be an IDB body atom of r. Then Unfold(P, r, α) is a rewriting of P0. Moreover, no IDB predicate in Unfold(P, r, α) occurs in P0.\nProof. Since P is a rewriting of P0, for the first claim it suffices to show Eval(P,D) = Eval(Unfold(P, r, α),D) for datasetsD over the signature of P0. This follows by Proposition 38 and Lemma 40 since P0 contains no occurrences of IDB predicates in P , and hence neither do datasets over the signature of P0. The second claim is immediate since all rules in Unfold(P, r, α) \\ P are obtained by resolution from those in P , and the set of IDB predicates in a program is closed under resolution.\nD Proofs for Section 6 Proposition 41. Checking O ∪D |= α for O an RLt ontology, D a dataset, and α a fact is co-NP-complete.\nProof. Membership in co-NP follows from the fact that both the rules in Table 1 and the rules axiomatising equality and > contain a bounded number of variables and atoms; hence, the corresponding programs can be grounded in polynomial time and entailment in the resulting propositional program can be checked in co-NP. For hardness, it suffices to provide a straightforward encoding of non-3-colorability. The following DL ontology O can be normalised into an RLt ontology\nV v R tG tB B u ∃edge.B v ⊥ B uG v ⊥ G u ∃edge.G v ⊥ G uR v ⊥ R u ∃edge.R v ⊥ B uR v ⊥\nGiven an undirected graph G = (V,E), the dataset DG contains a fact V (a) for each node a ∈ V and facts edge(a, b) and edge(b, a) for each edge connecting a and b in E. Then, G is non-3-colorable iff O ∪DG is unsatisfiable.\nTheorem 15. Checking O ∪D |= α, for O an RLt ontology that corresponds to a WL program, is PTIME-complete.\nProof. Hardness follows directly from the fact that the problem is already PTIME-hard if O is an OWL 2 RL ontology; thus, we focus on proving membership in PTIME. By Theorem 2 we have that O ∪ D |= α iff Ξ(O) ∪ D |= αθ for some injective predicate renaming θ. Thus, it suffices to show that the evaluation of Ξ(O) over D can be computed in polynomial time in the size of O and D. First, Ξ(O) is of size at most quadratic in the size of O, and the arity of a predicate in Ξ(O) is at most double the arity of a predicate in O. As we can see in Table 1, the rules corresponding to Axioms 1-11 contain a bounded number of variables and atoms in the body, and hence the number of variables in the body of each rule and the arity of predicates in Ξ(O) is bounded as well, as required.\nLet us fix an arbitrary SHIQ ontologyO, and let ΩO be obtained fromO by first removing all axioms of the form 5 and then adding the relevant axioms to preserve fact entailment as described in (Cuenca Grau et al. 2013). Furthermore, let us denote with RO the subset of all axioms in O of the form 5, 4, and 8. Finally, let DD(ΩO) be the result of applying the algorithm in (Hustadt, Motik, and Sattler 2007) to ΩO. The following lemma summarises the results in (Hustadt, Motik, and Sattler 2007; Cuenca Grau et al. 2013) that are relevant to us. Lemma 42. The following properties hold:\n1. ΩO is a model conservative extension of O. 2. ΩO |= DD(ΩO). 3. For each dataset D and each fact α the following holds:\nO ∪D |= α iff ΩO ∪ Eval(RO,D) |= α (21) ΩO ∪ D |= α iff DD(ΩO) ∪ D |= α (22)\nThen, the following theorem states that the program obtained from ΩO by applying the algorithm in (Hustadt, Motik, and Sattler 2007) and then adding the rules inRO entails the same facts as O w.r.t. all datasets. Theorem 43. O ∪D |= α iff DD(ΩO) ∪RO ∪ D |= α, for every dataset D and fact α about individuals in D.\nProof. Assume that O ∪ D |= α. By Lemma 42, Condition (21) we have ΩO ∪ Eval(RO,D) |= α. Since Eval(RO,D) is a dataset, by Lemma 42, Condition (22) we also have DD(ΩO)∪Eval(RO,D) |= α, which then implies DD(ΩO)∪RO∪D |= α, as required.\nAssume that O∪D 6|= α. Since, by Lemma 42, ΩO is a conservative extension of O andRO ⊆ O we have that ΩO ∪RO ∪ D 6|= α. Again, by Lemma 42, we have that ΩO |= DD(ΩO) and hence DD(ΩO) ∪RO ∪ D 6|= α.\nWe define a program P to be a rewriting of an ontology O if P is a rewriting of DD(ΩO) ∪ RO. By Theorems 43 and 13, we then obtain the following. Theorem 44. Let O be an ontology. If Rewrite terminates on DD(ΩO)∪RO with a datalog program P , then P is a rewriting of O.\nProof. Immediate by Theorems 43 and 13."
    } ],
    "references" : [ {
      "title" : "On datalog vs. polynomial time",
      "author" : [ "Cosmadakis Afrati", "F. Yannakakis 1995] Afrati", "S.S. Cosmadakis", "M. Yannakakis" ],
      "venue" : "J. Comput. System Sci",
      "citeRegEx" : "Afrati et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Afrati et al\\.",
      "year" : 1995
    }, {
      "title" : "Linearisability of datalog programs",
      "author" : [ "F.", "M. Gergatsoulis", "F. Toni" ],
      "venue" : "Theor. Comput. Sci. 308(1-3):199– 226.",
      "citeRegEx" : "F. et al\\.,? 2003",
      "shortCiteRegEx" : "F. et al\\.",
      "year" : 2003
    }, {
      "title" : "The DL-Lite family and relations",
      "author" : [ "Artale" ],
      "venue" : "J. Artif. Intell. Res",
      "citeRegEx" : "Artale,? \\Q2009\\E",
      "shortCiteRegEx" : "Artale",
      "year" : 2009
    }, {
      "title" : "Reasoning with minimal models: Efficient algorithms and applications",
      "author" : [ "Ben-Eliyahu-Zohary", "L. Palopoli" ],
      "venue" : null,
      "citeRegEx" : "Ben.Eliyahu.Zohary et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Ben.Eliyahu.Zohary et al\\.",
      "year" : 1997
    }, {
      "title" : "Ontology-based data access: A study through disjunctive datalog, CSP, and MMSNP",
      "author" : [ "Bienvenu" ],
      "venue" : "In PODS,",
      "citeRegEx" : "Bienvenu,? \\Q2013\\E",
      "shortCiteRegEx" : "Bienvenu",
      "year" : 2013
    }, {
      "title" : "OWLim: A family of scalable semantic repositories",
      "author" : [ "Bishop" ],
      "venue" : "Semantic Web J. 2(1):33–42",
      "citeRegEx" : "Bishop,? \\Q2011\\E",
      "shortCiteRegEx" : "Bishop",
      "year" : 2011
    }, {
      "title" : "The impact of disjunction on query answering under guarded-based existential rules",
      "author" : [ "Morak Bourhis", "P. Pieris 2013] Bourhis", "M. Morak", "A. Pieris" ],
      "venue" : "In IJCAI",
      "citeRegEx" : "Bourhis et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bourhis et al\\.",
      "year" : 2013
    }, {
      "title" : "Foundations of rule-based query answering",
      "author" : [ "Bry" ],
      "venue" : "In Reasoning",
      "citeRegEx" : "Bry,? \\Q2007\\E",
      "shortCiteRegEx" : "Bry",
      "year" : 2007
    }, {
      "title" : "Computing datalog rewritings beyond Horn ontologies",
      "author" : [ "Cuenca Grau" ],
      "venue" : "In IJCAI",
      "citeRegEx" : "Grau,? \\Q2013\\E",
      "shortCiteRegEx" : "Grau",
      "year" : 2013
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "Dantsin" ],
      "venue" : "ACM Comput. Surv",
      "citeRegEx" : "Dantsin,? \\Q2001\\E",
      "shortCiteRegEx" : "Dantsin",
      "year" : 2001
    }, {
      "title" : "Framework for an automated comparison of description logic reasoners",
      "author" : [ "Tsarkov Gardiner", "T. Horrocks 2006] Gardiner", "D. Tsarkov", "I. Horrocks" ],
      "venue" : "In ISWC,",
      "citeRegEx" : "Gardiner et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Gardiner et al\\.",
      "year" : 2006
    }, {
      "title" : "On the complexity of ontological reasoning under disjunctive existential rules",
      "author" : [ "Gottlob" ],
      "venue" : "In MFCS,",
      "citeRegEx" : "Gottlob,? \\Q2012\\E",
      "shortCiteRegEx" : "Gottlob",
      "year" : 2012
    }, {
      "title" : "Reasoning in Description Logics by a Reduction to Disjunctive Datalog",
      "author" : [ "Motik Hustadt", "U. Sattler 2007] Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "J. Autom. Reasoning",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2007
    }, {
      "title" : "Sufficient conditions for first-order and datalog rewritability in ELU",
      "author" : [ "Kaminski", "M. Cuenca Grau 2013] Kaminski", "B. Cuenca Grau" ],
      "venue" : "In DL,",
      "citeRegEx" : "Kaminski et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Kaminski et al\\.",
      "year" : 2013
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "Leone" ],
      "venue" : "ACM Trans. Comput",
      "citeRegEx" : "Leone,? \\Q2006\\E",
      "shortCiteRegEx" : "Leone",
      "year" : 2006
    }, {
      "title" : "Nonuniform data complexity of query answering in description logics. In KR",
      "author" : [ "Lutz", "C. Wolter 2012] Lutz", "F. Wolter" ],
      "venue" : null,
      "citeRegEx" : "Lutz et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2012
    }, {
      "title" : "Towards a complete OWL ontology",
      "author" : [ "Ma" ],
      "venue" : null,
      "citeRegEx" : "Ma,? \\Q2006\\E",
      "shortCiteRegEx" : "Ma",
      "year" : 2006
    }, {
      "title" : "OWL 2 Web Ontology Language Profiles",
      "author" : [ "Motik" ],
      "venue" : null,
      "citeRegEx" : "Motik,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik",
      "year" : 2009
    }, {
      "title" : "Parallel materialisation of datalog programs in centralised, main-memory rdf systems",
      "author" : [ "Motik" ],
      "venue" : null,
      "citeRegEx" : "Motik,? \\Q2014\\E",
      "shortCiteRegEx" : "Motik",
      "year" : 2014
    }, {
      "title" : "Hypertableau Reasoning for Description Logics",
      "author" : [ "Shearer Motik", "B. Horrocks 2009] Motik", "R. Shearer", "I. Horrocks" ],
      "venue" : "J. Artif. Intell. Res",
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "The loop absorption and the generalization strategies for the development of logic programs and partial deduction",
      "author" : [ "Proietti", "M. Pettorossi 1993] Proietti", "A. Pettorossi" ],
      "venue" : "J. Log. Programming",
      "citeRegEx" : "Proietti et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Proietti et al\\.",
      "year" : 1993
    }, {
      "title" : "Unfold/fold transformation of logic programs",
      "author" : [ "Tamaki", "H. Sato 1984] Tamaki", "T. Sato" ],
      "venue" : "In ICLP,",
      "citeRegEx" : "Tamaki et al\\.,? \\Q1984\\E",
      "shortCiteRegEx" : "Tamaki et al\\.",
      "year" : 1984
    }, {
      "title" : "Implementing an inference engine for RDFS/OWL constructs and user-defined rules in Oracle",
      "author" : [ "Wu" ],
      "venue" : null,
      "citeRegEx" : "Wu,? \\Q2008\\E",
      "shortCiteRegEx" : "Wu",
      "year" : 2008
    }, {
      "title" : "Making the most of your triple store: query answering in OWL 2 using an RL reasoner",
      "author" : [ "Zhou" ],
      "venue" : null,
      "citeRegEx" : "Zhou,? \\Q2013\\E",
      "shortCiteRegEx" : "Zhou",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 19,
      "context" : "Tractability in data complexity is an appealing property for data-intensive KR; in particular, the RL profile of the ontology language OWL 2 was designed such that each ontology corresponds to a datalog program (Motik et al. 2009).",
      "startOffset" : 211,
      "endOffset" : 230
    }, {
      "referenceID" : 16,
      "context" : "Dealing with Expressive Ontology Languages Hustadt, Motik, and Sattler (2007) developed an algorithm for transforming SHIQ ontologies into an equivalent disjunctive datalog program.",
      "startOffset" : 52,
      "endOffset" : 78
    }, {
      "referenceID" : 8,
      "context" : "Cuenca Grau et al. (2013) combined this algorithm with a knowledge compilation procedure (called Compile-Horn) obtaining a sound but incomplete and nonterminating datalog rewriting procedure for SHIQ.",
      "startOffset" : 7,
      "endOffset" : 26
    }, {
      "referenceID" : 8,
      "context" : "Complexity of disjunctive datalog with negation as failure has been extensively studied (Ben-Eliyahu-Zohary and Palopoli 1997; Eiter, Gottlob, and Mannila 1997). The class of head-cycle free programs was studied in Ben-EliyahuZohary and Palopoli; Ben-Eliyahu-Zohary, Palopoli, and Zemlyanker (1997; 2000), where it was shown that certain reasoning problems are tractable for such programs (fact entailment, however, remains intractable w.r.t. data). Gottlob et al. (2012) investigated complexity of disjunctive TGDs and showed tractability (w.",
      "startOffset" : 134,
      "endOffset" : 472
    }, {
      "referenceID" : 2,
      "context" : "Artale et al. (2009) showed tractability of fact entailment w.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 2,
      "context" : "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.",
      "startOffset" : 0,
      "endOffset" : 339
    }, {
      "referenceID" : 2,
      "context" : "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.",
      "startOffset" : 0,
      "endOffset" : 363
    }, {
      "referenceID" : 2,
      "context" : "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI.",
      "startOffset" : 0,
      "endOffset" : 563
    }, {
      "referenceID" : 2,
      "context" : "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI. The procedure in (Cuenca Grau et al. 2013), mentioned in Section 6, is used by Kaminski and Cuenca Grau (2013) to show first-order/datalog rewritability of two fragments of ELU .",
      "startOffset" : 0,
      "endOffset" : 778
    }, {
      "referenceID" : 2,
      "context" : "Artale et al. (2009) showed tractability of fact entailment w.r.t. data for DL-Litebool logics. This result is related to (Gottlob et al. 2012) since certain DL-Litebool logics can be represented as linear disjunctive TGDs. Finally, combined complexity of CQ answering for disjunctive TGDs was studied by Bourhis, Morak, and Pieris (2013). Lutz and Wolter (2012) investigated non-uniform data complexity of CQ answering w.r.t. extensions of ALC, and related CQ answering to constraint satisfaction problems. This connection was explored by Bienvenu et al. (2013), who showed NEXPTIME-completeness of first-order and datalog rewritability of instance queries for SHI. The procedure in (Cuenca Grau et al. 2013), mentioned in Section 6, is used by Kaminski and Cuenca Grau (2013) to show first-order/datalog rewritability of two fragments of ELU . Notably, both fragments yield linear programs. Finally, our unfolding-based rewriting procedure is motivated by the work of Afrati, Gergatsoulis, and Toni (2003) on linearisation of plain datalog programs by means of program transformation techniques (Tamaki and Sato 1984; Proietti and Pettorossi 1993; Gergatsoulis 1997).",
      "startOffset" : 0,
      "endOffset" : 1008
    } ],
    "year" : 2014,
    "abstractText" : "We study the problem of rewriting a disjunctive datalog program into plain datalog. We show that a disjunctive program is rewritable if and only if it is equivalent to a linear disjunctive program, thus providing a novel characterisation of datalog rewritability. Motivated by this result, we propose weakly linear disjunctive datalog—a novel rule-based KR language that extends both datalog and linear disjunctive datalog and for which reasoning is tractable in data complexity. We then explore applications of weakly linear programs to ontology reasoning and propose a tractable extension of OWL 2 RL with disjunctive axioms. Our empirical results suggest that many non-Horn ontologies can be reduced to weakly linear programs and that query answering over such ontologies using a datalog engine is feasible in practice.",
    "creator" : "LaTeX with hyperref package"
  }
}