{
  "name" : "1405.3792.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Minimum Model Semantics for Extensional Higher-order Logic Programming with Negation∗",
    "authors" : [ "Angelos Charalambidis", "Zoltán Ésik", "Panos Rondogiannis" ],
    "emails" : [ "a.charalambidis@di.uoa.gr)", "ze@inf.u-szeged.hu)", "prondo@di.uoa.gr)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n37 92\nv1 [\nlogic programming. An important characteristic of this paradigm is that it preserves all the well-known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. Using some recent results from non-monotonic fixed-point theory, we demonstrate that every higher-order logic program with negation has a unique minimum infinite-valued model. In this way we obtain the first purely model-theoretic semantics for negation in extensional higher-order logic programming. Using our approach, we resolve an old paradox that was introduced by W. W. Wadge in order to demonstrate the semantic difficulties of higher-order logic programming."
    }, {
      "heading" : "1 Introduction",
      "text" : "Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming. The key idea behind this paradigm is that all predicates defined in a program denote sets and therefore one can use standard extensional set theory in order to understand their meaning and to reason about them. For example, consider the following simple extensional higher-order program (Charalambidis et al. 2013) stating that a band (musical ensemble) is a group that has at least a singer and a guitarist:\nband(B):-singer(S),B(S),guitarist(G),B(G).\n∗ This research is being supported by the Greek General Secretariat for Research and Technology, the National Development Agency of Hungary, and the European Commission (European Regional Development Fund) under a Greek-Hungarian intergovernmental programme of Scientific and Technological collaboration. Project title: “Extensions and Applications of Fixed Point Theory for Non-Monotonic Formalisms”. It is also supported by grant no. ANN 110883 from the National Foundation of Hungary for Scientific Research.\nSuppose that we also have a database of musicians:\nsinger(sally).\nsinger(steve).\nguitarist(george).\nguitarist(grace).\nWe can then ask the query ?-band(B). Since predicates denote sets, an extensional higher-order language will return answers such as B = {sally, george} ∪ L, having the meaning that every set that contains at least sally and george is a potential band.\nA consequence of the set-theoretic nature of extensional higher-order logic programming is the fact that its semantics and its proof theory smoothly extend the corresponding ones for traditional (ie., first-order) logic programming. In particular, every program has a unique minimum Herbrand model which is the greatest lower bound of all Herbrand models of the program and the least fixed-point of an immediate consequence operator associated with the program; moreover, there exists an SLD resolution proof-procedure which is sound and complete with respect to the minimum model semantics.\nOne basic property of all the higher-order predicates that can be defined in the language of (Charalambidis et al. 2013) is that they are monotonic. Intuitively, the monotonicity property states that if a predicate is true of a relation R then it is also true of every superset of R. In the above example, it is clear that if band is true of a relation B then it is also true of any band that is a superset of B. However, there are many natural higher-order predicates that are non-monotonic. Consider for example a predicate single singer band which (apparently) defines a band that has a unique singer:\nsingle singer band(B):-band(B),not two singers(B).\ntwo singers(B):-B(S1),B(S2),singer(S1),singer(S2),not(S1=S2).\nThe predicate single singer band is obviously non-monotonic since it is satisfied by the set {sally, george} but not by the set {sally, steve, george}. In other words, the semantics of (Charalambidis et al. 2013) is not applicable to this extended higher-order language. We are therefore facing the same problem that researchers faced more than twenty years ago when they attempted to provide a sensible semantics to classical logic programs with negation; the only difference is that the problem now reappears in a much more general context, namely in the context of higher-order logic programming.\nThe solution we adopt is relatively simple to state (but non-trivial to materialize): it suffices to generalize the well-founded construction (van Gelder et al. 1991; Przymusinski 1989) to higher-order programs. For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014). This brings us to the two main contributions of the present paper:\n• We provide the first model-theoretic semantics for extensional higher-order logic\nprogramming with negation. In this way we initiate the study of a non-monotonic formalism that is much broader than classical logic programming with negation. • We provide further evidence that extensional higher-order logic programming is\na natural generalization of classical logic programming, by showing that all the well-known properties of the latter also hold for the new paradigm.\nIn the next section we provide an introduction to the proposed semantics for higherorder logic programming and the remaining sections provide the formal development of this semantics. The proofs of all the results have been moved to corresponding appendices."
    }, {
      "heading" : "2 An Intuitive Overview of the Proposed Semantics",
      "text" : "The starting point for the semantics proposed in this paper is the infinite-valued semantics for ordinary logic programs with negation, as introduced in (Rondogiannis andWadge 2005). In this section we give an intuitive introduction to the infinite-valued approach and discuss how it can be extended to the higher-order case.\nThe infinite-valued approach was introduced in order to provide a minimum model semantics to logic programs with negation. As we are going to see shortly, it is compatible with the well-founded semantics but it is purely model-theoretic1. The main idea of this approach can be explained with a simple example. Consider the program:\np ← r ← ∼p s ← ∼q\nUnder the well-founded semantics both p and s receive the value True. However, p is in some sense “truer” than s. Namely, p is true because there is a rule which says so, whereas s is true only because we are never obliged to make q true. In a sense, s is true only by default. This gave the idea of adding a “default” truth value T1 just below the “real” truth T0, and (by symmetry) a weaker false value F1 just above (“not as false as”) the real false F0. We can then understand negation-as-failure as combining ordinary negation with a weakening. Thus ∼ F0 = T1 and ∼ T0 = F1. Since negations can effectively be iterated, the infinite-valued approach requires a whole sequence . . . , T3, T2, T1 of weaker and weaker truth values below T0 but above the neutral value 0; and a mirror image sequence F1, F2, F3, . . . above F0 and below 0. In fact, to capture the well-founded model in full generality, we need a Tα and a Fα for every countable ordinal α. In other words, the underlying truth domain of the infinite-valued approach is:\nF0 < F1 < · · ·< Fω < · · ·< Fα < · · ·< 0 < · · ·< Tα < · · ·< Tω < · · ·< T1 < T0\nAs shown in (Rondogiannis and Wadge 2005), every logic program P with negation has a unique minimum infinite-valued model MP. Notice that MP is minimum with respect to a relation⊑ which compares interpretations in a stage-by-stage manner (see (Rondogiannis andWadge 2005) for details). As it is proven in (Rondogiannis andWadge 2005), if we collapse all the Tα and Fα to True and False respectively, we get the well-founded model. For the example program above, the minimum model is {(p, T0), (q, F0), (r, F1), (s, T1)}. This collapses to {(p,True), (q,False), (r,False), (s,True)}, which is the well-founded model of the program.\nAs shown in (Rondogiannis and Wadge 2005), one can compute the minimum infinitevalued model as the least fixed point of an operator TP. It can easily be seen that TP is not monotonic with respect to the ordering relation ⊑ and therefore one can not obtain\n1 In the same way that the equilibrium logic approach of (Pearce 1996) gives a purely logical reconstruction of the stable model semantics.\nthe least fixed point using the classical Knaster-Tarski theorem. However, TP possesses some form of partial monotonicity. More specifically, as it is shown in (Rondogiannis and Wadge 2005; Ésik and Rondogiannis 2014), TP is α-monotonic for all countable ordinals α, a property that guarantees the existence of the least fixed point. Loosely speaking, the property of TP being α-monotonic means that the operator is monotonic when we restrict attention to interpretations that are equal for all levels of truth values that are less than α. In other words, TP is monotonic in stages (but not overall monotonic).\nThe TP operator is a higher-order function since it takes as argument an interpretation and returns an interpretation as the result. This observation leads us to the main concept that helps us extend the infinite-valued semantics to the higher-order case. The key idea is to demonstrate that the denotation of every expression of predicate type in our higherorder language, is α-monotonic for all ordinals α (see Lemma 5). This property ensures that the immediate consequence operator of every program is also α-monotonic for all α (see Lemma 7), and therefore it has a least fixed-point which is a model of the program. Actually, this same model can also be obtained as the greatest lower bound of all the Herbrand models of the program (see Theorem 2, the model intersection theorem). In other words, the semantics of extensional higher-order logic programming with negation preserves all the familiar properties of classical logic programming and can therefore be considered as a natural generalization of the latter."
    }, {
      "heading" : "3 Non-Monotonic Fixed Point Theory",
      "text" : "The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014). The key objective of this area of research is to obtain novel fixed point results regarding functions that are not necessarily monotonic. In particular, the results obtained in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene’s theorem and also the Knaster-Tarski theorem). In this section we provide the necessary material from (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014) that will be needed in the next sections.\nSuppose that (L,≤) is a complete lattice in which the least upper bound operation is\ndenoted by ∨ and the least element is denoted by ⊥. Let κ > 0 be a fixed ordinal. We assume that for each ordinal α < κ, there exists a preordering ⊑α on L. We write x =α y iff x ⊑α y and y ⊑α x. We define x ❁α y iff x ⊑α y but x =α y does not hold. Moreover, we write x ❁ y iff x ❁α y for some α < κ. Finally, we define x ⊑ y iff x ❁ y or x = y.\nLet x ∈ L and α < κ. We define (x]α = {y : ∀β < α x =β y}. A key property that will be used throughout the paper is that if the above preordering relations satisfy certain simple axioms, then the structure (L,⊑) is a complete lattice; moreover, every function f : L → L that satisfies some restricted form of monotonicity, has a least fixed point. These ideas are formalized by the following definitions and results.\nDefinition 1 Let (L,≤) be a complete lattice equipped with preorderings ⊑α for all α < κ. Then, L will be called a basic model if and only if it satisfies the following axioms:\n1. For all x, y ∈ L and all α < β < κ, if x ⊑β y then x =α y.\n2. For all x, y ∈ L, if x =α y for all α < κ then x = y. 3. Let x ∈ L and α < κ. Let X ⊆ (x]α. Then, there exists y (denoted by ⊔ α X)\nsuch that X ⊑α y2 and for all z ∈ (x]α such that X ⊑α z, it holds y ⊑α z\nand y ≤ z. 4. If xj , yj ∈ L and xj ⊑α yj for all j ∈ J then ∨ {xj : j ∈ J} ⊑α ∨ {yj : j ∈ J}.\nLemma 1 Let L be a basic model. Then, (L,⊑) is a complete lattice.\nDefinition 2 Let A,B be basic models and let α < κ. A function f : A → B is called α-monotonic if for all x, y ∈ A if x ⊑α y then f(x) ⊑α f(y).\nIt should be noted that even if a function f is α-monotonic for all α < κ, then it need not be necessarily monotonic with respect to the relation ⊑ (for a counterexample, see (Rondogiannis and Wadge 2005, Example 5.7, pages 453–454)). Therefore, the standard tools of classical fixed point theory (such as the Knaster-Tarski theorem), do not suffice in order to find the least fixed point of f with respect to the relation ⊑.\nLet us denote by [A m → B] the set of functions from A to B that are α-monotonic for\nall α < κ.\nTheorem 1 Let L be a basic model and assume that f ∈ [L m → L]. Then, f has a ⊑-least pre-fixed point, which is also the ⊑-least fixed point of f .\nThe above theorem will be our main tool for establishing the fact that the immediate consequence operator of any extensional higher order logic program, always has a least fixed point, which is a model of the program."
    }, {
      "heading" : "4 The Syntax of the Higher-Order Language H",
      "text" : "In this section we introduce the higher-order language H, which extends classical firstorder logic programming to a higher-order setting. The language H is based on a simple type system that supports two base types: o, the boolean domain, and ι, the domain of individuals (data objects). The composite types are partitioned into three classes: functional (assigned to individual constants, individual variables and function symbols), predicate (assigned to predicate constants and variables) and argument (assigned to parameters of predicates).\nDefinition 3 A type can either be functional, predicate, argument, denoted by σ, π and ρ respectively and defined as:\nσ := ι | ι → σ\nπ := o | ρ → π\nρ := ι | π\nWe will use τ to denote an arbitrary type (either functional, predicate or argument one).\n2 We write X ⊑α y iff forall x ∈ X it holds x ⊑α y.\nAs usual, the binary operator → is right-associative. A functional type that is different than ι will often be written in the form ιn → ι, n ≥ 1 (which stands for ι → ι → · · · → ι (n+1)-times). Moreover, it can be easily seen that every predicate type π can be written uniquely in the form ρ1 → · · · → ρn → o, n ≥ 0 (for n = 0 we assume that π = o). We can now proceed to the definition of H, starting from its alphabet and continuing with expressions and program clauses:\nDefinition 4 The alphabet of the higher-order language H consists of the following:\n1. Predicate variables of every predicate type π (denoted by capital letters such\nas P,Q,R, . . .).\n2. Predicate constants of every predicate type π (denoted by lowercase letters\nsuch as p, q, r, . . .).\n3. Individual variables of type ι (denoted by capital letters such as X,Y,Z, . . .). 4. Individual constants of type ι (denoted by lowercase letters such as a, b, c, . . .). 5. Function symbols of every functional type σ 6= ι (denoted by lowercase letters\nsuch as f, g, h, . . .).\n6. The following logical constant symbols: the constants false and true of type o;\nthe equality constant ≈ of type ι → ι → o; the generalized disjunction and conjunction constants ∨\nπ and ∧ π of type π → π → π, for every predicate\ntype π; the generalized inverse implication constants ←π, of type π → π → o, for every predicate type π; the existential quantifier ∃ρ, of type (ρ → o) → o, for every argument type ρ; the negation constant ∼ of type o → o.\n7. The abstractor λ and the parentheses “(” and “)”.\nThe set consisting of the predicate variables and the individual variables of H will be called the set of argument variables of H. Argument variables will be usually denoted by V and its subscripted versions.\nDefinition 5 The set of expressions of the higher-order language H is defined as follows:\n1. Every predicate variable (respectively, predicate constant) of type π is an\nexpression of type π; every individual variable (respectively, individual constant) of type ι is an expression of type ι; the propositional constants false and true are expressions of type o. 2. If f is an n-ary function symbol and E1, . . . ,En are expressions of type ι, then\n(f E1 · · ·En) is an expression of type ι.\n3. If E1 is an expression of type ρ → π and E2 is an expression of type ρ, then\n(E1 E2) is an expression of type π.\n4. If V is an argument variable of type ρ and E is an expression of type π, then\n(λV.E) is an expression of type ρ → π.\n5. If E1,E2 are expressions of type π, then (E1 ∧ π E2) and (E1 ∨ π E2) are ex-\npressions of type π.\n6. If E is an expression of type o, then (∼E) is an expression of type o. 7. If E1,E2 are expressions of type ι, then (E1 ≈ E2) is an expression of type o.\n8. If E is an expression of type o and V is a variable of type ρ then (∃ρVE) is\nan expression of type o.\nTo denote that an expression E has type τ we will write E : τ . The notions of free and bound variables of an expression are defined as usual. An expression is called closed if it does not contain any free variables.\nDefinition 6\nA program clause is a clause p ←π E where p is a predicate constant of type π and E is a closed expression of type π. A program is a finite set of program clauses.\nExample 1\nThe subset predicate can be defined in H as follows:\nsubset ←π→π→o λP.λQ. ∼∃X((P X)∧ ∼(Q X))\nThe subset predicate is defined by a λ-expression (which obviates the need to have the formal parameters of the predicate in the left-hand side of the definition). Moreover, in the right-hand side we have an explicit existential quantifier for the variable X (in Prolog, if a variable appears in the body of a clause but not in the head, then it is implicitly existentially quantified)."
    }, {
      "heading" : "5 The Semantics of the Higher-Order Language H",
      "text" : "In this section we specify the semantics of H. We start with the semantics of types and proceed to the semantics of expressions.\nThe meaning of the boolean type o is equal to a partially ordered set (V,≤) of truth values. The number of truth values of V will be specified with respect to an ordinal κ > 0. All the results of the paper hold for every initial selection of κ. The set (V,≤) is therefore\nF0 < F1 < · · ·< Fα < · · ·< 0 < · · ·< Tα < · · ·< T1 < T0\nwhere α < κ.\nDefinition 7\nThe order of a truth value is defined as follows: order(Tα) = α, order(Fα) = α and order(0) = +∞.\nWe can now define the meaning of all the types of our language as well as the corre-\nsponding relations ≤ and ⊑α. This is performed in the following definitions:\nDefinition 8\nWe define the relation ⊑α on the set V for each α < κ as follows:\n1. x ⊑α x if order(x) < α; 2. Fα ⊑α x and x ⊑α Tα if order(x) ≥ α; 3. x ⊑α y if order(x), order(y) > α.\nNotice that x =α y iff either x = y or order(x) > α and order(y) > α.\nDefinition 9 Let D be a nonempty set. Then:\n• [[ι]]D = D, and ≤ι is the trivial partial order such that d ≤ι d, for all d ∈ D; • [[ιn → ι]]D = D n → D. A partial order in this case will not be needed; • [[o]]D = V , and ≤o is the partial order of V ; • [[ι → π]]D = D → [[π]]D, and ≤ι→π is the partial order defined as follows: for all\nf, g ∈ [[ι → π]]D, f ≤ι→π g iff f(d) ≤π g(d) for all d ∈ D;\n• [[π1 → π2]]D = [[[π1]]D m → [[π2]]D], and ≤π1→π2 is the partial order defined as follows:\nfor all f, g ∈ [[π1 → π2]]D, f ≤π1→π2 g iff f(d) ≤π2 g(d) for all d ∈ [[π1]]D.\nThe subscripts in the above partial orders will often be omitted when they are obvious\nfrom context.\nDefinition 10 Let D be a nonempty set and α < κ. Then:\n• The relation ⊑α on [[o]]D is the relation ⊑α on V . • The relation ⊑α on [[ρ → π]]D is defined as follows: f ⊑α g iff f(d) ⊑α g(d) for all\nd ∈ [[ρ]]D. Moreover, f ❁α g iff f ⊑α g and f(d) ❁α g(d) for some d ∈ [[ρ]]D.\nThe following lemma expresses the fact that all the predicate types correspond to\nsemantic domains that are both complete lattices and basic models:\nLemma 2 Let D be a nonempty set and π be a predicate type. Then, ([[π]]D,≤π) is a complete lattice and a basic model.\nWe now proceed to formally define the semantics of H:\nDefinition 11 An intepretation I of H consists of:\n1. a nonempty set D called the domain of I; 2. an assignment to each individual constant symbol c, of an element I(c) ∈ D; 3. an assignment to each predicate constant p : π of an element I(p) ∈ [[π]]D; 4. an assignment to each function symbol f : ιn → ι of a function I(f) ∈ Dn→ D.\nDefinition 12 Let D be a nonempty set. A state s of H over D is a function that assigns to each argument variable V of type ρ of H, of an element s(V) ∈ [[ρ]]D.\nDefinition 13 Let I be an interpretation of H, let D be the domain of I, and let s be a state over D. Then, the semantics of expressions of H with respect to I and s, is defined as follows:\n1. [[false]]s(I) = F0 2. [[true]]s(I) = T0 3. [[c]]s(I) = I(c), for every individual constant c 4. [[p]]s(I) = I(p), for every predicate constant p 5. [[V]]s(I) = s(V), for every argument variable V\n6. [[(f E1 · · ·En)]]s(I) = I(f) [[E1]]s(I) · · · [[En]]s(I), for every n-ary function sym-\nbol f\n7. [[(E1E2)]]s(I) = [[E1]]s(I)([[E2]]s(I)) 8. [[(λV.E)]]s(I) = λd.[[E]]s[V/d](I), where d ranges over [[type(V)]]D 9. [[(E1 ∨ π E2)]]s(I) = ∨ π{[[E1]]s(I), [[E2]]s(I)}, where ∨ π is the least upper bound\nfunction on [[π]]D 10. [[(E1 ∧ π E2)]]s(I) = ∧ π{[[E1]]s(I), [[E2]]s(I)}, where ∧ π is the greatest lower\nbound function on [[π]]D\n11. [[(∼E)]]s(I) =\n\n  \n  \nTα+1 if [[E]]s(I) = Fα Fα+1 if [[E]]s(I) = Tα 0 if [[E]]s(I) = 0\n12. [[(E1 ≈E2)]]s(I) =\n{\nT0, if [[E1]]s(I) = [[E2]]s(I) F0, otherwise\n13. [[(∃VE)]]s(I) = ∨\nd∈[[type(V)]] D\n[[E]]s[V/d](I)\nFor closed expressions E we will often write [[E]](I) instead of [[E]]s(I) (since, in this\ncase, the meaning of E is independent of s).\nLemma 3 Let E : ρ be an expression and let D be a nonempty set. Moreover, let s be a state over D and let I be an interpretation over D. Then, [[E]]s(I) ∈ [[ρ]]D.\nDefinition 14 Let P be a program and let M be an interpretation over a nonempty set D. Then M will be called a model of P iff for all clauses p ←π E of P, it holds [[E]](M) ≤π M(p), where M(p) ∈ [[π]]D."
    }, {
      "heading" : "6 Minimum Herbrand Model Semantics for H",
      "text" : "In this section we demonstrate that every program of H has a unique minimum Herbrand model which is the greatest lower bound of all the Herbrand models of the program, and also the least fixed point of the immediate consequence operator of the program. We start with the relevant definitions.\nDefinition 15 Let P be a program. The Herbrand universe UP of P is the set of all terms that can be formed out of the individual constants3 and the function symbols of P.\nDefinition 16 A Herbrand interpretation I of a program P is an interpretation such that:\n1. the domain of I is the Herbrand universe UP of P; 2. for every individual constant c of P, I(c) = c; 3. for every predicate constant p : π of P, I(p) ∈ [[π]]UP ;\n3 As usual, if P has no constants, we assume the existence of an arbitrary one.\n4. for every n-ary function symbol f of P and for all t1, . . . , tn ∈ UP, I(f) t1 · · · tn =\nf t1 · · · tn.\nA Herbrand state of a program P is a state whose underlying domain is UP. We denote\nthe set of Herbrand interpretations of a program P by IP.\nDefinition 17 A Herbrand model of a program P is a Herbrand interpretation that is a model of P.\nDefinition 18 Let P be a program. We define the following partial order on IP: for all I, J ∈ IP, I ≤IP J iff for every π and for every predicate constant p : π of P, I(p) ≤π J(p).\nDefinition 19 Let P be a program. We define the following preorder on IP for all α < κ: for all I, J ∈ IP, I ⊑α J iff for every π and for every predicate constant p : π of P, I(p) ⊑α J(p).\nThe following two lemmas play a main role in establishing the two central theorems.\nLemma 4 Let P be a program. Then, IP is a complete lattice and a basic model.\nLemma 5 (α-Monotonicity of Semantics) Let P be a program and let E : π be an expression. Let I, J be Herbrand interpretations and s be a Herbrand state of P. For all α < κ, if I ⊑α J then [[E]]s(I) ⊑α [[E]]s(J).\nSince by Lemma 4 the set IP is a basic model (and thus by Lemma 1 is a complete lattice with respect to ⊑), everyM ⊆ IP has a greatest lower bound d M with respect to ⊑. We have the following theorem which generalizes the familiar model intersection theorem for definite first-order logic programs (Lloyd 1987), the model intersection theorem for normal first-order logic programs (Rondogiannis and Wadge 2005, Theorem 8.6) and the model intersection theorem for definite higher-order logic programs (Charalambidis et al. 2013, Theorem 6.8).\nTheorem 2 (Model Intersection Theorem) Let P be a program and M be a nonempty set of Herbrand models of P. Then, d M is also a Herbrand model of P.\nDefinition 20 Let P be a program. The mapping TP : IP → IP is defined for every p : π and for every I ∈ IP as TP(I)(p) = ∨ {[[E]](I) : (p ←π E) ∈ P}. The mapping TP will be called the immediate consequence operator for P.\nThe following two lemmas are crucial in establishing the least fixed point theorem.\nLemma 6 Let P be a program. For every predicate constant p : π in P and I ∈ IP, TP (I)(p) ∈ [[π]]UP .\nLemma 7 Let P be a program. Then, TP is α-monotonic for all α < κ.\nTheorem 3 (Least Fixed Point Theorem) Let P be a program and let M be the set of all its Herbrand models. Then, TP has a least fixed point MP. Moreover, MP = d M.\nThe construction of the least fixed point in the above theorem is similar to the one given for (potentially infinite) propositional programs in (Rondogiannis and Wadge 2005, Section 6). Due to space limitations, we provide a short outline of this procedure. In order to calculate the least fixed point, we start with an interpretation, say I0, which for every predicate constant p of type ρ1 → · · · ρn → o, and for all d1 ∈ [[ρ1]]UP , . . . , dn ∈ [[ρn]]UP , I0(p) d1 · · · dn = F0. We start iterating TP on this interpretation until we get to a point where the additional iterations do not affect the F0 and T0 values. At this point, we reset all the remaining values (regarding predicate constants and arguments that have not stabilized) to F1, getting an interpretation I1. We start iterating TP on I1, until we get to a point where the additional iterations do not affect the F1 and T1 values. We repeat this process for higher ordinals. In particular, when we get to a limit ordinal, say α, we reset all the values that have not stabilized to a truth value of order less than α, to Fα. The whole process is repeated for κ times. If the value of certain predicate constants applied to certain arguments has not stabilized after the κ iterations, we assign to them the intermediate value 0. The resulting interpretation is the least fixed point MP."
    }, {
      "heading" : "7 Resolving a Semantic Paradox of Higher-Order Logic Programming",
      "text" : "One deficiency of extensional higher-order logic programming is the inability to define rules (or facts) that have predicate constants in their heads. The reason of this restriction is a semantic one and will be explained shortly. However, not all programs that use predicate constants in the heads of clauses are problematic. For example, the program\ncomputer scientist(john).\ngood profession(computer scientist).\nhas a clear declarative reading: the denotation of the computer scientist predicate is the relation {john}, while the denotation of good profession is the relation {{john}}.\nIn (Wadge 1991), W. W. Wadge argued that allowing rules to have predicate constants in their heads, creates tricky semantic problems to. Wadge gave a simple example (duplicated below) that revealed these problems; the example has since been used in other studies of higher-order logic programming (such as for example in (Bezem 2001)). We present the example in almost identical phrasing as it initially appeared.\nExample 2 Consider the program:\np(a).\nq(a).\nphi(p).\nq(b):-phi(q).\nOne candidate for minimum Herbrand model is the one in which p and q are true only of a, and phi is true only of p. However, this means that p and q have the same extension, and so themselves are equal. But since p and q are equal, and phi holds for p, it must also hold for q. The fourth rule forces us to add q(b), so that the model becomes\n{p(a), phi(p), q(a), q(b)} (in ad hoc notation). But this is problematic because p and q are no longer equal and q(b) has lost its justification.\nProblems such as the above led Wadge to disallow such clauses from the syntax of the language proposed in (Wadge 1991). Similarly, the higher-order language introduced in (Charalambidis et al. 2013) also disallows this kind of clauses.\nHowever, under the semantics presented in this paper, we can now assign a proper meaning to programs such as the above. Actually, higher order facts such as phi(p). above, can be seen as syntactic sugar in our fragment. A fact of this form simply states that phi is true of a relation if this relation is equal to p. This can simply be written as:\nphi(P):-equal(P,p).\nwhere equal is a higher-order equality relation that can easily be axiomatized in H using the subset predicate (see Example 1):\nequal ← λP.λQ.(subset P Q) ∧ (subset Q P).\nOne can compute the minimum model of the resulting program using the techniques presented in this paper. The paradox of Example 2 is no longer valid since in the minimum infinite-valued model the atom q(b) has value 0. Intuitively, this means that it is not possible to decide whether q(b) should be true or false.\nThe above discussion leads to an easy way of handling rules with predicate constants in their heads. The predicate constants are replaced with predicate variables and higherorder equality atoms are added in the bodies of clauses. Then, appropriate clauses defining the equal predicates for all necessary types, are added to the program. The infinite valued semantics of the resulting program is taken as the meaning of the initial program."
    }, {
      "heading" : "8 Future Work",
      "text" : "We have presented the first, to our knowledge, formal semantics for negation in extensional higher-order logic programming. The results we have obtained generalize the semantics of classical logic programming to the higher order setting. We believe that the most interesting direction for future work is the investigation of implementation techniques for (fragments of) H, based on the semantics introduced in this paper. One possible option would be to examine the implementation of a higher order extension of Datalog with negation. We are currently examining these possibilities."
    }, {
      "heading" : "Appendix A Proof of Lemma 2",
      "text" : "We will make use of certain facts established in (Ésik and Rondogiannis 2014).\nSuppose that L is a basic model. For each x ∈ L and α < κ, we define x|α = ⊔ α{x}. It was shown in (Ésik and Rondogiannis 2014) that x =α x|α and x|α =α x|β , x|α ≤ x|β for all α < β < κ. Moreover, x = ∨\nα<κ x|α. Also, for all x, y ∈ L and α < κ, it holds x =α y\niff x|α =α y|α iff x|α = y|α, and x ⊑α y iff x|α ⊑α y|α. And if x ⊑α y, then x|α ≤ y|α. It is also not difficult to prove that for all x ∈ L and α, β < κ, (x|α)|β = x|min{α,β}. More generally, whenever X ⊆ (z]α and β ≤ α < κ, it holds ( ⊔ α X)|β = ⊔ β X . And if α < β, then ( ⊔\nα X)|β = ⊔ α X . Finally, we will make use of the following two results from (Ésik\nand Rondogiannis 2014):\nProposition 8 Let A,B be basic models and let α < κ. If fj : A → B is an α-monotonic function for each j ∈ J , then so is f = ∨\nj∈J fj defined by f(x) = ∨ j∈J fj(x).\nLemma 9 Let Z be an arbitrary set and L be a basic model. Then, Z → L is a basic model with the pointwise definition of the order of relations ≤ and ⊑α for all α < κ.\nSuppose that A,B are basic models. By Lemma 9 the set A → B is also a model, where the relations ≤ and ⊑α, α < κ, are defined in a pointwise way (see (Ésik and Rondogiannis 2014, Subsection 5.3) for details). It follows that for any set F of functions A → B, ∨\nF can be computed pointwisely. Also, when F ⊆ (f ]α for some f : A → B, ⊔\nα F for α < κ can be computed pointwisely. We want to show that whenever f : A → B, β < κ and F ⊆ (f ]β is a set of functions\nsuch that F ⊆ [A m → B], then ⊔ β F ∈ [A m → B]. We will make use of a lemma.\nLemma 10 Let L be a basic model. For all x, y ∈ L and α, β < κ with α 6= β, x|β ⊑α y|β iff either β < α and x|β = y|β (or equivalently, x =β y), or β > α and x|α ⊑α y|α."
    }, {
      "heading" : "Proof",
      "text" : "Let x|β ⊑α y|β . If β < α then x|β = (x|β)|β = (y|β)|β = y|β . If β > α then x|α = (x|β)|α ⊑α (y|β)|α = y|α.\nSuppose now that β < α and x|β = y|β . Then (x|β)|α = x|β = y|β = (y|β)|α and thus x|β =α y|β . Finally, let β > α and x|α ⊑α y|α. Then (x|β)|α = x|α ⊑α y|α = (y|β)|α and thus x|β ⊑α y|β.\nRemark 1 Under the above assumptions, if β < α, then x|β ⊑α y|β iff x|β =α y|β iff x|β = y|β .\nCorollary 1 For all X,Y ⊆ L and α 6= β, ⊔\nβ X ⊑α ⊔ β Y iff β < α and ⊔ β X = ⊔\nβ Y , or β > α and ⊔\nα X ⊑α ⊔ α Y ."
    }, {
      "heading" : "Proof",
      "text" : "Let x = ⊔\nβ X and y = ⊔ β Y . Then x = ⊔ β X = ⊔ β{ ⊔ β X} = x|β and y = y|β .\nLet β < α. Then x ⊑α y iff x = y. Let β > α. Then x ⊑α y iff x|α ⊑α y|α. But x|α = ⊔ α{ ⊔ β X} = ⊔ α X and similarly for Y .\nLemma 11 Let A and B be basic models. Suppose that f : A → B and F ⊆ (f ]β (where β < κ) is a set of functions in [A m → B]. Then ⊔\nβ F is also α-monotonic for all α < κ."
    }, {
      "heading" : "Proof",
      "text" : "Suppose that α, β < κ and x ⊑α y in A. Then ( ⊔ β F )(x) = ⊔ β{f(x) : f ∈ F} and ( ⊔\nβ F )(y) = ⊔ β{f(y) : f ∈ F}. We have that f(x) ⊑α f(y) for all f ∈ F . Thus, if\nα = β, then clearly ( ⊔ β F )(x) ⊑α ( ⊔ β F )(y).\nSuppose that β < α. Then ⊔ β{f(x) : f ∈ F} = ⊔ β{f(y) : f ∈ F} since f(x) =β f(y)\nfor all f ∈ F . Thus, by Corollary 1, ( ⊔ β F )(x) ⊑α ( ⊔ β F )(y).\nSuppose that β > α. Then ( ⊔ β F )(x) ⊑α ( ⊔\nβ F )(y) follows by Corollary 1 from ⊔\nα{f(x) : f ∈ F} ⊑α ⊔ α{f(y) : f ∈ F}. We equip [A m → B] with the order relations ≤ and ⊑α inherited from A → B. We have\nthe following lemma:\nLemma 12 If A and B are basic models, then so is [A m → B] with the pointwise definition of the order of relations ≤ and ⊑α for all α < κ."
    }, {
      "heading" : "Proof",
      "text" : "It is proved in (Ésik and Rondogiannis 2014) that the set of functions A → B is a basic model with the pointwise definition of the relations ≤ and ⊑α, so that for all f, g : A → B and α < κ, f ≤ g iff f(x) ≤ g(x) for all x ∈ A and f ⊑α g iff f(x) ⊑α g(x) for all x ∈ A. It follows that for any F ⊆ BA and α < κ, ∨ F and ⊔\nα F can also be computed pointwise:\n( ∨ F )(x) = ∨ {f(x) : x ∈ A} and ( ⊔ α F )(x) = ⊔ α{f(x) : f ∈ F}. By Proposition 8 and Lemma 11, for all F ⊆ BA, if F is a set of functions α-monotonic for all α, then ∨\nF and ⊔\nβ F are also α-monotonic for all α. Since the relations ≤ and ⊑α, α < κ on [A m → B] are the restrictions of the corresponding relations on BA, in view of Proposition 8 and Lemma 11, [A m → B] also satisfies the axioms in Definition 1, so that [A m → B] is a basic model.\nThe following lemma is shown in (Ésik and Rondogiannis 2014, Subsection 5.2) and\nwill be used in the proof of the basis case of the next lemma:\nLemma 13 (V,≤) is a complete lattice and a basic model.\nLemma 2 Let D be a nonempty set and π be a predicate type. Then, ([[π]]D,≤π) is a complete lattice and a basic model."
    }, {
      "heading" : "Proof",
      "text" : "Let π be a predicate type. We prove that [[π]]D is a basic model by induction on the structure of π. When π = o, [[π]]D = V , a basic model. Suppose that π is of the sort ι → π′. Then [[π]]D = D → [[π ′]]D, which is a basic model, since [[π ′]]D is a model by the induction hypothesis. Finally, let π be of the sort π1 → π2. By the induction hypothesis, [[πi]]D is a model for i = 1, 2. Thus, by Lemma 12, [[π]]D = [[[π1]]D m → [[π2]]D] is also a basic model.\nRemark 2 Let C denote the category of all basic models and α-monotonic functions. The above results show that C is cartesian closed, since for all basic models A,B, the evaluation function eval : (A×B)×A → B is α-monotonic (in both arguments) for all α < κ.\nIndeed, suppose that f, g ∈ [A m → B] and x, y ∈ A with f ⊑α g and x ⊑α y. Then eval(f, x) = f(x) ⊑α g(x) = eval(g, x) by the pointwise definition of f ⊑α g. Also, eval(f, x) = f(x) ⊑α f(y) = eval(f, y) since f is α-monotonic.\nSince C is cartesian closed, for all f ∈ [B×A m → C] there is a unique Λf ∈ [B m → [A m →C]]\nin with f(y, x) = eval(Λf(y), x) for all x ∈ A and y ∈ B."
    }, {
      "heading" : "Appendix B Proofs of Lemmas 3, 4 and 5",
      "text" : "Lemma 3 Let E : ρ be an expression and let D be a nonempty set. Moreover, let s be a state over D and let I be an interpretation over D. Then, [[E]]s(I) ∈ [[ρ]]D."
    }, {
      "heading" : "Proof",
      "text" : "If ρ = ι then the claim is clear. Let E be of a predicate type π. We prove simultaneously the following auxiliary statement. Let α < κ, V : π, x, y ∈ [[π′]]D. If x ⊑α y then [[E]]s[V/x](I) ⊑α [[E]]s[V/y](I). The proof is by structural induction on E. We will cover only the nontrivial cases.\nCase (E1 E2): The main statement follows directly by the induction hypothesis of E1 and E2. There are two cases. Suppose that E1 : π1 → π and E2 : π1. Then [[E1]]s(I) ∈ [[π1 → π]]D = [[[π1]]D m → [[π]]D] and [[E2]]s(I) ∈ [[π1]]D by the induction hypothesis. Thus, [[E1]]s(I) ([[E]]s(I)) ∈ [[π]]D. Suppose now that E1 : ι → π and E2 : ι. Then [[E1]]s(I) ∈ [[ι → π]]D = D → [[π]]D by the induction hypothesis and [[E2]]s(I) ∈ [[ι]]D = D. It follows again that [[E1]]s(I) ([[E]]s(I)) ∈ [[π]]D. Auxiliary statement: Let x, y ∈ [[π′]]D and assume x ⊑α y. We have by definition\n[[(E1 E2)]]s[V/x](I) = [[E1]]s[V/x](I) ([[E2]]s[V/x](I)), and similarly for [[(E1 E2)]]s[V/y](I). We have E1 : π1 → π and E2 : π1 or E1 : ι → π and E2 : ι. In the first case, by induction hypothesis [[E1]]s[V/x](I) ∈ [[π1 → π]]D, and thus is α-monotonic. Also, [[E1]]s[V/x](I) ⊑α [[E1]]s[V/y](I) and [[E2]]s[V/x](I) ⊑α [[E2]]s[V/y](I) by the induction hypothesis. It follows that\n[[E1]]s[V/x](I) ([[E2]]s[V/x](I)) ⊑α [[E1]]s[V/x](I) ([[E2]]s[V/y](I)) ⊑α [[E1]]s[V/y](I) ([[E2]]s[V/y](I)).\nThe second case is similar. We have [[E1]]s[V/x](I) ⊑α [[E1]]s[V/y](I) by the induction hypothesis, moreover, [[E2]]s[V/x](I) = [[E2]]s[V/y](I). Therefore, [[E1]]s[V/x](I) ([[E2]]s[V/x](I)) ⊑α [[E1]]s[V/y](I) ([[E2]]s[V/y](I)). Case (λV.E): Assume V : ρ1 and E : π2. We will show that [[λV.E]]s(I) ∈ [[ρ1 → π2]]D. If ρ1 = ι then the result follows easily from the induction hypothesis of the first statement. Assume ρ1 = π1. We show that [[λV.E]]s(I) ∈ [[π1 → π2]]D, that is, λd.[[E]]s[V/d](I) is α-monotonic for all α < κ. That follows directly by the induction hypothesis of the auxiliary statement.\nAuxiliary statement: It suffices to show that [[(λU.E)]]s[V/x](I) ⊑α [[(λU.E)]]s[V/y](I) and equivalently for every d, [[E]]s[V/x][U/d](I) ⊑α [[E]]s[V/y][U/d](I) which follows from induction hypothesis.\nLemma 4 Let P be a program. Then, IP is a complete lattice and a basic model."
    }, {
      "heading" : "Proof",
      "text" : "From Lemma 2 we have that for all predicate types π, [[π]]UP is a complete lattice and a basic model. It follows, by Lemma 9, that for all predicate types π, Pπ → [[π]]UP is also a complete lattice and a model, where Pπ is the set of predicate constants of type π. Then, IP is ∏\nπ Pπ → [[π]]UP which is also a basic model (proved in (Ésik and Rondogiannis\n2014)).\nLemma 5 (α-Monotonicity of Semantics) Let P be a program and let E : π be an expression. Let I, J be Herbrand interpretations and s be a Herbrand state of P. For all α < κ, if I ⊑α J then [[E]]s(I) ⊑α [[E]]s(J)."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by structural induction on E.\nInduction Base: The cases V, false, true are straightforward since their meanings do not depend on I. Let I ⊑α J . If E is a predicate constant p then we have I(p) ⊑α J(p).\nInduction Step: Assume that the statement holds for expressions E1 and E2 and let I ⊑α J .\nCase (E1 E2): It holds [[(E1 E2)]]s(I) = [[E1]]s(I)([[E2]]s(I)). By induction hypothesis we have [[E1]]s(I) ⊑α [[E1]]s(J) and therefore [[E1]]s(I)([[E2]]s(I)) ⊑α [[E1]]s(J)([[E2]]s(I)). We perform a case analysis on the type of E2. If E2 is of type ι and since I, J are Herbrand interpretations, it is clear that [[E2]]s(I) = [[E2]]s(J) and therefore [[E1]]s(I)([[E2]]s(I)) ⊑α [[E1]]s(J)([[E2]]s(J)). By definition of application we get [[(E1 E2)]]s(I) ⊑α [[(E1 E2)]]s(J). If E2 is of type π then by induction hypothesis we have [[E2]]s(I) ⊑α [[E2]]s(J) and since\n[[E1]]s(J) is α-monotonic we get that [[E1]]s(J)([[E2]]s(I)) ⊑α [[E1]]s(J)([[E2]]s(J)). By transitivity of ⊑α and by the definition of application we conclude that [[(E1 E2)]]s(I) ⊑α [[(E1 E2)]]s(J). Case (λV.E1): It holds by definition that [[(λV.E1)]]s(I) = λd.[[E1]]s[V/d](I). It suffices to show that λd.[[E1]]s[V/d](I) ⊑α λd.[[E1]]s[V/d](J) and equivalently that for every d, [[E1]]s[V/d](I) ⊑α [[E1]]s[V/d](J) which holds by induction hypothesis. Case (E1 ∨ π E2): It holds [[(E1 ∨ π E2)]]s(I) = ∨ {[[E1]]s(I), [[E2]]s(I)}. It suffices to show that ∨\n{[[E1]]s(I), [[E2]]s(I)} ⊑α ∨ {[[E1]]s(J), [[E2]]s(J)} which holds by induction hypoth-\nesis and Axiom 4. Case (E1 ∧ π E2): It holds [[(E1 ∧ π E2)]]s(I) = ∧ {[[E1]]s(I), [[E2]]s(I)}. Let π = ρ1 → · · · → ρn → o, it suffices to show for all di ∈ [[ρi]]UP , ∧ {[[E1]]s(I) d1 · · · dn, [[E2]]s(I) d1 · · · dn} ⊑α ∧\n{[[E1]]s(J) d1 · · · dn, [[E2]]s(J) d1 · · · dn}. We define xi = [[Ei]]s(I) d1 · · · dn and yi =\n[[Ei]]s(J) d1 · · · dn for i ∈ {1, 2}. We perform a case analysis on v = ∧\n{x1, x2}. If v < Fα or v > Tα then ∧ {x1, x2} = ∧ {y1, y2} and thus ∧ {x1, x2} ⊑α ∧ {y1, y2}. If v = Fα then Fα ≤ ∧ {y1, y2} ≤ Tα and therefore ∧ {x1, x2} ⊑α ∧ {y1, y2}. If v = Tα then ∧ {y1, y2} = Tα and thus ∧ {x1, x2} ⊑α ∧ {y1, y2}. If Fα < v < Tα then Fα < ∧ {y1, y2} ≤ Tα and therefore ∧ {x1, x2} ⊑α ∧ {y1, y2}.\nCase (∼ E1): Assume order([[E1]]s(I)) = α. Then, by induction hypothesis [[E1]]s(I) ⊑α [[E1]]s(J) and thus order([[E1]]s(J)) ≥ α. It follows that order([[(∼ E1)]]s(I)) > α and order([[(∼E1)]]s(J)) > α and therefore [[(∼E1)]]s(I) ⊑α [[(∼E1)]]s(J). Case (∃V.E1): Assume V is of type ρ. It holds [[(∃V.E1)]]s(I) = ∨\nd∈[[ρ]] UP\n[[E1]]s[V/d](I). It\nsuffices to show ∨\nd∈[[ρ]] UP\n[[E1]]s[V/d](I) ⊑α ∨\nd∈[[ρ]] UP\n[[E1]]s[V/d](J) which holds by induc-\ntion hypothesis and Axiom 4."
    }, {
      "heading" : "Appendix C Proof of Theorem 2",
      "text" : "We start by providing some necessary background material from (Ésik and Rondogiannis 2014) on how the d operation on a set of interpretations is actually defined.\nLet x ∈ V . For every X ⊆ (x]α we define d α X as follows: if X = ∅ then d α X = Tα,\notherwise\nl α X =\n{\n∧ X order( ∧ X) ≤ α\nTα+1 otherwise\nLet P be a program, I ∈ IP be a Herbrand interpretation of P and X ⊆ (I]α. For all predicate constants p in P of type ρ1 → · · · → ρn → o and di ∈ [[ρi]]UP and for all\ni = {1, . . . , n}, it holds d α X as ( d α X)(p) d1 · · · dn = d α{I(p) d1 · · · dn : I ∈ X}.\nLet X be a nonempty set of Herbrand interpretations. By Lemma 4 we have that IP is a complete lattice with respect to ≤ and a basic model. Moreover, by Lemma 1 it follows that IP is also a complete lattice with respect to ⊑. Thus, there exist the least upper bound and greatest lower bound of X for both ≤ and ⊑. We denote the greatest lower bound of X as ∧ X and d X with respect to relations ≤ and ⊑ respectively. Then, d X can be constructed in an symmetric way to the least upper bound construction described in (Ésik and Rondogiannis 2014). More specifically, for each ordinal α < κ we define the sets Xα, Yα ⊆ X and xα ∈ IP, which are then used in order to obtain d X .\nLet Y0 = X and x0 = d 0 Y0. For every α, with 0 < α < κ we define Xα = {x ∈\nX : ∀β ≤ α x =α xα}, Yα = ⋂ β<αXβ ; moreover, xα = d α Yα if Yα is nonempty and xα = ∧ β<α xβ if Yα is empty.\nFinally, we define x∞ = ∧ α<κ xα. In analogy to the proof of (Ésik and Rondogiannis 2014) for the least upper bound it can be shown that x∞ = d X with respect to the relation ⊑. Moreover, it is easy to prove that by construction it holds xα =α xβ and xβ ≥ xα for all β < α.\nLemma 14\nLet P be a program, α < κ and Mα be a Herbrand model of P. Let M ⊆ (Mα]α be a nonempty set of Herbrand models of P. Then, d\nα M is also a Herbrand model of P."
    }, {
      "heading" : "Proof",
      "text" : "Assume d\nα M is not a model. Then, there exists a clause p ← E in P and di ∈\n[[ρi]]D such that [[E]]( d α M) d1 · · · dn > ( d α M)(p) d1 · · · dn. Since for every N ∈ M\nwe have d α M ⊑α N , using Lemma 5 we conclude [[E]]( d\nα M) ⊑α [[E]](N). Let x =d α{N(p) d1 · · · dn : N ∈ M}. By definition, x = ( d α M)(p) d1 · · · dn.\nIf order(x) = α then x = ∧\n{N(p) d1 · · · dn : N ∈ M}. If x = Tα then for all N ∈ M\nwe have N(p) d1 · · · dn = Tα. Moreover, [[E]]( d α M) d1 · · · dn > Tα and by α-monotonicity we have [[E]](N) d1 · · · dn > Tα for all N ∈ M. Then, N(p) d1 · · · dn < [[E]](N) d1 · · · dn and therefore N is not a model (contradiction). If x = Fα then there exists N ∈ M such that N(p) d1 · · · dn = Fα and since N is a model we have [[E]](N) d1 · · · dn ≤ Fα. But then, it follows [[E]]( d α M) d1 · · · dn ≤ Fα and [[E]]( d α M) d1 · · · dn ≤ x (contradiction).\nIf order(x) < α then x = Mα(p) d1 · · · dn. If x = Tβ then [[E]]( d α M) d1 · · · dn > Tβ and [[E]](Mα) d1 · · · dn > Tβ . Then, we have Mα(p) d1 · · · dn < [[E]](Mα) and thus Mα is not a model of P (contradiction). If x = Fβ then [[E]](Mα) d1 · · · dn ≤ Fβ and by α-monotonicity [[E]]( d α M) d1 · · · dn ≤ Fβ . Therefore, [[E]]( d α M) d1 · · · dn ≤ x (contradiction).\nIf order(x) > α then x = Tα+1 and there exists modelN ∈ M such thatN(p) d1 · · · dn <\nTα. Moreover, we have [[E]]( d α M) d1 · · · dn ≥ Tα and by α-monotonicity we conclude [[E]](N) d1 · · · dn ≥ Tα. But then, [[E]](N) d1 · · · dn > N(p) d1 · · · dn and therefore N is not a model of P (contradiction).\nIn the following, we will make use of the following lemma that has been shown in (Ésik\nand Rondogiannis 2014, Lemma 3.18):\nLemma 15\nIf α ≤ κ is an ordinal and (xβ)β<α is a sequence of elements of L such that xβ =β xγ and xβ ≤ xγ (xβ ≥ xγ) whenever β < γ < α, and if x = ∨ β<α xβ (x = ∧ β<α xβ), then xβ =β x holds for all β < α.\nLemma 16\nLet (Mα)α<κ be a sequence of Herbrand models of P such that Mα =α Mβ and Mβ ≤ Mα for all α < β < κ. Then, ∧\nα<κ Mα is also a Herbrand model of P."
    }, {
      "heading" : "Proof",
      "text" : "Let M∞ = ∧ α<κ Mα and assume M∞ is not a model of P. Then, there is a clause p ← E and di ∈ [[ρi]]D such that [[E]](M∞) d1 · · · dn > M∞(p) d1 · · · dn. We define xα = Mα(p) d1 · · · dn, x∞ = M∞(p) d1 · · · dn, yα = [[E]](Mα) d1 · · · dn and y∞ = [[E]](M∞) d1 · · · dn for all α < κ. It follows from Lemma 15 that M∞ =α Mα and thus x∞ =α xα for all α < κ. Moreover, using α-monotonicity we also have [[E]](M∞) =α [[E]](Mα) and thus y∞ =α yα for all α < κ. We distinguish cases based on the value of x∞.\nAssume x∞ = Tδ for some δ < κ. It follows by assumption that y∞ > Tδ. Then, since x∞ =δ xδ it follows xδ = Tδ. Moreover, since y∞ =δ yδ and order(y∞) < δ it follows yδ = y∞ > Tδ. But then, yδ > xδ (contradiction since Mδ is a model by assumption).\nAssume x∞ = Fδ for some δ < κ. Then, since x∞ =δ xδ it follows xδ = Fδ. Then, since Mδ is a model it follows yδ ≤ xδ and thus yδ ≤ Fδ. But then, since y∞ =δ yδ it follows yδ = y∞ ≤ Fδ. Therefore, y∞ ≤ x∞ that is a contradiction to our assumption that y∞ > x∞.\nAssume x∞ = 0. Then, y∞ > x∞ = 0. Let y∞ = Tβ for some β < κ. Then, since yβ =β y∞ it follows yβ = Tβ . Since Mβ is a model of P it holds Tβ = yβ ≤ xβ , that is xβ = Tγ for some γ ≤ β. Moreover, since x∞ =β xβ it follows that x∞ = Tγ that is a contradiction to our assumption that x∞ = 0.\nTheorem 2 (Model Intersection Theorem) Let P be a program and M be a nonempty set of Herbrand models of P. Then, d M is also a Herbrand model of P."
    }, {
      "heading" : "Proof",
      "text" : "We use the construction for d M described in the beginning of this appendix. More specifically, we define sets Mα, Yα ⊆ M and Mα ∈ IP. Let Y0 = M and M0 = d 0 Y0. For every α > 0, let Mα = {M ∈ M : ∀β ≤ α M =α Mα} and Yα = ⋂ β<α Mβ ;\nmoreover, Mα = d α Yα if Yα is nonempty and Mα = ∧\nβ<α Mβ if Yα is empty. Then,d M = ∧\nα<κ Mα. It is easy to see that Mα =α Mβ and Mβ ⊇ Mα for all β < α.\nWe distinguish two cases. First, consider the case when Yα is nonempty for all α < κ.\nThen, Mα = d α Yα and by Lemma 14 it follows that Mα is a model of P. Moreover, by Lemma 16 we get that M∞ = ∧ α<κ Mα is also a model of P.\nConsider now the case that there exists a least ordinal δ < κ such that Yδ is empty.\nIt holds (see (Ésik and Rondogiannis 2014)) that M∞ = ∧ α<δ Mδ. Suppose M∞ is not a model of P. Then, there is a clause p ← E, a Herbrand state s and di ∈ [[ρi]]D such that [[E]](M∞) d1 · · · dn > M∞(p) d1 · · · dn. We define xα = Mα(p) d1 · · · dn, x∞ = M∞(p) d1 · · · dn, yα = [[E]](Mα) d1 · · · dn, and y∞ = [[E]](M∞) d1 · · · dn for all β ≤ α. We distinguish cases based on the value of x∞.\nAssume x∞ = Tβ for some β < δ. It follows by assumption that y∞ > x∞ = Tβ . Then, by Lemma 15 it holds that M∞ =β Mβ and we get x∞ =β xβ and therefore xβ = Tβ. Moreover, by α-monotonicity we get [[E]](M∞) d1 · · · dn =β [[E]](Mβ) d1 · · · dn and it follows that y∞ =β yβ . Moreover, since y∞ > Tβ it follows yβ = y∞ > Tβ and yβ > xβ . Since Yβ is not empty by assumption we have that Mβ = d β Yβ and by Lemma 14 we get that Mβ is a model of P (contradiction since yβ > xβ).\nAssume x∞ = Fβ for some β < δ. Then, by Lemma 15 it holds M∞ =β Mβ and therefore x∞ =β xβ . It follows xβ = Fβ . Moreover, since Yβ is nonempty by assumption\nand by Lemma 14 it follows that Mβ = d β Yβ is a model of P and thus yβ ≤ xβ = Fβ . By α-monotonicity we get [[E]](M∞) =β [[E]](Mβ) and therefore y∞ =β yβ ≤ Fβ . It follows y∞ ≤ Fβ = x∞ (contradiction to the initial assumption y∞ > x∞).\nAssume x∞ = Tδ. By assumption we have y∞ > x∞ = Tδ. Then, let y∞ = Tγ for some γ < δ. By Lemma 15 it holds M∞ =γ Mγ and by α-monotonicity it follows [[E]](M∞) =γ [[E]](Mγ) and thus y∞ =γ yγ . It follows that yγ = Tγ . Moreover, since γ < δ we know by assumption that Yγ is nonempty and therefore Mγ = d Yγ and by Lemma 14 Mγ is a model of P. It follows Tγ = yγ ≤ xγ , that is, xγ = Tβ for some β ≤ γ < δ. Moreover, since x∞ =γ xγ it follows x∞ = Tβ that is a contradiction (since by assumption x∞ = Tδ).\nAssume x∞ = Fδ. This case is not possible. Recall that Yα is not empty for all α < δ\nand thus Mα = d Yα. By the definition of d α we observe that either d α Yα ≤ Fα ord\nα Yα ≥ Tα+1. Then, since M∞ = ∧ α<δ Mα it is not possible to have x∞ = Fδ. Assume x∞ = 0. This case does not arise. Again, Yα is not empty for all α < δ and\nthus Mα = d α Yα. Moreover, by definition of d α, xα 6= 0 for all α < δ. Moreover, since M∞ = ∧ α<δ Mα and since δ < κ it follows that the limit can be at most Tδ."
    }, {
      "heading" : "Appendix D Proofs of Lemmas 6, 7 and Theorem 3",
      "text" : "Lemma 6\nLet P be a program. For every predicate constant p : π in P and I ∈ IP, TP (I)(p) ∈ [[π]]UP ."
    }, {
      "heading" : "Proof",
      "text" : "It follows from the fact that [[π]]UP is a complete lattice (Lemma 2).\nLemma 7\nLet P be a program. Then, TP is α-monotonic for all α < κ."
    }, {
      "heading" : "Proof",
      "text" : "Follows directly from Lemma 5 and Proposition 8.\nLemma 17\nLet P be a program. Then, M ∈ IP is a model of P if and only if TP(M) ≤IP M ."
    }, {
      "heading" : "Proof",
      "text" : "An interpretation I ∈ IP is a model of P iff [[E]](I) ≤π I(p) for all clauses p ←π E in P iff ∨\n(p←E)∈P [[E]](I) ≤IP I(p) iff TP(I) ≤IP I.\nProposition 18\nLet D be a nonempty set, π be a predicate type and x, y ∈ [[π]]D. If x ≤π y and x =β y for all β < α then x ⊑α y."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by structural induction on π.\nInduction Basis: If x =β y for all β < α then either x = y or order(x), order(y) ≥ α. If x = y then x ⊑α y. Suppose x 6= y. If order(x), order(y) > α then x =α y. If x = Fα then clearly x ⊑α y. If x = Tα then Tα ≤ y and therefore y = Tα. The case analysis for y is similar.\nInduction Step: Assume that the statement holds for π. Let f, g ∈ [[ρ → π]]D and α < κ. For all x ∈ [[ρ]]D and β < α, f(x) ≤ g(x) and f(x) =β g(x). It follows that f(x) ⊑α g(x). Therefore, f ⊑α g.\nProposition 19 Let P be a program and I, J be Herbrand interpretations of P . If I ≤IP J and I =β J for all β < α then I ⊑α J ."
    }, {
      "heading" : "Proof",
      "text" : "Let I, J ∈ IP and α < κ. For all predicate constants p and β < α, I(p) ≤ J(p) and I(p) =β J(p). It follows by Proposition 18 that I(p) ⊑α J(p) and therefore, I ⊑α J .\nLemma 20 Let P be a program. If M is a model of P then TP(M) ⊑ M ."
    }, {
      "heading" : "Proof",
      "text" : "It follows from Lemma 17 that if M is a Herbrand model of P then TP(M) ≤IP M . If TP(M) = M then the statement is immediate. Suppose TP(M) <IP M and let α denote the least ordinal such that TP(M) =α M does not hold. Then, TP(M) =β M for all β < α. Since TP(M) <IP M , by Proposition 19 it follows that TP(M) ⊑α M . Since TP(M) =α M does not hold, it follows that TP(M) ❁α M . Therefore TP(M) ⊑ M .\nTheorem 3 (Least Fixed Point Theorem) Let P be a program and let M be the set of all its Herbrand models. Then, TP has a least fixed point MP. Moreover, MP = d M."
    }, {
      "heading" : "Proof",
      "text" : "It follows from Lemma 7 and Theorem 1 that TP has a least pre-fixed point with respect to ⊑ that is also a least fixed point. Let MP be that least fixed point of TP, i.e., TP(MP) = MP. It is clear from Lemma 17 that MP is a model of P, i.e., MP ∈ M. Then, it followsd M ⊑ MP. Moreover, from Theorem 2 it is implied that d M is a model and thus from Lemma 20, d M is a pre-fixed point of TP with respect to ⊑. Since MP is the least pre-fixed point of P, MP ⊑ d M and thus MP = d M."
    } ],
    "references" : [ {
      "title" : "An improved extensionality criterion for higher-order logic programs",
      "author" : [ "M. Bezem" ],
      "venue" : "Proceedings of the 15th International Workshop on Computer Science Logic (CSL). SpringerVerlag, London, UK, 203–216.",
      "citeRegEx" : "Bezem,? 2001",
      "shortCiteRegEx" : "Bezem",
      "year" : 2001
    }, {
      "title" : "Extensional higher-order logic programming",
      "author" : [ "A. Charalambidis", "K. Handjopoulos", "P. Rondogiannis", "W.W. Wadge" ],
      "venue" : "JELIA, T. Janhunen and I. Niemelä, Eds. Lecture Notes in Computer Science, vol. 6341. Springer, 91–103.",
      "citeRegEx" : "Charalambidis et al\\.,? 2010",
      "shortCiteRegEx" : "Charalambidis et al\\.",
      "year" : 2010
    }, {
      "title" : "Extensional higher-order logic programming",
      "author" : [ "A. Charalambidis", "K. Handjopoulos", "P. Rondogiannis", "W.W. Wadge" ],
      "venue" : "ACM Transactions on Computational Logic 14, 3, 21:1–21:40.",
      "citeRegEx" : "Charalambidis et al\\.,? 2013",
      "shortCiteRegEx" : "Charalambidis et al\\.",
      "year" : 2013
    }, {
      "title" : "A fixed point theorem for non-monotonic functions",
      "author" : [ "Z. Ésik", "P. Rondogiannis" ],
      "venue" : "Proceedings of 13th Panhellenic Logic Symposium, Athens, Greece.",
      "citeRegEx" : "Ésik and Rondogiannis,? 2013",
      "shortCiteRegEx" : "Ésik and Rondogiannis",
      "year" : 2013
    }, {
      "title" : "A fixed point theorem for non-monotonic functions",
      "author" : [ "Z. Ésik", "P. Rondogiannis" ],
      "venue" : "CoRR abs/1402.0299. Lloyd, J. W. 1987. Foundations of Logic Programming. Springer Verlag. Pearce, D. 1996. A new logical characterisation of stable models and answer sets. In NMELP, J. Dix, L. M. Pereira, and T. C. Przymusinski, Eds. Lecture Notes in Computer Science, vol.",
      "citeRegEx" : "Ésik and Rondogiannis,? 2014",
      "shortCiteRegEx" : "Ésik and Rondogiannis",
      "year" : 2014
    }, {
      "title" : "Every logic program has a natural stratification and an iterated least fixed point model",
      "author" : [ "T.C. Przymusinski" ],
      "venue" : "PODS, A. Silberschatz, Ed. ACM Press, 11–21.",
      "citeRegEx" : "Przymusinski,? 1989",
      "shortCiteRegEx" : "Przymusinski",
      "year" : 1989
    }, {
      "title" : "Minimum model semantics for logic programs with negation-as-failure",
      "author" : [ "P. Rondogiannis", "W.W. Wadge" ],
      "venue" : "ACM Transactions on Computational Logic 6, 2, 441–467.",
      "citeRegEx" : "Rondogiannis and Wadge,? 2005",
      "shortCiteRegEx" : "Rondogiannis and Wadge",
      "year" : 2005
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. van Gelder", "K.A. Ross", "J.S. Schlipf" ],
      "venue" : "J. ACM 38,",
      "citeRegEx" : "Gelder et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelder et al\\.",
      "year" : 1991
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "1 Introduction Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming.",
      "startOffset" : 76,
      "endOffset" : 142
    }, {
      "referenceID" : 2,
      "context" : "1 Introduction Extensional higher-order logic programming has been proposed (Wadge 1991; Charalambidis et al. 2010; Charalambidis et al. 2013) as a generalization of classical logic programming.",
      "startOffset" : 76,
      "endOffset" : 142
    }, {
      "referenceID" : 2,
      "context" : "For example, consider the following simple extensional higher-order program (Charalambidis et al. 2013) stating that a band (musical ensemble) is a group that has at least a singer and a guitarist: band(B):-singer(S),B(S),guitarist(G),B(G).",
      "startOffset" : 76,
      "endOffset" : 103
    }, {
      "referenceID" : 2,
      "context" : "One basic property of all the higher-order predicates that can be defined in the language of (Charalambidis et al. 2013) is that they are monotonic.",
      "startOffset" : 93,
      "endOffset" : 120
    }, {
      "referenceID" : 2,
      "context" : "In other words, the semantics of (Charalambidis et al. 2013) is not applicable to this extended higher-order language.",
      "startOffset" : 33,
      "endOffset" : 60
    }, {
      "referenceID" : 5,
      "context" : "The solution we adopt is relatively simple to state (but non-trivial to materialize): it suffices to generalize the well-founded construction (van Gelder et al. 1991; Przymusinski 1989) to higher-order programs.",
      "startOffset" : 142,
      "endOffset" : 185
    }, {
      "referenceID" : 6,
      "context" : "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014).",
      "startOffset" : 157,
      "endOffset" : 186
    }, {
      "referenceID" : 3,
      "context" : "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014).",
      "startOffset" : 276,
      "endOffset" : 332
    }, {
      "referenceID" : 4,
      "context" : "For this purpose, we have found convenient to use a relatively recent logical characterization of the well-founded semantics through an infinitevalued logic (Rondogiannis and Wadge 2005) and also the recent abstract fixed-point theory for non-monotonic functions developed in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014).",
      "startOffset" : 276,
      "endOffset" : 332
    }, {
      "referenceID" : 6,
      "context" : "In other words, the underlying truth domain of the infinite-valued approach is: F0 < F1 < · · ·< Fω < · · ·< Fα < · · ·< 0 < · · ·< Tα < · · ·< Tω < · · ·< T1 < T0 As shown in (Rondogiannis and Wadge 2005), every logic program P with negation has a unique minimum infinite-valued model MP.",
      "startOffset" : 176,
      "endOffset" : 205
    }, {
      "referenceID" : 6,
      "context" : "As shown in (Rondogiannis and Wadge 2005), one can compute the minimum infinitevalued model as the least fixed point of an operator TP.",
      "startOffset" : 12,
      "endOffset" : 41
    }, {
      "referenceID" : 6,
      "context" : "More specifically, as it is shown in (Rondogiannis and Wadge 2005; Ésik and Rondogiannis 2014), TP is α-monotonic for all countable ordinals α, a property that guarantees the existence of the least fixed point.",
      "startOffset" : 37,
      "endOffset" : 94
    }, {
      "referenceID" : 4,
      "context" : "More specifically, as it is shown in (Rondogiannis and Wadge 2005; Ésik and Rondogiannis 2014), TP is α-monotonic for all countable ordinals α, a property that guarantees the existence of the least fixed point.",
      "startOffset" : 37,
      "endOffset" : 94
    }, {
      "referenceID" : 3,
      "context" : "3 Non-Monotonic Fixed Point Theory The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014).",
      "startOffset" : 145,
      "endOffset" : 201
    }, {
      "referenceID" : 4,
      "context" : "3 Non-Monotonic Fixed Point Theory The main results of the paper will be obtained using some recent results from nonmonotonic fixed point theory (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014).",
      "startOffset" : 145,
      "endOffset" : 201
    }, {
      "referenceID" : 3,
      "context" : "In particular, the results obtained in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene’s theorem and also the Knaster-Tarski theorem).",
      "startOffset" : 39,
      "endOffset" : 95
    }, {
      "referenceID" : 4,
      "context" : "In particular, the results obtained in (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014) generalize the classical results of monotonic fixed-point theory (namely Kleene’s theorem and also the Knaster-Tarski theorem).",
      "startOffset" : 39,
      "endOffset" : 95
    }, {
      "referenceID" : 3,
      "context" : "In this section we provide the necessary material from (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014) that will be needed in the next sections.",
      "startOffset" : 55,
      "endOffset" : 111
    }, {
      "referenceID" : 4,
      "context" : "In this section we provide the necessary material from (Ésik and Rondogiannis 2013; Ésik and Rondogiannis 2014) that will be needed in the next sections.",
      "startOffset" : 55,
      "endOffset" : 111
    }, {
      "referenceID" : 0,
      "context" : "Wadge gave a simple example (duplicated below) that revealed these problems; the example has since been used in other studies of higher-order logic programming (such as for example in (Bezem 2001)).",
      "startOffset" : 184,
      "endOffset" : 196
    }, {
      "referenceID" : 2,
      "context" : "Similarly, the higher-order language introduced in (Charalambidis et al. 2013) also disallows this kind of clauses.",
      "startOffset" : 51,
      "endOffset" : 78
    } ],
    "year" : 2014,
    "abstractText" : "Extensional higher-order logic programming has been introduced as a generalization of classical logic programming. An important characteristic of this paradigm is that it preserves all the well-known properties of traditional logic programming. In this paper we consider the semantics of negation in the context of the new paradigm. Using some recent results from non-monotonic fixed-point theory, we demonstrate that every higher-order logic program with negation has a unique minimum infinite-valued model. In this way we obtain the first purely model-theoretic semantics for negation in extensional higher-order logic programming. Using our approach, we resolve an old paradox that was introduced by W. W. Wadge in order to demonstrate the semantic difficulties of higher-order logic programming.",
    "creator" : "LaTeX with hyperref package"
  }
}