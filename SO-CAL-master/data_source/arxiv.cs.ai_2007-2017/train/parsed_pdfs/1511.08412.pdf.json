{
  "name" : "1511.08412.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "lastname@inf.unibz.it", "lastname@dis.uniroma1.it", "alessandro.solimando@unige.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 1.\n08 41\n2v 1\n[ cs\n.A I]\n2 6\nN ov\n2 01"
    }, {
      "heading" : "1 Introduction",
      "text" : "Ontology-Based Data Access (OBDA) is a popular paradigm that enables end users to access data sources through an ontology, abstracting away low level details of the data sources themselves. The ontology provides a high-level description of the domain of interest, and is semantically linked to the data sources by means of a set of mapping assertions (Calvanese et al. 2009; Giese et al. 2015). Typically, the data sources are represented as relational data, the ontology is constituted by a set of logical axioms over concepts and roles, and each mapping assertion relates an SQL query over the database to a concept or role of the ontology.\nAs an example, consider a bank domain, where we can specify that a checking account in the name of a person is a simple account by means of the axiom (expressed in description logic notation) CAcc ⊓ ∃inNameOf.Person ⊑ SAcc. We assume that the information about the accounts and their\nCopyright © 2015, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nowners is stored in a database D, and that the ontology terms CAcc, inNameOf, and Person are connected to D respectively via the mapping assertions sql1(x) CAcc(x), sql2(x, y) inNameOf(x, y) and sql3(x) Person(x), where each sql i is a (possibly very complex) SQL query over D. Suppose now that the user intends to extract all simple accounts from D. Formulating such a query directly over D would require to know precisely how D is structured, and thus could be complicated. Instead, exploiting OBDA, the user can simply query the ontology with q(x) = SAcc(x), and rely on the OBDA system to get the answers.\nMaking OBDA work efficiently over large amounts of data, requires that query answering over the ontology is first-order (FO)-rewritable1 (Calvanese et al. 2007; Artale et al. 2009), which in turn limits the expressiveness of the ontology language, and the degree of detail with which the domain of interest can be captured. The current language of choice for OBDA is DL-LiteR, the logic underlying OWL 2 QL (Motik et al. 2009), which has been specifically designed to ensure FO-rewritability of query answering. Hence, it does not allow one to express disjunctive information, and any form of recursion on the data (e.g., as resulting from qualified existentials on the left-hand side of concept inclusions), since using such constructs in general causes the loss of FO-rewritability (Calvanese et al. 2013). For this reason, in many situations the expressive power of DLLiteR is too restricted to capture real-world scenarios; e.g., the axiom in our example is not expressible in DL-LiteR.\nThe aim of this work is to overcome these limitations of DL-LiteR by allowing the use of additional constructs in the ontology. To be able to exploit the added value coming from OBDA in real-world settings, an important requirement is the efficiency of query answering, achieved through a rewriting-based approach. This is only possible for ontology languages that are FOrewritable. Two general mechanisms that have been proposed to cope with computational complexity coming from high expressiveness of ontology languages, and that allow one to regain FO-rewritability, are conservative rewriting (Lutz, Piro, and Wolter 2011) and approximation (Ren, Pan, and Zhao 2010; Console et al. 2014). Given an ontology in a powerful language, in the former approach it\n1Recall that FO queries constitute the core of SQL.\nis rewritten, when possible, into an equivalent one in a restricted language, while in the latter it is approximated, thus losing part of its semantics.\nIn this work, we significantly extend the practical impact of both approaches by bringing into the picture the mapping, an essential component of OBDA that has been ignored so far. Indeed, it is a fairly expressive component of an OBDA system, since it allows one to make use of arbitrary SQL (hence FO) queries to relate the content of the data source to the elements of the ontology. Hence, a natural question is how one can use the mapping component to capture as much as possible additional domain semantics, resulting in better approximations or more cases where conservative rewritings are possible, while maintaining a DL-LiteR ontology.\nWe illustrate how this can be done on our running example, where the non-DL-LiteR axiom can be encoded by adding the assertion sql1(x) ⊲⊳ sql2(x, y) ⊲⊳ sql3(y) SAcc(x) to the mapping. This assertion connects D directly to the ontology term SAcc by making use of a join of the SQL queries in the original mapping. We observe that the resulting mapping, together with the ontology in which the non-DL-LiteR axiom has been removed, constitutes a conservative rewriting of the original OBDA specification.\nIn this paper, we elaborate on this idea, by introducing a novel framework for rewriting and approximation of OBDA specifications. Specifically, we provide a notion of rewriting based on query inseparability of OBDA specifications (Bienvenu and Rosati 2015). To deal with those cases where it is not possible to rewrite the OBDA specification into a query inseparable one whose ontology is in DL-LiteR, we give a notion of approximation that is sound for query answering. We develop techniques for rewriting and approximation of OBDA specifications based on compiling the extra expressiveness into the mappings. We target rather expressive ontology languages, and for Horn-ALCHIQ, a Horn fragment of OWL 2, we study decidability of existence of OBDA rewritings, and techniques to compute them when they exist, and to approximate them, otherwise.\nWe have implemented our techniques in a prototype system called Ontoprox, which exploits functionalities provided by the Ontop (Rodriguez-Muro, Kontchakov, and Zakharyaschev 2013) and Clipper systems (Eiter et al. 2012) to rewrite or approximate an OBDA specification expressed in Horn-SHIQ to one that can be directly processed by any OBDA system. We have evaluated Ontoprox over synthetic and real OBDA instances against (i) the default Ontop behavior, (ii) local semantic approximation (LSA), (iii) global semantic approximation (GSA), and (iv) Clipper over materialized ABoxes. We observe that using Ontoprox, for a few queries we have been able to obtain more answers (in fact, complete answers, as confirmed by Clipper). However, for most of the queries Ontoprox showed no difference with respect to the default Ontop behavior. One reason for this is that in the real-world scenarios, the mapping designers put significant effort to manually create complex mappings that overcome the limitations of DL-LiteR. Essentially they follow the principle of the technique presented here, and therefore the resulting OBDA specifications are already “complete” by\ndesign. The observations above immediately imply a significant practical value of our approach, which can be used to facilitate the design of new OBDA specifications for existing expressive ontologies: instead of a manual compilation, which is cumbersome, error-prone, and difficult to maintain, mapping designers can write straightforward mappings, and the resulting OBDA specification can then be automatically transformed into a DL-LiteR specification with rich mappings.\nThe paper is structured as follows. In Section 2, we provide some preliminary notions, and in Section 3, we present our framework of OBDA rewriting and approximation. In Section 4, we illustrate a technique for computing the OBDA-rewriting of a given Horn-ALCHIQ specification. In Section 5, we address the problem of OBDArewritability, and show how to obtain an approximation when a rewriting does not exist. In Section 6, we discuss our prototype Ontoprox and experiments. Finally, in Section 7, we conclude the paper.\nThe omitted proofs can be found in the appendix."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We give some basic notions about ontologies and OBDA."
    }, {
      "heading" : "2.1 Ontologies",
      "text" : "We introduce some preliminary notions on ontologies. We assume to have the following pairwise disjoint countably infinite alphabets: NC of concept names, NR of role names, and NI of constants (also called individuals).\nWe consider ontologies expressed in Description Logics (DLs). Here we present the logics Horn-ALCHIQ, the Horn fragment of SHIQ without role transitivity, and DLLiteR, for which we develop some of the technical results in the paper. However, the general approximation framework is applicable to any fragment of OWL 2.\nA Horn-ALCHIQ TBox in normal form is a finite set of axioms: concept inclusions (CIs) d i Ai ⊑ C, role inclusions (RIs) R1 ⊑ R2 and role disjointness axioms R1 ⊓ R2 ⊑ ⊥, where A, Ai denote concept names, R, R1, R2 denote role names P or their inverses P−, and C denotes a concept of the form ⊥, A, ∃R.A, ∀R.A, or ≤1R.A (Kazakov 2009). For an inverse role R = P−, we use R− to denote P . ⊥ denotes the empty concept/role. A DL-LiteR TBox is a finite set of axioms of the formB1 ⊑ B2, B1⊓B2 ⊑ ⊥, R1 ⊑ R2, andR1⊓R2 ⊑ ⊥, whereBi denotes a concept of the form A or ∃R.⊤. In what follows, for simplicity we write ∃R instead of ∃R.⊤, and we use N to denote either a concept or a role name. We also assume that all TBoxes are in normal form.\nAn ABox is a finite set of membership assertions of the form A(c) or P (c, c′), where c, c′ ∈ NI. For a DL L, an L-ontology is a pair O = 〈T ,A〉, where T is an L-TBox and A is an ABox. A signature Σ is a finite set of concept and role names. An ontology O is said to be defined over (or simply, over) Σ if all the concept and role names occurring in it belong to Σ (and likewise for TBoxes, ABoxes, concept inclusions, etc.). When T is over Σ, we denote by sig(T ) the subset of Σ actually occurring in T . Moreover we denote with Ind(A), the set of individuals appearing in A.\nThe semantics, models, and the notions of satisfaction and consistency of ontologies are defined in the standard way. We only point out that we adopt the Unique Name Assumption (UNA), and for simplicity we also assume to have standard names, i.e., for every interpretation I and every constant c ∈ NI interpreted by I, we have that cI = c."
    }, {
      "heading" : "2.2 OBDA and Mappings",
      "text" : "Let S be a relational schema over a countably infinite set NS of database predicates. For simplicity, we assume to deal with plain relational schemas without constraints, and with database instances that directly store abstract objects (as opposed to values). In other words, a database instance D of S is a set of ground atoms over the predicates in NS and the constants in NI.2 Queries over S are expressed in SQL. We use ϕ(~x) to denote that query ϕ has ~x = x1, . . . , xn as free (i.e., answer) variables, where n is the arity of ϕ. Given a database instance D of S and a query ϕ over S, ans(ϕ,D) denotes the set of tuples of constants in NI computed by evaluating ϕ over D.\nIn OBDA, one provides access to an (external) database through an ontology TBox, which is connected to the database by means of a mapping. Given a source schema S and a TBox T , a (GAV) mapping assertion between S and T has the form ϕ(x) A(x) or ϕ′(x, x′) P (x, x′), where A and P are respectively concept and role names, and ϕ(x), ϕ′(x, x′) are arbitrary (SQL) queries expressed over S.\nAn OBDA specification is a triple P = 〈T ,M,S〉, where T is a DL TBox, S is a relational schema, and M is a finite set of mapping assertions. Without loss of generality, we assume that all concept and role names appearing in M are contained in sig(T ). An OBDA instance is a pair 〈P ,D〉, where P is an OBDA specification, and D is a database instance for S. This means that we can directly transfer through the mapping the objects retrieved from the database into the concepts and roles of the TBox. Indeed, given the mapping assertion ϕ(x) A(x), intuitively, the queryϕ(x) is evaluated overD and the returned set ans(ϕ,D) of objects is used to instantiate the conceptA; similarly for an assertion ϕ(x, x′) P (x, x′).\nThe semantics of an OBDA instance 〈P ,D〉, where P = 〈T ,M,S〉, is specified in terms of interpretations of the concepts and roles in T , given the database instance D. We define it by relying on the following (virtual3) ABox\nAM,D = {N(~o) | ~o ∈ ans(ϕ,D) and ϕ(~x) N(~x) in M}\ngenerated by M from D, where N is a concept or role name in T . Then, a model of 〈P ,D〉 is simply a model of the ontology 〈T ,AM,D〉.\nFollowing Di Pinto et al. (2013), we split each mapping assertion m = ϕ(~x) N(~x) in M into two parts by introducing an intermediate view name Vm for the SQL query ϕ(~x). We obtain a low-level mapping assertion of the form ϕ(~x) Vm(~x), and a high-level mapping assertion of the\n2All our results easily extend to the case where objects are constructed from retrieved database values (Calvanese et al. 2009).\n3We call such an ABox ’virtual’, because we are not interested in actually materializing its facts.\nform Vm(~x) N(~x). In our technical development, we deal only with the high-level mappings. Hence, we abstract away the low-level mapping part, and in the following we directly consider the intermediate views as our data sources."
    }, {
      "heading" : "2.3 Query Answering",
      "text" : "We consider conjunctive queries, which are the basic and most important querying mechanism in relational database systems and ontologies. A conjunctive query (CQ) q(~x) over a signature Σ is a formula ∃~y. ϕ(~x, ~y), where ϕ is a conjunction of atoms N(~z), such that N is a concept or role name in Σ, and ~z are variables from ~x and ~y. The set of certain answers to a CQ q(~x) over an ontology 〈T ,A〉, denoted cert(q, 〈T ,A〉), is the set of tuples ~c of elements from Ind(A) of the same length as ~x, such that q(~c) (considered as a FO sentence) holds in every model of 〈T ,A〉. We mention two more query classes. An atomic query (AQ) is a CQ consisting of exactly one atom whose variables are all free. A CQ with inequalities (CQ 6=) is a CQ that may contain inequality atoms between the variables of the predicate atoms.\nGiven a CQ q, an OBDA specification P = 〈T ,M,S〉 and a database D, the answer to q over the OBDA instance 〈P ,D〉, denoted cert(q,P ,D), is defined as cert(q, 〈T ,AM,D〉). Observe that, when D is inconsistent with P (i.e., 〈P ,D〉 does not have a model), then cert(q,P ,D) is the set of all possible tuples of constants in AM,D (of the same arity as q)."
    }, {
      "heading" : "3 An OBDA Rewriting Framework",
      "text" : "We extend the notion of query inseparability of ontologies (Botoeva et al. 2014) to OBDA specifications. We adopt the proposal by Bienvenu and Rosati (2015), but we do not enforce preservation of inconsistency. Definition 1. Let Σ be a signature. Two OBDA specifications P1 = 〈T1,M1,S〉 and P2 = 〈T2,M2,S〉 are Σ-CQ inseparable if cert(q,P1,D) = cert(q,P2,D), for every CQ q over Σ and every database instance D of S.\nIn OBDA, one must deal with the trade-off between the computational complexity of query answering and the expressiveness of the ontology language. Suppose that for an OBDA specification P = 〈T ,M,S〉, T is expressed in an ontology language L that does not allow for efficient query answering. A possible solution is to exploit the expressive power of the mapping layer to compute a new OBDA specification P ′ = 〈T ′,M′,S〉 in which T ′ is expressed in a language Lt more suitable for query answering than L. The aim is to encode in M′ not only M but also part of the semantics of T , so that P ′ is query-inseparable from P . This leads to the notion of rewriting of OBDA specifications. Definition 2. Let Lt be an ontology language. The OBDA specification P ′ = 〈T ′,M′,S〉 is a CQ-rewriting in Lt of the OBDA specification P = 〈T ,M,S〉 if (i) sig(T ) ⊆ sig(T ′), (ii) T ′ is an Lt-TBox, and (iii) P and P ′ are ΣCQ inseparable, for Σ = sig(T ). If such P ′ exists, we say that P is CQ-rewritable into Lt.\nWe observe that the new OBDA specification can be defined over a signature that is an extension of that of the original TBox. This is specified by condition (i). In condition (ii),\nwe impose that the new ontology is specified in the target language Lt. Finally, condition (iii) imposes that the OBDA specifications cannot be distinguished by CQs over the original TBox. Note that the definition allows for changing the ontology and the mappings, but not the source schema, accounting for the fact that the data sources might not be under the control of the designer of the OBDA specification.\nAs expected, it is not always possible to obtain a CQrewriting of P in an ontology language Lt that allows for efficient query answering. Indeed, the combined expressiveness of Lt with the new mappings might not be sufficient to simulate query answering over P without loss. In these cases, we can resort to approximating query answers over P in a sound way, which means that the answers to queries posed over the new specification are contained in those produced by querying P . Hence, we say that the OBDA specification P ′ = 〈T ′,M′,S〉 is a sound CQ-approximation in Lt of the OBDA specification P = 〈T ,M,S〉 if P ′ satisfies (i), (ii), and cert(q,P ′,D) ⊆ cert(q,P ,D), for each CQ q over sig(T ) and for each instance D of S.\nNext, we study CQ-rewritability of OBDA specifications into DL-LiteR, developing suitable techniques."
    }, {
      "heading" : "4 Rewriting OBDA Specifications",
      "text" : "In this section, we develop our OBDA rewriting technique, which relies on Datalog rewritings of the TBox (and mappings). Recall that a Datalog program (with inequalities) is a finite set of definite Horn clauses without functions symbols, i.e., rules of the form head ← ϕ, where ϕ is a finite non-empty list of predicate atoms and guarded inequalities called the body of the rule, and head is an atom, called the head of the rule, all of whose variables occur in the body. The predicates that occur in rule heads are called intensional (IDB), the other predicates are called extensional (EDB)."
    }, {
      "heading" : "4.1 ET-mappings",
      "text" : "Now, we extend the notion of T-mappings introduced by Rodriguez-Muro, Kontchakov, and Zakharyaschev (2013), and define the notion of an ET-mapping that results from compiling into the mapping the expressiveness of ontology languages that are Datalog rewritable, as introduced below.\nWe first introduce notation we need. Let Π be a Datalog program and N an IDB predicate. For a database D over the EDB predicates of Π, let N iΠ(D) denote the set of facts about N that can be deduced from D by at most i ≥ 1 applications of the rules in Π, and let N∞Π (D) = ⋃ i≥1 N i Π(D). It is known that the predicate N∞Π (·) defined by N in Π can be characterized by a possibly infinite union of CQ 6=s (Cosmadakis et al. 1988), i.e., there exist CQ 6=s ϕN0 , ϕ N 1 , . . . such that for every D, we have N∞Π (D) = ⋃ i≥0{N(~a) | ~a ∈ ans(ϕNi ,D)}. The ϕ N i ’s are called the expansions of N and can be described in terms of expansion trees (see Appendix A.1). We denote by ΦΠ(N) the set of expansion trees for N in Π, and abusing notation also the (possibly infinite) union of CQ 6=s corresponding to it. Note that ΦΠ(N) might be infinite due to the presence of IDB predicates that are recursive, i.e., either directly or indirectly refer to themselves.\nWe call a TBox T Datalog rewritable if it admits a translation ΠT to Datalog that preserves consistency and answers to AQs (see, e.g., the translations by Hustadt, Motik, and Sattler (2005), Eiter et al. (2012), and Trivela et al. (2015) for Horn-SHIQ, and by Cuenca Grau et al. (2013) for SHI). We assume that ΠT makes use of a special nullary predicate ⊥ that encodes inconsistency, i.e., for an ABox A, 〈T ,A〉 is consistent iff ⊥∞ΠT (A) is empty.\n4 We also assume that ΠT includes the following auxiliary rules, which ensure that ΠT derives all possible facts constructed over sig(T ) and Ind(A) whenever 〈T ,A〉 is inconsistent:\n⊤∆(x) ← A(x); ⊤∆(x) ← P (x, y); ⊤∆(y) ← P (x, y); A(x) ← ⊥,⊤∆(x); P (x, y) ← ⊥,⊤∆(x),⊤∆(y);\nwhere A and P respectively range over concept and role names in sig(T ), and ⊤∆ is a fresh unary predicate denoting the set of all the individuals appearing in A.\nIn the following, we denote with ΠM the (high-level) mapping M viewed as Datalog, and with ΠT ,M the Datalog program ΠT ∪ ΠM associated to a Datalog rewritable TBox T and a mappingM. From the properties of the translation ΠT (and the simple structure of ΠM), we obtain that ΠT ,M satisfies the following:\nLemma 3. Let 〈T ,M,S〉 be an OBDA specification where T is Datalog rewritable. Then, for every database instance D of S, concept or role name N of T , and ~a in Ind(AM,D), we have that 〈T ,AM,D〉 |= N(~a) iff N(~a) ∈ N∞ΠT ,M(D).\nFor a predicate N , we say that an expansion ϕN ∈ ΦΠT ,M(N) is DB-defined if ϕ\nN is defined over database predicates. Now we are ready to define ET-mappings.\nDefinition 4. Let 〈T ,M,S〉 be an OBDA specification where T is Datalog rewritable. The ET-mapping for M and T , denoted etmT (M), is defined as the set of assertions of the form ϕN (~x) N(~x) such that N is a concept or role name in T , and ϕN ∈ ΦΠT ,M(N) is DB-defined.\nIt is easy to show that, for M′ = etmT (M) and each database instance D, the virtual ABox AM′,D (which can be defined for ET-mappings as for ordinary mappings) contains all facts entailed by 〈T ,AM,D〉. In this sense, the ETmapping etmT (M) plays for a Datalog rewritable TBox T the same role as T-mappings play for (the simpler) DL-LiteR TBoxes. Note that, in general, an ET-mapping is not a mapping, as it may contain infinitely many assertions. However, AM′,D is still finite, given that it is constructed over the finite number of constants appearing in D.\n4.2 Rewriting Horn-ALCHIQ OBDA Specifications to DL-LiteR\nLet 〈T ,M,S〉 be an OBDA specification, where T is a Horn-ALCHIQ TBox over a signature Σ. Figure 1 describes the algorithm RewObda(T ,M), which constructs a DL-LiteR TBox Tr and an ET-mapping Mc such that 〈Tr,Mc,S〉 is Σ-CQ inseparable from 〈T ,M,S〉.\nIn Step 2, the algorithm applies to T1 the normalization procedure norm∃, which gets rid of concepts of the form\n4Here we simply consider A as a database.\n∃R.( d A′j) in the right-hand side of CIs. This is achieved by the following well-known substitution (Artale et al. 2009): every CI dm i=1 Ai ⊑ ∃R.( dn j=1 A\n′ j) in T1 is replaced withdm\ni=1 Ai ⊑ ∃Pnew , Pnew ⊑ R, and ⊤ ⊑ ∀Pnew .A ′ j , for 1 ≤ j ≤ n, where Pnew is a fresh role name. Notice that the latter two forms of inclusions introduced by norm∃ are actually in DL-LiteR, as ⊤ ⊑ ∀Pnew .A′j is equivalent to ∃P−\nnew ⊑ A′j . In Step 3, the algorithm applies to T2 a further normalization procedure, norm⊓, which introduces a fresh concept name AA1⊓···⊓An for each concept conjunction A1 ⊓ · · · ⊓ An appearing in T2, and adds A1 ⊓ · · · ⊓ An ≡ AA1⊓···⊓An\n5 to the TBox. Note that norm∃(T1) and norm⊓(T2) are model-conservative extensions of T1 and T2, respectively (Lutz, Walther, and Wolter 2007), as one can easily show. We denote by rew(T ) the resulting TBox Tr, which in general is exponential in the size of T , and by comp(T ,M) the resulting ET-mapping Mc, which in general is infinite. Example 5. Assume that the domain knowledge is represented by the axiom about bank accounts from Section 1. The normalization of this axiom is the TBox T b = {Person ⊑ ∀inNameOf−.A1,CAcc⊓A1 ⊑ SAcc}. Assume that the database schema Sb consists of the two relations ENT(ID, TYPE,EMPID), PROD(NUM,TYPE,CUSTID), whose data are mapped to the ontology terms by means of the following mapping M:\nmP: SELECT ID AS X FROM ENT WHERE ENT.TYPE=’P’ Person(X) mN: SELECT NUM AS X,CUSTID AS Y FROM PROD inNameOf(X,Y) mC: SELECT NUM AS X FROM PROD P WHERE P.TYPE=’B’ CAcc(X)\nWe will work with the corresponding high-level mapping Mb consisting of the assertions:\nhP : {x | VPerson(x)} Person(x) hN : {x, y | VinNameOf(x, y)} inNameOf(x, y) hC : {x | VCAcc(x)} CAcc(x)\nNow, consider the OBDA specification Pb = 〈T b,Mb,Sb〉. The RewObda algorithm invoked on (T b,Mb) produces:\n• The intermediate TBoxes T b1 and T b 2 coinciding with T b, and T b3 extending T\nb with ACAcc⊓A1 ≡ CAcc ⊓ A1. • The ET-mapping Mbc = etmT b\n3\n(Mb), which extends Mb\nwith the assertions {x | VinNameOf(x, y), VPerson(y)} A1(x),\n5We use ≡ to abbreviate inclusion in both directions.\n{x | VCAcc(x), VinNameOf(x, y), VPerson(y)} SAcc(x), and {x | VCAcc(x), VinNameOf(x, y), VPerson(y)} ACAcc⊓A1(x).\nThe algorithm returns the DL-LiteR TBox T br = {ACAcc⊓A1 ⊑ CAcc, ACAcc⊓A1 ⊑ A1, ACAcc⊓A1 ⊑ SAcc} and the mapping Mbc. It is possible to show that P b DL-LiteR = 〈T br ,M b c,S b〉 is a CQ-rewriting of Pb into DL-LiteR.\nThe TBox T3 obtained as an intermediate result in Step 3 of RewObda(T ,M), is a model-conservative extension of T that is tailored towards capturing in DL-LiteR the answers to tree-shaped CQs. This is obtained by introducing in Step 2 sufficiently new role names, and in Step 3 new concept names, so as to capture entailed axioms that generate the tree-shaped parts of models. On the other hand, the ET-mapping Mc = comp(T ,M) is such that it generates from a database instance a virtual ABox Av that is complete with respect to all ABox facts that might be involved in the generation of the tree-shaped parts of models of Tr and Av. This allows us to prove the main result of this section.\nTheorem 6. Let 〈T ,M,S〉 be an OBDA specification such that T is a Horn-ALCHIQ TBox, and let 〈Tr,Mc〉 = RewObda(T ,M). Then 〈T ,M,S〉 and 〈Tr,Mc,S〉 are ΣCQ inseparable, for Σ = sig(T ).\nClearly, 〈Tr,Mc,S〉 is a candidate for being a CQ-rewriting of 〈T ,M,S〉 into DL-LiteR. However, since Mc might be an infinite set, 〈Tr,Mc,S〉 might not be an OBDA specification and hence might not be effectively usable for query answering. Next we address this issue, and show that in some cases we obtain proper CQ-rewritings, while in others we have to resort to approximations."
    }, {
      "heading" : "5 Approximating OBDA Specifications",
      "text" : "To obtain from an ET-mapping a proper mapping, we exploit the notion of predicate boundedness in Datalog, and use a bound on the depth of Datalog expansion trees.\nAn IDB predicate N is said to be bounded in a Datalog program Π, if there exists a constant k depending only on Π such that, for every database D, we have NkΠ(D) = N ∞ Π (D) (Cosmadakis et al. 1988). If N is bounded in Π, then there exists an equivalent Datalog program Π′ such that ΦΠ′(N) is finite, and thus represents a finite union of CQ 6=s. It is well known that predicate boundedness for Datalog is undecidable in general (Gaifman et al. 1987). We say that Ω is a boundedness oracle if for a Datalog program Π and a predicate N it returns one of the three answers: N is bounded in Π, N is not bounded in Π, or unknown. When N is bounded, Ω returns also a finite union of CQ 6=s, denoted ΩΠ(N), defining N . Given a constant k, ΦkΠ(N) denotes the set of trees (and the corresponding union of CQ 6=s) in ΦΠ(N) of depth at most k, hence ΦkΠ(N) is always finite.\nWe introduce a cutting operator cutΩk , which is parametric with respect to the cutting depth k > 0 and the boundedness oracle Ω, which, when applied to a predicate N and a Datalog program Π, returns a finite union of CQ 6=s as follows:\ncutΩk ( N,Π ) =\n{\nΩΠ(N), if N is bounded in Π w.r.t. Ω ΦkΠ(N), otherwise.\nWe apply cutting also to ET-mappings: given an ET-mapping\netmT (M), the mapping cutΩk (etmT (M)) is the (finite) set of mapping assertions ϕN (~x) N(~x) s.t. N is a concept or role name in T , and ϕN ∈ cutΩk (N,ΠT ,M) is DB-defined.\nThe following theorem provides a sufficient condition for CQ-rewritability into DL-LiteR in terms of the well-known notion of first-order (FO)-rewritability, which we recall here: a query q is FO-rewritable with respect to a TBox T , if there exists a FO query q′ such that cert(q, 〈T ,A〉) = ans(q′,A), for every ABox A over sig(T ) (viewed as a database). It uses the fact that if an AQ is FO-rewritable with respect to a Horn-ALCHIQ TBox T , then it is actually rewritable into a union of CQ 6=s, and the fact that if T is FO-rewritable for AQs (i.e., every AQ is FO-rewritable with respect to T ), then each concept and role name is bounded in ΠT (Lutz and Wolter 2011; Bienvenu, Lutz, and Wolter 2013).\nTheorem 7. Let 〈T ,M,S〉 be an OBDA specification such that T is a Horn-ALCHIQ TBox. Further, let Tr = rew(T ) and M′ = cutΩk (comp(T ,M)), for a boundedness oracle Ω and some k > 0. If T is FO-rewritable for AQs, then 〈T ,M,S〉 is CQ-rewritable into DL-LiteR, and 〈Tr,M′,S〉 is its CQ-rewriting. Otherwise, 〈Tr ,M′,S〉 is a sound CQapproximation of 〈T ,M,S〉 in DL-LiteR.\nThe above result provides us with decidable conditions for rewritability of OBDA specifications in several significant cases. It is shown by Bienvenu, Lutz, and Wolter (2013) and Lutz and Wolter (2011) that FO-rewritability of AQs relative to Horn-SHI-TBoxes, Horn-ALCF -TBoxes, and Horn-ALCIF -TBoxes of depth two is decidable. In fact, these FO-rewritability algorithms provide us with a boundedness oracle Ω: for each concept and role name N in T , they return a FO-rewriting of the AQ N(~x) that combined with the mapping M results in ΩΠT ,M(N).\nUnfortunately, a complete characterization of CQrewritability into DL-LiteR is not possible if arbitrary FOqueries are allowed in the (low-level) mapping.\nTheorem 8. The problem of checking whether an OBDA specification with an EL ontology and FO source queries in the mapping is CQ-rewritable into DL-LiteR is undecidable.\nHowever, if we admit only unions of CQs in the (lowlevel) mapping, we can fully characterize CQ-rewritability.\nTheorem 9. The problem of checking whether an OBDA specification with a Horn-ALCHI ontology of depth one and unions of CQs as source queries in the mapping is CQrewritable into DL-LiteR is decidable."
    }, {
      "heading" : "6 Implementation and Experiments",
      "text" : "To demonstrate the feasibility of our OBDA specification rewriting technique, we have implemented a prototype system called Ontoprox6 and evaluated it over synthetic and real OBDA instances. Our system relies on the OBDA reasoner Ontop7 and the complete Horn-SHIQ CQ-answering system Clipper8, used as Java libraries. Ontoprox also relies on\n6 https://github.com/ontop/ontoprox 7 http://ontop.inf.unibz.it/ 8 http://www.kr.tuwien.ac.at/research/systems/clipper/\na standard Prolog engine and on an OWL 2 reasoner (SWIprolog9 and HermiT10, resp.).\nEssentially, Ontoprox implements the rewriting and compiling procedure described in Figure 1, but instead of computing the (possibly infinite) ET-mapping comp(T ,M), it computes its finite part cutk(comp(T ,M)). So, it gets as input an OWL 2 OBDA specification 〈TOWL2,M,S〉 and a positive integer k, and produces a DL-LiteR OBDA specification that can be used with any OBDA system. Below we describe some of the implementation details:\n(a) TOWL2 is first approximated to the Horn-SHIQ TBox T by dropping the axioms outside this fragment.\n(b) T is translated into a (possibly recursive) Datalog program Π and saturated with all CIs of the form d Ai ⊑\n∃R.( d\nA′j), using functionalities provided by Clipper.\n(c) The expansions cutk(ΦΠ(X)) are computed by an auxiliary Prolog program using Prolog meta-programming.\n(d) To produce actual mappings that can be used by an OBDA reasoner, the views in the high-level mapping cutk(comp(T ,M)) are replaced with their original SQL definitions using functionalities of Ontop.\n(e) The DL-LiteR closure is computed by relying on the OWL 2 reasoner for Horn-SHIQ TBox classification.\nFor the experiments, we have considered two scenarios:\nUOBM. The university ontology benchmark (UOBM) (Ma et al. 2006) comes with a SHOIN ontology (with 69 concepts, 35 roles, 9 attributes, and 204 TBox axioms), and an ABox generator. We have designed a database schema for the generated ABox, converted the ABox to a 10MB database instance for the schema, and manually created the mapping, consisting of 96 assertions11.\nAmong others, we have considered the following queries:\nQu1 : SELECT DISTINCT ?X WHERE { ?X a ub:Person . }\nQu2 : SELECT DISTINCT ?X WHERE { ?X a ub:Employee . }\nQu3 : SELECT DISTINCT ?X ?Y WHERE { ?X rdf:type ub:ResearchGroup . ?X ub:subOrganizationOf ?Y . }\n9 http://www.swi-prolog.org/\n10 http://hermit-reasoner.com/ 11 https://github.com/ontop/ontop-examples/tree/master/aaai-2016-ontoprox/uobm\nTable 1: Query evaluation with respect to 5 setups (number of answers / running time in seconds)\nOntop LSA GSA Ontoprox Clipper\nUOBM Qu1 14,129 / 1.02 14,197 / 0.50 14,197 / 1.50 14,197 / 0.68 14,197 / 20.7 Qu2 1,105 / 0.13 2,170 / 0.38 2,170 / 1.22 2,170 / 0.68 2,170 / 20.6 Qu3 235 / 0.10 235 / 0.44 235 / 1.76 247 / 0.31 247 / 22.1 Qu4 19 / 0.08 19 / 0.26 19 / 0.91 38 / 0.28 38 / 21.0\nTelecom Qt1 0 / 3.05 0 / 0.64 0 / 2.09 82,455 / 5.05 N/A Qt2 0 / 0.66 0 / 0.17 0 / 0.72 16,487 / 224 N/A Qt3 5,201,363 / 152 5,201,363 / 203 5,201,363 / 817 5,260,346 / 483 N/A\nQu4 : SELECT DISTINCT ?X ?Y ?Z WHERE { ?X rdf:type ub:Chair . ?X ub:worksFor ?Y .\n?Y rdf:type ub:Department . ?Y ub:subOrganizationOf ?Z . }\nTelecom benchmark. The telecommunications ontology models a portion of the network of a leading telecommunications company, namely the portion connecting subscribers to the operating centers of their service providers. The current specification consists of an OWL 2 ontology with 152 concepts, 53 roles, 73 attributes, 458 TBox axioms, and of a mapping with 264 mapping assertions. The database instance contains 32GB of real-world data. In the following, we only provide a description of some of the queries because the telecommunications ontology itself is bound by a confidentiality agreement.\n• Query Qt1 asks, for each cable in the telecommunications network, the single segments of which the cable is composed, and the network line (from one device to another one) that the cable covers. For each cable, it also returns its bandwidth and its status (functioning, non-functioning, etc.). • Query Qt2 asks for each path in the network that runs on fiber-optic cable, to return the specific device from which the path originates, and also requires to provide the number of different channels that are available in the path. • Query Qt3 asks, for each cable in the telecommunications network, the port to which the cable is attached, the slot on the device in which the port is installed, and, for each such slot, its status and its type. For each cable, it also returns its status.\nFor each OBDA instance 〈〈T ,M,S〉,D〉, we have evaluated the number of query answers and the query answering time with respect to five different setups:\n(1) The default behavior of Ontop v1.15, which simply ignores all non-DL-LiteR axioms in T , i.e., using 〈T 1,M,S〉 where T 1 are all the DL-LiteR axioms in T .\n(2) The local semantic approximation (LSA) of T in DLLiteR, i.e., using 〈T 2,M,S〉 where T 2 is obtained as the union, for each axiom α ∈ T , of the set of DL-LiteR axioms Γ(α) entailed by α (Console et al. 2014).\n(3) The global semantic approximation (GSA) of T in DLLiteR, i.e., using 〈T 3,M,S〉 where T 3 is the DL-LiteR\nclosure of T (Pan and Thomas 2007).\n(4) Result of Ontoprox, 〈rew(T ), cut5(comp(T ,M)),S〉.\n(5) Clipper over the materialization of the virtual ABox.\nIn Table 1, we present details of the evaluation for some of the queries for which we obtained significant results. In Table 2, we provide statistics about the Ontoprox precomputations. The performed evaluation led to the following findings:\n• Compared to the default Ontop behavior, LSA produces more answers for 2 queries out of 4 for UOBM.\n• Compared to LSA, Ontoprox produces more answers for 2 queries out of 4 for UOBM, and for all Telecom queries.\n• For UOBM, Ontoprox answers are complete, as confirmed by the comparison with the results provided by Clipper. We cannot determine completeness for the Telecom queries, the Telecom database was too large and its materialization in an ABox was not feasible.\n• Query answering of Ontoprox is ~3–5 times slower than Ontop, when the result sets are of comparable size (note that for Qt2 the result set is significantly larger).\n• The size of the new DL-LiteR OBDA specifications is comparable with that of the original specifications."
    }, {
      "heading" : "7 Conclusions",
      "text" : "We proposed a novel framework for rewriting and approximation of OBDA specifications in an expressive ontology language to OBDA specifications in a weaker language, in which the core idea is to exploit the mapping layer to encode part of the semantics of the original OBDA specification, and we developed techniques for DL-LiteR as the target language. We intend to extend our technique to Horn-SHIQ, and, more generally, to Datalog rewritable TBoxes (Cuenca Grau et al. 2013). Further, we are going to deepen our understanding of the computational complexity of deciding CQ-rewritability of OBDA specifications into DLLiteR. We also plan to carry out more extensive experiments, considering queries that contain existentially quantified variables. This will allow us to verify the effectiveness of RewObda, which was designed specifically to deal with existentially implied objects.\nAcknowledgement. This paper is supported by the EU under the large-scale integrating project (IP) Optique (Scal-\nable End-user Access to Big Data), grant agreement n. FP7318338. We would like to thank Martin Rezk for insightful discussions, and Benjamin Cogrel and Elem Güzel for help with the experimentation."
    }, {
      "heading" : "A Appendix",
      "text" : "A.1 Expansion of Datalog Programs\nWe recall here the notion of the expansion trees (Cosmadakis et al. 1988). Formally, an expansion tree for a predicate N in a Datalog program Π is a finite tree ϕNΠ satisfying the following conditions: • Each node x of ϕNΠ is labeled by a pair of the form (αx, ρx), where αx is an IDB atom and ρx is an instance of a rule of Π such that the head of ρx is αx. Moreover, the variables in the body of ρx either occur in αx or they do not occur in the label of any node above x in the tree. • The IDB atom labeling the root of ϕNΠ is an N -atom. • If x is a node, where αx = Y (~t), ρx = Y (~t) ← Y1(~t1), . . . , Ym(~tm), and the IDB atoms in the body of ρx are Yi1(~t i1), . . . , Yiℓ(~t iℓ), then x has ℓ children, re-\nspectively labeled with the atoms Yi1 (~t i1), . . . , Yiℓ(~t iℓ). In particular, if ρx is an initialization rule (i.e., the body of ρx does not contain an IDB predicate), then x is a leaf.\nA.2 Proofs of Section 4.1\nIn the following, for an OBDA specification P and a database instance D, if 〈P ,D〉 has a model, we say that D is consistent with P .\nLemma 3. Let 〈T ,M,S〉 be an OBDA specification where T is Datalog rewritable. Then, for every database instance D of S, concept or role name N of T , and ~a in Ind(AM,D), we have that 〈T ,AM,D〉 |= N(~a) iff N(~a) ∈ N∞ΠT ,M(D).\nProof. We assume that the Datalog translation ΠT of T satisfies the following properties (see, e.g., Theorem 1 in (Hustadt, Motik, and Sattler 2005) and Proposition 2 in (Eiter et al. 2012)):\n⋆ for every ABox A, 〈T ,A〉 is consistent iff ⊥∞ΠT (A) is empty, and if 〈T ,A〉 is consistent, then for every concept or role name N of T and ~a in Ind(A), 〈T ,A〉 |= N(~a) iff N(~a) ∈ N∞ΠT (A).\nRecall that for an ABox A such that 〈T ,A〉 is inconsistent, 〈T ,A〉 entails all possible facts of the form N(~a) for a concept or role name N of T and ~a in Ind(AM,D). We prove that the translation ΠT containing the auxiliary rules involving ⊤∆ and ⊥ satisfies a stronger property:\n⋆⋆ for every ABox A, for every concept or role name N of T and ~a in Ind(A), 〈T ,A〉 |= N(~a) iff N(~a) ∈ N∞ΠT (A).\nIndeed, it is easy to see that considering that (i) ⊤∆ contains precisely Ind(A), i.e., ⊤∆(a) ∈ ⊤∆ ∞ ΠT (A) for each a ∈ Ind(A), and (ii) if ⊥ is true in ΠT (A), then for each concept or role name N of T and ~a in Ind(AM,D), we have that N(~a) ∈ N∞ΠT (A).\nAs ΠT ,M = ΠT ∪ ΠM, the statement of the lemma follows directly from the property ⋆⋆ of ΠT and the fact that the rules in ΠM connect two disjoint vocabularies.\nLemma 10. Let 〈T ,M,S〉 be an OBDA specification where T is Datalog rewritable, and M′ = etmT (M). Then for every database instance D of S, we have that AM′,D is exactly the set of all facts entailed by 〈T, AM,D〉, i.e., assertions of the form A(a), P (a, b) for a, b ∈ Ind(AM,D), A,P ∈ sig(T ).\nProof. Let D be a database instance of S, a ∈ Ind(AM,D), A a concept name in sig(T ). Then\n• 〈T, AM,D〉 |= A(a) iff (by Lemma 3) • A(a) ∈ A∞ΠT ,M(D) iff (by the properties of expansions)\n• there exists DB-defined ϕ ∈ ΦΠT ,M(A) such that a ∈ ans(ϕ,D).\nLet 〈T, AM,D〉 |= A(a). By construction of M′, the mapping assertion ΦΠT ,M(A) A(x) is in M\n′. We conclude that A(a) ∈ AM′,D . Now, assume that A(a) ∈ AM′,D . It follows that in M′ there is a mapping assertion ΦΠT ,M(A) A(x) and a ∈ ans(ϕ,D) for some ϕ ∈ ΦΠT ,M(A). We conclude that 〈T, AM,D〉 |= A(a).\nThe proof for role assertions is analogous.\nA.3 Proof of Theorem 6 We start by showing a sufficient condition for Σ-CQ inseparability of OBDA specifications.\nA homomorphism between two interpretations is a mapping between their domains that preserves constants and relations. A model of an ontology O that can be homomorphically embedded in every model of O is called a canonical model of O, from now on denoted CO . The notion of canonical model is important in the context of CQ answering, since answers to CQs are preserved under homomorphisms, i.e., if q(~a) holds in an interpretation I, and there is a homomorphism from I to an interpretation I ′, then q(~a) holds in I ′ (Chandra and Merlin 1977). It follows that certain answers can be characterized as the answers over the canonical model.\nLemma 11. Let O = 〈T ,A〉 be a consistent ontology that has a canonical model CO, q(~x) a CQ, and ~a a tuple from Ind(A). Then ~a ∈ cert(q,O) iff CO satisfies q(~a).\nIt is well known that Horn variants of DLs have the canonical model property (Eiter et al. 2012; Botoeva et al. 2014), i.e., every satisfiable ontology O admits a (possibly infinite) canonical model.\nA Σ-homomorphism is a mapping that preserves constants and relations in Σ. Given two interpretations I and J , we say that I is (Σ-)homomorphically embeddable into J if there exists a (Σ-)homomorphism from I to J . Moreover, I and J are (Σ-)homomorphically equivalent if they are (Σ-)homomorphically embeddable into each other. The following characterization can be easily derived from Lemma 11, the property of canonical models, and the definitions of certain answers.\nLemma 12. Let Σ be a signature, and P1 = 〈T1,M1,S〉 and P2 = 〈T2,M2,S〉 two OBDA specifications. Assume that for every ABox A, both 〈T1,A〉 and 〈T2,A〉 admit a canonical model. If\n• for every database instance D of S that is consistent with both P1 and P2, we have that C〈T1,AM1,D〉 and C〈T2,AM2,D〉 are Σ-homomorphically equivalent, and • for every database instance D of S that is inconsistent with P1 or P2, we have that 〈T1,AM1,D〉 and 〈T2,AM2,D〉 entail the same ABox facts over Σ,\nthen P1 and P2 are Σ-CQ inseparable.\nNow we show several properties of the intermediate and final TBoxes obtained during the RewObda(T ,M) procedure. First, we show that, for ABoxes containing a single assertion, the DL-LiteR TBox Tr generates a canonical model equivalent to the canonical model generated by the intermediate Horn-ALCHIQ TBox T3.\nLemma 13. Let T be a Horn-ALCHIQ TBox, T3 the TBox obtained in step 3 of RewObda(T ,M), and Tr = rew(T ). Also, for A a concept name in sig(T3) and a ∈ NI, let A = {A(a)} be an ABox such that 〈T3,A〉 is consistent. Then C〈T3,A〉 is homomorphically equivalent to C〈Tr,A〉.\nProof. In this proof, we call an element σ′ a successor of σ in a canonical model C of 〈T ,A〉, for σ, σ′ ∈ ∆C , if σ′ is added (i.e., generated) to satisfy an existential assertion α of the form d Ai ⊑ ∃( d Qj).( d A′k) such that σ ∈ ACi . Here we assume a construction of the canonical model that is “minimal” and uniquely defined: a new successor σ′ of σ is generated only if there is no other element δ of ∆C that can be used to satisfy α, in this case we employ the following naming convention: σ′ is a path of the form σ ·w({Qj},{A′k}). In particular, if there is a role P in T such that it only appears on the left-hand side of role inclusions, and T |= { d Ai ⊑ ∃P, P ⊑ Qj , ∃P− ⊑ A′k}, then σ has to have a successor δ introduced to satisfy the assertion d Ai ⊑ ∃P , so δ can be used to satisfy α and no new successor σ′ is generated. Also, if the predecessor δ′ of σ is such that δ′ ∈ (A′k)\nC and (σ, δ′) ∈ QCj , then no new successor is introduced. Here, we call each fresh role name Pnew introduced by the normalization procedure norm∃ a generating DL-LiteR-role precisely because it satisfies the above properties. Note that for a generating DL-LiteR-role P , the concept ∃P− has no non-empty sub-concepts and P does not appear in constructs ∃P .C where C is a concept distinct from ⊤. Therefore, the element introduced as a P -successor of σ can be simply named σ · wP (or σ · vP to distinguish between two canonical models).\nObserve that sig(T3) = sig(Tr). Let A be a satisfiable concept name in sig(T3), andA = {A(a)}. Denote by C1 the canonical model of 〈T3,A〉, and by C2 the canonical model of 〈Tr,A〉.\nFirst, for each element in ∆C1 distinct from a, we prove that it is of the form aw1 · · ·wn, where each wi = wP for some generating DL-LiteR-role P . Suppose that σ ∈ ∆C1 , σ ∈ BC1i , 1 ≤ i ≤ k, and T3 |= α where α = B1 ⊓ · · · ⊓ Bk ⊑ ∃Q.(A1 ⊓ · · · ⊓ Am). By induction on the length of σ, we find an element δ ∈ ∆C1 such that δ ∈ AC1i , 1 ≤ i ≤ m, (σ, δ) ∈ QC1 , and δ is of the desired form. Note that without loss of generality we may assume that none of\nB1, . . . , Bk and none ofA1, . . . , Am is a fresh concept name introduced by norm⊓ as we can substitute each such name with its definition. Therefore, {B1, . . . , Bk, A1, . . . , Am} ⊆ sig(T ). Consider the following cases: (a) If Q ∈ sig(T ), then by step 1 α ∈ T1, and by norm∃ in step 2, T2 (hence, T3) contains axioms B1 ⊓ · · · ⊓Bk ⊑ ∃P , P ⊑ Q, ∃P− ⊑ Ai, 1 ≤ i ≤ m, for a fresh role name P . If σ = a, then we set δ = awP ∈ ∆C1 , for which it holds that that awP ∈ A C1 i , 1 ≤ i ≤ m, and (a, awP ) ∈ Q\nC1 . If σ = σ′wS for some generating DL-LiteR-role S, and it is not the case that T3 |= S ⊑ Q− and σ′ ∈ A C1 i , then we set δ = σwP , for which we have that σwP ∈ A C1 i , 1 ≤ i ≤ m, and (σ, σwP ) ∈ QC1 . Otherwise we set δ = σ′, which is of the desired form. (b) If Q /∈ sig(T ), then Q is a fresh generating DL-LiteR role introduced by norm∃. It means that there exists a CId A′j ⊑ ∃S.( d A′′l ) in T1 such that T2 contains axiomsd\nA′j ⊑ ∃Q, Q ⊑ S, and ⊤ ⊑ ∀Q.A ′′ l . Since Q occurs only in these axioms, it must be the case that T3 |= B1 ⊓ · · · ⊓Bk ⊑ d A′j and T3 |= d A′′l ⊑ A1 ⊓ · · · ⊓ Am. Because of the former, we obtain that σ ∈ (A′j) C1 , and similarly to (a) that there is an element δ ∈ ∆C1 such that δ ∈ (A′′l )\nC1 and (σ, δ) ∈ QC1 . Because of the latter, we also have that δ ∈ AC1i , 1 ≤ i ≤ m.\nSecond, we show that there exists a Σ-homomorphism from C1 to C2, by constructing one. Let a ∈ BC1 for a basic concept B. Then it must be that T3 |= A ⊑ B. By construction, Tr |= A ⊑ B, and therefore a ∈ BC2 . So we can set h(a) = a.\nLet σ ∈ ∆C1 such that h(σ) is set, h(σ) = δ, and σwP ∈ ∆C1 . Then σ ∈ (∃P )C1 , hence δ ∈ (∃P )C2 . Since P is a generating DL-LiteR-role in T3, and Tr is derived from T3, it follows that P is a generating DL-LiteR-role in Tr, hence there exists a successor δvP ∈ ∆C2 . By construction of Tr, it follows that we can set h(σwP ) = δvP (that is, the homomorphism conditions are satisfied).\nFinally, as for a homomorphism from C2 to C1, its existence follows from the fact that T3 |= Tr: C2 is homomorphically embeddable into each model I of 〈Tr,A〉 and as T3 |= Tr, C1 is a model of 〈Tr,A〉 as well.\nIn general, however, Tr does not preserve ABox entailments for non-singleton ABoxes. Example 14. Consider the following TBox T , together with the computed T3 and Tr:\nT = {B ⊓ C ⊑ A, B ⊓ C ⊑ ∃P} T3 = T ∪ {AB⊓C ≡ B ⊓ C, AB⊓C ⊑ ∃P} Tr = {AB⊓C ⊑ A,AB⊓C ⊑ B,AB⊓C ⊑ C,AB⊓C ⊑ ∃P}\nThen, for A = {B(a), C(a)} an ABox, 〈T3,A〉 |= A(a), however 〈Tr,A〉 6|= A(a).\nNext, we extend Lemma 13 towards arbitrary ABoxes. To do so, we consider ABoxes that are closed with respect to T3, where an ABox A is closed with respect to a TBox T if A = EABox(T ,A) where EABox(T ,A) is the set of all membership assertions over sig(T ) and Ind(A) entailed by 〈T ,A〉. We say that an ABox A is complete (within\nRewObda(T ,M)), if it is closed with respect to T3. The following result is a corollary of Lemma 13.\nLemma 15. Let T be a Horn-ALCHIQ TBox, T3 the TBox obtained in step 3 of RewObda(T ,M), and Tr = rew(T ). Then for each ABoxA that is complete and such that 〈T3,A〉 is consistent, we have that C〈T3,A〉 and C〈Tr,A〉 are homomorphically equivalent.\nProof. We use the same assumptions for the canonical model as in the proof of Lemma 13. Denote by C1 the canonical model of 〈T3,A〉, and by C2 the canonical model of 〈Tr,A〉 for a complete ABox A. The existence of a homomorphism from C2 to C1 is straightforward. We show that there exists a homomorphism from C1 to C2. Let a ∈ Ind(A), it is sufficient to show that for each successor awP of a in C1, there is a successor avP of a in C2. The rest of the proof follows from Lemma 13.\nLet σ be a successor of a in C1. It follows from the proof of Lemma 13 that σ is of the form awP whereP is a generating DL-LiteR role and 〈T3,A〉 |= ∃P (a) (moreover, there exists no individual b ∈ Ind(A) such that R(a, b) ∈ A for each role R with T3 |= P ⊑ R and B(b) ∈ A for each concept name B with T3 |= ∃P− ⊑ B).\nWe show that 〈Tr,A〉 |= ∃P (a). Recall that T3 contains all possible CIs with ∃P on the right-hand side. From 〈T3,A〉 |= ∃P (a), it follows that there exists a CI A1⊓· · ·⊓ An ⊑ ∃P in T3, n ≥ 1, such that Ai(a) ∈ A. If n = 1, then Tr |= A1 ⊑ ∃P , hence 〈Tr,A〉 |= ∃P (a). Assume that n > 1, then by step 3 T3 contains AA1⊓···⊓An ≡ A1 ⊓ · · · ⊓ An, therefore Tr contains AA1⊓···⊓An ⊑ ∃P , and since A is closed with respect to T3, A contains AA1⊓···⊓An(a). Finally, we obtain that Tr |= ∃P (a).\nNow, as no individual b can be used as a P -successor of a, in C2 there is a successor avP of a.\nThe result above is significant, because the mapping Mc = comp(T ,M) is such that it generates from a database instance a virtual ABox that is complete (within comp(T ,M)). Finally, combined with Lemmas 10 and 15, we are ready to prove Theorem 6.\nTheorem 6. Let 〈T ,M,S〉 be an OBDA specification,Σ = sig(T ), and 〈Tr,Mc〉 = RewObda(T ,M). Then, for each database instance D of S and for each Σ-query q, we have that cert(q, 〈T ,M,S〉,D) = cert(q, 〈Tr ,Mc,S〉,D).\nProof. (a) Let D be an instance of S inconsistent with 〈T ,M,S〉. By Lemma 10 AMc,D = EABox(〈T3,AM,D〉), and since D is inconsistent with 〈T3,M,S〉, we have that AMc,D contains all possible facts over sig(T ). The axioms in Tr do not add more facts.\n(b) We show that for each database instance D of S consistent with 〈T ,M,S〉, the canonical models C〈T ,AM,D〉 and C〈Tr,AMc,D〉 are Σ-homomorphically equivalent.\n(I) We observe that by Lemma 10, it follows that AMc,D is closed with respect to T3.\n(II) We show that C〈T ,A〉 is Σ-homomorphically equivalent to C〈T3,A〉, where A is an ABox and Σ = sig(T ). The interesting direction is the existence of a Σ-homomorphism\nfrom C〈T3,A〉 to C〈T ,A〉. Since T3 is a model-conservative extension of T , C〈T ,A〉 can be extended without changing the interpretations of symbols in Σ to a model I of 〈T3,A〉. By definition of canonical model, there exists a homomorphism from C〈T3,A〉 to I and since I agrees with C〈T ,A〉 on Σ, we obtain that there exists a Σ-homomorphism from C〈T3,A〉 to C〈T ,A〉.\n(III) We show that EABoxΣ(T ,AMc,D) = EABoxΣ(T ,AM,D), where Σ = sig(T ) and EABoxΣ(T ,A) is the projection of EABox(T ,A) on Σ. Assume that A(a) ∈ EABox(T3,AMc,D) such that A(a) /∈ EABox(T ,AM,D). Then A is a fresh concept introduced in step 3, hence A /∈ Σ and EABoxΣ(T3,AMc,D) = EABoxΣ(T ,AM,D). Combining it with (II), we conclude that EABoxΣ(T ,AMc,D) = EABoxΣ(T ,AM,D).\nNow, by Lemma 15 and (I), by (II) and by (III) we obtain the following (Σ-)homomorphic equivalences ≡ (≡Σ):\nC〈Tr,AMc,D〉 ≡ C〈T3,AMc,D〉 ≡Σ C〈T ,AMc,D〉 ≡Σ C〈T ,AM,D〉.\nHence, C〈Tr,AMc,D〉 and C〈T ,AM,D〉 are Σ-homomorphically equivalent.\nFinally, by Lemma 12 and (a), (b), we conclude that 〈T ,M,S〉 and 〈Tr,Mc,S〉 are Σ-CQ inseparable.\nA.4 Proofs of Section 5\nTheorem 7. Let 〈T ,M,S〉 be an OBDA specification such that T is a Horn-ALCHIQ TBox. Further, let Tr = rew(T ) and M′ = cutΩk (comp(T ,M)), for a boundedness oracle Ω and some k > 0. If T is FO-rewritable for AQs, then 〈T ,M,S〉 is CQ-rewritable into DL-LiteR, and 〈Tr,M′,S〉 is its CQ-rewriting. Otherwise, 〈Tr,M′,S〉 is a sound CQapproximation of 〈T ,M,S〉 in DL-LiteR.\nProof. We note that since T is a TBox of depth 1 (it is assumed to be in normal form), if T is FO-rewritable for AQs then by (Lutz and Wolter 2011, Lemma 5) T is FOrewritable for CQs.\nTheorem 8. The problem of checking whether an OBDA specification with an EL ontology and FO source queries in the mapping is CQ-rewritable into DL-LiteR is undecidable.\nProof. Proof by reduction from the satisfiability problem of first-order logic.\nLet ϕ be a closed first-order formula. We construct an OBDA specification P = 〈T ,M,S〉 such that P is CQrewritable into DL-LiteR iff ϕ is unsatisfiable.\nWe set T = {∃R.A ⊑ A}. S contains all predicates in ϕ, a binary relation tableR and a unary relation tableA such that tableR, tableA do not occur in ϕ. M consists of two mapping assertions: tableR(x, y) ∧ ϕ R(x, y) and tableA(x) A(x).\nAssume that ϕ is unsatisfiable. Then for each database instance D of S we have that R is empty in AM,D. It is straightforward to see that 〈∅,M,S〉 is a CQ-rewriting of P into DL-LiteR.\nAssume that ϕ is satisfiable and, for the sake of contradiction, suppose that P is CQ-rewritable into DL-LiteR and\nP ′ = 〈T ′,M′,S〉 is such a CQ-rewriting where T ′ is a DL-LiteR TBox. Now, consider an instance of the reachability problem G = (V,E) and two vertices s, t ∈ V . Let D be a database instance that satisfies ϕ and such that for each (v, u) ∈ E, (v, u) ∈ tableR and s ∈ tableA. It is the standard reduction of the reachability problem to query answering in EL, therefore t ∈ cert(A(x), 〈P ,D〉) iff t is reachable from s in G. Since P ′ is a rewriting of Pand T ′ is a DL-LiteR TBox, there exists a FO-query qA(x) such that cert(A(x), 〈P ,D〉) = cert(A(x), 〈P ′,D〉) = ans(qA(x),D). Thus, we obtain that t ∈ ans(qA(x),D) iff t is reachable from s in G. It means that we can solve the reachability problem by evaluating a FO-query over the database encoding the graph, which contradicts the NLOGSPACE-hardness of the reachability problem. Contradiction rises from the assumption that P is CQ-rewritable into DL-LiteR.\nTheorem 9. The problem of checking whether an OBDA specification with a Horn-ALCHI ontology of depth one and unions of CQs as source queries in the mapping is CQrewritable into DL-LiteR is decidable.\nProof. Let P = 〈T ,M,S〉 be an OBDA specification (here we do not split M into high- and low-level mappings). We construct a monadic Datalog programΠ without inequalities worst case exponential in the size of T and M such that\nΠ is program bounded iff P is CQ-rewritable into DL-LiteR, (1) where Π is said to be program bounded if each predicate N mentioned in Π is bounded in Π, and a Datalog program Π is monadic if all its IDB predicates are monadic (unary). It is known that program boundedness of monadic Datalog programs without inequalities in decidable in 3EXPTIME (Cosmadakis et al. 1988). Thus, we obtain a 4EXPTIME algorithm for deciding CQ-rewritability into DL-LiteR.\nLet T3 be the TBox obtained as an intermediate result in Step 3 of RewObda(T ,M). Then Π is the monadic Datalog program such that\nA∞Π (D) = A ∞ ΠT3,M (D), (2)\nfor each instance D of S and each concept A in T3,\nand ϕA is DB-defined for each ϕA ∈ ΦΠ(A). Observe that the Datalog translation ΠT3,M of the Horn-ALCHI TBox T3 is a Datalog program without inequalities. Therefore, we have that Π is a monadic Datalog program without inequalities and its program boundedness is decidable. Moreover, observe that ΦΠ1(P ) is a finite union of CQs for each role name P in T3. We first prove (1), then we show how Π is constructed.\nAssume that Π is program bounded and let Ω be a boundedness oracle for it. Note that since Π is bounded, for a concept name A, cutΩk (A,Π) does not depend on the value of k. Next, let Tr = rew(T ), and Mc be the set of • mapping assertions ϕA(x) A(x) such that A is a con-\ncept name in T3 and ϕA ∈ cutΩk (A,Π), and of • mapping assertions ϕP (x, y) P (x, y) such that P is a\nrole name in T3 and ϕP ∈ ΦΠT3,M(P ).\nIt is straightforward to see that 〈Tr,Mc,S〉 is a CQrewriting of 〈T ,M,S〉 into DL-LiteR.\nAssume that Π is CQ-rewritable into DL-LiteR and 〈T ′,M′,S〉 is its CQ-rewriting where the source queries in M′ are unions of CQs. Let N be a concept or role name in T and denote by qN (~x) the rewriting of the query N(~x) into a union of CQs over S with respect to 〈T ′,M′,S〉 (recall that the rewriting of N(~x) with respect to T ′ is a union of CQs, and since M′ contains unions of CQs as source queries, qN (~x) is also a union of CQs).\nWe construct now a Datalog program Π′ consisting of the rules N(~x) ← ϕN (~x), for a concept or role name N in T and a CQ ϕN (~x) ∈ qN (~x). Obviously, Π′ is program bounded. Since 〈T ′,M′,S〉 is a CQ-rewriting of 〈T ,M,S〉, and T3 is a model-conservative extension of T , we have that N∞Π′ (D) = N ∞ ΠT ,M (D) = N∞ΠT3,M (D), for each instance D of S and each concept or role name N in T . Next, because of (2), we have that A∞Π′(D) = A ∞ Π (D) for each instance D of S and each concept name A in T . Now, we set the finite union of CQs ΩΠ(A) for each concept name A in T3: • if A is a concept name in T , then ΩΠ(A) = ΦΠ′(A) • otherwise, A is introduced for a concept conjunctionA1⊓ · · ·⊓An in Step 3, then ΩΠ(A) is the DNF of the formula ΦΠ′(A1)∧ · · · ∧ΦΠ′(An) where each ΦΠ′ is viewed as a formula in DNF. Hence, we obtain that Π is program bounded.\nWe now show how Π is constructed from ΠT3,M. First, we remove from ΠT3,M the rules which are not reachable from the database predicates. Namely, let Π1 be the set of rules π = head ← X1, . . . , Xn in ΠT3,M such that there are sets of rules ρ1, . . . , ρm in ΠT3,M such that ρm is a set of rules from ΠM, the predicates in the bodies of the rules in ρi−1 are exactly the predicates in the heads of the rules in ρi, for 2 ≤ i ≤ m, and ρ1 = {π}. It should be clear that N∞Π1(D) = N ∞ ΠT3,M\n(D), for each instance D of S and each concept or role name N in T3.\nThenΠ is the monadic Datalog program such that for each instance D of S and each concept name A in T3, A∞Π (D) = A∞Π1(D). We obtain Π by substituting each occurrence in the body of a rule of an atom of the form R(x, y), for R a role in T , by ΦΠ1(R), and by removing all rules whose head predicates are roles. Namely for the former, let ρ = head ← ϕ,R(x, y) be a rule in Π1. Then we replace ρ with the rules, head ← ϕ, ψ, for each CQ ψ ∈ ΦΠ1(R). We repeat this procedure until we get a Datalog program Π where no atom of the form R(x, y), for a role R in T3, occurs in the a body of a rule. Observe that ΦΠ1(R) is always finite.\nIt is easy to see that Π is as required."
    } ],
    "references" : [ {
      "title" : "The DL-Lite family and relations",
      "author" : [ "Artale" ],
      "venue" : "J. of Artificial Intelligence Research",
      "citeRegEx" : "Artale,? \\Q2009\\E",
      "shortCiteRegEx" : "Artale",
      "year" : 2009
    }, {
      "title" : "R",
      "author" : [ "M. Bienvenu", "Rosati" ],
      "venue" : "2015. Query-based comparison of OBDA specifications. In Proc. of the 28th Int. Workshop on Description Logic (DL), volume",
      "citeRegEx" : "Bienvenu and Rosati 2015",
      "shortCiteRegEx" : null,
      "year" : 1350
    }, {
      "title" : "First-order rewritability of atomic queries in Horn description logics",
      "author" : [ "Lutz Bienvenu", "M. Wolter 2013] Bienvenu", "C. Lutz", "F. Wolter" ],
      "venue" : "In Proc. of the 23rd Int. Joint Conf. on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Bienvenu et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bienvenu et al\\.",
      "year" : 2013
    }, {
      "title" : "Query inseparability for description logic knowledge bases",
      "author" : [ "Botoeva" ],
      "venue" : "In Proc. of the 14th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Botoeva,? \\Q2014\\E",
      "shortCiteRegEx" : "Botoeva",
      "year" : 2014
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "Calvanese" ],
      "venue" : "J. of Automated Reasoning",
      "citeRegEx" : "Calvanese,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese",
      "year" : 2007
    }, {
      "title" : "Ontologies and databases: The DL-Lite approach",
      "author" : [ "Calvanese" ],
      "venue" : null,
      "citeRegEx" : "Calvanese,? \\Q2009\\E",
      "shortCiteRegEx" : "Calvanese",
      "year" : 2009
    }, {
      "title" : "Data complexity of query answering in description logics",
      "author" : [ "Calvanese" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Calvanese,? \\Q2013\\E",
      "shortCiteRegEx" : "Calvanese",
      "year" : 2013
    }, {
      "title" : "P",
      "author" : [ "A.K. Chandra", "Merlin" ],
      "venue" : "M.",
      "citeRegEx" : "Chandra and Merlin 1977",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "D",
      "author" : [ "M. Console", "J. Mora", "R. Rosati", "V. Santarelli", "Savo" ],
      "venue" : "F.",
      "citeRegEx" : "Console et al. 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "M",
      "author" : [ "S.S. Cosmadakis", "H. Gaifman", "P.C. Kanellakis", "Vardi" ],
      "venue" : "Y.",
      "citeRegEx" : "Cosmadakis et al. 1988",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Computing datalog rewritings beyond Horn ontologies",
      "author" : [ "Cuenca Grau" ],
      "venue" : "In Proc. of the 23rd Int. Joint Conf. on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Grau,? \\Q2013\\E",
      "shortCiteRegEx" : "Grau",
      "year" : 2013
    }, {
      "title" : "D",
      "author" : [ "F. Di Pinto", "D. Lembo", "M. Lenzerini", "R. Mancini", "A. Poggi", "R. Rosati", "M. Ruzzi", "Savo" ],
      "venue" : "F.",
      "citeRegEx" : "Di Pinto et al. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Query rewriting for Horn-SHIQ plus rules",
      "author" : [ "Eiter" ],
      "venue" : "In Proc. of the 26th AAAI Conf. on Artificial Intelligence (AAAI),",
      "citeRegEx" : "Eiter,? \\Q2012\\E",
      "shortCiteRegEx" : "Eiter",
      "year" : 2012
    }, {
      "title" : "M",
      "author" : [ "H. Gaifman", "H.G. Mairson", "Y. Sagiv", "Vardi" ],
      "venue" : "Y.",
      "citeRegEx" : "Gaifman et al. 1987",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Ö",
      "author" : [ "M. Giese", "A. Soylu", "G. Vega-Gorgojo", "A. Waaler", "P. Haase", "E. Jiménez-Ruiz", "D. Lanti", "M. Rezk", "G. Xiao", "Özçep" ],
      "venue" : "L.; and Rosati, R.",
      "citeRegEx" : "Giese et al. 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Data complexity of reasoning in very expressive description logics",
      "author" : [ "Motik Hustadt", "U. Sattler 2005] Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2005
    }, {
      "title" : "and Wolter",
      "author" : [ "C. Lutz" ],
      "venue" : "F.",
      "citeRegEx" : "Lutz and Wolter 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Description logic TBoxes: Model-theoretic characterizations and rewritability",
      "author" : [ "Piro Lutz", "C. Wolter 2011] Lutz", "R. Piro", "F. Wolter" ],
      "venue" : "In Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Lutz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2011
    }, {
      "title" : "Conservative extensions in expressive description logics",
      "author" : [ "Walther Lutz", "C. Wolter 2007] Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "In Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Lutz et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2007
    }, {
      "title" : "Towards a complete OWL ontology benchmark",
      "author" : [ "Ma" ],
      "venue" : "In Proc. of the 3rd European Semantic Web Conf. (ESWC),",
      "citeRegEx" : "Ma,? \\Q2006\\E",
      "shortCiteRegEx" : "Ma",
      "year" : 2006
    }, {
      "title" : "and Thomas",
      "author" : [ "J.Z. Pan" ],
      "venue" : "E.",
      "citeRegEx" : "Pan and Thomas 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "J",
      "author" : [ "Ren, Y.", "Pan" ],
      "venue" : "Z.; and Zhao, Y.",
      "citeRegEx" : "Ren. Pan. and Zhao 2010",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Ontology-based data access: Ontop of databases",
      "author" : [ "Kontchakov Rodriguez-Muro", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : null,
      "citeRegEx" : "Rodriguez.Muro et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Rodriguez.Muro et al\\.",
      "year" : 2013
    }, {
      "title" : "Optimising resolution-based rewriting algorithms for OWL ontologies",
      "author" : [ "Trivela" ],
      "venue" : "J. of Web Semantics",
      "citeRegEx" : "Trivela,? \\Q2015\\E",
      "shortCiteRegEx" : "Trivela",
      "year" : 2015
    }, {
      "title" : "Expansion of Datalog Programs We recall here the notion of the expansion trees (Cosmadakis et al. 1988). Formally, an expansion tree for a predicate N in a Datalog program Π is a finite tree",
      "author" : [ "A Appendix A" ],
      "venue" : null,
      "citeRegEx" : "A.1,? \\Q1988\\E",
      "shortCiteRegEx" : "A.1",
      "year" : 1988
    } ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Ontology-based data access (OBDA) is a novel paradigm facilitating access to relational data, realized by linking data sources to an ontology by means of declarative mappings. DL-LiteR, the current language of choice for OBDA, has been designed with the goal of delegating query answering to the underlying database engine, and thus is restricted in expressive power. E.g., it does not allow one to express disjunctive information, and any form of recursion on the data. The aim of this paper is to overcome these limitations of DLLiteR, and extend OBDA to more expressive ontology languages, while still leveraging the underlying relational technology for query answering. We achieve this by relying on two well-known mechanisms, namely conservative rewriting and approximation, but significantly extend their practical impact by bringing into the picture the mapping, an essential component of OBDA. Specifically, we develop techniques to rewrite OBDA specifications with an expressive ontology to “equivalent” ones with a DL-LiteR ontology, if possible, and to approximate them otherwise. We do so by exploiting the high expressive power of the mapping layer to capture part of the domain semantics of rich ontology languages. We have implemented our techniques making use of a state-of-the-art OBDA system, and we have shown their feasibility and effectiveness with experiments on synthetic and real-world data.",
    "creator" : "LaTeX with hyperref package"
  }
}