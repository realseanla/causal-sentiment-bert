{
  "name" : "1402.0575.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reasoning about Explanations for Negative Query Answers in DL-Lite",
    "authors" : [ "Diego Calvanese", "Magdalena Ortiz", "Giorgio Stefanoni" ],
    "emails" : [ "calvanese@inf.unibz.it", "ortiz@kr.tuwien.ac.at", "simkus@dbai.tuwien.ac.at", "Giorgio.Stefanoni@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Ontology-based data access (OBDA) systems are a new form of information systems that use an ontology, a set of logical constraints, to mediate the access to data. The role of the ontology in an OBDA system is twofold. On the one hand, it is an intermediate layer between the domain user and the physical data providing a unified view of the information held in the various data sources. In many cases, the ontology extends the data vocabulary by introducing new intensional predicates that can be used to query information in a more succinct and declarative way. On the other hand, the ontology provides constraints, which are taken into account while answering queries and which may contribute to enrich the obtained answers. Hence, potentially relevant implicit knowledge that can be derived from the data, plus the ontology, can be made explicit by using specifically tailored reasoning algorithms. Most existing OBDA systems are based on the DL-Lite family of lightweight Description Logics (DLs), introduced by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2007), which is also the basis for the QL profile of the OWL 2 ontology language (Motik, Fokoue, Horrocks, Wu, Lutz, & Grau, 2009).\nAs argued by McGuinness and Patel-Schneider (1998), in order to meet usability requirements set by domain users, knowledge-based systems should be equipped with explanation algorithms for reasoning services. This holds also for Description Logics, where\nc©2013 AI Access Foundation. All rights reserved.\nresearch has focused on the explanation of TBox reasoning (cf., McGuinness & Borgida, 1995; Borgida, Franconi, & Horrocks, 2000; Penaloza & Sertkaya, 2010; Horridge, Parsia, & Sattler, 2008). Additionally, Borgida, Calvanese, and Rodriguez-Muro (2008) studied the problem of explaining positive query answers to conjunctive queries over DL-Lite ontologies. In particular, they outlined a procedure for computing the reasons for a tuple to be in the answer to a query, and for minimizing the corresponding explanation shown to the user. In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining positive query answers, should also explain negative query answers; that is, those tuples that a user expects to be in the result but actually do not occur there. As OBDA systems answer queries under ontological constraints, explaining negative query answers is not trivial: these constraints need to be taken into account to understand why a required tuple is missing from the answers. A procedure for explaining negative query answers would then improve the usability of OBDA systems.\nFor this reason, we formalize this explanation problem in the context of query answering over DL ontologies. Following Eiter and Gottlob (1995), we adopt abductive reasoning ; that is, explanations are set of facts that need to be asserted in the ABox to force the required tuple to be in the result. Such explanations help users in debugging a negative answer by giving an effective way of repairing the OBDA system in terms of updates to the data layer. Since ontologies can be used to enrich the data vocabulary, we consider also restrictions to the vocabulary over which the additional assertions can be constructed. More precisely, given a DL TBox T , an ABox A, a query q, and a set Σ of predicates, an explanation for a given tuple ~c is a new ABox E , all whose predicates occur in Σ, such that the answer to q over the ontology 〈T ,A ∪ E〉 contains ~c. According to the Occam’s razor principle, an important aspect in explanations is to provide users with solutions that are simple to understand and free of redundancy, hence as small as possible. To address this requirement, we study various restrictions on explanations, in particular, we focus on subset minimal and cardinality minimal ones. We consider standard decision problems associated to logic-based abduction: (i) existence of an explanation, (ii) recognition of a given ABox as being an explanation, and (iii) relevance and (iv) necessity of an ABox assertion—that is, whether it occurs in some or all explanations. At first, the latter two problems may appear rather artificial, however, they provide valuable information to the user when debugging negative answers. Relevance can be used to test whether an assertion the user deems related to the negative answer is indeed so; whereas, necessity can be used to test whether an assertion is intrinsically related to the negative answer.\nThe idea of restricting the vocabulary of explanations is an adaptation of a concept introduced by Baader, Bienvenu, Lutz, and Wolter (2010), who study among others the query emptiness problem. That is, given a query q over a TBox T decide whether for all ABoxes A over a given signature Σ, we have that evaluating q over 〈T ,A〉 leads to an empty result. In Section 3, we shall see that in our framework deciding the existence of an explanation relates to the query non-emptiness problem. In fact, for many DLs, deciding whether a query is non-empty w.r.t. a TBox reduces to checking whether there exists an explanation for a missing answer.\nThe purpose of this paper is to shed light on the computational complexity of explaining missing answers to queries over ontologies formulated in DL-LiteA—an expressive member of the DL-Lite family of DLs. To this end, we consider two important classes of queries—\nthat is, instance queries and unions of conjunctive queries (UCQs)—and we provide computational complexity results for the four decision problems defined above. Moreover, we perform our complexity analysis under two different explanation settings. We consider the case in which the explanation vocabulary is a strict subset of the vocabulary of the ontology and the data, as well as the case in which explanations can be constructed over arbitrary predicates. In Section 4, we show that when we consider instance queries as input, the relevant decision problems are NL-complete, irrespective of the chosen explanation setting and of the particular minimality criterion applied over explanations. In Section 5, we analyze the complexity of the problem when we admit UCQs as input, and we show that the complexity varies with respect to both the chosen explanation setting and the minimality criterion. Our complexity results for UCQs are summarized in Table 5.1."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section, we first introduce ontologies formulated in DLs, with a particular focus on the DL DL-LiteA. We then introduce the languages for querying ontologies that we consider, and we recall some important properties of DL-LiteA that will be used throughout the paper. Finally, we briefly present some of the less known complexity classes that will be mentioned later."
    }, {
      "heading" : "2.1 Description Logic Ontologies",
      "text" : "As usual in DLs, we consider countably infinite sets NC , NR, and NI of atomic concepts, atomic roles, and individuals, respectively. Whenever the distinction between atomic concepts and roles is immaterial, we call an element of NC ∪NR a predicate.\nA DL TBox T is a finite set of axioms, whose form depends on the specific DL being considered; for DL-LiteA, the DL adopted in this paper, the definition is given below. A DL ABox A is a finite set of ABox assertions, which are expressions of the form A(c) or P (c, d), where A is an atomic concept, P is an atomic role, and c and d are individuals. A DL ontology is a pair O = 〈T ,A〉, where T is a DL TBox and A is a DL ABox.\nThe semantics of DL ontologies is based on first-order interpretations I = 〈∆I , ·I〉, where ∆I is a non-empty set called the domain and ·I is the interpretation function mapping each individual c ∈ NI to an object cI ∈ ∆I , each atomic concept A ∈ NC to a set AI ⊆ ∆I , and each atomic role P ∈ NR to a binary relation P I ⊆ ∆I ×∆I .\nAn interpretation I satisfies an ABox assertion A(c) if cI ∈ AI , and it satisfies an assertion P (c, d) if 〈cI , dI〉 ∈ P I . Satisfaction of TBox axioms is also defined according to their form in each specific DL; we define it below for DL-LiteA. An interpretation I is a model of 〈T ,A〉, if it satisfies all the axioms in T and all the assertions in A. We call 〈T ,A〉 consistent if it admits at least one model, and inconsistent otherwise. Also, an ABox A is consistent with a TBox T if the ontology 〈T ,A〉 is consistent.\n2.1.1 DL-LiteA\nDL-LiteA is a member of the DL-Lite family of DLs (Calvanese et al., 2007; Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodriguez-Muro, & Rosati, 2009), which has been designed for dealing efficiently with large amounts of extensional information. In DL-LiteA,\nconcept expressions (or, concepts) C, denoting sets of objects, and role expressions (or, roles) R, denoting binary relations between objects, are formed according to the following syntax, where A denotes an atomic concept and P an atomic role.1\nC −→ A | ∃R R −→ P | P−\nA DL-LiteA TBox consists of axioms of the following form.\nC1 v C2 R1 v R2\nC1 v ¬C2 R1 v ¬R2 (funct R)\nAxioms in the first column are called positive inclusions (among concepts and roles, respectively), those in the second column disjointness axioms, and those in the third column functionality assertions on roles. In order to retain tractability of reasoning, DL-LiteA TBoxes must satisfy the additional restriction that roles that are functional or inverse functional cannot be specialized. Formally, if a DL-LiteA TBox contains (funct P ) or (funct P\n−), then for each role R it does not contain Rv P or Rv P− (Calvanese et al., 2007).\nThe semantics of concept expressions is specified as follows.\n(∃R)I = {o ∈ ∆I | ∃o′ ∈ ∆I : 〈o, o′〉 ∈ RI}\n(P−)I = {〈o, o′〉 ∈ ∆I ×∆I | 〈o′, o〉 ∈ P I}\nAn interpretation I satisfies axiom α1 v α2 if αI1 ⊆ αI2 , it satisfies axiom α1 v ¬α2 if αI1 ∩ αI2 = ∅, and it satisfies axiom (funct R) if RI is a partial function—that is, for each set of objects {o, o1, o2} ⊆ ∆I , if 〈o, o1〉 ∈ RI and 〈o, o2〉 ∈ RI , then o1 = o2.\nFollowing the common practice for the DLs of the DL-Lite family (Calvanese et al., 2007), we usually adopt the unique name assumption (UNA)—that is, for each interpretation I and individual pair c 6= d, we require that cI 6= dI . Whenever we drop this assumption, we will explicitly say so. Under the UNA, the problem of checking whether a DL-LiteA ontology is consistent is NL-complete, whereas without the UNA, the problem becomes PTime-complete (Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009)."
    }, {
      "heading" : "2.2 Instance Queries and Conjunctive Queries",
      "text" : "Let NV be a countably infinite set of variables. Together NI and NV form the set of terms. Expressions of the form A(t) or P (t, t′), where A is an atomic concept, P is an atomic role, and t, t′ are terms, are called atoms.\nA conjunctive query (CQ) q of arity n ≥ 0 is an expression q(x1, . . . , xn)← a1, . . . , am, where, for each i ∈ {1, . . . ,m}, we have that ai is an atom. The tuple 〈x1, . . . , xn〉 is the tuple of answer variables of q. Let NV (q) be the set of variables occurring in q, let NI(q) be the set of individuals in q, let at(q) = {a1, . . . , am}, and let |q| be the number of terms occurring in q. We consider safe CQs—that is, each answer variable xi of q occurs in at least one of the atoms of q. A Boolean conjunctive query is a CQ with arity 0, and we shall write it simply as a set of atoms. An instance query q(x) is a conjunctive query whose body consists of a single unary atom A(x). A union of conjunctive queries (UCQ) is a set of CQs\n1. We ignore here the distinction between data values and objects present in DL-LiteA and OWL 2 QL, since it is immaterial for our results. That is, we do not consider value domains and attributes.\nof the same arity, and we assume w.l.o.g. that all CQs in a UCQ have the same tuple of answer variables. In the following, we denote with IQ the set of all instance queries and with CQ the set of all UCQs.\nA match for an n-ary CQ q in an interpretation I is a mapping π : NV (q)∪NI(q)→ ∆I such that\n(i) π(c) = cI , for each c ∈ NI(q),\n(ii) π(t) ∈ AI , for each A(t) ∈ at(q), and\n(iii) 〈π(t), π(t′)〉 ∈ P I , for each P (t, t′) ∈ at(q).\nAn n-tuple of individuals 〈c1, . . . , cn〉 is an answer to q in I, if there exists a match π for q in I such that 〈cI1 , . . . , cIn〉 = 〈π(x1), . . . , π(xn)〉. We let ans(q, I) denote the set of all answers to q in I. A Boolean CQ returns as answer either ∅, representing the value ‘false’, or the empty tuple 〈〉, representing the value ‘true’. For a UCQ q, we let ans(q, I) = ⋃ q′∈q ans(q\n′, I). The certain answer to a UCQ q of arity n over ontology 〈T ,A〉 is defined as\ncert(q, T ,A) = {~c ∈ (NI)n | ~c ∈ ans(q, I), for each model I of 〈T ,A〉}.\n2.3 Query Answering in DL-LiteA\nThe problem of query answering in DLs is the problem of computing the certain answer to a given query over a given DL ontology. Formulated in this way, query answering is a computation problem and not a decision problem. Since in this paper we are interested in establishing computational complexity results, we identify query answering with its decision problem, sometimes called the recognition problem, in which the input is constituted by a DL ontology 〈T ,A〉, a query q(~x), and a tuple ~c of arity |~x|, and the task is to determine whether ~c ∈ cert(q, T ,A). In the special case of instance queries, this problem is also known as instance checking. Notice that, since we consider both the ontology and the query as part of the input, we are considering so-called combined complexity (Vardi, 1982).\nIn many DLs, instance checking can be reduced to the problem of deciding ontology consistency. This holds also for DL-LiteA and, thus, answering an instance query can be done in nondeterministic logarithmic space. In contrast, the problem of answering a UCQ (and hence a CQ) q over a DL-LiteA ontology 〈T ,A〉 can be solved in nondeterministic polynomial time by adopting a pure query rewriting approach (Calvanese et al., 2007, 2009). This technique works in two steps. In the first step, we compute the perfect reformulation Rq,T of q w.r.t. T—that is, we rewrite the input query q with respect to the TBox T into a UCQ Rq,T . In this rewriting step, the portion of the TBox relevant for answering q is compiled into Rq,T . In the second step, we simply evaluate the computed rewriting Rq,T over the ABox A—seen as a first order interpretation. This is captured by the proposition below, which makes use of the notion of interpretation associated to an ABox, formalized in the following definition.\nDefinition 2.1. Given an ABox A, let DBA be the interpretation whose domain ∆DBA is the set of individuals occurring in A, and\n(i) cDBA = c, for all individuals c occurring in A;\n(ii) ADBA = {c | A(c) ∈ A}, for all A ∈ NC ; (iii) PDBA = {〈c, d〉 | P (c, d) ∈ A}, for all P ∈ NR.\nThe following proposition summarizes the results about query answering based on rewriting that have been shown for the logics of the DL-Lite family (and for DL-LiteA in particular) and that we will exploit in the following.\nProposition 2.1. (Calvanese et al., 2007, 2009) Let 〈T ,A〉 be a DL-LiteA ontology, let q be a UCQ, and let max(q) = maxqi∈q |at(qi)|. It is possible to construct a UCQ Rq,T , called the perfect reformulation of q w.r.t. T , such that\ncert(q, T ,A) = ans(Rq,T ,DBA).\nMoreover, Rq,T satisfies the following properties.\n• All predicates occurring in Rq,T occur in T or in q. • Each qr ∈ Rq,T has at most max(q) atoms and at most 2 ·max(q) terms. • If q consists of a single instance query, then each qr ∈ Rq,T has only one atom. • Each qr ∈ Rq,T can be obtained in nondeterministic polynomial time in the combined\nsize of T and q. • Deciding whether a given tuple of individuals is in ans(Rq,T ,DBA) can also be achieved\nin nondeterministic polynomial time in the combined size of T and q."
    }, {
      "heading" : "2.4 Complexity Theory",
      "text" : "We briefly outline the definition of some non-canonical complexity classes used in the paper; for more details, we refer the reader to standard textbooks on computational complexity (e.g., Papadimitriou, 1994). The class ΣP2 is a member of the Polynomial Hierarchy: it is the class of all decision problems solvable in nondeterministic polynomial time using an NP oracle. The class PNP‖ contains all decision problems that can be solved in polynomial time with an NP oracle, where all oracle calls must be first prepared and then issued in parallel. The class DP contains all problems that, considered as languages, can be characterized as the intersection of a language in NP and a language in coNP. Additionally, the class NL contains all decision problems that can be solved by a nondeterministic Turing machine using a logarithmic amount of space. It is believed that NL ⊆ PTime ⊆ NP ⊆ DP ⊆ PNP‖ ⊆ ΣP2 is a strict hierarchy of inclusions. Here we make such an assumption.\nAs usual, we use reductions between problems to infer complexity bounds throughout the paper. Unless stated otherwise, these are all many-one logarithmic space reductions."
    }, {
      "heading" : "3. Explaining Negative Query Answers",
      "text" : "In this section, we formalize as an abductive task the problem of finding explanations for negative answers to queries over DL ontologies.\nFor a DL TBox T , a DL ABox A, and a query q from IQ∪CQ, we let Σ(T ,A, q) denote the set of all those predicates that occur in T , A, or q. A signature Σ is a non-empty finite subset of NC ∪ NR. Furthermore, an ABox A is a Σ-ABox if all the assertions in A use only predicates from Σ; that is, if Σ(∅,A, ∅) ⊆ Σ.\nDefinition 3.1. Let 〈T ,A〉 be a DL ontology, q(~x) a query from IQ ∪ CQ, ~c a tuple of individuals of arity |~x|, and Σ a signature. We call P = 〈T ,A, q,~c,Σ〉 a Query Abduction Problem (QAP). An explanation for (or, a solution to) P is a Σ-ABox E such that\n(i) the ontology 〈T ,A ∪ E〉 is consistent, and\n(ii) ~c ∈ cert(q, T ,A ∪ E).\nThe set of all explanations for P is denoted by expl(P). The predicates in Σ are the ones allowed in explanations, hence we call them abducible predicates. If Σ(T ,A, q) ⊆ Σ, we say that P has unrestricted explanation signature; otherwise, if Σ does not contain all symbols in Σ(T ,A, q), we say that P has restricted explanation signature.\nFor such a QAP, we call tuple ~c a negative answer to q over 〈T ,A〉, if ~c /∈ cert(q, T ,A). Clearly, query q over ontology 〈T ,A〉 admits a negative answer only if 〈T ,A〉 is consistent. Also, by condition (i), if the ontology is inconsistent, then P does not admit explanations.\nOntology languages, such as DL-LiteA, which allow for the specification of existential restrictions and negative constraints (e.g., disjointness axioms), sometimes require explanations to introduce fresh individuals that do not occur within the QAP. We next precisely characterize these individuals.\nDefinition 3.2. Let P = 〈T ,A, q,~c,Σ〉 be a QAP and let E be a solution to P. An arbitrary individual u occurring in E is anonymous if it does not occur in T , A, q, and in ~c.\nNow, we use an example to highlight how query abduction problems can be useful in debugging negative query answers.\nExample 3.1. Let Au be the following set of assertions about a particular university.\nDPhil(Anna) DPhil(Beppe) enroll(Anna,KR) teach(Marco,KR) enroll(Luca, IDB) teach(Carlo, IDB)\nThat is, Anna and Beppe are doctoral students, Anna is enrolled in the KR course, which is taught by Marco, and Luca is enrolled in the introductory DB course (IDB), which is taught by Carlo. Now, consider the following DL-LiteA TBox Tu formalizing the university domain, of which Au is a (partial) instance.\n∃enroll v Student ∃enroll− v Course\nDPhil v Student\n∃teach v Lecturer ∃teach− v Course Course v ∃teach−\nTu models that objects in the domain of enroll are Students, and objects in the domain of teach are Lecturers, whereas objects in the range of enroll or of teach are Courses. Among the students we have DPhil students. Finally, every Course must be taught by someone.\nNow, assume that the university administration is interested in finding all those who are teaching a course in which at least one of the enrolled students is a doctoral student, which is captured by the following query.\nqu(x)← teach(x, y), enroll(z, y),DPhil(z)\nAssume that Carlo is expected to be part of the result. This is not the case, as Luca is the only student of Carlo and he is not known to be a DPhil student. Hence Carlo /∈ cert(q, T ,A) and Carlo is a negative answer. Suppose that we have complete information on all the predicates but enroll and teach—that is, only the latter predicates are abducible. It is easy to see that\nEu = {teach(Carlo, c), enroll(Beppe, c), enroll(Luca, c)}\nis an explanation for the QAP Pu = 〈Tu,Au, qu,Carlo, {enroll, teach}〉, which suggests the existence of a course, represented by the anonymous individual c, that does not occur in the ABox Au.\nThe above example shows that certain explanations may be too assumptive in that they include assertions that are not required to solve the problem. Indeed, in the example’s explanation there is no reason to assume that Luca is enrolled in the anonymous course c. In the following, we will examine various restrictions to expl(P) to reduce redundancy in explanations, achieved by introducing a preference relation among explanations. This relation is reflexive and transitive—that is, we have a pre-order among explanations. For such a pre-order on expl(P), we write E ≺ E ′ if E E ′ and E ′ E .\nDefinition 3.3. The preferred explanations expl (P) of a QAP P under the pre-order , called -explanations or ( -solutions), are defined as follows.\nexpl (P) = { E ∈ expl(P) | there is no E ′ ∈ expl(P) such that E ′ ≺ E }\nWe consider two preference orders that are commonly adopted when comparing abductive solutions: the subset-minimality order, denoted by ⊆, and the minimum explanation size order, denoted by ≤. The latter order is defined by E ≤ E ′ iff |E| ≤ |E ′|. Considering that, by the definition, explanations are finite, for an arbitrary QAP P, we have that each ≤-solution to P is also a ⊆-solution to P; that is, expl≤(P) ⊆ expl⊆(P).\nExample 3.2. As we already argued, the ABox Eu is a redundant solution to the QAP Pu introduced in Example 3.1. Next, we introduce two minimal solutions. First, we consider the solution asserting Carlo to teach an anonymous course c and Beppe to be enrolled in that course. This ABox E ′u = {teach(Carlo, c), enroll(Beppe, c)} is a ⊆-explanation. Second, we consider the solution asserting Beppe to be enrolled in the IDB course. This ABox E ′′u = {enroll(Beppe, IDB)} is a ≤-explanation (and hence also a ⊆-explanation).\nIn the context of logic-based abduction, four main decision problems have been considered of interest (Eiter & Gottlob, 1995), and they are parametrized according to the chosen preference order .\nDefinition 3.4. Given a QAP P, an ABox assertion ϕ(~d) over abducible predicate ϕ, and an ABox E, we define the following decision problems.\n• -exist(ence): Does there exist a -explanation for P?\n• -nec(essity): Does assertion ϕ(~d) occur in all -explanations for P?\n• -rel(evance): Does assertion ϕ(~d) occur in some -explanation for P?\n• -rec(ognition): Is ABox E a -explanation for P?\nWhenever no preference is applied (i.e., when is the identity), we omit to write in front of the problems’ names.\nIn this paper, we study the complexity of the above reasoning problems for query abduction. We start by highlighting, in the remaining part of this section, interesting properties of query abduction problems and important connections between reasoning tasks."
    }, {
      "heading" : "3.1 Reductions between Reasoning Problems",
      "text" : "We now show that some of the introduced problems can be reduced to each other. Unless otherwise stated, the reductions we present work for all DLs, for both instance queries and UCQs, and for both restricted and unrestricted explanation signatures.\nWe start by showing that nec is at least as hard as non-exist (i.e., the complement of the exist problem).\nProposition 3.1. For every DL, non-exist is reducible to nec.\nProof. Assume a QAP P = 〈T ,A, q,~c,Σ〉 and let ϕ(~d) be an arbitrary ABox assertion, such that ϕ and ~d do not occur in P. The following holds: P has no explanation iff ϕ(~d) is necessary for P ′ = 〈T ,A, q,~c,Σ ∪ {ϕ}〉. By the construction, it follows that each solution to P is also a solution to P ′; furthermore, for each solution E ′ to P ′, ϕ 6∈ Σ(∅, E ′, ∅) implies that E ′ is a solution to P. By the definition of P ′ and since ϕ and ~d are globally fresh, for each ABox E , we have that E is an explanation for P ′ if and only if E \\ {ϕ(~d)} is an explanation for P ′. The correctness of the reduction immediately follows.\nFor QAPs with restricted explanation signatures, we next show that nec reduces to non-exist. The reduction works for every DL that allows for disjointness axioms.\nProposition 3.2. For every DL that allows for concept and role disjointness axioms, and under restricted explanation signatures, nec is reducible to non-exist.\nProof. Consider an instance of nec given by a QAP P = 〈T ,A, q,~c,Σ〉 where Σ might be restricted, and by an ABox assertion ϕ(~d). Next, we show how to construct a QAP P ′ such that ϕ(~d) is necessary for P iff P ′ does not admit solutions. To this end, let ϕ′ and ϕ̄ be two globally fresh predicates of the same arity as ϕ; furthermore, let TBox T ′, ABox A′, and signature Σ′ be as follows.\nT ′ := T ∪ {ϕ′ v ϕ} ∪ {ϕ̄v ¬ϕ′} A′ := A ∪ {ϕ̄(~d)} Σ′ := {ψ ∈ Σ | ψ 6= ϕ} ∪ {ϕ′}\nFinally, let P ′ := 〈T ′,A′, q,~c,Σ′〉. Now, we show the correctness of the reduction; that is, ϕ(~d) is necessary for P iff P ′ does not admit solutions.\n(⇒) We prove the contrapositive. Suppose that P ′ has a solution E ′. By the definition of 〈T ′,A′〉 and of Σ′, we have that ϕ′(~d) 6∈ E ′ and that predicate ϕ does not occur in E ′. Let ABox E be defined as follows.\nE := {ψ(~t) ∈ E ′ | ψ 6= ϕ′} ∪ {ϕ(~t) | ϕ′(~t) ∈ E ′}\nBy the construction, E is a Σ-ABox that does not contain ϕ(~d). It remains to show that E is a solution to P. To this end, please observe that each model J of 〈T ′,A′ ∪ E ′〉 is a model of 〈T ,A ∪ E〉, since ϕ′ v ϕ ∈ T ′. In addition, each model I of 〈T ,A ∪ E〉 can be extended to a model J of 〈T ′,A′ ∪ E ′〉 by setting ϕ′J := {(~t)J | ϕ′(~t) ∈ E ′} and ϕ̄J := {(~d)J }. It follows that 〈T ′,A′ ∪ E ′〉 is a conservative extension of 〈T ,A ∪ E〉. Given that ~c ∈ cert(q, T ′,A′ ∪ E ′) and that q is over 〈T ,A〉, we obtain that ~c ∈ cert(q, T ,A ∪ E). Furthermore, since 〈T ′,A′ ∪ E ′〉 is consistent, we also have that 〈T ,A ∪ E〉 is consistent; so E is a solution to P that does not contain assertion ϕ(~d), as required.\n(⇐) We prove the contrapositive. Suppose that a solution E to P exists such that ϕ(~d) 6∈ E . Let ABox E ′ be defined as follows.\nE ′ := {ψ(~t) ∈ E | ψ 6= ϕ} ∪ {ϕ′(~t) | ϕ(~t) ∈ E}\nBy the construction, E ′ is a Σ′-ABox which does not contain ϕ′(~d). It remains to show that E ′ is a solution to P ′. As we have seen before, 〈T ′,A′ ∪ E ′〉 is a conservative extension of 〈T ,A ∪ E〉. Given that ~c ∈ cert(q, T ,A ∪ E), we obtain that ~c ∈ cert(q, T ′,A′ ∪ E ′). Furthermore, since 〈T ,A ∪ E〉 is consistent and ϕ′(~d) 6∈ E ′, we also have that 〈T ′,A′ ∪ E ′〉 is consistent; so E ′ is a solution to P ′, as required.\nA simple modification of Proposition 3.2 shows that this result applies also to DLs that allow for negative ABox assertions of the form ¬A(c) and ¬P (c, c′) instead of disjointness axioms. We next show that rel and exist are mutually reducible.\nProposition 3.3. For every DL, rel and exist are mutually reducible.\nProof. First, we show that we can reduce rel to exist. Let P be an arbitrary QAP of the form 〈T ,A, q,~c,Σ〉 and let ϕ(~d) be an arbitrary ABox assertion such that ϕ ∈ Σ. We construct a QAP P ′ such that ϕ(~d) is relevant to P if and only if P ′ admits a solution. To this end, let A′ be the ABox defined as A′ = A ∪ {ϕ(~d)}. Then, we define QAP P ′ as P ′ = 〈T ,A′, q,~c,Σ〉. Next, we prove the correctness of the reduction. The only-if direction is immediate. For the if direction, suppose that P ′ admits a solution E ′. It follows, by the definition of P ′, that Σ-ABox E ′ ∪ {ϕ(~d)} is consistent with TBox T . Moreover, this latter ABox is also a solution to P and, therefore, the given assertion is relevant.\nSecond, we prove that exist is reducible to rel. Let P be an arbitrary QAP of the form 〈T ,A, q,~c,Σ〉, let ϕ be an arbitrary predicate from Σ, and let ~d be an arbitrary tuple of individuals not occurring in P such that ~d is of the same arity as predicate ϕ. We prove that P admits a solution iff ϕ(~d) is relevant for P. The if direction follows by the definition of relevance. To show the only-if direction, suppose that P admits a solution E . If ϕ(~d) occurs in E , it is relevant for P. Otherwise, since individuals ~d do not occur in P and ϕ ∈ Σ, ABox E ∪ {ϕ(~d)} is also a solution to P, and hence ϕ(~d) is relevant for P.\nMoreover, ⊆-nec and nec are also mutually reducible.\nProposition 3.4. For every DL, ⊆-nec and nec are mutually reducible.\nProof. For an arbitrary QAP P and an arbitrary ABox assertion ϕ(~d), we have that ϕ(~d) occurs in all ⊆-minimal explanations for P iff ϕ(~d) occurs in all explanations for P. Thus, nec and ⊆-nec are equivalent problems.\nFinally, since our preference orders prefer ‘smaller’ explanations and, by the definition, explanations are finite, our orders are well-founded. It immediately follows that there exists an explanation for an arbitrary QAP P if and only if P admits a minimal explanation under both our preference orders.\nProposition 3.5. For every DL, ⊆-exist, ≤-exist, and exist are mutually reducible."
    }, {
      "heading" : "3.2 QAPs and the Query Emptiness Problem",
      "text" : "As mentioned in the introduction, deciding the existence of an explanation is related to the query emptiness problem studied by Baader et al. (2010). Since we will rely on that problem to infer some complexity bounds throughout the paper, we briefly introduce it here.\nDefinition 3.5. Let T be a DL TBox, Q ∈ {IQ, CQ} a query language, and Σ a signature. We say that a Q-query q is empty for Σ given T if for every Σ-ABox A that is consistent with T we have that cert(q, T ,A) = ∅. Otherwise, we say that q is non-empty for Σ given T . The Q non-emptiness problem consists in deciding, for input T , q, and Σ, whether q is non-empty for Σ given T .\nNext, we first show that, for every DL, and for both instance queries and Boolean UCQs, query non-emptiness reduces to exist. Then, we show that for the DL-LiteA case this holds even for arbitrary UCQs.\nProposition 3.6. For every DL and both instance queries and Boolean UCQs, Q nonemptiness is reducible to exist.\nProof. Let T be an arbitrary DL TBox, let q ∈ IQ ∪ CQ be an arbitrary query such that q ∈ CQ implies that q is a Boolean UCQ, and let Σ be an arbitrary signature. We show how to construct a QAP P such that q is non-empty for Σ given T iff P admits a solution. To this end, let ~c be an arbitrary tuple such that q ∈ CQ implies that ~c = 〈〉, and q ∈ IQ implies that ~c = 〈a〉 where a is a globally fresh individual. Clearly, we have that q is non-empty for Σ given T iff P = 〈T , ∅, q,~c,Σ〉 admits a solution.\nThe relationship between CQ non-emptiness and exist can tightened, when we restrict our attention to DL-LiteA TBoxes.\nProposition 3.7. For DL-LiteA, CQ non-emptiness is reducible to exist.\nProof. Consider a DL-LiteA TBox T , a signature Σ, and this time an n-ary query q ∈ CQ. W.l.o.g., we assume that q is a CQ. Then, we cannot immediately extend the proof given for Boolean CQs by introducing n (distinct) individuals since we might be forced to match distinct answer variables of q to the same individual in an ABox witnessing non-emptiness of q. However, we can adapt the proof to this case as follows. We let N be a fresh atomic concept not occurring in Σ(T , ∅, q)∪Σ. We define Σ′ = Σ∪{N} and we let q′ be the Boolean CQ such that at(q′) = at(q)∪ {N(x1), . . . , N(xn)}. Finally, we let P = 〈T , ∅, q′, 〈〉,Σ′〉 be a QAP. In the following, we show that q is non-empty for Σ given T iff P admits a solution.\n(⇒) Suppose that q is non-empty for Σ given T . That is, there exists a Σ-ABox A such that 〈T ,A〉 is consistent and there exists some n-ary tuple ~a = 〈a1, . . . , an〉 of individuals\nsuch that ~a ∈ cert(q, T ,A). Now, consider the Σ′-ABox E = A ∪ {N(ai) | 1 ≤ i ≤ n}. Since N is a fresh predicate, we have that 〈T , E〉 is a conservative extension of 〈T ,A〉. That is, each model of 〈T ,A〉 can be extended to be a model of 〈T , E〉, and every model of 〈T , E〉 is also a model of 〈T ,A〉. By the assumption that 〈T ,A〉 is consistent and that ~a ∈ cert(q, T ,A), we conclude that E is a solution to P.\n(⇐) Suppose that P admits a solution E . It follows that 〈T , E〉 is consistent and that for each model I of 〈T , E〉, there exists a match π for q′ such that I |=π q′. Since N is a fresh predicate not occurring in T and for each answer variable xi of q the atom N(xi) is contained in q′, we have that π(xi) = a I i for some ai ∈ NI such that N(ai) ∈ E . It follows that ~a ∈ cert(q, T , E). Consider the Σ-ABox A obtained from E by removing all the assertions over N ; it immediately follows that 〈T , E〉 is a conservative extension of 〈T ,A〉. Therefore, also ~a ∈ cert(q, T ,A) and, thus, q is non-empty for Σ given T .\nProposition 3.7 can be generalized to Horn DLs—that is, to all those DLs for which answering instance and conjunctive queries reduces to evaluating the input query over a single, canonical model of the ontology. It follows that for DL-LiteA and, more in general, for all Horn-DLs, deciding exist generalizes the query non-emptiness problem. Hence, all the hardness results for non-emptiness obtained by Baader et al. (2010) that hold for instance queries and UCQs apply also to the exist problem under restricted explanation signatures. However, since we also consider ABoxes and we require a specific tuple to be in the query answer, the converse does not hold and we can not always transfer their upper bounds to our setting."
    }, {
      "heading" : "3.3 Canonical Explanations",
      "text" : "Before studying the complexity of reasoning over query abduction problems, we first show that we can restrict the search for explanations. In order to do so, we define the notion of instantiation of a conjunctive query.\nDefinition 3.6. Let q be an n-ary CQ with answer variables 〈x1, . . . , xn〉; furthermore, let ~c = 〈c1, . . . , cn〉 be a tuple of individuals. Let ξ be a mapping from the terms of q to NI such that ξ is identity over NI and for each answer variable xj of q we have that ξ(xj) = cj. Then, we call the ABox\nEξ = {A(ξ(t)) | A(t) ∈ at(q)} ∪ {R(ξ(s), ξ(t)) | R(s, t) ∈ at(q)}\na ~c-instantiation of q. Given a DL ontology O, if we additionally have that, for each quantified variable y, ξ(y) is a distinct anonymous individual uy not occurring in q and O, then we say that Eξ is direct for O.\nNote that in the following we do not distinguish between instantiations that differ only in the assignment of anonymous individuals to variables. Hence, a CQ has only a finite number of distinct instantiations, and a unique direct one."
    }, {
      "heading" : "3.3.1 Unrestricted Explanation Signature",
      "text" : "To obtain an explanation for a QAP P with unrestricted explanation signature, we can iterate over the set of all possible instantiations to the input query, searching for one such\ninstantiation that is consistent with the input ontology. In the absence of the UNA, we can even consider one single instantiation of each CQ: the direct instantiation, where all existentially quantified variables are mapped to distinct anonymous individuals. In the presence of the UNA, if our underlying DL is expressive enough to enforce inequalities over the individuals occurring in P (e.g., by means of disjointness axioms), we can again reduce the problem to searching for a CQ whose direct instantiation is consistent with the input ontology, when the UNA is dropped.\nProposition 3.8. Let O = 〈T ,A〉 be an arbitrary DL ontology and let P = 〈T ,A, q,~c,Σ〉 be an arbitrary QAP with unrestricted explanation signature. Furthermore, for each qi ∈ q, let Eqi be the direct ~c-instantiation of qi for O. The following hold:\n1. Under the UNA, a solution to P exists iff a ~c-instantiation Eξ of some qi ∈ q exists such that 〈T ,A ∪ Eξ〉 is consistent.\n2. Without the UNA, a solution to P exists iff a query qi ∈ q exists such that 〈T ,A ∪ Eqi〉 is consistent.\n3. Furthermore, suppose that the DL supports concept disjointness axioms. Under the UNA, a solution to P exists iff a query qi ∈ q exists such that 〈T ′,A′ ∪ Eqi〉 is consistent without the UNA, where A′ and T ′ extend A and T with a quadratic number of assertions and axioms, respectively.\nProof. Consider an arbitrary qi ∈ q and let Eξ be an arbitrary ~c-instantiation of qi. We first prove that consistency of 〈T ,A ∪ Eξ〉 (with or without the UNA) implies that Eξ is a solution to P (with or without the UNA, resp.). This shows the if direction of 1 and 2. Let ξ be the mapping generating Eξ and suppose that 〈T ,A ∪ Eξ〉 is consistent. Let I be an arbitrary model of 〈T ,A ∪ Eξ〉. Then we build a match π for qi in I by setting π(t) = ξ(t)I for each term t in qi. As π(xj) = ξ(xj)\nI = cIj for each answer variable xj , the match π witnesses ~c ∈ ans(q, I). Hence ~c ∈ cert(q, T ,A ∪ Eξ) and Eξ is a solution to P, as desired.\nFor the only-if direction of 1, we assume an arbitrary solution E to P, and use it to show that there exists a ~c-instantiation Eξ of some qi ∈ q such that 〈T ,A ∪ Eξ〉 is consistent. Since E is a solution to P, by definition, there exists a model I of 〈T ,A ∪ E〉 under the UNA. Without loss of generality, we assume that ∆I = NI and that for each c ∈ NI we have that cI = c. Moreover, the interpretation I admits a match π for some qi ∈ q witnessing ~c ∈ ans(qi, I). To define the mapping ξ, we let ξ(t) = π(t) for each term t occurring in qi. Then I is a model of Eξ. Since it is also a model of 〈T ,A〉, it is a model of 〈T ,A ∪ Eξ〉 and shows that the latter is consistent, as desired.\nThe only-if direction of 2 is shown similarly. Suppose that P admits a solution E . Then there exists a model I of 〈T ,A ∪ E〉 (without the UNA) that admits a match π for some qi ∈ q witnessing ~c ∈ ans(qi, I). To obtain an interpretation J that is a model of 〈T ,A ∪ Eqi〉, we extend I as follows. For every anonymous individual uy that was introduced in Eqi due to an existentially quantified variable y, we let uyJ = π(y). The resulting interpretation is a model of Eqi , and since these individuals uy do not occur in the ontology, modelhood for 〈T ,A〉 is preserved.\nFor 3, we use the extended ABox A′ and TBox T ′ to enforce the UNA over the individuals occurring in P. The ABox A′ extends A with an assertion Ac(c) for each individual\nc occurring in P, where each Ac is a fresh concept name. The TBox T ′ consists of axioms Ac v ¬Ac′ for all pairs c 6= c′ of individuals occurring in P. Since the interpretations of 〈T ,A〉 under the UNA and of 〈T ′,A′〉 without the UNA coincide, the claim easily follows from statement 2 above.\nA direct consequence of this proposition is that, for all DLs, we can restrict our search to explanations that result from instantiating the input query.\nCorollary 3.9. Let P = 〈T ,A, q,~c,Σ〉 be a QAP with unrestricted explanation signature, let max(q) = maxqi∈q |at(qi)|, and let max-terms(q) = maxqi∈q |qi|. If P has an explanation, then P has an explanation with concepts and roles only from q, at most max(q) atoms, and at most max-terms(q) individuals."
    }, {
      "heading" : "3.3.2 Restricted Explanation Signature",
      "text" : "If we allow for restricted explanation signatures, then Proposition 3.8 does not hold anymore, and the search space for possible explanations becomes significantly larger. As we will see in the following sections, this has a notable effect on the complexity of the different decision problems. However, in the case of DL-LiteA, we can still show a weaker version of the proposition that allows us to restrict our search to the instantiations of the queries in the perfect reformulation of the input query q. Moreover, every ⊆-minimal explanation can be obtained this way.\nProposition 3.10. Let P = 〈T ,A, q,~c,Σ〉 be a QAP where 〈T ,A〉 is a DL-LiteA ontology, and let Rq,T be the perfect reformulation of q w.r.t. T . A solution to P exists if and only if a ~c-instantiation Eξ of some qr ∈ Rq,T exists such that (i) 〈T ,A ∪ Eξ〉 is consistent, and (ii) Eξ \\ A is a Σ-ABox. Moreover, E ′ is a ⊆-minimal explanation implies that query qr ∈ Rq,T and ABox Eξ exist such that Eξ is a ~c-instantiation of qr and E ′ = Eξ \\ A.\nProof. The first part of the claim is shown analogously to item 1 of Proposition 3.8 (recall that in DL-LiteA we make the UNA). For the if direction, consider an arbitrary qr ∈ Rq,T and let Eξ be a ~c-instantiation of qr generated from a mapping ξ. We assume that 〈T ,A ∪ Eξ〉 is consistent and that Eξ \\ A is a Σ-ABox. Then, to show that Eξ \\ A is a solution to P, it suffices to show the existence of a match π for qr in DBA∪Eξ witnessing ~c ∈ cert(q, T ,A∪Eξ). This π is easily obtained by setting π(t) = ξ(t)I for each term t in qr. For the only-if direction, we assume an arbitrary solution E to P and use it to show that there exists a ~cinstantiation Eξ of some qr ∈ Rq,T that satisfies conditions (i) and (ii). Since E is a solution to P, by definition, E is a Σ-ABox, 〈T ,A ∪ E〉 is consistent, and ~c ∈ cert(q, T ,A ∪ E). By Proposition 2.1, it follows that there exists a query qr ∈ Rq,T and a match π for qr in DBA∪E that witness ~c ∈ ans(qr,DBA∪E). We define a mapping ξ by setting ξ(t) = π(t) for each term t in qr. Then, for the resulting ~c-instantiation Eξ we have that Eξ ⊆ E ∪A, which implies the consistency of 〈T ,A ∪ Eξ〉 and that Eξ \\ A is also a Σ-ABox as desired.\nTo show the second part of the claim, suppose E is a ⊆-minimal solution to P. By Proposition 2.1, we have that there exists some qr ∈ Rq,T for which there exists a match π witnessing ~c ∈ ans(qr,DBA∪E). We construct a ~c-instantiation Eξ of qr as follows:\nEξ = {A(π(t)) ∈ A ∪ E | A(t) ∈ at(qr)} ∪ {R(π(t), π(t′)) ∈ A ∪ E | R(t, t′) ∈ at(qr)}\nBy the minimality of E , we have that E = Eξ \\ A.\nSimilarly as above, this implies that we can consider only small explanations whose size is linear in the size of the input query q, but now their signature depends not only on q, but also on the signature of the input TBox T .\nCorollary 3.11. Let P = 〈T ,A, q,~c,Σ〉 be a QAP where 〈T ,A〉 is a DL-LiteA ontology. Furthermore, let max(q) = maxqi∈q |at(qi)|. If P = 〈T ,A, q,~c,Σ〉 has an explanation, then P has an explanation with concepts and roles only from T and q, at most max(q) atoms, and at most 2 ·max(q) individuals."
    }, {
      "heading" : "4. Complexity for Instance Queries",
      "text" : "We now study the complexity of reasoning over query abduction problems. We consider the complexity under both unrestricted and restricted explanation signatures, and we consider the different minimality criteria over abductive solutions. We measure the complexity of a QAP P = 〈T ,A, q,~c,Σ〉 in terms of the combined size of T , A, q, and Σ—that is, we consider combined complexity. In this section, we investigate the complexity of reasoning over QAPs when the body of the input query consists of a single unary atom—that is, we consider instance queries. In the following section, we shall turn our attention to UCQs."
    }, {
      "heading" : "4.1 Existence of Explanations",
      "text" : "Before giving the first complexity results, we show that, for instance queries, ⊆-minimal and ≤-minimal explanations coincide. To see this, consider an arbitrary QAP P = 〈T ,A, q, c,Σ〉 such that q ∈ IQ and let qr be an arbitrary CQ in the perfect reformulation Rq,T . By Propositions 2.1 and 3.10, it follows that each ~c-instantiation of qr that is consistent with 〈T ,A〉 contains an explanation for P; moreover, each ⊆-minimal explanation for P can be obtained in this way. As these explanations contain at most one assertion (cf. Proposition 2.1), ≤- and ⊆-minimal explanations are both of size at most one, and we obtain the following result.\nProposition 4.1. Let P = 〈T ,A, q,~c,Σ〉 be a QAP such that 〈T ,A〉 is a DL-LiteA ontology and q ∈ IQ, and let E be an arbitrary Σ-ABox. Then, E is a solution to P implies that a solution E ′ ⊆ E to P exists such that |E ′| ≤ 1. Hence, expl≤(P) = expl⊆(P).\nNow we consider the complexity of deciding existence of an explanation.\nTheorem 4.2. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, exist, ⊆-exist, and ≤-exist are NL-complete.\nProof. By Proposition 3.5, it suffices to show the result for exist. We first provide an algorithm that yields the desired upper bound, even with restricted explanation signatures. Then we show that the problem is NL-hard already for the case of unrestricted signatures.\n(membership) Let P = 〈T ,A, q, c,Σ〉 be a QAP such that q ∈ IQ. To decide exist in non-deterministic logarithmic space, we can exploit Proposition 4.1 and test all candidate singleton explanations by iterating over Σ, the individuals occurring in P, and at most two anonymous individuals. This results in at most polynomially many candidate solutions E of constant size. For each of them we test whether 〈T ,A ∪ E〉 is consistent and c ∈ cert(q, T ,A ∪ E). Since for DL-LiteA both ontology consistency and instance checking can be solved in non-deterministic logarithmic space, exist is in NL.\nAlgorithm 1 isNEC\nInput: QAP P = 〈T ,A, q,~c,Σ〉 and assertion ϕ(~d) such that 〈T ,A〉 is a DL-LiteA ontology, q ∈ IQ ∪ CQ, Σ is unrestricted, and ϕ ∈ Σ. Output: “yes” iff ϕ(~d) is necessary for P. 1: Let ϕ̄ be a globally fresh predicate of the same arity as ϕ. 2: Let T ′ := T ∪ {ϕ̄v ¬ϕ} and let A′ := A ∪ {ϕ̄(~d)}. 3: If 〈T ′,A′, q,~c,Σ〉 admits a solution, then return “no”. 4: Let I be the set of all individuals occurring in P and ~d. 5: Let u be a globally fresh anonymous individual. 6: for all Σ-ABoxes E∗ over the individuals in I ∪ {u} s.t. |E∗| ≤ 1 and ϕ(~d) 6∈ E∗ do 7: If 〈T ,A ∪ E∗〉 |= ϕ(~d) and 〈T ,A ∪ E∗, q,~c,Σ〉 admits a solution, then return “no”. 8: end for 9: Return “yes”.\n(hardness) We reduce the DL-LiteA ontology consistency problem (under the UNA) to exist. Consider an arbitrary DL-LiteA ontology 〈T ,A〉. Furthermore, consider an arbitrary atomic concept A not occurring in 〈T ,A〉, let q = A(x), let c ∈ NI be an arbitrary individual, and let P = 〈T ,A, q, c,Σ〉 be a QAP with unrestricted Σ. We show that 〈T ,A〉 is consistent if and only if P admits a solution. The if direction is trivial. For the onlyif direction, suppose that 〈T ,A〉 is consistent, and consider E = {A(c)}. Since 〈T ,A〉 is consistent and A is fresh, 〈T ,A ∪ E〉 is also consistent. As each model I of 〈T ,A ∪ E〉 satisfies the assertion A(c), E is a solution to P."
    }, {
      "heading" : "4.2 Deciding Necessity",
      "text" : "In Section 3.1, we have seen that for QAPs with restricted explanation signatures and DLs that allow for disjointness axioms, nec reduces to non-exist. For the case of QAPs with unrestricted explanation signatures but ontologies restricted to DL-LiteA, we provide in Algorithm 1 a Turing reduction to (non-)exist; that is, a procedure that solves nec by employing a subroutine for solving exist. The following proposition proves its correctness.\nProposition 4.3. For DL-LiteA, instance queries and UCQs, and under unrestricted explanation signatures, algorithm isNEC decides nec.\nProof. Let P = 〈T ,A, q,~c,Σ〉 be a QAP such that 〈T ,A〉 is a DL-LiteA ontology, query q ∈ IQ ∪ CQ, and signature Σ is unrestricted; furthermore, let ϕ(~d) be an assertion over abducible predicate ϕ ∈ Σ. We prove that ϕ(~d) is necessary for P iff isNEC returns “yes”.\nFor the only-if direction, we prove the contrapositive. Suppose that isNEC returns “no” on the given instance; we show that a solution E to P exists such that ϕ(~d) 6∈ E . According to the construction of isNEC, we consider two alternative cases.\n• QAP 〈T ′,A′, q,~c,Σ〉 admits a solution E . For DL-LiteA, Calvanese et al. (2009) showed that negative inclusion axioms affect only the consistency of the given ontology, but do not contribute towards computing the certain answer; that is, ~c ∈ cert(q, T ′,A′) iff 〈T ′,A′〉 is consistent and ~c ∈ cert(q, T ,A′). Then, since assertion ϕ̄(~d) is over a predicate not occurring in P and 〈T ′,A′〉 is consistent, we have that E is also a solution\nto P = 〈T ,A, q,~c,Σ〉. By the definition, such solution does not contain ϕ(~d), since 〈T ′,A′〉 |= ϕ̄(~d) and ϕ̄v ¬ϕ ∈ T ′.\n• QAP 〈T ′,A′, q,~c,Σ〉 has no solution. Since isNEC returns “no”, a Σ-ABox E∗ exists such that |E∗| ≤ 1, ϕ(~d) 6∈ E∗, 〈T ,A ∪ E∗〉 |= ϕ(~d), and QAP 〈T ,A ∪ E∗, q,~c,Σ〉 has a solution E . Given that assertion ϕ(~d) is entailed by 〈T ,A ∪ E∗〉 we have that E ′ := E \\ {ϕ(~d)} is also a solution to 〈T ,A ∪ E∗, q,~c,Σ〉. We conclude that E ′ ∪ E∗ is a solution to 〈T ,A, q,~c,Σ〉 that does not contain ϕ(~d), as required.\nFor the if direction, we prove the contrapositive. Suppose that a Σ-ABox E exists such that E is a solution to P and ϕ(~d) 6∈ E ; we show that isNEC returns “no”. W.l.o.g., the individual u of Algorithm 1 does not occur in E . Now, if 〈T ,A ∪ E〉 6|= ϕ(~d), we have that E is a solution to QAP 〈T ′,A′, q,~c,Σ〉, so isNEC returns “no”, as required. Otherwise, consider the case in which 〈T ,A ∪ E〉 |= ϕ(~d) and take the conjunctive query q′(~x)← ϕ(~x). By the assumption, we have that ~d ∈ cert(q′, T ,A ∪ E). By Proposition 2.1, a query r ∈ Rq′,T and a match π for r exist such that r contains a single atom and ~d ∈ ans(r,DBA∪E) is witnessed by π. Let ψ(~y) be the unique atom occurring in r such that ~x ⊆ ~y and let ψ(~t) be the assertion obtained from ψ(~y) by replacing each variable y ∈ ~y with π(y). Clearly, we have that ψ(~t) ∈ A ∪ E . Next, we distinguish among two cases.\n• For each variable y ∈ ~y we have that π(y) ∈ I. Then, let E∗ := ∅, if ψ(~t) ∈ A, and let E∗ := {ψ(~t)}, if ψ(~t) ∈ E . In either case, we have that ϕ(~d) 6∈ E∗, that 〈T ,A ∪ E∗〉 |= ϕ(~d), and that E∗ ⊆ E . Hence, E is a solution to QAP 〈T ,A ∪ E∗, q,~c,Σ〉; so isNEC returns “no”, as required.\n• Variable y ∈ ~y exists such that π(y) 6∈ I. Given that ~d ⊆ I, ~d ∈ ans(r,DBA∪E), and predicates have arity at most 2, we have that ~d is of the form ~d := 〈d〉, ϕ ∈ NC , and ψ ∈ NR. It follows that CQ r is of the form r(x)← ψ(x, y) or r(x)← ψ(y, x). Next, we consider the former case only, as the other case is symmetrical. Then, assertion ψ(~t) is of the form ψ(d, π(y)). Since π(y) 6∈ I, we have that ψ(d, π(y)) ∈ E . Now, let E ′ be the ABox obtained from E by replacing each occurrence of individual π(y) with the individual u of Algorithm 1. Since E ′ is obtained from solution E by uniformly replacing an anonymous individual with an individual that does not occur in E and P, we have that E ′ is also a solution to P. By the definition, ϕ(d) 6∈ E ′ and ψ(d, u) ∈ E ′. Now, let E∗ := {ψ(d, u)}. Since d ∈ ans(r,DBA∪E) is witnessed by π and by the definition of E∗, we have that 〈T ,A ∪ E∗〉 |= ϕ(d). At last, since E∗ ⊆ E ′ and E ′ is a solution to P, we conclude that ABox E ′ is a solution to 〈T ,A ∪ E∗, q,~c,Σ〉. Hence, isNEC returns “no”, as required.\nNext, we use Algorithm 1 and Propositions 3.1 and 3.2 to characterize the complexity of nec in the presence of instance queries.\nTheorem 4.4. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, nec, ≤-nec, and ⊆-nec are NL-complete.\nProof. For the NL upper bound for nec and under restricted signatures, observe that, by Proposition 3.2, nec reduces to non-exist. In Theorem 4.2, we proved that exist is in NL.\nGiven that NL = coNL, we have that nec is in NL as well. The NL upper bound in the case of unrestricted signature can be established using algorithm isNEC and Proposition 4.3. Indeed, given that NL = coNL, that non-exist is in coNL, and that checking whether an assertion is entailed by a DL-LiteA ontology is in coNL as well, we immediately obtain that isNEC runs in nondeterministic logarithmic space. The coNL-hardness and thus also NLhardness of nec follows from Proposition 3.1 and Theorem 4.2. In addition, Proposition 3.4 states that nec and ⊆-nec are equivalent and, thus, also ⊆-nec is NL-complete. Finally, by Proposition 4.1, we conclude that ≤-nec is NL-complete."
    }, {
      "heading" : "4.3 Deciding Relevance",
      "text" : "By Proposition 3.3, deciding the relevance of an assertion to a QAP is equivalent to assessing whether a QAP admits a solution. We already showed this latter problem to be NL-complete (see Theorem 4.2). Therefore, the following result easily follows.\nTheorem 4.5. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, rel is NL-complete.\nIn the next theorem, we show that the complexity of the problem does not change even when we apply a minimality criterion over solutions.\nTheorem 4.6. For DL-LiteA, instance queries, and under both restricted and unrestricted explanation signatures, ≤-rel and ⊆-rel are NL-complete.\nProof. By Proposition 4.1, it suffices to show that ≤-rel is NL-complete. (membership) Let P = 〈T ,A, q, c,Σ〉 be a QAP such that q ∈ IQ and let ϕ(~d) be an ABox assertion over abducible predicate ϕ. We argue that ϕ(~d) is≤-relevant to P if and only if (i) c 6∈ cert(q, T ,A), (ii) 〈T ,A ∪ {ϕ(~d)}〉 is consistent, and (iii) c ∈ cert(q, T ,A∪{ϕ(~d)}). We show the only-if direction, since the if direction directly follows by Proposition 4.1 and by the definition of solution. Suppose that ϕ(~d) is ≤-relevant to P. By the definition of minimal solution, it follows that c 6∈ cert(q, T ,A). Also, by Proposition 4.1, it follows that {ϕ(~d)} is a ≤-solution to P. But then, we have that c ∈ cert(q, T ,A ∪ {ϕ(~d)}) and that the ontology 〈T ,A ∪ {ϕ(~d)}〉 is consistent. Since conditions (i-iii) can be decided in non-deterministic logarithmic space for DL-LiteA ontologies, we conclude that, for instance queries and (un)restricted explanation signatures, ≤-rel is in NL.\n(hardness) Hardness can be proved by employing the same reduction as in Theorem 4.2 and by taking A(c) to be the assertion to be shown relevant. By Proposition 4.1, we have that 〈T ,A〉 is consistent if and only if A(c) is ≤-relevant for P."
    }, {
      "heading" : "4.4 Deciding Recognition",
      "text" : "Finally, we consider the problem of deciding whether a given ABox is a solution to a QAP.\nTheorem 4.7. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, rec is NL-complete.\nProof. (membership) Let P = 〈T ,A, q, c,Σ〉 be a QAP (where Σ may be restricted) such that q ∈ IQ and let E be an ABox. By the definition of solution to a QAP, we can decide\nwhether E ∈ expl(P) in three steps: (i) check that E is a Σ-ABox, (ii) check that 〈T ,A ∪ E〉 is consistent, and (iii) check that c ∈ cert(q, T ,A ∪ E). For DL-LiteA ontologies, we can perform these three steps in non-deterministic logarithmic space. Thus, for instance queries and under both restricted and unrestricted signatures, rec is in NL.\n(hardness) We provide a reduction from the consistency problem of DL-LiteA ontologies. Consider an arbitrary ontology 〈T ,A〉. Then, we let A be a fresh concept name not occurring in the ontology and we let c be a fresh individual. Furthermore, let q(x)← A(x) be our instance query. Finally, we let P = 〈T ,A, q, c,Σ〉 be our query abduction problem with unrestricted explanation signature and we let E = {A(c)} be our target ABox. It is not too difficult to see that 〈T ,A〉 is consistent iff E is a solution to P.\nUnsurprisingly, the complexity does not change when we consider a minimality criterion over solutions.\nTheorem 4.8. For DL-LiteA, instance queries, and under both unrestricted and restricted explanation signatures, ≤-rec and ⊆-rec are NL-complete\nProof. By Proposition 4.1, we focus only on ≤-rec. (membership) In order to decide whether E ∈ expl≤(P) we first check that E is indeed a solution to P, which we can do in non-deterministic logarithmic space (see Theorem 4.7). Then, by Proposition 4.1, we need to check that |E| ≤ 1 and that E is the empty ABox whenever c ∈ cert(q, T ,A). Since instance checking in DL-LiteA is in NL, we conclude that ≤-rec is in NL as well.\n(hardness) We can reuse the reduction to consistency in DL-LiteA provided in Theorem 4.7 to show that, for instance queries and under unrestricted explanation signatures, ≤-nec is NL-hard. We conclude that, under both restricted and unrestricted explanation signature, ≤-nec and ⊆-nec are NL-complete."
    }, {
      "heading" : "5. Complexity for Unions of Conjunctive Queries",
      "text" : "In this section, we consider the more general problem of reasoning over query abduction problems that admit UCQs in the input. We establish the complexity of the various rea-\nAlgorithm 2 someExplanation\nInput: QAP P = 〈T ,A, q,~c,Σ〉. Output: “yes” iff P has an explanation.\n1: Guess a CQ qr in the perfect reformulation Rq,T of q w.r.t. T . 2: Guess a ~c-instantiation Eξ of qr. 3: If Eξ \\ A is a Σ-ABox and 〈T ,A ∪ Eξ〉 is consistent, then return “yes”. 4: Return “no”.\nsoning tasks for these problems in DL-LiteA, under both unrestricted and restricted explanation signatures, and under the different minimality criteria. The results in this section are summarized in Table 5.1."
    }, {
      "heading" : "5.1 Existence of Explanations",
      "text" : "We first focus on the problem of deciding whether a query abduction problem with unrestricted signature admits at least one explanation.\nIt follows from Proposition 3.8 that the complexity of this problem coincides with the complexity of deciding consistency without the UNA in the underlying DL. By Proposition 3.5, this extends to ⊆-exist, and ≤-exist. Since reasoning without the UNA is PTime-complete for DL-LiteA (Artale et al., 2009), we obtain the following result.\nTheorem 5.1. For every DL L, UCQs, and under unrestricted explanation signatures, exist, ⊆-exist, and ≤-exist have the same complexity as consistency checking without the UNA in L. Hence for DL-LiteA, the mentioned problems are PTime-complete.\nIf we allow for restricted explanation signatures, then deciding exist becomes harder. For DL-LiteA, the complexity increases from PTime to NP.\nTheorem 5.2. For DL-LiteA, UCQs, and under restricted explanation signatures, exist, ⊆-exist, and ≤-exist are NP-complete. NP-hardness holds already in the following restricted settings:\n1. QAPs where the TBox contains only concept inclusions of the forms A1 v A2 and A1v¬A2 for concept names A1 and A2, the ABox is empty, and the query is a Boolean CQ consisting of a conjunction of unary atoms over a single quantified variable.\n2. QAPs with an empty TBox.\nProof. By Proposition 3.5, it is sufficient to show that exist is NP-complete.\n(membership) The upper bound follows from guess-and-check Algorithm 2, which is immediate by Proposition 3.10. It guesses non-deterministically a CQ qr in the perfect reformulation Rq,T of q w.r.t. T , and a ~c-instantiation Eξ of qr. The algorithm then checks in polynomial time that Eξ \\A is a Σ-ABox and that the ontology 〈T ,A ∪ Eξ〉 is consistent; it was shown by Calvanese et al. (2009) that the latter check is polynomial.\n(hardness) Next, we provide the two hardness results. The first one follows directly from Proposition 3.7 and the hardness proof for CQ query emptiness for the sublogic of\nDL-LiteA known as DL-Litecore given in Theorem 17 by Baader et al. (2010). For showing hardness in the second setting, we reduce the following NP-complete problem: given a pair of directed graphs G = (V,E) and G′ = (V ′, E′), decide whether there exists an homomorphism from G to G′. To this end, let A = {e(ca, cb) | (a, b) ∈ E′} be an ABox. Furthermore, for B an arbitrary atomic concept and c a globally fresh individual, let q = {e(xa, xb) | (a, b) ∈ E} ∪ {B(c)} be a Boolean CQ and Σ = {B} be a signature. Finally, let PG,G′ = 〈∅,A, q,Σ〉 be a QAP; we show that there exists a homomorphism from G to G′ iff there is a solution to PG,G′ . Indeed, if there is a homomorphism from G to G′, then {B(c)} is a solution to P. For the other direction, assume there is an explanation E for P. Since binary atoms are prohibited from occurring in E by the selection of Σ, there must exist a match π from q to DBA. Such a mapping π also witnesses the existence a homomorphism from G to G′."
    }, {
      "heading" : "5.2 Deciding Necessity",
      "text" : "Now, we consider the problem of checking whether an assertion occurs in all the solutions to a QAP P; that is, whether an assertion is necessary for P. For the case of restricted explanation signatures, we use the reductions from Section 3.1 and Theorem 5.2 to derive that nec and ⊆-nec are coNP-complete. For the case of unrestricted explanation signatures, we use the procedure for solving nec described in Algorithm 1 to show that nec and ⊆-nec are PTime-complete.\nTheorem 5.3. For DL-LiteA, UCQs, and under unrestricted explanation signatures, nec and ⊆-nec are PTime-complete. Furthermore, under restricted explanation signatures, nec and ⊆-nec are coNP-complete.\nProof. In Theorem 5.1 and Theorem 5.2, we proved that the problems of deciding the existence of a solution to a QAP with unrestricted and with restricted explanation signatures are PTime-complete and NP-complete, respectively. By applying the reduction in Proposition 3.1, we have that nec is PTime-hard under unrestricted and coNP-hard under restricted explanation signatures.\nFor the upper bound, we first consider the case of restricted explanation signatures. By Proposition 3.2, nec reduces to non-exist. By Theorem 5.2, this latter problem can be solved in nondeterministic polynomial time. We readily obtain that nec is in coNP. For the case of unrestricted signatures, Proposition 4.3 states that algorithm isNEC solves nec, even when we consider UCQs in input. By the definition, isNEC requires checking whether polynomially many QAPs do not admit a solution, and whether polynomially many DLLiteA ontologies entail a given assertion. Since for DL-LiteA, instance checking is in PTime and, by Theorem 5.1, non-exist is in PTime, we conclude that isNEC runs in polynomial time. Thus, nec under unrestricted signatures is in PTime.\nWe conclude that nec is PTime-complete under unrestricted and coNP-complete under restricted explanation signatures.\nFinally, Proposition 3.4 states that nec and ⊆-nec are equivalent and, thus, also ⊆-nec is PTime-complete under unrestricted and coNP-complete under restricted explanation signatures.\nNow, we consider the complexity of ≤-nec and we show that, under common assumptions, the problem is harder than nec. Intuitively, this is because one has to first compute the minimal size of an explanation, and then inspect all the explanations of that size. In the following, we will use [i..j] to denote the integer interval {i, . . . , j}. Theorem 5.4. For DL-LiteA, UCQs, and under both unrestricted and restricted explanation signatures, ≤-nec is PNP‖ -complete. The hardness holds already for QAPs with an empty TBox and a CQ.\nProof. We structure the proof as follows. First, we show that ≤-nec is in PNP‖ . Then, we prove that the problem is PNP‖ -hard under restricted signatures. Finally, we argue that the same reduction can also be used in the particular case of unrestricted signatures.\n(membership) Consider an arbitrary QAP P = 〈T ,A, q,~c,Σ〉 (where the signature may be restricted) and let α be an arbitrary ABox assertion. From Corollary 3.9, we know that if P has an explanation, then there exists an explanation whose size m is bounded by max(q) = maxqi∈q |at(qi)|. Observe that 〈P, α〉 is a negative instance of ≤-nec iff there is an i ∈ [0..m] such that (a) P has an explanation E with |E| = i and α 6∈ E , and (b) E is ≤-minimal. Thus, we use an auxiliary problem size-out, which is to decide given a tuple 〈P ′, α′, n′〉, where P ′ is a QAP, α′ is an assertion, and n′ is an integer, whether there exists an explanation E ′ for P ′ such that |E ′| = n′ and α′ 6∈ E ′. Furthermore, the problem no-smaller is to decide, given a tuple 〈P ′, n′〉 of a QAP and an integer, whether there is no explanation E ′ for P ′ such that |E ′| < n′. Observe that size-out is in NP, while no-smaller is in coNP. Take the tuple S = 〈A0, B0, . . . , Am, Bm〉, where Ai = 〈P, α, i〉 and Bi = 〈P, i〉, for all i ∈ [0..m]. Due to the above observation, α occurs in all ≤-minimal explanations E for P iff for all i ∈ [0..m], one of the following holds: (i) Ai is a negative instance of size-out, or (ii) Bi is a negative instance of no-smaller. S can be built in polynomial time in the size of the input, and whether all instances instances in S satisfy (i) and (ii) above can be decided by making 2m parallel calls to an NP oracle. Thus we obtain membership in PNP‖ .\n(hardness) We give a reduction from OddMinVertexCover, which is PNP‖ -complete (Wagner, 1987). An instance of this problem is given by a graph G = (V,E), and we are asked whether the least cardinality over all vertex covers in G is odd. That is, is there an odd integer k ∈ [1..|V |] such that G has a vertex cover C with |C| = k, and there is no vertex cover C ′ in G with |C ′| < k?\nIn the reduction we exploit the following property. Given an integer k and a directed graph G = (V,E) with m vertices, construct a new graph G′ = ([1..m], E′) such that there exist two symmetric edges between each i ∈ [1..k] and j ∈ [1..m]. The following holds: if there is an injective homomorphism h from G to G′, then G has a vertex cover of size k. Indeed, take C = {v ∈ V | h(v) ≤ k}. Due to injectivity, |C| = k. Assume an arbitrary edge {v1, v2} ∈ E. Since h is a homomorphism, due to the selection of edges we must have h(v1) ≤ k or h(v2) ≤ k. Then {v1, v2} ∩ C 6= ∅ by the selection of C.\nAssume an arbitrary graph G = (V,E) with vertices V = {v1, . . . , vm}. W.l.o.g., G is connected, directed, and has at least 2 nodes. We construct next a QAP PG = 〈∅,A|V |, qG, 〈〉,ΣG〉 and an assertion αG such that G is a positive instance of OddMinVertexCover iff αG is ≤-necessary for PG. In the reduction we use individuals odd , even, cij , where i, j ∈ [0..m], concept names M , L, and roles P , 6=, Edge.\nLet qG be the Boolean query consisting of atoms\n(i) Edge(xi1 , xi2), for each edge (vi1 , vi2) ∈ E,\n(ii) 6=(xi1 , xi2), for each i1, i2 ∈ [1..m], i1 6= i2, and\n(iii) L(x1), . . . , L(xm) and P (x1, y), M(y).\nIntuitively, in (i) we represent the graph G in the query. We will use atoms in (ii) to ensure that different variables are mapped to distinct elements. The atoms L(xi) will be used to measure the size of vertex covers, while the atoms P (x1, y) and M(y) will be used to determine their parity. We allow explanations only over concept names, and thus set ΣG = {M,L}.\nTo define A|V |, we first construct a collection A0, . . . ,Am of ABoxes, where each Aj consists of the assertions\n(a) L(cji ), for each i ∈ [j..m],\n(b) Edge(cji1 , c j i2 ), for all i1, i2 ∈ [1..m] with i1 ≤ j or i2 ≤ j, and\n(c) 6=(cji1 , c j i2 ), for all i1, i2 ∈ [1..m] with i1 6= i2.\nFor an integer k, let par(k) = odd if k is odd, and par(k) = even, otherwise. Let A′ = {P (cji , par(j)) | i, j ∈ [0..m]}. Then A|V | = A0∪· · ·∪Am∪A′. See Figure 1 for an example.\nFinally, we let αG = M(odd). To prove the correctness of the reduction, we define up(k) = {L(ck1), . . . , L(ckk),M(par(k))}, and claim the following:\nclaim 1: If C is a vertex cover in G of size k, then up(k) is an explanation for PG. Let A∗ = A|V | ∪up(k). It suffices to show the existence of a match π for qG in DBA∗ . Take an enumeration z1, . . . , zm of variables x1, . . . , xm such that {z1, . . . , zk} = {xi | vi ∈ C}. Take the mapping π such that π(zi) = c k i for all i ∈ [1..m], and π(y) = par(k). Assume an atom Edge(xi1 , xi2) in qG. Due to (b) in the definition of Aj , it suffices to show that π(xi1) = c k ` or π(xi2) = c k ` for some ` ≤ k. Indeed, since C is a vertex cover, vi1 ∈ C or vi2 ∈ C. Then due to the enumeration of variables, xi1 = z` or xi2 = z` for some ` ≤ k. Due to the definition of π, π(xi1) = c k ` or π(xi2) = c k ` for ` ≤ k. The atoms 6=(xi1 , xi2) in qG are properly mapped due to (c) in the construction of Aj and the fact that π is injective\nby construction. For an atom L(xi) in qG we have two options. If π(xi) = c k ` with ` ≤ k, then L(ck` ) ∈ up(k) by the definition of up(k). Otherwise, if ` > k, then L(ck` ) ∈ Ak by the definition of Ak. The atom P (π(x1), π(y)) belongs to A∗ due to the definition of A′, while M(π(y)) ∈ up(k) by construction of up(k).\nclaim 2: Assume up(k) is an explanation for PG. Then G has a vertex cover of size k. Let A∗ = A|V |∪up(k) and let π be a match for qG in DBA∗ . Observe that due irreflexivity of the role 6= and the atoms (ii) in qG, π must be injective. Observe also that for all ` ∈ [1..m], where ` 6= k, we have |{c`i | L(c`i) ∈ A`}| < m. Due to the connectedness of G and atoms L(x1), . . . , L(xm) in qG, π must use only the atoms in Ak ∪A′ ∪ up(k). That is, π is also a match for qG in DBAk∪A′∪up(k). Let C = {vi ∈ V | π(xi) = ckn, n ∈ [1..k]}. Then |C| = k due to the injectivity of π. To see that C is a vertex cover, assume an edge (vi1 , vi2) ∈ E. By construction, qG has the atom Edge(xi1 , xi2). Since π is a match in DBAk∪A′∪up(k), Edge(π(xi1), π(xi2)) ∈ Ak. Then, by construction of Ak, we have π(xi1) = ckn or π(xi2) = ckn with n ≤ k. Then by the selection of C, {π(xi1), π(xi2)} ∩ C 6= ∅.\nclaim 3: Assume E is a ≤-minimal explanation for PG with size k. Then E = up(k − 1). Since G is connected and E is ≤-minimal, there exist an index ` ∈ [1..m] such that E ⊆ {L(c`1), . . . , L(c`m),M(par(`))} and there is a match for qG in A` ∪ A′ ∪ E . Since L(c`i) ∈ A` for i ∈ [`+1..m] by the definition of A`, we have by cardinality minimality that E ⊆ {L(c`1), . . . , L(c``),M(par(`))}. By the definition of A`, |{c`i | L(c`i) ∈ A`}| = m − `. Thus, due to the injectivity of any match π for qG, we must have |{c`i | L(c`i) ∈ E}| ≥ `. Hence, E = {L(c`1), . . . , L(c``),M(par(`))} = up(`). Since |E| = k, we have ` = k − 1.\nWe can now finalize the correctness proof:\n(⇒) Suppose there exists an odd integer k ∈ [1..|V |] such that G has a vertex cover C with |C| = k, and there is no vertex cover C ′ in G with |C ′| < k. By claim 1, up(k) is an explanation for PG. We make sure that up(k) is ≤-minimal. Suppose there exists an explanation E ′ with size |E ′| < |up(k)|, i.e., |E ′| = ` for some ` ≤ k. We can assume that E ′ is ≤-minimal. Then by claim 3, E ′ = up(` − 1). It follows from claim 2 that G has a vertex cover of size ` − 1. Since ` − 1 < k, we arrive at a contradiction to the assumption that G has no vertex cover of size < k. Thus up(k) is ≤-minimal. Since k is odd, we have M(odd) ∈ up(k). By claim 3, apart from up(k) there is no other ≤-minimal explanation for PG. That is, M(odd) occurs in all ≤-minimal explanations for PG.\n(⇐) Assume M(odd) occurs in all ≤-minimal explanations for PG. By claim 3, we know that up(k) is the unique ≤-minimal explanation, for some integer k. Since M(odd) ∈ up(k), we get that k is odd. Then, by claim 2, there is a vertex cover C with size k. It remains to ensure that there is no vertex cover C ′ of size ` < k. Assume the opposite. Then by claim 1 we have that up(`) is an explanation with size |up(`)| < |up(k)|, which contradicts the assumption that up(k) is ≤-minimal. Thus G is a positive instance of OddMinVertexCover.\nThe definition of ΣG prohibits binary atoms from occurring in ≤-minimal explanations. The same effect can be achieved by using ΣG = Σ(∅,A|V |, qG) and by modifying A|V | and qG to make it prohibitively expensive to have binary atoms in ≤-minimal explanations. Simply replace each binary assertion r(c, d) in A|V | by fresh assertions r1(c, d), . . . , rm+2(c, d), and each binary r(x, y) in qG by r1(x, y), . . . , rm+2(x, y). In this way the lower-bound can be shown for unrestricted explanation signatures."
    }, {
      "heading" : "5.3 Deciding Relevance",
      "text" : "Using Theorems 5.1 and 5.2, and the reductions in Section 3, we obtain the following results.\nTheorem 5.5. For DL-LiteA, UCQs, and under unrestricted explanation signatures, rel is PTime-complete. Under restricted explanation signatures, rel is NP-complete.\nUnsurprisingly, for UCQs, ≤-rel has the same complexity as ≤-nec. Indeed, the two problems share the same source of complexity, namely the need to inspect all explanations up to a computed size, which allows us to reduce the OddMinVertexCover problem. In fact, PNP‖ -hardness can be shown using the same reduction as in the proof of Theorem 5.4, and a matching upper bound can be obtained by slightly modifying the algorithm for ≤-nec.\nTheorem 5.6. For DL-LiteA, UCQs, and under both unrestricted and restricted explanation signatures, ≤-rel is PNP‖ -complete. P NP ‖ -hardness holds already for QAPs with an empty TBox and a CQ.\nProof. First, we show that, under restricted explanation signatures, the problem ≤-rel is in PNP‖ . Second, we argue that, under unrestricted explanation signatures, ≤-rel is P NP ‖ -hard.\n(membership) ≤-rel can be tackled in a way similar to ≤-nec. In fact, the algorithm described in Theorem 5.4 can be modified in order to solve this problem. Let size-in solve the following problem: given a tuple 〈P, α, n〉, where P is a QAP, α an assertion, and n an integer, decide whether there exists an explanation E , with |E| = n and α ∈ E . Then, we change the positivity condition of the ≤-nec algorithm as follows: α occurs in some ≤-minimal explanation E for P iff for some i ∈ [0..m] it holds that: (i) Ai is a positive instance of size-in, and (ii) Bi is a positive instance of no-smaller. It is easy to see that size-in is solvable in NP, hence the whole problem is again in PNP‖ .\n(hardness) Recall the reduction from OddMinVertexCover to ≤-nec in the proof of Theorem 5.4. We argue that exactly the same reduction also shows PNP‖ -hardness of ≤-rel. Assume a directed graph G and let PG and αG be the QAP and the assertion resulting in the reduction. To prove the claim it suffices to show the following equivalence: αG is ≤-necessary for PG iff αG is ≤-relevant for PG. This equivalence follows directly from claim 3, which states that PG has a unique ≤-minimal explanation.\nWe now turn our attention to ⊆-rel. For this problem we obtain a precise complexity characterization for the case of restricted explanation signatures, but we leave it open whether for unrestricted signatures the ΣP2 upper bound shown below is tight.\n2 We note that for the latter case, a coNP lower bound can be easily shown, for instance, by a reduction from the non-existence of a homomorphism between two graphs.\nTheorem 5.7. For DL-LiteA, UCQs, and under both unrestricted and restricted explanation signatures, ⊆-rel is in ΣP2 . Under restricted explanation signatures, ⊆-rel is ΣP2 -hard, and the hardness holds already for QAPs with an empty TBox and a CQ.\nProof. (membership) Let P = 〈T ,A, q,~c,Σ〉 be a QAP and let α be an ABox assertion. We now provide an extended version of the algorithm solving existence, which decides whether α\n2. The proof of the ΣP2 lower bound under unrestricted signatures in Theorem 2 by Calvanese, Ortiz, Simkus, and Stefanoni (2011) is incorrect.\nis ⊆-relevant for P. Let has-subexpl solve the problem of deciding whether a given explanation E has a subset which is itself an explanation. In our modified algorithm, similarly to Algorithm 2, first we non-deterministically guess a CQ qr in the perfect reformulation Rq,T of q w.r.t. T and a ~c-instantiation Eξ of qr such that α ∈ Eξ. Additionally to the consistency test and to checking that Eξ is a Σ-ABox, we also check the complement of has-subexpl for E , in order to assure that E is ⊆-minimal. It follows that α is ⊆-relevant. Since checking the complement of has-subexpl can be done in coNP, the problem is solvable in ΣP2 .\n(hardness) We reduce the ΣP2 -complete problem non-cert3col (Stewart, 1991, see also Bonatti, Lutz, & Wolter, 2009). An instance of non-cert3col is given by a graph G = (V,E) with vertices V = {1, . . . , n} such that every edge is labelled with a disjunction of two literals over the Boolean propositions {p(i,j) | 1 ≤ i, j ≤ n}. We say that edge e ∈ E evaluates to true under truth assignment τ if τ satisfies the disjunction labelling e. Then, graph G is a positive instance to non-cert3col iff a truth assignment τ exists such that graph τ(G)—obtained from G by including only those edges that evalute to true under τ—is not 3-colorable. Assume an instance G of non-cert3col. We show how to build in polynomial time a QAP PG = 〈TG,AG, qG,~cG,ΣG〉 and an ABox assertion αG. We first present all relevant definitions, after which we discuss the intuition behind the reduction and prove its correctness.\nIn the construction, we use an empty TBox and a Boolean CQ, thus TG = ∅ and ~cG = 〈〉. In order to define the ABox AG, let L be a function that assigns to each edge e ∈ E the set {l1, l2} of literals occurring in its label. Moreover, we let T(e) (resp., F(e)) be the set containing each truth assignment τ to the literals in L(e) such that edge e evaluates to true (resp., false) under τ . Finally, for each truth assignment τ and each literal l occurring in G, we define the image of l w.r.t. τ , written imgτ (l), as follows.\nimgτ (l) :=\n{ l if τ(l) = t\nl̄ otherwise\nWe are now ready to define the ABox AG. In the definition, we use individuals a1, . . . , a4; moreover, for each literal l in G, we use individuals l and l̄ to denote l’s truth value. Also, for all 1 ≤ k ≤ ` ≤ 4, each edge e ∈ E, and each truth assignment τ ∈ T(e) ∪ F(e), we let σe,τk,` be a fresh individual. ABox AG consists of four distinct components A\n∗, AtT , AfT , and AC which we introduce next.\nA∗ ={d(l, l̄), d(l̄, l) | literal l occurs in G} ∪ {B(ak) | 1 ≤ k ≤ 3}\nAtT ={Re(ak, σ e,τ k,` ), Re(σ e,τ k,` , a`) | e ∈ E, τ ∈ T(e), 1 ≤ k < ` ≤ 3} ∪\n{P (σe,τk,` , imgτ (l)) | e ∈ E, τ ∈ T(e), l ∈ L(e), 1 ≤ k < ` ≤ 3}\nAfT ={Re(ak, σ e,τ k,` ), Re(σ e,τ k,` , a`) | e ∈ E, τ ∈ F(e), 1 ≤ k ≤ ` ≤ 3} ∪\n{P (σe,τk,` , imgτ (l)) | e ∈ E, τ ∈ F(e), l ∈ L(e), 1 ≤ k ≤ ` ≤ 3}\nAC ={Re(a4, σe,τ4,4), Re(σ e,τ 4,4 , a4) | e ∈ E, τ ∈ T(e) ∪ F(e)} ∪\n{P (σe,τ4,4 , imgτ (l)) | e ∈ E, τ ∈ T(e) ∪ F(e), l ∈ L(e)}\nNext, we define the Boolean query qG. To this end, for each vertex i ∈ V , let xi be a distinct variable; for each edge 〈i, j〉 ∈ E, let yi,j be a distinct variable; and, for each literal l occurring in G, let zl and z̄l be two distinct variables. Then, for each edge 〈i, j〉 ∈ E, let qG contain the following atoms.\n{B(xi), Re(xi, yi,j), Re(yi,j , xj), B(xj)} ∪ {P (yi,j , zl), Al(zl), d(zl, z̄l) | l ∈ L(e)}\nFinally, we let αG = B(a4) be the assertion we want to show to be relevant and let ΣG = {Al | literal l occurs in G} ∪ {B} be the signature.\nNow, we outline the main idea behind this construction. ABox AG encodes two structures: a triangular structure AtT ∪ AfT and a cyclic structure AC . The former structure over individuals a1, a2, and a3 is such that edges in G that evaluate to true according to an arbitrary truth assignment τ can be mapped only to non-reflexive edges (cf. AtT ). In contrast, edges of G that evaluate to false according to τ can be mapped to an arbitrary edge (cf. AfT ). The latter, cyclic, structure AC over individual a4 (which is not asserted to be member of B) is such that G can be mapped over AC under all possible truth assignments.\nQuery qG is obtained from graph G by requiring that each vertex of the graph is a member of concept B, by reifying edges of the graph, and by incorporating the disjunction over literals. In particular, for each literal l in G, variables zl and z̄l represent the truth values of l and atom Al(zl) is used to enforce a particular truth assignment. Since ABox AG does not contain assertions over concept Al, each minimal explanation Eτ for PG corresponds to a truth assignment τ for G. That is, such Eτ contains, for each literal l in G, either Al(l) or Al(l̄). Also, by the definition of the ABox, query qG can be mapped over AtT ∪ AfT under minimal explanation Eτ implies that τ(G) is 3-colorable. In contrast, for every truth assignment τ , we can map query qG over the cyclic structure AC , provided that explanation Eτ asserts the individual a4 to be a member of B. We are now ready to formally prove the correctness of our reduction.\n(⇒) Suppose there is a truth assignment τ such that τ(G) is not 3-colorable; we show that assertion B(a4) is ⊆-relevant for PG. Consider the Σ-ABox E = {B(a4)} ∪ Eτ , where Eτ = {Al(l) | τ(l) = t} ∪ {Al(l̄) | τ(l) = f}. Clearly, E is an explanation. Indeed, we can match the query qG over the cyclic structure AC by mapping all variables xi of qG to (interpretation of) a4. Suppose there is a smaller explanation E ′ ⊂ E . Observe that Eτ ⊆ E ′. This is because, for each literal l, concept Al does not occur in AG but does occur in qG. Then, E \\ {B(a4)} must be an explanation. Then qG can be matched over the triangular structure encoded in AG. Thus, τ(G) is 3-colorable which contradicts the assumption.\n(⇐) Let E be a ⊆-minimal explanation for PG containing B(a4); we show that there exists a truth assignment τ such that τ(G) is not 3-colorable. We first argue that for each literal l we have that either Al(l) ∈ E or Al(l̄) ∈ E . This follows from three considerations. First, due to the signature restriction, predicate d cannot occur in E . Second, for each literal l, query qG contains atoms Al(zl) and d(zl, z̄l), whereas ABox AG contains assertions d(l, l̄) and d(l̄, l). Third, for each literal l, concept Al occurs in qG with one and only variable zl. Therefore, since E is a minimal solution, we know that exactly one of Al(l) ∈ E and Al(l̄) ∈ E holds. Next, we define the truth assignment τ to the literals occurring in G. For each literal l in G, let τ(l) = t if Al(l) ∈ E , and τ(l) = f if Al(l̄) ∈ E . It is not difficult to argue that t(G) is not 3-colorable and thus G is a positive instance of non-cert3col.\nIndeed, if τ(G) was 3-colorable, qG could be mapped over the triangle structure of AG making E \\ {B(a4)} a smaller explanation, which is a contradiction."
    }, {
      "heading" : "5.4 Recognizing Explanations",
      "text" : "Unsurprisingly, for UCQs and under both unrestricted and restricted explanation signatures, rec is in NP. Indeed, in order to solve the problem, we need to check consistency of the explanation with the ontology, and check whether the given tuple is in the certain answer to the query. The former is polynomial and the latter in NP.\nTheorem 5.8. For DL-LiteA, UCQs, and under both restricted and unrestricted explanation signatures, we have that rec is NP-complete. NP-hardness holds already for QAPs with an empty TBox and a CQ.\nProof. As usual, we first show that, under (un)restricted explanation signatures, rec is in NP. Then, we argue that, under unrestricted explanation signatures, the problem is NP-hard.\n(membership) Given a QAP P = 〈T ,A, q,~c,Σ〉 and an ABox E , we devise an algorithm deciding rec as follows. Firstly, the procedure checks that E is indeed a Σ-ABox; this check is linear in E . Then it makes sure that extending the ontology with ABox E does not lead to an inconsistent theory; this can be checked in polynomial time (Artale et al., 2009). At last, it decides whether ~c occurs in cert(q, T ,A ∪ E); by Proposition 2.1 this is feasible in NP. Hence overall the algorithm runs in non-deterministic polynomial time.\n(hardness) We use essentially the same reduction from the existence of a homomorphism between directed graphs G and G′ as in the proof of Theorem 5.2, the only difference being that instead of reducing it to the existence of an explanation over the signature Σ = {B}, we leave the signature unrestricted (that is, Σ = Σ(T ,A, q)), and reduce the problem to deciding whether E = {B(c)} is an explanation.\nIn case a preference order is in place, to recognize an explanation one has to check minimality as well. This check is coNP-hard for ⊆- and ≤-minimality, leading to completeness for DP.\nTheorem 5.9. For DL-LiteA, UCQs, and under both restricted and unrestricted explanation signatures, we have that ≤-rec and ⊆-rec are DP-complete. DP-hardness holds already for QAPs with an empty TBox and a CQ.\nProof. We first argue that, under (un)restricted explanation signatures, the two problems are in DP. Then, under unrestricted explanation signatures, we prove that ≤-rec and ⊆-rec are DP-hard.\n(membership) Membership of a problem Π in DP can be shown by providing two languages L1 ∈ NP and L2 ∈ coNP, such that the set of all yes-instances of Π is L1 ∩ L2. For ≤-rec, simply let\nL1 = {(P, E) | E ∈ expl(P)} L2 = {(P, E) | P has no explanation E ′ s.t. |E ′| < |E|}\nFor ⊆-rec, we take L1 as above and L2 = {(P, E) | P has no explanation E ′ s.t. E ′ ( E}.\n(hardness) DP-hardness is shown by a reduction from the problem HP-noHP. An instance of HP-noHP is given by two directed graphs G = (V,E) and G′ = (V ′, E′), where 〈G,G′〉 is a positive instance iff G has an Hamilton path and G′ does not have one. For such a pair 〈G,G′〉, we define a QAP P = 〈∅,A, q, 〈〉,Σ〉 and a Σ-ABox E such that: (a) 〈G,G′〉 is a positive instance of HP-noHP iff E is a ≤-minimal explanation for P, and (b) 〈G,G′〉 is a positive instance of HP-noHP iff E is a ⊆-minimal explanation for P. W.l.o.g., nodes in G and G′ are disjoint and are ordinary individuals. Construct an ABox AG = {e(vi, vj) | (vi, vj) ∈ E} ∪ {d(vi, vj) | vi, vj ∈ V, vi 6= vi}. Intuitively, an assertion e(vi, vj) encodes an edge (vi, vj) in the graph G, whereas an assertion d(vi, vj) encodes that nodes vi and vj are distinct. The ABox AG′ encodes G′ in a similar way as before, using roles e′ instead of e, and in addition it has an assertion A(v′i) for each v ′ i ∈ V ′. Take a set of fresh individuals O = {o1, . . . , o|V ′|} and an ABox AC = {e′(oi, oj), d(oi, oj) | 1 ≤ i 6= j ≤ |V ′|}. Then the ABox A in P is defined as A = AG ∪ AG′ ∪ AC .\nLet q = q1 ∧ q′1 ∧ q2 ∧ q′2 ∧ q3 be a Boolean CQ with\nq1 = {e(x1, x2), e(x2, x3), . . . , e(x|V |−1, x|V |))}, q′1 = {d(xi, xj) | vi, vj ∈ V, vi 6= vj}, q2 = {e′(y1, y2), e′(y2, y3), . . . , e′(y|V ′|−1, y|V ′|)}, q′2 = {d(yi, yj) | v′i, v′j ∈ V ′, v′i 6= v′j}, q3 = {A(y1), . . . , A(y|V ′|)}.\nIntuitively, q1∧q′1 asks for a simple path with |V | vertices related via the role e. Analogously, q2 ∧ q′2 asks for a simple path with |V ′| vertices related via the role e′. Additionally, q3 asks that each node on the latter path satisfies A.\nFinally, we let E = {A(oi) | oi ∈ O} and we let Σ = Σ(T ,A, q). (⇒) Assume that 〈G,G′〉 is a positive instance of HP-noHP, and let a1, . . . a|V | be a Hamilton path in G. We show that E is a ≤-minimal and a ⊆-minimal explanation for P. To this end, first take a mapping π for variables in q such that π(x1) = a1, . . . , π(x|V |) = a|V | and π(y1) = o1, . . . , π(y|V ′|) = o|V ′|. Then clearly π is a match for q in DBA∪E , and hence E is an explanation to P. Indeed, the subquery q1 ∧ q′1 of q is fulfilled because a1, . . . a|V | is a Hamilton path in G, q2 ∧ q′2 is fulfilled because AC has a clique of size |V ′|, while q3 is fulfilled by E . To assure minimality, assume towards a contradiction that there is an explanation E ′ with |E ′| < |E| or |E ′| ⊂ |E|. In any case, |E ′| < |V ′|. Assume π′ is a match for q in DBA∪E ′ . Note that AG and AG′ do not share individuals. Since q3 ∧ q′2 asks for |V ′| elements satisfying A and |E ′| < |V ′|, π′ must map the variables y1, . . . , y|V ′| to the |V ′| distinct individuals of AG′ . Then the presence of q2 in q implies the existence of a Hamilton path in G′. Contradiction.\n(⇐) Assume that E ∈ expl≤(P) (resp., E ∈ expl⊆(P)) and π is a match for q in DBA∪E . Note that e′ does not occur in AG and e does not occur in AG′ ∪AC . Then by construction of q1 ∧ q′1 and AG, π maps the variables x1, . . . , x|V | to the |V | distinct constants of AG and G must have a Hamilton path. Towards a contradiction suppose G′ also has a Hamilton path. Then by construction of AG′ , q2 ∧ q′2 ∧ q3 has a match in DBAG′ . This means we can build a match π′ for q in DBAG′ , which in turn means that ∅ is an explanation to P. This contradicts the assumption that E is ≤-minimal (resp., ⊆-minimal)."
    }, {
      "heading" : "6. Discussion",
      "text" : "In this section, we discuss some issues that remain for further investigation."
    }, {
      "heading" : "6.1 Computing Explanations",
      "text" : "In our complexity analysis for DL-LiteA, we have not considered the problem of computing solutions to query abduction problems. Nevertheless, we can infer upper bounds on the complexity of computing solutions to a QAP P from the presented results. If the input query in P is an instance query, then both computing an arbitrary solution and computing all minimal3 solutions is easy, since by Proposition 3.10, we only need to consider singleton candidate explanations, and their number is polynomially bounded. The problem of computing an arbitrary solution E remains polynomial for UCQs if the signature of P is unrestricted, since we can always obtain E by creating a suitable direct instantiation of one of the CQs in input (see Section 3.3). Instead, under restricted signatures, the total number of (minimal) solutions is in general exponential in the size of the signature Σ and in the maximal size of each query occurring in the input UCQ; so computing all of them requires in general exponential time. It remains to be investigated whether these solutions can be enumerated with a polynomial delay (cf., Penaloza & Sertkaya, 2010). In the case of a restricted signature, however, the NP-harness result established in Theorem 5.2 implies that to compute a solution E one essentially essentially cannot do better than guessing the ABox E and deciding whether E ∈ expl (P)."
    }, {
      "heading" : "6.2 Data Complexity",
      "text" : "In this work we have focused on combined complexity. With respect to data complexity (i.e., when the complexity is measured with respect to the size of the ABox only, while both the query and the TBox are considered fixed) and ontology complexity (i.e., when only the query is considered fixed), we observe that those inference tasks that we have shown to be NP-complete essentially rely on checking ontology consistency, and hence are in AC0 in data complexity (Calvanese et al., 2009). Moreover, by Corollaries 3.9 and 3.11, one can restrict the attention to explanations that are bounded by the size of the query, it follows that for a fixed query, there are only polynomially many explanations to be considered. Hence all our reasoning tasks are polynomial both in data complexity and in ontology complexity."
    }, {
      "heading" : "6.3 Other Description Logics.",
      "text" : "All the lower bounds proved in the paper do not rely on properties that are exclusive to DL-LiteA, hence they hold for other DLs as well. In fact, as we have mentioned, many lower bounds hold even in the absence of a TBox. As for the upper bounds, we have relied on DL-LiteA and on the existence of the perfect reformulation of a given query (see Proposition 2.1) only to argue that canonical explanations are small and have a restricted signature (more specifically, that they can be obtained by instantiating CQs in the perfect reformulation of the input query) and that query answering can be done in NP. For this reason, we expect our results to carry over to other DLs that admit “small” explanations\n3. Since every ABox that is a superset of a solution is itself a solution, if we don’t impose any minimality condition, there will always be an exponential number of solutions, provided that one exists.\nand for which query answering is in NP. For instance, both the lower and the upper bounds we have established hold for OWL 2 QL, which is obtained from DL-LiteA by forbidding functionality assertions and dropping the unique name assumption (as our results do not rely on functionality axioms, the unique name assumption is irrelevant).\nFor more expressive DLs, some bounds on the complexity of our reasoning tasks can also be inferred. In Corollary 5.1, we showed that for QAPs under unrestricted explanation signatures, deciding the existence of an explanation has the same complexity as ontology consistency without the UNA. Hence, the problem is ExpTime-complete for all the extensions of ALC in which standard reasoning (with or without the UNA) is also ExpTime-complete, like the well known SHIQ. If we consider restricted explanation signatures, the problem becomes significantly harder. This is witnessed by the lower bounds by Baader et al. (2010) stemming from CQ-emptiness (see Proposition 3.6): exist is already 2ExpTime hard for ALCI (Theorem 28 of Baader et al., 2010), and undecidable for ALCF (Theorem 29). For ALC, the authors have recently improved the lower bound of CQ-emptiness from ExpTime to NExpTime (personal communication). As mentioned in Section 3, their upper bounds do not apply directly to our setting (although we expect some of them to extend), and the precise characterization of the reasoning problems considered in this paper for expressive DLs remains open."
    }, {
      "heading" : "7. Related Work",
      "text" : "The problem of explaining missing query answers was first considered by the database community (Jagadish, Chapman, Elkiss, Jayapandian, Li, Nandi, & Yu, 2007). In the literature, we found three different models of explanation for missing answers, which differ on the notion of solution. First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan, and Naughton (2008) have defined solutions to be sequences of database update operations such that the result of answering the given conjunctive query over the updated relational instance includes the missing answer. Herschel and Hernández (2010) have generalized this latter model by considering UCQs with aggregation and grouping. Although this explanation model is closely related to ours, both the work by Huang et al. and by Herschel and Hernández tackle the problem from the point of view of computing solutions, whereas we are interested in outlining the computational complexity of the problem. Moreover, in the spirit of abductive reasoning, our solutions are of a declarative rather than operational nature—that is, solutions are databases rather than a sequence of database operations.\nIn classical logic, abductive reasoning is a form of non sequitur argument, in which a conclusion B is not a logical consequence of the premises Γ (Γ 6|= B), even though B is assumed to follow from the theory (Eiter & Gottlob, 1995). The aim is to find a set of formulas A such that Γ ∪ A |= B. Abductive reasoning is important also in the context of Description Logics (Elsenbroich, Kutz, & Sattler, 2006), where three orthogonal abductive problems have been studied. First, abduction has been studied to explain concepts—that is, given two concepts C and D and a TBox T , concept abduction amounts to finding a\nconcept H such that T |= C uH v D and C uH is satisfiable w.r.t. T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems. In particular, given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction amounts to finding a subset A of Ax such that T ∪ A |= O. Third, Klarman, Endriss, and Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies. This problem consists in finding which additions need to be made to the ABox in order to force a set of ABox assertions to be logically entailed by the ontology. Along the same line, Du, Qi, Shen, and Pan (2011a) have considered this problem from a more practical perspective.\nMore recently, Du, Wang, Qi, Pan, and Hu (2011b) have defined the problem of abductive conjunctive query answering, which they use as the basis for a new approach to semantic matchmaking. Given a satisfiable DL ontologyO and a CQ q, a tuple ~c is called an abductive answer to q w.r.t. O if there exists a set E of ABox assertions such that O ∪ E |= q(~c). Similarly to our approach, the authors allow to restrict the signature over which abductive solutions can be constructed. In addition, one can limit the impact of E on O by specifying a set of closed predicates; for each assertion α over a closed predicate we require that O ∪ E |= α if and only if O |= α. The main contribution of the paper is a procedure for computing abductive answers to CQs over ontologies formulated in the DLP fragment of OWL 2, which is a fragment orthogonal to DL-LiteA in terms of expressiveness. Considering closed predicates in the context of DL-LiteA and QAPs is an interesting research direction."
    }, {
      "heading" : "8. Conclusions",
      "text" : "In this paper we have studied the problem of explaining negative answers to user queries over DL-LiteA ontologies. We have formalized the problem as an abductive task: given a (U)CQ q, a consistent ontology O and a tuple of constants ~c such that ~c is not in the certain answers of q over O, an explanation is defined as a set of ABox assertions that, when added to O, preserve its consistency and result in ~c being in the certain answers. We considered the special cases of allowing only a restricted signature for the assertions in the explanation, and having only an instance query rather than a full (U)CQ in the input. We have also considered preference orders between explanations, and studied two such orders: subset minimal and cardinality minimal explanations. For all these cases, we have obtained complexity bounds for four decision problems inspired in knowledge base abduction: deciding existence of an explanation (exist), deciding whether a given assertion occurs in all (nec) or some (rel) explanations, and recognizing explanations (rec). All our complexity bounds are tight, with the exception of rel for subset minimal explanations under unrestricted signatures, for which we leave open a gap between coNP-hardness and membership in ΣP2 .\nSpecifically, we have shown that in the case of instance queries all these decision problems are tractable, and in fact NL-complete, even when restricted explanations signatures and preference orders are simultaneously considered. The picture is significantly different for (U)CQs, as the results in Table 5.1 show. Indeed, tractability is always lost as soon as one considers restricted explanations signatures. If the signatures are not restricted, considering a preference order also results in intractability for most cases, the only exceptions being exist, which is always tractable, and nec, which is polynomial for subset minimal\nexplanations but PNP‖ for cardinality minimal ones. In contrast to nec, rel is harder, under common assumptions, for subset minimal than for cardinality minimal explanations. rec is hard even when the explanations signature is not restricted and no preference order is considered.\nIt would be interesting to apply this framework to other lightweight description logics, starting with those of the EL-family. Also, we would like to investigate other minimality criteria. For instance, semantic criteria allow one to reward explanations that are less/more constraining in terms of the models of an ontology."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors would like to thank the anonymous referees for their careful reading of the submitted manuscript and their valuable comments. This work was partially supported by the Austrian Science Fund (FWF) grants P20840 and T515, the EU FP7 projects ACSI (Artifact-Centric Service Interoperation), grant agreement n. FP7-257593, and Optique (Scalable End-user Access to Big Data), grant agreement n. FP7-318338, and by AlcatelLucent and EPSRC."
    } ],
    "references" : [ {
      "title" : "The DL-Lite family and relations",
      "author" : [ "A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "J. of Artificial Intelligence Research,",
      "citeRegEx" : "Artale et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2009
    }, {
      "title" : "Query and predicate emptiness in description logics",
      "author" : [ "F. Baader", "M. Bienvenu", "C. Lutz", "F. Wolter" ],
      "venue" : "In Proc. of the 12th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Baader et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2010
    }, {
      "title" : "Complexity of abduction in the EL family of lightweight description logics",
      "author" : [ "M. Bienvenu" ],
      "venue" : "Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR 2008), pp. 220–230. AAAI Press.",
      "citeRegEx" : "Bienvenu,? 2008",
      "shortCiteRegEx" : "Bienvenu",
      "year" : 2008
    }, {
      "title" : "The complexity of circumscription in description logics",
      "author" : [ "P.A. Bonatti", "C. Lutz", "F. Wolter" ],
      "venue" : "J. of Artificial Intelligence Research,",
      "citeRegEx" : "Bonatti et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Bonatti et al\\.",
      "year" : 2009
    }, {
      "title" : "Explanation in the DL-Lite family of description logics",
      "author" : [ "A. Borgida", "D. Calvanese", "M. Rodriguez-Muro" ],
      "venue" : "In Proc. of the 7th Int. Conf. on Ontologies, DataBases, and Applications of Semantics (ODBASE 2008),",
      "citeRegEx" : "Borgida et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Borgida et al\\.",
      "year" : 2008
    }, {
      "title" : "Ontologies and databases: The DL-Lite approach",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "M. Rodriguez-Muro", "R. Rosati" ],
      "venue" : "Semantic Technologies for Informations Systems – 5th Int. Reasoning Web Summer School (RW 2009),",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2009
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "J. of Automated Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "The complexity of conjunctive query abduction in DL-Lite",
      "author" : [ "D. Calvanese", "M. Ortiz", "M. Simkus", "G. Stefanoni" ],
      "venue" : "In Proc. of the 24th Int. Workshop on Description Logic (DL 2011),",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2011
    }, {
      "title" : "Why not",
      "author" : [ "A. Chapman", "H.V. Jagadish" ],
      "venue" : "In Proc. of the ACM SIGMOD Int. Conf. on Management of Data,",
      "citeRegEx" : "Chapman and Jagadish,? \\Q2009\\E",
      "shortCiteRegEx" : "Chapman and Jagadish",
      "year" : 2009
    }, {
      "title" : "Towards practical ABox abduction in large OWL DL ontologies",
      "author" : [ "J. Du", "G. Qi", "Shen", "Y.-D", "J.Z. Pan" ],
      "venue" : "In Proc. of the 25th AAAI Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "Du et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Du et al\\.",
      "year" : 2011
    }, {
      "title" : "A new matchmaking approach based on abductive conjunctive query answering",
      "author" : [ "J. Du", "S. Wang", "G. Qi", "J.Z. Pan", "Y. Hu" ],
      "venue" : "In Proc. of the Joint Int. Semantic Tech. Conf. (JIST",
      "citeRegEx" : "Du et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Du et al\\.",
      "year" : 2011
    }, {
      "title" : "The complexity of logic-based abduction",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "J. of the ACM,",
      "citeRegEx" : "Eiter and Gottlob,? \\Q1995\\E",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1995
    }, {
      "title" : "A case for abductive reasoning over ontologies",
      "author" : [ "C. Elsenbroich", "O. Kutz", "U. Sattler" ],
      "venue" : "In Proc. of the 2nd Int. Workshop on OWL: Experiences and Directions (OWLED 2006),",
      "citeRegEx" : "Elsenbroich et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Elsenbroich et al\\.",
      "year" : 2006
    }, {
      "title" : "Explaining missing answers to SPJUA queries",
      "author" : [ "M. Herschel", "M.A. Hernández" ],
      "venue" : "Proc. of the VLDB Endowment,",
      "citeRegEx" : "Herschel and Hernández,? \\Q2010\\E",
      "shortCiteRegEx" : "Herschel and Hernández",
      "year" : 2010
    }, {
      "title" : "Laconic and precise justifications in OWL",
      "author" : [ "M. Horridge", "B. Parsia", "U. Sattler" ],
      "venue" : "In Proc. of the 7th Int. Semantic Web Conf. (ISWC 2008),",
      "citeRegEx" : "Horridge et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Horridge et al\\.",
      "year" : 2008
    }, {
      "title" : "On the provenance of non-answers to queries over extracted data",
      "author" : [ "J. Huang", "T. Chen", "A. Doan", "J. Naughton" ],
      "venue" : "Proc. of the VLDB Endowment,",
      "citeRegEx" : "Huang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Huang et al\\.",
      "year" : 2008
    }, {
      "title" : "A diagnostics framework based on abductive description logic reasoning",
      "author" : [ "T. Hubauer", "S. Grimm", "S. Lamparter", "M. Roshchin" ],
      "venue" : "In Proc. of the IEEE Int. Conf. on Industrial Technology,",
      "citeRegEx" : "Hubauer et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hubauer et al\\.",
      "year" : 2012
    }, {
      "title" : "Making database systems usable",
      "author" : [ "H.V. Jagadish", "A. Chapman", "A. Elkiss", "M. Jayapandian", "Y. Li", "A. Nandi", "C. Yu" ],
      "venue" : "In Proc. of the ACM SIGMOD Int. Conf. on Management of Data,",
      "citeRegEx" : "Jagadish et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Jagadish et al\\.",
      "year" : 2007
    }, {
      "title" : "ABox abduction in the description logic ALC",
      "author" : [ "S. Klarman", "U. Endriss", "S. Schlobach" ],
      "venue" : "J. of Automated Reasoning,",
      "citeRegEx" : "Klarman et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Klarman et al\\.",
      "year" : 2011
    }, {
      "title" : "Explaining subsumption in description logics",
      "author" : [ "D.L. McGuinness", "A. Borgida" ],
      "venue" : "In Proc. of the 14th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "McGuinness and Borgida,? \\Q1995\\E",
      "shortCiteRegEx" : "McGuinness and Borgida",
      "year" : 1995
    }, {
      "title" : "Usability issues in knowledge representation systems",
      "author" : [ "D.L. McGuinness", "P.F. Patel-Schneider" ],
      "venue" : "In Proc. of the 15th Nat. Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "McGuinness and Patel.Schneider,? \\Q1998\\E",
      "shortCiteRegEx" : "McGuinness and Patel.Schneider",
      "year" : 1998
    }, {
      "title" : "OWL 2 Web Ontology Language Profiles",
      "author" : [ "B. Motik", "A. Fokoue", "I. Horrocks", "Z. Wu", "C. Lutz", "B.C. Grau" ],
      "venue" : "W3C Recommendation,",
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "A tableaux-based calculus for abduction in expressive description logics: Preliminary results",
      "author" : [ "T.D. Noia", "E.D. Sciascio", "F.M. Donini" ],
      "venue" : "In Proc. of the 22rd Int. Workshop on Description Logic (DL 2009),",
      "citeRegEx" : "Noia et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Noia et al\\.",
      "year" : 2009
    }, {
      "title" : "Computational Complexity",
      "author" : [ "C.H. Papadimitriou" ],
      "venue" : "Addison Wesley Publ. Co.",
      "citeRegEx" : "Papadimitriou,? 1994",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1994
    }, {
      "title" : "Complexity of axiom pinpointing in the DL-Lite family of description logics",
      "author" : [ "R. Penaloza", "B. Sertkaya" ],
      "venue" : "In Proc. of the 19th Eur. Conf. on Artificial Intelligence (ECAI",
      "citeRegEx" : "Penaloza and Sertkaya,? \\Q2010\\E",
      "shortCiteRegEx" : "Penaloza and Sertkaya",
      "year" : 2010
    }, {
      "title" : "Complete problems involving boolean labelled structures and projection transactions",
      "author" : [ "I.A. Stewart" ],
      "venue" : "J. of Logic and Computation, 1 (6), 861–882.",
      "citeRegEx" : "Stewart,? 1991",
      "shortCiteRegEx" : "Stewart",
      "year" : 1991
    }, {
      "title" : "How to ConQueR why-not questions",
      "author" : [ "Q.T. Tran", "Chan", "C.-Y" ],
      "venue" : "In Proc. of the ACM SIGMOD Int. Conf. on Management of Data,",
      "citeRegEx" : "Tran et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Tran et al\\.",
      "year" : 2010
    }, {
      "title" : "The complexity of relational query languages",
      "author" : [ "M.Y. Vardi" ],
      "venue" : "Proc. of the 14th Symp. on Theory of computing (STOC 1982), pp. 137–146.",
      "citeRegEx" : "Vardi,? 1982",
      "shortCiteRegEx" : "Vardi",
      "year" : 1982
    }, {
      "title" : "More complicated questions about maxima and minima, and some closures of NP",
      "author" : [ "K.W. Wagner" ],
      "venue" : "Theoretical Computer Science, 51 (1–2), 53–80.",
      "citeRegEx" : "Wagner,? 1987",
      "shortCiteRegEx" : "Wagner",
      "year" : 1987
    } ],
    "referenceMentions" : [ {
      "referenceID" : 20,
      "context" : "As argued by McGuinness and Patel-Schneider (1998), in order to meet usability requirements set by domain users, knowledge-based systems should be equipped with explanation algorithms for reasoning services.",
      "startOffset" : 13,
      "endOffset" : 51
    }, {
      "referenceID" : 3,
      "context" : "In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining positive query answers, should also explain negative query answers; that is, those tuples that a user expects to be in the result but actually do not occur there.",
      "startOffset" : 13,
      "endOffset" : 35
    }, {
      "referenceID" : 3,
      "context" : "In addition, Borgida et al. (2008) suggested that OBDA systems, besides explaining positive query answers, should also explain negative query answers; that is, those tuples that a user expects to be in the result but actually do not occur there. As OBDA systems answer queries under ontological constraints, explaining negative query answers is not trivial: these constraints need to be taken into account to understand why a required tuple is missing from the answers. A procedure for explaining negative query answers would then improve the usability of OBDA systems. For this reason, we formalize this explanation problem in the context of query answering over DL ontologies. Following Eiter and Gottlob (1995), we adopt abductive reasoning ; that is, explanations are set of facts that need to be asserted in the ABox to force the required tuple to be in the result.",
      "startOffset" : 13,
      "endOffset" : 714
    }, {
      "referenceID" : 2,
      "context" : "The idea of restricting the vocabulary of explanations is an adaptation of a concept introduced by Baader, Bienvenu, Lutz, and Wolter (2010), who study among others the query emptiness problem.",
      "startOffset" : 107,
      "endOffset" : 141
    }, {
      "referenceID" : 6,
      "context" : "DL-LiteA is a member of the DL-Lite family of DLs (Calvanese et al., 2007; Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, Rodriguez-Muro, & Rosati, 2009), which has been designed for dealing efficiently with large amounts of extensional information.",
      "startOffset" : 50,
      "endOffset" : 154
    }, {
      "referenceID" : 6,
      "context" : "Formally, if a DL-LiteA TBox contains (funct P ) or (funct P −), then for each role R it does not contain Rv P or Rv P− (Calvanese et al., 2007).",
      "startOffset" : 120,
      "endOffset" : 144
    }, {
      "referenceID" : 6,
      "context" : "Following the common practice for the DLs of the DL-Lite family (Calvanese et al., 2007), we usually adopt the unique name assumption (UNA)—that is, for each interpretation I and individual pair c 6= d, we require that cI 6= dI .",
      "startOffset" : 64,
      "endOffset" : 88
    }, {
      "referenceID" : 27,
      "context" : "Notice that, since we consider both the ontology and the query as part of the input, we are considering so-called combined complexity (Vardi, 1982).",
      "startOffset" : 134,
      "endOffset" : 147
    }, {
      "referenceID" : 1,
      "context" : "As mentioned in the introduction, deciding the existence of an explanation is related to the query emptiness problem studied by Baader et al. (2010). Since we will rely on that problem to infer some complexity bounds throughout the paper, we briefly introduce it here.",
      "startOffset" : 128,
      "endOffset" : 149
    }, {
      "referenceID" : 1,
      "context" : "Hence, all the hardness results for non-emptiness obtained by Baader et al. (2010) that hold for instance queries and UCQs apply also to the exist problem under restricted explanation signatures.",
      "startOffset" : 62,
      "endOffset" : 83
    }, {
      "referenceID" : 5,
      "context" : "For DL-LiteA, Calvanese et al. (2009) showed that negative inclusion axioms affect only the consistency of the given ontology, but do not contribute towards computing the certain answer; that is, ~c ∈ cert(q, T ′,A′) iff 〈T ′,A′〉 is consistent and ~c ∈ cert(q, T ,A′).",
      "startOffset" : 14,
      "endOffset" : 38
    }, {
      "referenceID" : 0,
      "context" : "Since reasoning without the UNA is PTime-complete for DL-LiteA (Artale et al., 2009), we obtain the following result.",
      "startOffset" : 63,
      "endOffset" : 84
    }, {
      "referenceID" : 5,
      "context" : "The algorithm then checks in polynomial time that Eξ \\A is a Σ-ABox and that the ontology 〈T ,A ∪ Eξ〉 is consistent; it was shown by Calvanese et al. (2009) that the latter check is polynomial.",
      "startOffset" : 133,
      "endOffset" : 157
    }, {
      "referenceID" : 1,
      "context" : "DL-LiteA known as DL-Litecore given in Theorem 17 by Baader et al. (2010). For showing hardness in the second setting, we reduce the following NP-complete problem: given a pair of directed graphs G = (V,E) and G′ = (V ′, E′), decide whether there exists an homomorphism from G to G′.",
      "startOffset" : 53,
      "endOffset" : 74
    }, {
      "referenceID" : 28,
      "context" : "(hardness) We give a reduction from OddMinVertexCover, which is P ‖ -complete (Wagner, 1987).",
      "startOffset" : 78,
      "endOffset" : 92
    }, {
      "referenceID" : 0,
      "context" : "Then it makes sure that extending the ontology with ABox E does not lead to an inconsistent theory; this can be checked in polynomial time (Artale et al., 2009).",
      "startOffset" : 139,
      "endOffset" : 160
    }, {
      "referenceID" : 5,
      "context" : ", when only the query is considered fixed), we observe that those inference tasks that we have shown to be NP-complete essentially rely on checking ontology consistency, and hence are in AC0 in data complexity (Calvanese et al., 2009).",
      "startOffset" : 210,
      "endOffset" : 234
    }, {
      "referenceID" : 1,
      "context" : "This is witnessed by the lower bounds by Baader et al. (2010) stemming from CQ-emptiness (see Proposition 3.",
      "startOffset" : 41,
      "endOffset" : 62
    }, {
      "referenceID" : 8,
      "context" : "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.",
      "startOffset" : 7,
      "endOffset" : 35
    }, {
      "referenceID" : 8,
      "context" : "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database.",
      "startOffset" : 7,
      "endOffset" : 259
    }, {
      "referenceID" : 8,
      "context" : "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan, and Naughton (2008) have defined solutions to be sequences of database update operations such that the result of answering the given conjunctive query over the updated relational instance includes the missing answer.",
      "startOffset" : 7,
      "endOffset" : 444
    }, {
      "referenceID" : 8,
      "context" : "First, Chapman and Jagadish (2009) have proposed a model in which explanations are those relational operations (e.g., natural joins or selections) that are responsible for preventing the given tuple to be returned in the answers. Second, Tran and Chan (2010) have defined solutions to be refinements to the input query such that the given tuple is an answer to the relaxed query over the database. Third, Huang, Chen, Doan, and Naughton (2008) have defined solutions to be sequences of database update operations such that the result of answering the given conjunctive query over the updated relational instance includes the missing answer. Herschel and Hernández (2010) have generalized this latter model by considering UCQs with aggregation and grouping.",
      "startOffset" : 7,
      "endOffset" : 671
    }, {
      "referenceID" : 2,
      "context" : "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008).",
      "startOffset" : 2,
      "endOffset" : 50
    }, {
      "referenceID" : 2,
      "context" : "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems.",
      "startOffset" : 35,
      "endOffset" : 107
    }, {
      "referenceID" : 2,
      "context" : "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems. In particular, given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction amounts to finding a subset A of Ax such that T ∪ A |= O. Third, Klarman, Endriss, and Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies.",
      "startOffset" : 35,
      "endOffset" : 383
    }, {
      "referenceID" : 2,
      "context" : "T (Noia, Sciascio, & Donini, 2009; Bienvenu, 2008). Second, Hubauer, Grimm, Lamparter, and Roshchin (2012) have applied TBox abductive reasoning to diagnosis of complex systems. In particular, given a TBox T , a set of abducible axioms Ax , and a set of axioms O, TBox abduction amounts to finding a subset A of Ax such that T ∪ A |= O. Third, Klarman, Endriss, and Schlobach (2011) have studied the problem of ABox abduction over ALC ontologies. This problem consists in finding which additions need to be made to the ABox in order to force a set of ABox assertions to be logically entailed by the ontology. Along the same line, Du, Qi, Shen, and Pan (2011a) have considered this problem from a more practical perspective.",
      "startOffset" : 35,
      "endOffset" : 660
    } ],
    "year" : 2013,
    "abstractText" : "In order to meet usability requirements, most logic-based applications provide explanation facilities for reasoning services. This holds also for Description Logics, where research has focused on the explanation of both TBox reasoning and, more recently, query answering. Besides explaining the presence of a tuple in a query answer, it is important to explain also why a given tuple is missing. We address the latter problem for instance and conjunctive query answering over DL-Lite ontologies by adopting abductive reasoning; that is, we look for additions to the ABox that force a given tuple to be in the result. As reasoning tasks we consider existence and recognition of an explanation, and relevance and necessity of a given assertion for an explanation. We characterize the computational complexity of these problems for arbitrary, subset minimal, and cardinality minimal explanations.",
    "creator" : "TeX"
  }
}