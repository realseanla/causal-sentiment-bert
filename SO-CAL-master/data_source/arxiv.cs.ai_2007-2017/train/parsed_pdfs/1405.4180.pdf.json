{
  "name" : "1405.4180.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Algorithm for Adapting Cases Represented in a Tractable Description Logic",
    "authors" : [ "Liang Chang", "Uli Sattler", "Tianlong Gu" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n41 80\nv1 [\ncs .A\nI] 1\n6 M\nay 2\n01 4"
    }, {
      "heading" : "1 Introduction",
      "text" : "Description logic (DL) is a family of logics for representing and reasoning about knowledge of static application domains [2]. It is playing a central role in the Semantic Web, serving as the basis of the W3C-recommended Web ontology language OWL [10]. The main strength of DLs is that they offer considerable expressive power often going far beyond propositional logic, while reasoning is still decidable. Furthermore, DLs have well-defined semantics and are supported by many efficient reasoners.\nIn the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18]. CBR is a type of analogical reasoning in which new problem is solved by reusing past experiences called source cases. There are two basic tasks in the CBR inference: retrieval and adaptation. Retrieval aims at selecting a source case that is similar to the new problem according to some similarity criterion. Adaptation aims at generating a solution for the new problem by adapting the solution contained in the source case. At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].\nIn comparison to retrieval, adaptation is often considered to be the more difficult task. One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12]. In propositional logic, there are many revision operators which satisfy the AGM postulates and can be applied to complete the adaptation task [16]. However, in DLs, it is very difficult to design revision operators and algorithms that satisfy the AGM postulates [8]. Especially, it is a great challenge to design revision algorithms that are independent of the syntactical forms of KBs and fine-grained for the minimal change principle.\nThere are two kinds of revision operators and algorithms in the literature: model-based approaches (MBAs) and formula-based approaches (FBAs). Revision operators of MBAs can be treated as DL-based extensions of the classical revision operators in propositional logic, in that the semantics of minimal change is defined by measuring the distance between models [13]. MBAs are syntax-independent and fine-grained, but at present they only work for DLs of the DL-Lite family. In FBAs, the semantics of minimal change is reflected in the minimality of formulas removed by the revision process. There are two FBAs in the literature. One is based on the deductive closure of a KB [4,15]; it is syntax-independent and fine-grained, but again only works for DLs of the DLLite family. Another is based on justifications [20]; although it is applicable to DLs such as SHOIN , it is syntax-dependent and not fine-grained.\nDLs of the EL family are popular for building large-scale ontologies [3]. Some important medical ontologies and life science ontologies are built in EL, such as the SNOMED CT [19] and the Gene Ontology [6]. A feature of this family of DLs is that they allow for reasoning in polynomial time, while being able to describe “relational structures”. They are promising DLs for CBR since they are, on the one hand, of interesting expressive power (orthogonal to DL-Lite) and, on the other hand, restricted enough so that we can hope for a practical adaptation approach. In the literature, some good results on introducing DLs of the EL family into the retrieval of source cases have been presented [18]; the problem of measuring the similarity of concepts in these DLs is also well-studied [14]. However, adaptation based on these DLs is still an open problem. The reason is that existing revision operators, to the best of our knowledge, are not syntax-independent and fine-grained.\nIn this paper we present a new method for adaptation in the DL EL⊥ of the EL family. Our contributions regard three aspects. Firstly, we extend the logical basis for describing cases from propositional logic to the DL EL⊥, with a powerful way of describing cases as ABoxes in DL. Secondly, we extend the “adaptation as KB revision” view from [16] to the above setting and get a formalism for adaptation based on EL⊥. Finally, for the adaptation setting we provide an adaptation algorithm. Our algorithm is syntax-independent and fine-grained, and satisfies the requirements on revision operators."
    }, {
      "heading" : "2 The Description Logic EL⊥",
      "text" : "The DL EL⊥ extends EL with bottom concept (and consequently disjointness statements) [3]. Let NC , NR and NI be disjoint sets of concept names, role names and individual names, respectively. EL⊥-concepts are built according to the following syntax rule C ::= ⊤ | ⊥ |A | C ⊓D | ∃r.C, where A ∈ NC , r ∈ NR, and C,D range over EL⊥-concepts.\nA TBox T is a finite set of general concept inclusions (GCIs) of the form C ⊑ D, where C and D are concepts. An ABox A is a finite set of concept assertions of the form C(a) and role assertions of the form r(a, b), where a, b ∈ NI , r ∈ NR, and C is a concept. A knowledge base (KB) is a pair K = 〈T ,A〉.\nExample 1. Consider the example on breast cancer treatment discussed in [16]. We add some background knowledge to it and describe the knowledge by the following GCIs in a TBox T :\nTamoxifen ⊑ Anti-oestrogen, Anti-aromatases ⊑ Anti-oestrogen,\nTamoxifen ⊑ ∃metabolizedTo.(Compounds⊓ ∃bindto.OestrogenReceptor),\n(∃hasGene.CY P2D6) ⊓ (∃TreatBy.Tamoxifen) ⊑ ⊥.\nThese GCIs state that both tamoxifen and anti-aromatases are anti-estrogens; tamoxifen can be metabolized into compounds which will bind to the oestrogen receptor; and tamoxifen is contraindicated for people with the gene CYP2D6.\nSuppose Mary is a patient with the gene CYP2D6 and with some symptom captured by a concept Symp. Then we can describe these information by an ABox N = {Symp(Mary), ∃hasGene.CY P2D6(Mary)}. ⊓⊔\nThe semantics is defined by means of an interpretation I = (∆I , ·I), where the interpretation domain ∆I is a non-empty set composed of individuals, and ·I is a function which maps each concept name A ∈ NC to a set AI ⊆ ∆I , maps each role name r ∈ NR to a binary relation rI ⊆ ∆I ×∆I , and maps each individual name a ∈ NI to an individual aI ∈ ∆I . The function ·I is inductively extended to arbitrary concepts as follows:\n– ⊤ := ∆I , – ⊥ := ∅, – (C ⊓D)I := CI ∩DI , and – (∃r.C)I := {x ∈ ∆I | there exists y ∈ ∆I such that (x, y) ∈ rI and y ∈ CI}.\nThe satisfaction relation “|=” between any interpretation I and any GCI C ⊑ D, concept assertion C(a), role assertion r(a, b), TBox T or ABox A is defined inductively as follows: I |= C ⊑ D iff CI ⊆ DI ; I |= C(a) iff aI ∈ CI ; I |= r(a, b) iff (aI , bI) ∈ rI ; I |= T iff I |= X for every X ∈ T ; and I |= A iff I |= X for every X ∈ A.\nI is a model of a KB K = 〈T ,A〉 if I |= T and I |= A. We use mod(K) to denote the set of models of KB K. Two KBs K1 and K2 are equivalent (written K1 ≡ K2) iff mod(K1) = mod(K2).\nThere are many inference problems on DLs. Here we only introduce consistency and entailment. A KB K = 〈T ,A〉 is consistent (or A is consistent w.r.t. T ) ifmod(K) 6= ∅. K entails a GCI, assertion or ABox X (written K |= X) if I |= X for every I ∈ mod(K). For these two inference problems the following results hold: a KB K is inconsistent iff K |= ⊤ ⊑ ⊥ iff K |= ⊥(a) for some individual name a occurring in K. If K is inconsistent, then we say that K entails a clash.\nExample 2. Consider the TBox T and ABoxN presented in Example 1. Suppose there is an ABox A = {TreatBy(Mary, y), T amoxifen(y)} and a KB K = 〈T ,A∪N〉. It is obvious that K is inconsistent and entails a clash. More precisely, we have that K |= ⊤ ⊑ ⊥ and K |= ⊥(Mary). ⊓⊔\nLet X be a concept, GCI, assertion, TBox, ABox or KB. Then NXC (resp., NXR , N X I ) is the set of concept names (resp., role names, individual names) occurring in X , and sig(X) = NXC ∪N X R ∪N X I .\nFor any concept C, the role depth rd(C) is the maximal nesting depth of ∃ in C. Let X be a GCI, assertion, TBox, ABox or KB. Then sub(X) is the set of all subconcepts occurring in X , and depth(X) = max{rd(C) | C ∈ sub(X)}."
    }, {
      "heading" : "3 Formalization of Adaptation Based on EL⊥",
      "text" : "In this section we present a formalism for adaptation based on EL⊥. There are many different approaches for the formalization of adaptation in CBR. Here we follow the approach presented in [16] to formulate adaptation as knowledge base revision, with the difference that our formalism is based on the DL EL⊥ instead of propositional logic.\nThe basic idea of CBR is to solve similar problems with similar solutions. The new problem that needs to be solved is called target problem. The problems which have been solved and stored are called source problems. Each source problem srce has a solution solsrce, and the pair (srce, solsrce) is called a source case. A finite set of source cases forms a case base. Given a target problem tgt, the retrieval step of CBR will pick out a source case (srce, solsrce) according to the similarity between target problem and source problem, and the adaptation step will generate a solution soltgt for tgt by adapting solsrce.\nIn [16], the adaptation process is modeled as KB revision in propositional logic. More precisely, let two formulas kb1 = srce ∧ solsrce and kb2 = tgt, then the solution soltgt is generated by calculating (dk ∧ kb1) ◦ (dk ∧ kb2), where dk is the domain knowledge, and ◦ is a revision operator that satisfies the AGM postulates in propositional logic.\nHere, after introducing the DL EL⊥ into CBR, knowledge in a CBR system is composed of three parts:\n– the domain or background knowledge which is represented as a TBox T ; – the knowledge about case base in which each source case is described by a\npair of ABoxes (srce, sol), where srce describes the source problem and sol describes the solution;\n– the knowledge about target problem described by an ABox tgt.\nWith such a framework, given a target problem tgt, we can make use of similarity-measuring algorithms presented in the literature [18,14] to select a source case (srce, sol) such that, by treating individual names occurring in srce as variables, there exists a substitution σ such that σ(srce) and tgt has the maximum similarity. The retrieval algorithm applies σ on sol and return σ(sol) as a possible solution for the target problem. Since retrieval algorithm is not the topic of this paper, we do not discuss it in detail here.\nNow suppose a possible solution has been returned by the retrieval algorithm, we defined adaptation setting as follows.\nDefinition 1. An adaptation setting based on EL⊥ is a triple AS = (T ,A,N ), where T is a TBox describing the domain knowledge of the CBR system, N is an ABox describing the target problem, and A is an ABox describing the possible solution returned by retrieval algorithm.\nAn ABox A′ is a solution for an adaptation setting AS = (T ,A,N ) if it satisfies the following requirements:\n(R1) 〈T ,A′〉 |= N ; (R2) A′ = A∪N if A ∪N is consistent w.r.t. T ; (R3) if N is consistent w.r.t. T then A′ is also consistent w.r.t. T .\nThe adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12]. More precisely, R1 specifies that a revision result must entail the new information N ; R2 states that the revision operator should not change the KB 〈T ,A∪N〉 if there is no conflict; R3 states that the revision operator must preserve the consistency of KBs.\nFrom the point of view of adaptation, the requirements on solutions are explained as follows [16]. If R1 is violated, then it means that the adaptation process failed to solve the target problem. R2 states that if the possible solution does not contradict the target problem w.r.t. the background knowledge, then it can be applied directly to the target problem. R3 states that whenever the description of the target problem is consistent w.r.t. the domain knowledge, the adaptation process provides satisfiable result.\nIn the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20]. However, in practice, besides these three necessary requirements, we hope that the adaptation algorithm satisfies two more requirements.\nFirstly, the adaptation algorithm should be syntax-independent. More precisely, if the descriptions of two target problems are essentially the same w.r.t. the domain knowledge, then we hope that the adaptation process will generate the same solution for these two problems. Under the framework of adaptation setting, we formalize this requirement as follows:\n(R4) for any adaptation setting AS1 = (T ,A1,N1) satisfying 〈T ,A1〉 ≡ 〈T ,A〉 and 〈T ,N1〉 ≡ 〈T ,N〉, there always exists a solution A′1 such that 〈T ,A ′ 1〉 ≡\n〈T ,A′〉.\nSecondly, the adaptation algorithm should guarantee a minimal change so that the experience contained in the solution of source cases is preserved as much as possible. Taking the adaptation setting AS = (T ,A,N ) as an example, if we do not introduce the requirement on minimal change, then in the case that A ∪ N is inconsistent w.r.t. T , the ABox N is a solution according to the definition. However, it is not a good solution obviously, since information contained in A is completely lost.\nWe hope to specify the requirement on minimal change formally. However, it is non-trivial to do it in a framework based on DLs. One reason is that there are different approaches to define minimality, and it is well-accepted that there is no general notion of minimality that will do the right thing under all circumstances [4]. Therefore, under the framework of adaptation setting, we only specify this requirement as follows:\n(R5) the change from the KB 〈T ,A〉 to the KB 〈T ,A′〉 is minimal.\nTo sum up, given an adaptation setting, we hope to generate a solution which not only satisfies R1-R3 specified in Definition 1, but also satisfies R4 and some reading of R5.\nBefore the end of this section, we look an example of adaptation setting.\nExample 3. Consider the TBox T and ABox N presented in Example 1. Suppose N is a description of the target problem. Suppose many successful treatment cases are recorded in the case base, and from them a possible solution A = {TreatBy(Mary, y), T amoxifen(y)} is returned by the retrieval algorithm. Then we get an adaptation setting AS = (T ,A,N ). ⊓⊔"
    }, {
      "heading" : "4 Existing Approaches to Instance-Level Revision",
      "text" : "As we mentioned in Section 1, there exist two groups of revision operators and algorithms for DLs in the literature. In this section, we show that they either do not support the DL EL⊥ or do not satisfy R4 and R5."
    }, {
      "heading" : "4.1 Model-based Approaches",
      "text" : "MBAs define revision operators over the distance between interpretations [13]. In propositional logic, it is easy to measure the distance between interpretations and to calculate the revision results based on the distance [12], since each interpretation is only a truth assignment on propositional symbols. However, in DLs, it becomes very complex.\nFor an adaptation setting AS = (T ,A,N ), let M be the set of all interpretations that satisfy both the solutions and the TBox T . Then, with MBAs, M is the set of models of 〈T ,N〉 that are minimally distant from the models of 〈T ,A〉 [13], i.e.,\nM = {J ∈ mod(〈T ,N〉) | there exists I ∈ mod(〈T ,A〉) such that dist(I,J ) =\nmin{dist(I ′,J ′) | I ′ ∈ mod(〈T ,A〉),J ′ ∈ mod(〈T ,N〉)} }.\nLet Σ be the set of concept names and role names occurring in AS. There are four different approaches for measuring the distance dist(I,J ):\n– dists♯(I,J ) = ♯{X ∈ Σ | X I 6= XJ }, – dists⊆(I,J ) = {X ∈ Σ | X I 6= XJ }, – dista♯ (I,J ) = sum X∈Σ ♯(XI ⊖XJ ), – dista⊆(I,J , X) = X I ⊖XJ for every X ∈ Σ,\nwhere XI⊖XJ = (XI−XJ )∪(XJ −XI). Distances under dists♯ and dist a ♯ are natural numbers and are compared in the standard way. Distances under dists⊆ are sets and are compared by set inclusion. Distances under dista⊆ are compared as follows: dista⊆(I1,J1) ≤ dist a ⊆(I2,J2) iff dist a ⊆(I1,J1, X) ⊆ dist a ⊆(I2,J2, X) for every X ∈ Σ. It is assumed that the interpretations of individual names are fixed. In [13], the above four different semantics for MBAs are denoted as Gs♯ , Gs⊆, G a ♯ , and G a ⊆ respectively.\nUnder the framework of adaptation setting, we need to find a finite number of ABoxes A′i (1 ≤ i ≤ n) such that sig(A ′ i) ⊆ sig(T ) ∪ sig(A) ∪ sig(N ) and M = ⋃\n1≤i≤n\nmod(〈T ,A′i〉).\nExample 4. Consider an adaptation setting AS1 = (T1,A1,N1), where\nT1 = {A ⊑ ∃R.A, A ⊑ C, E ⊓ ∃R.A ⊑ ⊥}, A1 = {A(a)}, N1 = {E(a)}.\nLet Σ = {A,C,E,R}. Firstly, we investigate the semantics Gs⊆ and G s ♯ . It is obvious that, for any interpretations I ∈ mod(〈T1,A1〉) and J ∈ mod(〈T1,N1〉), it must be AI 6= AJ and EI 6= EJ . Therefore, {A,E} is the minimal set of signatures whose interpretations must be changed. So, under both Gs⊆ and G s ♯ , we have that"
    }, {
      "heading" : "M = {J ∈ mod(〈T1,N1〉) | there exists I ∈ mod(〈T1,A1〉) such that",
      "text" : "XI = XJ for any X ∈ Σ \\ {A,E}}.\nNow, for every positive integer k, let us construct an interpretation Ik = (∆Ik , ·Ik) as ∆Ik = {p1, ..., pk}, a Ik = p1, A Ik = ∅, EIk = {p1}, C\nIk = {p1, ..., pk}, and RIk = {(p1, p2), ..., (pk−1, pk), (pk, pk)}. At the same time, be corresponding to each Ik, construct another interpretation I ′k = (∆ I′ k , ·I ′ k) as ∆I ′ k = ∆Ik , aI ′ k = p1, A I′ k = {p1, ..., pk}, EI ′ k = ∅, CI ′ k = CIk , and RI ′\nk = RIk . Then, it is obvious that Ik ∈ mod(〈T1,N1〉), I ′ k ∈ mod(〈T1,A1〉), and Ik ∈ M.\nIn the case that k = 1, we can construct an ABox A′1 = {E(a), C(a), R(a, a)} so that I1 is contained in mod(〈T1,A′1〉). However, for any k ≥ 2, it is impossible to find an ABox A′i such that sig(A ′ i) ⊆ Σ ∪ {a} and Ik ∈ mod(〈T1,A ′ i〉). So, solutions of adaptation under Gs⊆ and G s ♯ is not expressible.\nSecondly, we investigate the semantics Ga⊆ and G a ♯ . It is obvious that, for any interpretations I ∈ mod(〈T1,A1〉) and J ∈ mod(〈T1,N1〉), it must be aI /∈\nEI and aJ /∈ AJ . Therefore {A(a), E(a)} is the minimal set of atoms whose interpretations must be changed. So, under both Ga⊆ and G a ♯ , we have that\nM = {J ∈ mod(〈T1,N1〉) | there exists I ∈ mod(〈T1,A1〉) such that\nAI ⊖AJ = EI ⊖ EJ = {aI}, and\nXI = XJ for any X ∈ Σ \\ {A,E}}.\nFrom M we can construct an ABox A′1 = {E(a), C(a), R(a, a)} so that M = mod(〈T1,A′1〉). Therefore, under both G a ⊆ and G a ♯ , A ′ 1 is a solution for the adaptation setting. This result is very strange, since during the adaptation process there seems to be no “good” reason to enforce the assertion R(a, a) to hold. ⊓⊔\nTo sum up, there are four notions of computing models in existing MBAs. For the adaptation based on EL⊥, two notions suffer from inexpressibility and the other two notions are semantically questionable."
    }, {
      "heading" : "4.2 Formula-based Approaches",
      "text" : "In the literature there are two typical formula-based approaches for instance-level revision in DLs.\nThe first one is based on deductive closures [4,15]. Under the framework studied in our paper, given an adaptation setting AS = (T ,A,N ), this approach will firstly calculates the deductive closure of A w.r.t. T (denoted clT (A)); then it computes a maximal subsetAm of clT (A) that does not conflict withN and T ; and finally returns Am ∪ N as a solution. Such an approach behaves well in DLs of the DL-Lite family, where clT (A) is finite and can be calculated effectively. However, it does not work in EL⊥, since clT (A) is infinite in EL⊥ and can not be calculated directly. Therefore, it can not be applied for solving our problem.\nThe second FBA is based on justifications (also known as MinAs or kernel) [20]. Under the framework studied here, given an adaptation setting AS = (T ,A,N ), this approach will firstly construct a KB K0 = 〈T ,A∪N〉, and find all the minimal subsets of K0 that entail a clash (i.e., all justifications for clashes); then it will compute a minimal set R ⊆ A which contains at least one element from each justification (such a set is also called a repair); and finally returns (A∪N ) \\R as a solution. This approach is applicable to DLs such as SHOIN , and obviously can deal with EL⊥. However, as shown by the following examples, it is syntax-dependent and not fine-grained, and therefore does not satisfy our requirements specified by R4 and R5.\nExample 5. Consider the adaptation setting AS1 = (T1,A1,N1) described in the previous example. It is obvious that 〈T1,A1 ∪ N1〉 |= ⊥(a) and for which there is only one justification J = {A ⊑ ∃R.A,E ⊓ ∃R.A ⊑ ⊥, A(a), E(a)}.\nSince T1 is fixed and E(a) ∈ N1, the only choice is to remove A(a) from A1 ∪ N1 and get the solution A′1 = {E(a)}. This result is not so good, since it loses many information which is entailed by the KB 〈T1,A1〉 and not conflicted with N1, such as the concept assertions C(a) and ∃R.C(a). In other words, this result does not satisfy R5. ⊓⊔\nExample 6. Consider another adaptation setting AS2 = (T2,A2,N2), where T2 = T1, N2 = N1 and A2 = {A(a), C(a), ∃R.C(a)}. It is obvious that 〈T1,A1〉 ≡ 〈T2,A2〉 and 〈T1,N1〉 ≡ 〈T2,N2〉.\nNow, apply the FBA based on justifications again, we will get a solution A′2 = {E(a), C(a), ∃R.C(a)}. This solution is essentially different from the solution A′1 = {E(a)} of AS1, since 〈T1,A ′ 1〉 6≡ 〈T2,A ′ 2〉. So, the FBA based on justifications does not satisfy R4. It is unhelpful that we get two different solutions for two target problems which are essentially the same. ⊓⊔\nTo sum up, for the adaptation based on EL⊥, existing FBAs either can not be applied directly, or can be applied but is syntax-dependent and not fine-grained."
    }, {
      "heading" : "5 Our Approach for Adaptation Based on EL⊥",
      "text" : "In this section we present an algorithm for adaptation based on EL⊥. Our algorithm is based on a structure named revision graph, which is close to the completion graph used in classical tableau decision algorithms of DLs [11]. We firstly introduce some notions and operations on this structure, then present the algorithm, and finally discuss two examples."
    }, {
      "heading" : "5.1 Notions and Operations on Revision Graph",
      "text" : "A revision graph for EL⊥ is a directed graph G = (V,E,L), where\n– V is a finite set of nodes composed of individual names and variables; – E ⊆ V × V is a set of edges satisfying:\n• there is no edge from variables to individual names, and • for each variable y ∈ V , there is at most one node x with 〈x, y〉 ∈ E;\n– each node x ∈ V is labelled with a set of concepts L(x); and – each edge 〈x, y〉 ∈ E is labelled with a set of role names L(〈x, y〉); further-\nmore, if y is a variable then ♯L(〈x, y〉) = 1.\nFor each edge 〈x, y〉 ∈ E, we call y a successor of x and x a predecessor of y. Descendant is the transitive closure of successor.\nFor any node x ∈ V , we use level(x) to denote the level of x in the graph, and define it inductively as follows: level(x) = 0 if x is an individual name, and level(x) = level(y) + 1 if x is a variable with a predecessor y.\nA graph B = (V ′, E′,L′) is a branch of G if B is a tree and a subgraph of G. A branch B1 = (V1, E1,L1) is subsumed by another branch B2 = (V2, E2,L2) if B1 and B2 have the same root node, ♯(V1 ∩ V2) = 1, and there is a function f : V1 → V2 such that: f(x) = x if x is the root node, L1(x) ⊆ L2(f(x)) for every node x ∈ V1, 〈f(x), f(y)〉 ∈ E2 for every edge 〈x, y〉 ∈ E1, and L1(〈x, y〉) ⊆ L2(〈f(x), f(y)〉) for every edge 〈x, y〉 ∈ E1.\nA branch B is redundant in G if every node in B except the root is a variable, and B is subsumed by another branch in G.\nRevision graphs can be seen as ABoxes with variables. Given a revision graph G = (V,E,L), we call AG = ⋃\nx∈V\n{C(x) | C ∈ L(x)} ∪ ⋃\n〈x,y〉∈E\n{R(x, y) | R ∈\nL(〈x, y〉)} as the ABox representation of G, and call G as the revision-graph representation of AG .\nGiven a KB K = 〈T ,A〉 and a non-negative integer k, we use procedure B-MW(K, k) to construct a revision graph for them.\nProcedure B-MW(K, k)\nInput: a KB K = 〈T ,A〉 and a non-negative integer k. Output: a revision graph G = (V,E,L).\n1 Initialize the revision graph G = (V,E,L) as\n– V = NKI , – L(a) = {C | C(a) ∈ A} for each node a ∈ V , – E = {〈a, b〉 | there is some R with R(a, b) ∈ A}, – L(〈a, b〉) = {R | R(a, b) ∈ A} for each edge 〈a, b〉 ∈ E.\n2 while there exists an expansion rule in Fig. 1 that is applicable to G do expand G by applying this rule.\n3 for each node x ∈ V do L(x) = {C ∈ L(x) | C is a concept name }.\n4 while there exists a redundant branch B = (VB, EB,LB) in G do E = E \\ EB; V = V \\ (VB \\ {xB}), where xB is the root of B.\n5 Return G = (V,E,L).\nIt is easy to prove the following property.\nProposition 1. Given a KB K and a non-negative integer k, let G = B-MW(K, k), and let AG be the ABox representation of G. Then, for any ABox assertion α with sig(α) ⊆ sig(K) and depth(α) ≤ k, K |= α iff 〈∅,AG〉 |= α.\nBased on this property, given an adaptation setting AS = (T ,A,N ), we can firstly construct a revision graph G = B-MW(〈T ,A〉, k) for some well selected integer k, and then realize adaptation by computing a maximal subset Am of AG that does not conflict with N .\nBecause Am is an ABox that may contain variables, we use the following procedure to roll up variables contained in it.\nProcedure Rolling(Am, T )\nInput: an ABox Am that may contain variables, and a TBox T . Output: an ABox A0 without variables.\n1 Transform Am into its revision-graph representation G = (V,E,L). 2 Delete from V the variables which are not descendants of any individual name. 3 while there exists variable in V do\nselect a variable y ∈ V that has no successor; x = the predecessor of y; if L(y) 6= ∅ then Cy = d\nC∈L(y)"
    }, {
      "heading" : "C else Cy = ⊤;",
      "text" : "R = the role name contained in L(〈x, y〉); if 〈T , {D(x) | D ∈ L(x)}〉 6|= (∃R.Cy)(x) then L(x) = L(x) ∪ {∃R.Cy}; E = E \\ {〈x, y〉}; V = V \\ {y}.\n4 Return A0 = ⋃\nx∈V\n{C(x) | C ∈ L(x)} ∪ ⋃\n〈x,y〉∈E\n{R(x, y) | R ∈ L(〈x, y〉)}."
    }, {
      "heading" : "5.2 The Revision Algorithm",
      "text" : "Let T be a TBox, and let A, N be two ABoxes. If 〈T ,A∪N〉 |= ⊤ ⊑ ⊥, then:\n– a set J ⊆ A is a (A,N )-justification for a clash w.r.t. T if 〈T ,J ∪ N〉 |= ⊤ ⊑ ⊥ and 〈T ,J ′ ∪ N〉 6|= ⊤ ⊑ ⊥ for every J ′ ⊂ J ; – a set R ⊆ A is a (A,N )-repair for clashes w.r.t. T if ♯(R∩J ) = 1 for every (A,N )-justification J .\nNow we are ready to present our algorithm for adaptation based on EL⊥.\nAlgorithm 1: Adaptation(AS, k)\nInput: an adaptation setting AS = (T ,A,N ), and a non-negative integer k. Output: a finite number of pairs (A′′1 ,R1), ..., (A ′′ n,Rn), where A ′′ i is a solution and Ri records the information been removed. if A ∪ N is consistent w.r.t. T then\nreturn (A ∪N , ∅); else\nG = B-MW(〈T ,A〉, k); AG = the ABox representation of G; SR = {R1, ...,Rn} all the (AG ,N )-repairs for a clash w.r.t. T ; for i ← 1 to n do\nAi = AG \\ Ri; A′i = Rolling(Ai, T );\nreturn (A′1 ∪ N ,R1), ..., (A ′ n ∪N ,Rn).\nGiven an adaptation setting AS = (T ,A,N ), our algorithm will firstly construct a revision graph G according to the KB 〈T ,A〉 and some integer k, where\nk is required to be greater than the role depthes of all the concepts occurring in the adaptation setting. Secondly, a revision process based on justifications will be carried out on the ABox representation AG of G. Thirdly, for each maximal subset Ai of AG that does not conflict with N and T , the procedure Rolling(Ai, T ) will be used to roll up variables and get an ABox A′i. Finally, the ABox A ′ i ∪ N will be returned as a solution for the adaptation setting; together with the solution, an ABox Ri which records the information been removed from the solution of source problem is also displayed, so that the user can determine the best solution according to it.\nThe following theorems state that our algorithm satisfies R1-R4.\nTheorem 1. Let (A′′i ,Ri) (1 ≤ i ≤ n) be the pairs returned by Adaptation(AS , k) for AS = (T ,A,N ). Then the following statements hold for every 1 ≤ i ≤ n: (1) 〈T ,A′′i 〉 |= N ; (2) A ′′ i = A ∪ N if A ∪ N is consistent w.r.t. T ; and (3) if N is consistent w.r.t. T then A′′i is also consistent w.r.t. T .\nTheorem 2. Given two adaptation settings ASi = (T ,Ai,Ni) (i = 1, 2) and an integer k satisfying k ≥ depth(T ), k ≥ depth(Ai), and k ≥ depth(Ni) (i = 1, 2). Let (A′′1 ,R1) be a pair returned by Adaptation(AS1, k). If 〈T ,A1〉 ≡ 〈T ,A2〉 and 〈T ,N1〉 ≡ 〈T ,N2〉, then there must be a pair (A′′2 ,R2) returned by Adaptation(AS2, k) such that 〈T ,A′′1 〉 ≡ 〈T ,A ′′ 2 〉 and R2 = σ(R1) for some substitution σ of variables.\nTheorem 2 is based on the following fact: let Gi = B-MW(〈T ,Ai〉, k) (i = 1, 2), then G1 and G2 are identical up to variable renaming in the case that k is sufficiently large. There is no requirement on the value of k in Theorem 1.\nIn our algorithm, the revision graph G constructed by the procedure BMW(〈T ,A〉, k) is in fact a non-redundant k-depth-bounded model for the KB 〈T ,A〉. Therefore, our revision process works on fine-grained representation of models and guarantees the minimal change principle in a fine-grained level. So, our algorithm satisfies the property specified by R5.\nThe following theorem states that our algorithm is in exponential time.\nTheorem 3. For any adaptation setting AS = (T ,A,N ), assume the role depth of every concept occurring in AS is bounded by some integer k, then the algorithm Adaptation(AS , k) runs in time exponential with respect to the size of AS."
    }, {
      "heading" : "5.3 Examples",
      "text" : "Example 7. Consider the adaptation setting AS1 = (T1,A1,N1) described in Example 4. Since max{depth(T1), depth(A1), depth(N1)} = 1, we let k=1 and execute the algorithm Adaptation(AS1, k).\nFirstly we call the procedure B-MW(〈T1,A1〉, k) to construct a revision graph G. Two variables x1, x2 are introduced during this procedure. By treating G as an ABox, we getAG = {A(a), C(a), R(a, x1), A(x1), C(x1), R(x1, x2), A(x2), C(x2)}.\nSecondly, for the clash AG ∪ N1 |=T1 ⊤ ⊑ ⊥, there are two (AG ,N1)justifications J1 = {A ⊑ ∃R.A, E ⊓ ∃R.A ⊑ ⊥, E(a), A(a)} and J2 = {E ⊓\n∃R.A ⊑ ⊥, E(a), A(a), R(a, x1), A(x1)}. Based on them we get two (AG ,N1)repairs R1 = {A(a), A(x1)} and R2 = {A(a), R(a, x1)}.\nThirdly, from R1 we get A1 = AG \\R1 = {C(a), R(a, x1), C(x1), R(x1, x2), A(x2), C(x2)}, and then get A ′ 1 = Rolling(A1, T1) = {C(a), ∃R.(C⊓∃R.A)(a)}. From R2, we get A2 = AG \\R2 = {C(a), A(x1), C(x1), R(x1, x2), A(x2), C(x2)} and A′2 = Rolling(A2, T1) = {C(a)}.\nFinally, the algorithm returns (A′1 ∪ N1,R1) and (A ′ 2 ∪ N1,R2).\nNow R2 contains a role assertion R(a, x1) which indicates that all the information related to x1 is lost in A′2 ∪N1, hence A ′ 2 is rather weak (in fact weaker than A′1). Thus the user should select (A ′ 1 ∪ N1,R1) and get a solution A ′′ 1 = A′1 ∪ N1 = {E(a), C(a), ∃R.(C ⊓ ∃R.A)(a)}. ⊓⊔\nLooking back Example 4 and Example 5, given the same adaptation setting AS1 = (T1,A1,N1), the solution generated by MBAs under the semantics Ga⊆ and Ga♯ is A ′ 1 = {E(a), C(a), R(a, a)}; the solution generated by the FBA based on justifications is A′1 = {E(a)}. Obviously, our algorithm is more fine-grained.\nExample 8. Consider the adaptation setting AS = (T ,A,N ) constructed in Example 1. Since max{depth(T ), depth(A), depth(N )} = 2, we let k = 2 and execute the algorithm Adaptation(AS, k).\nBy this algorithm we will get two results (A′′1 ,R1) and (A ′′ 2 ,R2), where R1\n= {Tamoxifen(y)}, A′′1 = {C(Mary), ∃hasGene.CY P2D6(Mary), ∃TreatBy. (Anti-oestrogen ⊓ ∃metabolizedTo.(Compounds⊓∃bindto.OestrogenReceptor)) (Mary)},R2 = {TreatBy(Mary, y)}, andA′′2 = {C(Mary), ∃hasGene.CY P2D6 (Mary)}. Since R2 contains a role assertion TreatBy(Mary, y) which indicates that all the information related to y is lost in A′′2 , the user should select (A ′′ 1 ,R1) and get a solution described by A′′1 . ⊓⊔"
    }, {
      "heading" : "6 Discussion and Related Work",
      "text" : "The idea of applying KB revision theory to adaptation in CBR was proposed by Lieber [16]. Based on a classical revision operator in propositional logic, a framework for adaptation was presented and it was demonstrated that the adaptation process should satisfy the AGM postulates. This idea was extended by Cojan and Lieber [5] to deal with adaptation based on the DL ALC. Based on an extension of the classical tableau method used for deductive inferences in ALC, an algorithm for adapting cases represented in ALC was proposed. It was shown that, except for the requirements on syntax-independence and minimality of change (i.e., R4 and R5 in our paper), all the other requirements specified by the AGM postulates (i.e., R1-R3 in our paper) are satisfied by their algorithm.\nFrom the point of view of KB revision in DLs, it is a great challenge to design revision operators or algorithms that satisfy the requirements specified by the AGM postulates [8]. In the literature, there are two kinds of approaches, i.e., MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs. As we analyzed in Section 4, they either do not satisfy the requirements specified by R4 and R5, or only work well for DLs of the DL-Lite family.\nOur method can be viewed as a combination of MBAs and FBAs. On the one hand, in our algorithm, the revision graph G constructed by the procedure B-MW(〈T ,A〉, k) can be seen as a non-redundant, k-depth-bounded model for the KB 〈T ,A〉, and therefore our revision process essentially works on models. On the other hand, our revision process makes use of (AG ,N )-repairs which inherits some ideas of FMAs based on justifications. As a result, our algorithm not only satisfies the requirements R4 and R5, but also works for the DL EL⊥.\nFor the adaptation setting AS = (T ,A,N ) defined in this paper, A only contains knowledge on the solution of the selected source case. We can define A to contain knowledge on the problem description of the source case also, and the algorithm still works for such a new definition.\nGiven an adaptation setting, our algorithm will return a finite number of pairs (A′′i ,Ri) (1 ≤ i ≤ n), and it is left to the user to select the best solution according to the sets Ri. We can extend the algorithm to recommend solutions automatically. For example, if some Ri contains role assertions, then the corresponding solution A′′i will be the last one to be considered. Furthermore, we can define a selection function according to the user’s selection criteria, and enable our algorithm to return only one best solution."
    }, {
      "heading" : "7 Conclusion and Future Work",
      "text" : "We studied the adaptation problem of CBR in the DL EL⊥. A formalism for adaptation based on EL⊥ was presented, and in this formalism the adaptation task was modeled as the instance-level KB revision problem in EL⊥. We have illustrated that existing revision operators and algorithms in DLs did not work for the adaptation setting based on EL⊥. By combining MBAs and FBAs, we presented a new algorithm for the adaptation problem, and showed that our algorithm behaves well for EL⊥ in that it satisfies the requirements proposed in the literature for revision operators.\nFor future work, we will extend our method to support adaptation based on EL++ [3]. Another work is to implement and optimize our algorithm and test its feasibility in practice."
    }, {
      "heading" : "Appendix. Proofs for Propositions and Theorems",
      "text" : "We introduce a lemma for proving Proposition 1.\nLemma 1. Given a KB K = 〈T ,A〉 and a non-negative integer k, let G = (V,E,L) be the revision graph generated after executing Step 2 of the procedure B-MW(K, k), and let AG be the ABox representation of G. Then, for any ABox assertion α with sig(α) ⊆ sig(K) and depth(α) ≤ k, K |= α iff 〈∅,AG〉 |= α.\nProof. (The If direction) Suppose 〈∅,AG〉 |= α. It is obvious that 〈T ,AG〉 |= α. We need to show that 〈T ,A〉 |= α.\nIf A is inconsistent w.r.t. T , then the result is trivial. Now suppose A is consistent w.r.t. T . Let I = (△I , ·I) be any interpretation with I |= T and I |= A. Let G0 be the revision graph constructed in Step 1 of the procedure B-MW(K, k). Let n be the number of times of applying expansion rules in Step 2, and let Gk (1 ≤ k ≤ n) be the revision graph after the i-th expansion. Let Ak (0 ≤ k ≤ n) be the ABox representation of Gi. Then we have A0 = A and An = AG .\nFirstly, by induction on k (0 ≤ k ≤ n), we show that for each Ak there exists some interpretation Ik = (△Ik , ·Ik) with\n– Ik |= T , – Ik |= Ak, – △Ik = △I , and – XIk = XI for any X ∈ sig(K).\n(Base case.) If k = 0, then we can construct I0 = I and get the interpretation we want.\n(Inductive step.) Let Ik = (△Ik , ·Ik) be an interpretation satisfying the above property. There are two cases to be investigated.\n(Case 1.) Suppose the revision graph Gk+1 is generated by applying the GCIInd-rule, GCIV ar-rule or ⊓-rule on the graph Gk. Then it is obvious that Ik |= Ak+1. Construct Ik+1 = Ik. Then Ik+1 is the interpretation we want.\n(Case 2.) Suppose Gk+1 is generated by applying the ∃-rule for some node x in Gk and some concept ∃R.C ∈ L(x). Let z be the new variable introduced by applying this rule. Since Ik |= Ak, we have Ik |= (∃R.C)(x). Therefore, there exists some p ∈ △Ik with 〈xIk , p〉 ∈ RIk and p ∈ CIk . Construct an interpretation Ik+1 = (△Ik+1 , ·Ik+1) as follows:\n– △Ik+1 = △Ik , – XIk+1 = XIk for any X ∈ sig(T ) ∪ sig(Ak), and – zIk+1 = p.\nIt is obvious that Ik+1 |= Ak+1 and Ik+1 is the interpretation we want. Secondly, from In |= An, In |= T , An = AG and 〈T ,AG〉 |= α, we have In |= α. Furthermore, since sig(α) ⊆ sig(K) and XIn = XI for any X ∈ sig(K), we have I |= α. Therefore, we have 〈T ,A〉 |= α.\n(The Only-if direction) Suppose 〈T ,A〉 |= α. We need to show that 〈∅,AG〉 |= α.\nIf AG is inconsistent, then the result is trivial. Now suppose AG is consistent. Let I = (△\nI , ·I) be any interpretation with I |= AG . Construct a revision graph G′ = (V ′, E′,L′) as follows:\n1. Initialize G′ = G. 2. Expand G′ by applying the following rules, until none of these rules is appli-\ncable: – if C ⊑ D ∈ T , D /∈ L′(x), x /∈ NKI , and 〈T , {E(x) | E ∈ L\n′(x)}〉 |= C(x), then set L′(x) = L′(x) ∪ {D}; – if C1 ⊓ C2 ∈ L′(x), and {C1, C2} * L′(x), then set L′(x) = L′(x) ∪ {C1, C2}; – if ∃R.C ∈ L′(x), x has no successor z with C ∈ L′(z), then introduce a new variable z, set V ′ = V ′ ∪ {z}, E′ = E′ ∪ {〈x, z〉}, L′(z) = {C}, and L′(〈x, z〉) = {R}.\nLet AG′ be the ABox representation of G′. Based on I and G′, construct an interpretation I ′ = (△I ′ , ·I ′ ) as follows:\n1. Initialize I ′ = I. 2. For every x ∈ V ′ \\ V , expand I ′ as follows:\n– set △I ′ = △I ′\n∪ {x}; – set xI ′\n= x; – let C1, ..., Cm be all the concept names contained in L′(x), then set CI ′\ni\n= CI ′\ni ∪ {x} for each 1 ≤ i ≤ m; – let y be the predecessor of x in graph G′, and let R be the concept name\ncontained in L′(〈y, x〉), then set RI ′ = RI ′ ∪ {〈y, x〉}.\nAccording to the above constructions, it is obvious that I ′ |= AG′ and I ′ |= T . At the same time, we have A ⊆ AG ⊆ AG′ and consequently I ′ |= A. Therefore, from 〈T ,A〉 |= α, we can get I ′ |= α.\nBy investigating the relationship between I and I ′, we have the following results:\n– aI = aI ′\nfor every individual name a ∈ sig(K); – for every concept name C ∈ sig(K), x ∈ CI ′\n\\ CI only if level(x) > k, and – for every role name R ∈ sig(K), 〈x, y〉 ∈ RI ′ \\RI only if level(y) > k.\nSince sig(α) ⊆ sig(K) and depth(α) ≤ k, from I ′ |= α we have I |= α. Therefore, we have 〈∅,AG〉 |= α. ⊓⊔\nProof of Proposition 1. Let G0 = (V0, E0,L0) be the revision graph generated after executing Step 2 of the procedure B-MW(K, k), and let AG0 be the ABox representation of G0. By Lemma 1, we have K |= α iff 〈∅,AG0〉 |= α.\nLet G1 = (V1, E1,L1) be the graph generated by Step 3 of the procedure, and let AG1 be the ABox representation of G1. Based on the expansion rules in Fig. 1, it is obvious that 〈∅,AG0〉 |= α iff 〈∅,AG1〉 |= α.\nLet G2 = (V2, E2,L2), ..., Gm = (Vm, Em,Lm) be the sequence of all graphs generated during the execution of Step 4 of the procedure B-MW(K, k). Let Gi = (Vi, Ei,Li) (2 ≤ i ≤ m) is generated by dropping a redundant branch Bi = (VBi , EBi ,LBi) for which the root node is xi. Let AGi (2 ≤ i ≤ m) be the ABox representation of Gi. Then we have Gm = G and AGm = AG .\nFor any concept assertion C(xi) with rd(C) ≤ k− level(xi), it is obvious that AGi |= C(xi) iff AGi−1 |= C(xi). So, we have 〈∅,AGi−1〉 |= α iff 〈∅,AGi〉 |= α.\nTo sum up, we have K |= α iff 〈∅,AG〉 |= α. ⊓⊔\nWe introduce two lemmas for proving Theorem 1 and Theorem 2.\nLemma 2. Let K = 〈T ,A〉 and K′ = 〈T ,A′〉 be two consistent KBs, let k be an integer with k ≥ depth(K) and k ≥ depth(K′). Let G = (V,E,L) and G′ = (V ′, E′,L′) be the revision graphs returned by B-MW(K, k) and B-MW(K′, k) respectively. If K ≡ K′, then there exists a bijection f : V → V ′ such that\n– f(x) = x if x is an individual name, – L(x) = L′(f(x)) for every node x ∈ V , – 〈x, y〉 ∈ E iff 〈f(x), f(y)〉 ∈ E′ for every pair of nodes x, y, and – L(〈x, y〉) = L′(〈f(x), f(y)〉) for every edge 〈x, y〉 ∈ E.\nProof. We prove the result by constructing the function f : V → V ′. Let AG , AG′ be the ABox representation of G and G\n′ respectively. Then AG and AG′ only contains of role assertions and concept assertions of the form C(x) with C ∈ NKC . Furthermore, for every individual name x, we have x ∈ V iff x ∈ V\n′. Firstly, set f(x) = x for every individual name x in V . Let a be any individual name in V , and let C be any concept name in L(a). By the construction of AG , we have C(a) ∈ AG and consequently 〈∅,AG〉 |= C(a). By Proposition 1, we have 〈T ,A〉 |= C(a). Since K ≡ K′, we have 〈T ,A′〉 |= C(a). By Proposition 1 again, we have 〈∅,AG′〉 |= C(a) and consequently C(a) ∈ AG′ . By the construction of AG′ , we have C ∈ L′(a). Therefore, we have L(a) ⊆ L′(a), i.e., L(a) ⊆ L′(f(a)). Similarly, we can get L′(f(a)) ⊆ L(a).\nLet 〈a, b〉 be any edge in E with a, b individual names, and let r be any role name in L(〈a, b〉). By the construction of AG , we have r(a, b) ∈ AG and consequently 〈∅,AG〉 |= r(a, b). By Proposition 1, we have 〈T ,A〉 |= r(a, b). Since K ≡ K′, we have 〈T ,A′〉 |= r(a, b). By Proposition 1 again, we have 〈∅,AG′〉 |= r(a, b) and consequently r(a, b) ∈ AG′ . By the construction of AG′ , we have 〈a, b〉 ∈ E′ and r ∈ L′(〈a, b〉). Therefore, we have L(〈a, b〉) ⊆ L′(〈f(a), f(b)〉). Similarly, we can get L′(〈f(a), f(b)〉) ⊆ L(〈a, b〉).\nTo sum up, we have L(a) = L′(f(a)) for every individual name a. Furthermore, for every pair of individual names a and b, we have 〈a, b〉 ∈ E iff 〈f(a), f(b)〉 ∈ E′, and L(〈a, b〉) = L′(〈f(a), f(b)〉).\nSecondly, let a1, ..., am be all the individual names contained in V and V ′. Let Vi ⊆ V (1 ≤ i ≤ m) be a set composed of ai and all the variables which are descendants of ai in G, and let V ′i ⊆ V\n′ (1 ≤ i ≤ m) be a set composed of ai and all the variables which are descendants of ai in G′. Let Gi (1 ≤ i ≤ m) be the subgraph induced on G by the vertex subset Vi, and let G′i (1 ≤ i ≤ m)\nbe the subgraph induced on G′ by the vertex subset V ′i . For any node x of Gi (1 ≤ i ≤ m), let Roll(x) be a concept constructed inductively as follows:\n– if x has no successor, then Roll(x) = d\nC∈L(x)\nC, else\n– Roll(x) = ∃r1.Roll(y1) ⊓ ... ⊓ ∃rt.Roll(yt) ⊓ d\nC∈L(x)\nC, where y1, ..., yt are\nall the successors of x in G, and ri (1 ≤ i ≤ t) is the role name contained in L(〈x, yi〉).\nSimilarly, for any node x of G′i (1 ≤ i ≤ m), let Roll ′(x) be a concept constructed inductively as follows:\n– if x has no successor, then Roll′(x) = d\nC∈L′(x)\nC, else\n– Roll′(x) = ∃r1.Roll′(y1) ⊓ ... ⊓ ∃rt.Roll′(yt) ⊓ d\nC∈L′(x)\nC, where y1, ..., yt are\nall the successors of x in G′, and ri (1 ≤ i ≤ t) is the role name contained in L′(〈x, yi〉).\nFor each individual name ai (1 ≤ i ≤ m), let Roll(ai) be of the form ∃r1.Roll(y1) ⊓ ... ⊓ ∃rt.Roll(yt) ⊓ d\nC∈L(ai)\nC, and let Roll′(ai) be of the form\n∃r′1.Roll ′(y′1) ⊓ ... ⊓ ∃r ′ s.Roll ′(y′s) ⊓ d\nC∈L′(ai)\nC. Then we have 〈∅,AG〉 |=Roll(ai)(ai)\nand 〈∅,AG′〉 |= Roll ′(ai)(ai). By Proposition 1, we have 〈T ,A〉 |= Roll(ai)(ai) and 〈T ,A′〉 |= Roll′(ai)(ai). Since K ≡ K′, we have 〈T ,A′〉 |= Roll(ai)(ai) and 〈T ,A〉 |= Roll′(ai)(ai). By Proposition 1 again, we have 〈∅,AG′〉 |= Roll(ai)(ai) and 〈∅,AG〉 |= Roll′(ai)(ai). Therefore, it must be t = s. Furthermore, there must be a one-to-one correspondence from {y1, ..., yt} to {y′1, ..., y ′ s} (w.l.o.g. we assume yi is corresponding to y ′ i) such that 〈∅,AG′〉 |= Roll(yk)(y ′ k), 〈∅,AG〉 |= Roll′(y′k)(yk), rk = r ′ k, and L(yk) = L\n′(y′k) for every 1 ≤ k ≤ t. So, we can continue the construction of the function f , and set f(yk) = y ′ k for each node yk (1 ≤ k ≤ t). Now, for each node yk (1 ≤ k ≤ t), let Roll(yk) be of the form ∃rk,1.Roll(yk,1) ⊓ ... ⊓ ∃rk,u.Roll(yk,u) ⊓ d\nC∈L(yk)\nC, and let Roll′(y′k) be of the form ∃r ′ k,1.\nRoll′(y′k,1) ⊓ ... ⊓ ∃r ′ k,v.Roll ′(y′k,v) ⊓ d\nC∈L′(y′ k )\nC. From 〈∅,AG′〉 |= Roll(yk)(y ′ k)\nand 〈∅,AG〉 |= Roll′(y′k)(yk), it must be u = v. Furthermore, there must be a oneto-one correspondence from {yk,1, ..., yk,u} to {y ′ k,1, ..., y ′ k,v} (w.l.o.g. we assume yk,i is corresponding to y ′ k,i) such that 〈∅,AG′〉 |= Roll(yk,j)(y ′ k,j), 〈∅,AG〉 |= Roll′(y′k,j)(yk,j), rk,j = r ′ k,j , and L(yk,j) = L\n′(y′k,j) for every 1 ≤ j ≤ u. So, we can continue the construction of the function f , and set f(yk,j) = y ′ k,j for each node yk,j (1 ≤ j ≤ u). Repeat the above process, we can finish the construction of the function f : V → V ′ which satisfies the property stated by the lemma. ⊓⊔\nLemma 3. For any ABox AG and TBox T , let A be the ABox returned by the procedure Rolling(AG , T ). Then, 〈T ,AG〉 |= A.\nProof. Let G = (V,E,L) be the revision-graph representation of AG . Let G0 = (V0, E0,L0) be the revision graph generated by Step 2 of the procedure. Let n be the number of variables contained in V0, and let Gi = (Vi, Ei,Li) (1 ≤ i ≤ n) be the revision graph generated after removing k variables from G0 in Step 3. Let Ai (0 ≤ i ≤ n) be the ABox representation of Gi. Then we have An = A.\nIf AG is inconsistent w.r.t. T , then the result trivial. Now suppose AG is consistent w.r.t. T . Let I be any interpretation with I |= T and I |= AG . It is obvious that I |= A0. According to the operations of Step 3, we can get I |= Ai (1 ≤ i ≤ n) from I |= T and I |= Ai−1. Therefore we have I |= An, i.e., I |= A. So, we have 〈T ,AG〉 |= A. ⊓⊔\nProof of Theorem 1. The first two statements are obvious. Here we prove the third one.\nSuppose N is consistent w.r.t. T . Then the set SR of (AG ,N )-repairs constructed in Algorithm 1 is not empty. For any Ri ∈ SR, let Ai = AG \\Ri, then, by the definition of (AG ,N )-repairs, we have that Ai ∪ N is consistent w.r.t. T . Let A′i = Rolling(Ai, T ). By Lemma 3, We have Amin |=T A0. Therefore, A′i ∪ N is also consistent w.r.t. T . So, for each pair (A ′′ i ,Ri) returned by the algorithm, A′′i is consistent w.r.t. T . ⊓⊔\nProof of Theorem 2. Let Gi = B-MW(〈T ,Ai〉, k), and let AGi be the ABox representation of Gi (i = 1, 2). Since k ≥ max{depth(T ), depth(A1), depth(N1), depth(A2), depth(N2)}, we know that between G1 and G2 there exists an isomorphism relationship specified by Lemma 2. In other words, there exists a substitution σ of variables such that σ(AG1 ) = AG2 .\nLet J1 ⊆ AG1 be any (AG1 ,N1)-justification for a clash w.r.t. T , and let J2 = σ(J1). From 〈T ,N1〉 ≡ 〈T ,N2〉 and σ(AG1) = AG2 , we have that J2 ⊆ AG2 and J2 is a (AG2 ,N2)-justification for a clash w.r.t. T .\nLet R2 = σ(R1). Since R1 is a (AG1 ,N1)-repair for clashes w.r.t. T , from 〈T ,N1〉 ≡ 〈T ,N2〉 and σ(AG1) = AG2 , we have that R2 ⊆ AG2 and R2 is a (AG2 ,N2)-repair for clashes w.r.t. T .\nLet A1 = AG1 \\ R1 and A2 = AG2 \\ R2. Then we have that A2 = σ(A1). Let A′1 = Rolling(A1, T ) and A ′ 2 = Rolling(A2, T ). Then we have that A ′ 1 = A′2 and A ′′ 1 = A ′ 1 ∪ N1.\nNow construct a set A′′2 = A ′ 2 ∪ N2. Then the pair (A ′′ 2 ,R2) will be returned by Adaptation(AS2, k). Furthermore, since A′1 = A ′ 2 and 〈T ,N1〉 ≡ 〈T ,N2〉, we have that 〈T ,A′′1 〉 ≡ 〈T ,A ′′ 2 〉. ⊓⊔\nProof of Theorem 3. Let k = max{depth(T ),A), depth(N )}. Let T ′ be a normal form of T such that there is no conjunction in the right hand side of every GCI contained in it, and let m = |T ′|. It is obvious that m is linearly bounded by |T |.\nFor the revision graph G returned by the procedure B-MW(〈T ,A〉, k), the number of nodes is bounded by |NKI | × m\nk+1. Therefore, for the ABox representation AG of G, |AG | is bounded by |A|+ |NKC | × |N K I | ×m k+1. Since every\n(AG ,N )-justification and every (AG ,N )-repair is a subset of AG , together with the fact that KB consistency problem is polynomial time in EL⊥, we can conclude that the time complexity of Algorithm 1 is O(2|N K C |×|NK I |×mk+1). Since k is bounded by some constant, we get the result stated by the theorem. ⊓⊔"
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "C.E. Alchourrón", "P. Gärdenfors", "D. Makinson" ],
      "venue" : "J. Symb. Log, 50(2), 510-530",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "The Description Logic Handbook: Theory, Implementation and Applications",
      "author" : [ "F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : "Cambridge University Press, Cambridge",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Pushing the EL envelope",
      "author" : [ "F. Baader", "S. Brandt", "C. Lutz" ],
      "venue" : "Proc. of the 19th International Joint Conference on Artificial Intelligence, pp. 364-369. Morgan Kaufmann",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Evolution of DL-lite knowledge bases",
      "author" : [ "D. Calvanese", "E. Kharlamov", "W. Nutt", "D. Zheleznyakov" ],
      "venue" : "Patel-Schneider, P.F., Pan, Y., Hitzler, P., Mika, P., Zhang,  Adapting Cases Represented in a Tractable Description Logic 15 L., Pan, J.Z., Horrocks, I., Glimm, B. (eds.) ISWC 2010. LNCS, vol. 6496, pp. 112-128. Springer, Heidelberg",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "An algorithm for adapting cases represented in an expressive description logic",
      "author" : [ "J. Cojan", "J. Lieber" ],
      "venue" : "Bichindaritz, I., Montani, S. (eds.) ICCBR 2010. LNCS, vol. 6176, pp. 51-65. Springer, Heidelberg",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Gene Ontology: Tool for the unification of biology",
      "author" : [ "T.G.O. Consortium" ],
      "venue" : "Nature Genetics, 25, 25-29",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Decentralized case-based reasoning for the semantic web",
      "author" : [ "M. d’Aquin", "J. Lieber", "A. Napoli" ],
      "venue" : "Gil, Y., Motta, E., Benjamins, V.R., Musen, M.A. (eds.) ISWC 2005. LNCS, vol. 3729, pp. 142-155. Springer, Heidelberg",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "On applying the AGM theory to DLs and OWL",
      "author" : [ "G. Flouris", "D. Plexousakis", "G. Antoniou" ],
      "venue" : "Gil, Y., Motta, E., Benjamins, V.R., Musen, M.A. (eds.) ISWC 2005. LNCS, vol. 3729, pp. 216-231. Springer, Heidelberg",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Modelling the CBR life cycle using description logics",
      "author" : [ "M. Gómez-Albarrán", "P.A. González-Calero", "B. Díaz-Agudo", "C. Fernández-Conde" ],
      "venue" : "Althoff, K.-D., Bergmann, R., Karl Branting, L. (eds.) ICCBR 1999. LNCS, vol. 1650, pp. 147-161. Springer, Heidelberg",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "From SHIQ and RDF to OWL: the making of a web ontology language",
      "author" : [ "I. Horrocks", "P.F. Patel-Schneider", "F.V. Harmelen" ],
      "venue" : "J. Web Semantics, 1(1), 7-26",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "A tableau decision procedure for SHOIQ",
      "author" : [ "I. Horrocks", "U Sattler" ],
      "venue" : "J. Autom. Reasoning, 39(3), 249-276",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Propositional knowledge base revision and minimal change",
      "author" : [ "H. Katsuno", "A.O. Mendelzon" ],
      "venue" : "Artificial Intelligence, 52(3), 263-294",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Capturing model-based ontology evolution at the instance level: The case of DL-Lite",
      "author" : [ "E. Kharlamov", "D. Zheleznyakov", "D Calvanese" ],
      "venue" : "J. Comput. Syst. Sci., 79(6), 835-872",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A Framework for Semantic-Based Similarity Measures for ELH -Concepts",
      "author" : [ "K. Lehmann", "A.Y. Turhan" ],
      "venue" : "Cerro, L.F., Herzig, A., Mengin, J. (eds.) JELIA 2012. LNCS, vol. 7519, pp. 307-319. Springer, Heidelberg",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On the evolution of the instance level of DL-Lite knowledge bases",
      "author" : [ "M. Lenzerini", "D.F. Savo" ],
      "venue" : "Proc. of the 24th International Workshop on Description Logics",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Application of the revision theory to adaptation in case-based reasoning: the conservative adaptation",
      "author" : [ "J. Lieber" ],
      "venue" : "Weber, R.O.,Richter, M.M. (eds.) ICCBR 2007. LNCS, vol. 4626, pp. 239-253. Springer, Heidelberg",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Study and formalization of a case-based reasoning system using a description logic",
      "author" : [ "S. Salotti", "V. Ventos" ],
      "venue" : "Smyth, B., Cunningham, P. (eds.) EWCBR 1998. LNCS, vol. 1488, pp. 286-297. Springer, Heidelberg",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Measuring similarity in description logics using refinement operators",
      "author" : [ "A.A. Sánchez-Ruiz-Granados", "S. Ontañón", "P.A. González-Calero", "E. Plaza" ],
      "venue" : "Ram, A., Wiratunga, N. (eds.) ICCBR 2011. LNCS, vol. 6880, pp. 289-303. Springer, Heidelberg",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Managing clinical terminology hierarchies using algorithmic calculation of subsumption: Experience with SNOMED-RT",
      "author" : [ "K. Spackman" ],
      "venue" : "J. American Medical Informatics Assoc., Fall Symposium Special Issue",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Belief base revision for expressive description logics",
      "author" : [ "C.H. Wiener", "Y. Katz", "B. Parsia" ],
      "venue" : "Proc. of the 4th International Workshop on OWL: Experiences and Directions",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "Description logic (DL) is a family of logics for representing and reasoning about knowledge of static application domains [2].",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 9,
      "context" : "It is playing a central role in the Semantic Web, serving as the basis of the W3C-recommended Web ontology language OWL [10].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 6,
      "context" : "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].",
      "startOffset" : 132,
      "endOffset" : 143
    }, {
      "referenceID" : 8,
      "context" : "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].",
      "startOffset" : 132,
      "endOffset" : 143
    }, {
      "referenceID" : 16,
      "context" : "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].",
      "startOffset" : 132,
      "endOffset" : 143
    }, {
      "referenceID" : 17,
      "context" : "In the last few years, there has been a growing interest in bringing the power and character of DLs into case-based reasoning (CBR) [7,9,17,18].",
      "startOffset" : 132,
      "endOffset" : 143
    }, {
      "referenceID" : 6,
      "context" : "At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].",
      "startOffset" : 93,
      "endOffset" : 102
    }, {
      "referenceID" : 16,
      "context" : "At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].",
      "startOffset" : 93,
      "endOffset" : 102
    }, {
      "referenceID" : 17,
      "context" : "At present, most research is concerned with the retrieval task when introducing DLs into CBR [7,17,18].",
      "startOffset" : 93,
      "endOffset" : 102
    }, {
      "referenceID" : 15,
      "context" : "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].",
      "startOffset" : 111,
      "endOffset" : 117
    }, {
      "referenceID" : 4,
      "context" : "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].",
      "startOffset" : 111,
      "endOffset" : 117
    }, {
      "referenceID" : 0,
      "context" : "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].",
      "startOffset" : 211,
      "endOffset" : 217
    }, {
      "referenceID" : 11,
      "context" : "One approach for this task is to model the adaptation process as the revision problem of a knowledge base (KB) [16,5]; it is hoped that an adaptation algorithm satisfies the AGM postulates on revision operators [1,12].",
      "startOffset" : 211,
      "endOffset" : 217
    }, {
      "referenceID" : 15,
      "context" : "In propositional logic, there are many revision operators which satisfy the AGM postulates and can be applied to complete the adaptation task [16].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 7,
      "context" : "However, in DLs, it is very difficult to design revision operators and algorithms that satisfy the AGM postulates [8].",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 12,
      "context" : "Revision operators of MBAs can be treated as DL-based extensions of the classical revision operators in propositional logic, in that the semantics of minimal change is defined by measuring the distance between models [13].",
      "startOffset" : 217,
      "endOffset" : 221
    }, {
      "referenceID" : 3,
      "context" : "One is based on the deductive closure of a KB [4,15]; it is syntax-independent and fine-grained, but again only works for DLs of the DLLite family.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 14,
      "context" : "One is based on the deductive closure of a KB [4,15]; it is syntax-independent and fine-grained, but again only works for DLs of the DLLite family.",
      "startOffset" : 46,
      "endOffset" : 52
    }, {
      "referenceID" : 19,
      "context" : "Another is based on justifications [20]; although it is applicable to DLs such as SHOIN , it is syntax-dependent and not fine-grained.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 2,
      "context" : "DLs of the EL family are popular for building large-scale ontologies [3].",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 18,
      "context" : "Some important medical ontologies and life science ontologies are built in EL, such as the SNOMED CT [19] and the Gene Ontology [6].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 5,
      "context" : "Some important medical ontologies and life science ontologies are built in EL, such as the SNOMED CT [19] and the Gene Ontology [6].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 17,
      "context" : "In the literature, some good results on introducing DLs of the EL family into the retrieval of source cases have been presented [18]; the problem of measuring the similarity of concepts in these DLs is also well-studied [14].",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 13,
      "context" : "In the literature, some good results on introducing DLs of the EL family into the retrieval of source cases have been presented [18]; the problem of measuring the similarity of concepts in these DLs is also well-studied [14].",
      "startOffset" : 220,
      "endOffset" : 224
    }, {
      "referenceID" : 15,
      "context" : "Secondly, we extend the “adaptation as KB revision” view from [16] to the above setting and get a formalism for adaptation based on EL⊥.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 2,
      "context" : "The DL EL⊥ extends EL with bottom concept (and consequently disjointness statements) [3].",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 15,
      "context" : "Consider the example on breast cancer treatment discussed in [16].",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 15,
      "context" : "Here we follow the approach presented in [16] to formulate adaptation as knowledge base revision, with the difference that our formalism is based on the DL EL⊥ instead of propositional logic.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 15,
      "context" : "In [16], the adaptation process is modeled as KB revision in propositional logic.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 17,
      "context" : "With such a framework, given a target problem tgt, we can make use of similarity-measuring algorithms presented in the literature [18,14] to select a source case (srce, sol) such that, by treating individual names occurring in srce as variables, there exists a substitution σ such that σ(srce) and tgt has the maximum similarity.",
      "startOffset" : 130,
      "endOffset" : 137
    }, {
      "referenceID" : 13,
      "context" : "With such a framework, given a target problem tgt, we can make use of similarity-measuring algorithms presented in the literature [18,14] to select a source case (srce, sol) such that, by treating individual names occurring in srce as variables, there exists a substitution σ such that σ(srce) and tgt has the maximum similarity.",
      "startOffset" : 130,
      "endOffset" : 137
    }, {
      "referenceID" : 3,
      "context" : "The adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12].",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 0,
      "context" : "The adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12].",
      "startOffset" : 197,
      "endOffset" : 203
    }, {
      "referenceID" : 11,
      "context" : "The adaptation setting defined above is similar to the instance-level revision setting based on DLs [4]; R1-R3 are just the basic requirements specified by the AGM postulates on revision operators [1,12].",
      "startOffset" : 197,
      "endOffset" : 203
    }, {
      "referenceID" : 15,
      "context" : "From the point of view of adaptation, the requirements on solutions are explained as follows [16].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 3,
      "context" : "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].",
      "startOffset" : 139,
      "endOffset" : 153
    }, {
      "referenceID" : 7,
      "context" : "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].",
      "startOffset" : 139,
      "endOffset" : 153
    }, {
      "referenceID" : 12,
      "context" : "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].",
      "startOffset" : 139,
      "endOffset" : 153
    }, {
      "referenceID" : 14,
      "context" : "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].",
      "startOffset" : 139,
      "endOffset" : 153
    }, {
      "referenceID" : 19,
      "context" : "In the literature, there exist some revision operators and algorithms that can generate revision results satisfying the above requirements [4,8,13,15,20].",
      "startOffset" : 139,
      "endOffset" : 153
    }, {
      "referenceID" : 3,
      "context" : "One reason is that there are different approaches to define minimality, and it is well-accepted that there is no general notion of minimality that will do the right thing under all circumstances [4].",
      "startOffset" : 195,
      "endOffset" : 198
    }, {
      "referenceID" : 12,
      "context" : "MBAs define revision operators over the distance between interpretations [13].",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 11,
      "context" : "In propositional logic, it is easy to measure the distance between interpretations and to calculate the revision results based on the distance [12], since each interpretation is only a truth assignment on propositional symbols.",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 12,
      "context" : "Then, with MBAs, M is the set of models of 〈T ,N〉 that are minimally distant from the models of 〈T ,A〉 [13], i.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 12,
      "context" : "In [13], the above four different semantics for MBAs are denoted as G ♯ , G ⊆, G a ♯ , and G a ⊆ respectively.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 3,
      "context" : "The first one is based on deductive closures [4,15].",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 14,
      "context" : "The first one is based on deductive closures [4,15].",
      "startOffset" : 45,
      "endOffset" : 51
    }, {
      "referenceID" : 19,
      "context" : "The second FBA is based on justifications (also known as MinAs or kernel) [20].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 10,
      "context" : "Our algorithm is based on a structure named revision graph, which is close to the completion graph used in classical tableau decision algorithms of DLs [11].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 15,
      "context" : "The idea of applying KB revision theory to adaptation in CBR was proposed by Lieber [16].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 4,
      "context" : "This idea was extended by Cojan and Lieber [5] to deal with adaptation based on the DL ALC.",
      "startOffset" : 43,
      "endOffset" : 46
    }, {
      "referenceID" : 7,
      "context" : "From the point of view of KB revision in DLs, it is a great challenge to design revision operators or algorithms that satisfy the requirements specified by the AGM postulates [8].",
      "startOffset" : 175,
      "endOffset" : 178
    }, {
      "referenceID" : 12,
      "context" : ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 3,
      "context" : ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.",
      "startOffset" : 21,
      "endOffset" : 30
    }, {
      "referenceID" : 14,
      "context" : ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.",
      "startOffset" : 21,
      "endOffset" : 30
    }, {
      "referenceID" : 19,
      "context" : ", MBAs [13] and FBAs [4,15,20], for the instance-level KB revision problem in DLs.",
      "startOffset" : 21,
      "endOffset" : 30
    }, {
      "referenceID" : 2,
      "context" : "For future work, we will extend our method to support adaptation based on EL [3].",
      "startOffset" : 77,
      "endOffset" : 80
    } ],
    "year" : 2014,
    "abstractText" : "Case-based reasoning (CBR) based on description logics (DLs) has gained a lot of attention lately. Adaptation is a basic task in CBR that can be modeled as a knowledge base revision problem which has been solved in propositional logic. However, in DLs, adaptation is still a challenge problem since existing revision operators only work well for DLs of the DL-Lite family. It is difficult to design revision algorithms that are syntax-independent and fine-grained. In this paper, we present a new method for adaptation based on the tractable DL EL⊥. Following the idea of adaptation as revision, we firstly extend the logical basis for describing cases from propositional logic to the DL EL⊥, and then present a formalism for adaptation based on EL⊥. With this formalism, we show that existing revision operators and algorithms in DLs do not work for it, and then present our adaptation algorithm. Our algorithm is syntax-independent and fine-grained, and satisfies the requirements on revision operators.",
    "creator" : "LaTeX with hyperref package"
  }
}