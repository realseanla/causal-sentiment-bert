{
  "name" : "1611.02453.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "clu@uni-bremen.de", "wolter@liverpool.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n61 1.\n02 45\n3v 1\n[ cs\n.A I]\n8 N"
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "In recent years, the use of ontologies to access instance data has become increasingly popular [PLC+08, KZ14, BO15]. The general idea is that an ontology provides domain knowledge and an enriched vocabulary for querying, thus serving as an interface between the query and the data, and enabling the derivation of additional facts. In this emerging area, called ontology-mediated querying, it is a central research goal to identify ontology languages for which query evaluation scales to large amounts of instance data. Since the size of the data typically dominates the size of the ontology and the size of the query by orders of magnitude, the central measure for such scalability is data complexity—the complexity of query evaluation where only the data is considered to be an input, but both the query and the ontology are fixed.\nIn description logic (DL), ontologies take the form of a TBox, data is stored in an ABox, and the most important classes of queries are conjunctive queries (CQs) and variations thereof, such as positive existential queries (PEQs). A fundamental observation regarding this setup is that, for expressive DLs such as ALC and SHIQ, the complexity of query evaluation is CONP-complete and thus intractable [Sch93, HMS07, GLHS08].1 The classical approach to avoid this problem is to replace ALC and SHIQ with less expressive DLs that are ‘Horn’ in the sense that they can\n1998 ACM Subject Classification: Logic, Description Logics. Key words and phrases: Description Logic, Ontology-Based Data Access, Data Complexity, Conjunctive Queries. 1When speaking of complexity, we always mean data complexity\nLOGICAL METHODS IN COMPUTER SCIENCE DOI:10.2168/LMCS-???\nc© DATA COMPLEXITY OF ONTOLOGIES Creative Commons\n1\nbe embedded into the Horn fragment of first-order (FO) logic. Horn DLs typicall admit query evaluation in PTIME, examples include a variety of logics from the EL [BBL05] and DL-Lite families [CDGL+07] as well as Horn-SHIQ, a large fragment of SHIQ with PTIME query evaluation [HMS07].\nIt may thus seem that the data complexity of query evaluation in the presence of DL ontologies is understood rather well. However, all results discussed above are on the level of logics, i.e., traditional results about data complexity concern a class of TBoxes that is defined in a syntactic way in terms of expressibility in a certain DL language, but no attempt is made to identify more structure inside these classes. Such a more fine-grained study, however, seems very natural both from a theoretical and from a practical perspective; in particular, it is well-known that ontologies which emerge in practice tend to use ‘expensive’ language constructs that can result in CONPhardness of data complexity, but they typically do so in an extremely restricted and intuitively ‘harmless’ way. This distinction between hard and harmless cases cannot be analyzed on the level of logics. The aim of this paper is to initiate a more fine-grained study of data complexity that is non-uniform in the sense that it does not treat all TBoxes formulated in the same DL in a uniform way.\nWhen taking a non-uniform perspective, there is an important choice regarding the level of granularity. First, one can analyze the complexity on the level of TBoxes, quantifying over the actual query. Then, query evaluation for a TBox T is in PTIME if every query (from the class under consideration) can be evaluated in PTIME w.r.t. T and it is CONP-hard if there is at least one query that is CONP-hard to evaluate w.r.t. T . And second, one might take an even more fine-grained approach where the query is not quantified away and the aim is to classify the complexity on the level of ontology-mediated queries (OMQs), that is, combinations of a TBox and an actual query. From a practical perspective, both setups make sense; when the actual queries are fixed at the design time of the application, one would probably prefer to work on the level of OMQs whereas the level of TBoxes seems more appropriate when the queries can be freely formulated at application running time. A non-uniform analysis on the level of OMQs has been carried out in [BtCLW14]. In this paper, we concentrate on the level of TBoxes. The ultimate goal of our approach is as follows:\nFor a fixed DL L and query language Q, classify all TBoxes T in L according to the complexity of evaluating queries from Q w.r.t. T .\nWe consider the basic expressive DL ALC, its extensions ALCI with inverse roles and ALCF with functional roles, and their union ALCFI. As query languages, we cover CQs, acyclic CQs, and PEQs (which have the same expressive power as unions of conjunctive queries, UCQs, which are thus implicitly also covered). It turns out that, even for ALC, fully achieving the above goal is far beyond the scope of a single research paper. In fact, we show that for any of the mentioned query languages, a full classification of the complexity of ALC- and ALCI-TBoxes is essentially equivalent to a full classification of the complexity of non-uniform constraint satisfaction problems with finite templates (CSPs). The latter is a major research programme ongoing for many years that combines complexity theory, graph theory, logic, and algebra [BJK05, KS09, Bul11, Bar14].\nIn the current paper, we mainly concentrate on understanding the boundary between PTIME and CONP-hardness of query evaluation w.r.t. DL TBoxes, mostly neglecting other relevant classes such as AC0, LOGSPACE, and NLOGSPACE. Our main results are as follows (they always apply to all query languages mentioned above).\n1. There is a PTIME/CONP-dichotomy for query evaluation w.r.t. ALCFI-TBoxes of depth one, i.e., TBoxes in which existential and universal restrictions are not nested; moreover, PTIME query\nevaluation coincides with rewritability into monadic Datalog (with inequalities, to capture functional roles).\nThe proof rests on interesting model-theoretic characterizations of polynomial time CQ-evaluation which are discussed below. Note that this is a relevant case since most TBoxes from practical applications have depth one. In particular, all TBoxes formulated in DL-Lite and its extensions proposed in [CDGL+07, ACKZ09] have depth one, and the same is true for more than 80 percent of the 429 TBoxes in the BioPortal ontology repository.\n2. There is a PTIME/CONP-dichotomy for CQ-evaluation w.r.t. ALC-TBoxes if and only if Feder and Vardi’s dichotomy conjecture for CSPs is true; the same holds for ALCI-TBoxes.\nThe proof establishes a close link between query evaluation in ALC and CSP. While dichotomy questions are mainly of theoretical interest, linking these two worlds is potentially very relevant also for more applied DL research.\n3. There is no PTIME/CONP-dichotomy for query evaluation w.r.t. ALCF-TBoxes (unless PTIME = NP).\nThis is proved by showing that, for every problem in CONP, there is an ALCF-TBox for which CQevaluation has the same complexity (up to polynomial time reductions); it then remains to apply Ladner’s Theorem, which guarantees the existence of NP-intermediate problems. Consequently, we cannot expect an exhaustive classification of the complexity of query evaluation w.r.t. ALCFTBoxes.\nTo prove these results, we introduce two new notions that are of independent interest and general utility. The first one is materializability of a TBox T , which means that evaluating a query over an ABox A w.r.t. T can be reduced to query evaluation in a single model of A and T (a materialization). Note that such models play a crucial role in the context of Horn DLs, where they are often called canonical models or universal models. In contrast to the Horn DL case, however, we only require the existence of such a model without making any assumptions about its form or construction.\n4. If an ALCFI-TBox T is not materializable, then CQ-evaluation w.r.t. T is CONP-hard.\nWe also investigate the nature of materializations. It turns out that if a TBox is materializable for one of the considered query languages, then it is materializable also for all others. The concrete materializations, however, need not agree. To obtain these results, we characterize CQ-materializations in terms of homomorphisms and ELIQ-materializations in terms of simulations (an ELIQ is an ELI-instance query, thus the DL version of an acyclic CQ, with a single answer variable).\nPerhaps in contrary to the intuitions that arise from the experience with Horn DLs, materializability of a TBox T is not a sufficient condition for query evaluation w.r.t. T to be in PTIME (unless PTIME = NP) since the existing materialization might be hard to compute. This leads us to study the notion of unraveling tolerance of a TBox T , meaning that answers to acyclic CQs over an ABox A w.r.t. T are preserved under unraveling the ABox A. In CSP, unraveling tolerance corresponds to the existence of tree obstructions, a notion that characterizes the well-known arc consistency condition and rewritability into monadic Datalog [FV93, Kro10a]. It can be shown that every TBox formulated in Horn-ALCFI (the intersection of ALCFI and Horn-SHIQ) is unraveling tolerant and that there are unraveling tolerant TBoxes which are not equivalent to any Horn-ALCFI-TBox. Thus, the following result yields a rather general (and uniform!) PTIME upper bound for CQ-evaluation.\n5. If an ALCFI-TBox T is unraveling tolerant, then query evaluation w.r.t. T is in PTIME.\nAlthough the above result is rather general, unraveling tolerance of a TBox T is not a necessary condition for CQ-evaluation w.r.t. T to be in PTIME (unless PTIME = NP). However, for ALCFITBoxes T of depth one, being materializable and being unraveling tolerant turns out to be equivalent. For such TBoxes, we thus obtain that CQ-evalutation w.r.t. T is in PTIME iff T is materializable iff T is unraveling tolerant while, otherwise, CQ-evaluation w.r.t. T is CONP-hard. This establishes the first main result above.\nOur framework also allows to formally capture some intuitions and beliefs commonly held in the context of CQ-answering in DLs. For example, we show that for every ALCFI-TBox T , CQ-evaluation is in PTIME iff PEQ-evaluation is in PTIME iff ELIQ-evaluation is in PTIME, and the same is true for rewritability into monadic Datalog and for CONP-hardness. In fact, the use of multiple query languages and in particular of ELI-instance queries does not only yield additional results, but is at the heart of our proof strategies. Another interesting observation in this spirit is that an ALCFI-TBox is materializable iff it is convex, a condition that is also called the disjunction property and plays a central role in attaining PTIME complexity for standard reasoning in Horn DLs such as EL, DL-Lite, and Horn-SHIQ; see for example [BBL05, KL07] for more details.\nThis paper is an extended and revised version of the conference publication [LW12].\nRelated Work. An early reference on data complexity in DLs is [Sch93], showing CONP-hardness of ELQs in the fragment ALE of ALC (an ELQ is an ELIQ in which all edges are directed away from the answer variable). A CONP upper bound for ELIQs in the much more expressive DL SHIQ was obtained in [HMS07] and generalized to CQs in [GLHS08]. Horn-SHIQ was first defined in [HMS07], where also a PTIME upper bound for ELIQs is established; the generalization to CQs can be found in [EGOS08]. See also [KL07, Ros07, OCE08, CDL+13] and references therein for the data complexity in DLs and [BGO10, BMRT11] for related work on the guarded fragment and on existential rules.\nTo the best of our knowledge, the conference version of this paper was first to initiate the study of data complexity in ontology-mediated querying at the level of individual TBoxes and the first to observe a link between this area and CSP. There is, however, a certain technical similarity to the link between view-based query processing for regular path queries (RPQs) and CSP found in [CGLV00, CGLV03b, CGLV03a]. In this case, the recognition problem for perfect rewritings for RPQs can be polynomially reduced to non-uniform CSP and vice versa. On the level of OMQs, the data complexity of ontology-mediated querying with DLs has been studied in [BtCLW14]; also here, a connection to CSP plays a central role. In [LSW13, LSW15], the non-uniform data complexity of ontology-mediated query answering is studied in the case where the TBox is formulated in an inexpressive DL of the DL-Lite or EL family and where individual predicates in the data can be given a closed-world reading, which also gives rise to CONP-hardness of query evaluation; while [LSW13] is considering the level of TBoxes, [LSW15] treats the level of OMQs, establishing a connection to surjective CSPs.\nThe work on CSP dichotomies started with Schaefer’s PTIME/NP-dichotomy theorem, stating that every CSP defined by a two element template is in PTIME or NP-hard [Sch78]. Schaefer’s theorem was followed by dichotomy results for CSPs with (undirected) graph templates [HN90] and several other special cases, leading to the widely known Feder-Vardi conjecture which postulates a PTIME/NP-dichotomy for all CSPs, independently of the size of the template [FV93]. An influential approach to studying the complexity of CSPs is via universal algebra [BJK05], and it has resulted in a confirmation of the Feder Vardi conjecture for ternary CSPs [Bul02]. Interesting results have also\nbeen obtained for other complexity classes such as AC0 [ABI+05, LLT07]. For a recent summary of the state of the art we refer to [Bar14]."
    }, {
      "heading" : "2. PRELIMINARIES",
      "text" : "We introduce the relevant description logics and query languages, define the fundamental notions studied in this paper, and illustrate them with suitable examples.\nWe shall be concerned with the DL ALC and its extensions ALCI, ALCF , and ALCFI. Let NC, NR, and NI denote countably infinite sets of concept names, role names, and individual names, respectively. ALC concepts are constructed according to the rule\nC,D := ⊤ | ⊥ | A | C ⊓D | C ⊔D | ¬C | ∃r.C | ∀r.C\nwhere A ranges over NC and r ranges over NR. ALCI concepts admit, in addition, inverse roles from the set N−\nR = {r− | r ∈ NR}, which can be used in place of role names. Thus, A ⊓ ∃r−.∀s.B\nis an example of an ALCI concept. To avoid heavy notation, we set r− := s if r = s− for a role name s; in particular, we thus have (r−)− = r.\nIn DLs, ontologies are formalized as TBoxes. An ALC-TBox is a finite set of concept inclusions (CIs) C ⊑ D, where C,D are ALC concepts, and ALCI TBoxes are defined analogously. An ALCF-TBox (resp. ALCFI-TBox) is an ALC-TBox (resp. ALCI-TBox) that additionally admits functionality assertions func(r), where r ∈ NR (resp. r ∈ NR ∪ N − R\n), declaring that r is interpreted as a partial function. Note that there is no such thing as an ALCF concept or an ALCFI concept, as the extension with functional roles does not change the concept language.\nAn ABox A is a non-empty finite set of assertions of the form A(a) and r(a, b) with A ∈ NC, r ∈ NR, and a, b ∈ NI. In some cases, we drop the finiteness condition on ABoxes and then explicitly speak about infinite ABoxes. We use Ind(A) to denote the set of individual names used in the ABox A and sometimes write r−(a, b) ∈ A instead of r(b, a) ∈ A.\nThe semantics of DLs is given by interpretations I = (∆I , ·I), where ∆I is a non-empty set and ·I maps each concept name A ∈ NC to a subset AI of ∆I and each role name r ∈ NR to a binary relation rI on ∆I . The extension (r−)I of r− under the interpretation I is defined as the converse relation (rI)−1 of rI and the extension CI ⊆ ∆I of concepts under the interpretation I is defined inductively as follows:\n⊤I = ∆I\n⊥I = ∅\n(C ⊓D)I = CI ∩DI\n(C ⊔D)I = CI ∪DI\n(∃r.C)I = {d ∈ ∆I | ∃d′ ∈ ∆I : (d, d′) ∈ rI and d′ ∈ CI}\n(∀r.C)I = {d ∈ ∆I | ∀d′ ∈ ∆I : (d, d′) ∈ rI implies d′ ∈ CI}\nAn interpretation I satisfies a CI C ⊑ D if CI ⊆ DI , an assertion A(a) if a ∈ CI , an assertion r(a, b) if (a, b) ∈ rI , and a functionality assertion func(r) if rI is a partial function. Note that we make the standard name assumption, that is, individual names are not interpreted as domain elements (like first-order constants), but as themselves. This assumption is common both in DLs and in database theory. The results in this paper do not depend on it.\nAn interpretation I is a model of a TBox T if it satisfies all CIs in T and I is a model of an ABox A if it satisfies all assertions in A. We call an ABox A consistent w.r.t. a TBox T if A and T have a joint model.\nWe consider several query languages. A positive existential query (PEQ) q(~x) is a first-order formula with free variables ~x = x1, . . . , xn constructed from atoms A(x) and r(x, y) using conjunction, disjunction, and existential quantification where A ∈ NC, r ∈ NR, and x, y are individual variables. The variables in ~x are the answer variables of q(~x). A PEQ without answer variables is Boolean. An assignment π for q(~x) in an interpretation I is a mapping from the variables that occur in q(~x) to ∆I . A tuple ~a = a1, . . . , an in Ind(I) is an answer to q(~x) in I if there exists an assigment π for q(~x) in I such that I |=π q(~x) (in the standard first-order sense) and π(xi) = ai for 1 ≤ i ≤ n. In this case, we write I |= q(~a). A tuple ~a ∈ Ind(A), A an ABox, is a certain answer to q(~x) in A w.r.t. a TBox T , in symbols T ,A |= q(~a), if I |= q(~a) for all models I of T and A. Computing certain answers to a query in the sense just defined is that main querying problem that we are interested in. Although this paper focusses on the theoretical aspects of query answering, we given a concrete example that illustrates the usefulness of query answering with DL ontologies.\nExample 1. Let\nT = {Professer ⊑ Academic, Professor ⊑ ∃gives.Course}\nA = {Student(john), supervisedBy(john,mark), Professor(mark)}\nq(x, y) = ∃z Student(x) ∧ supervisedBy(x, y) ∧ Academic(y) ∧ gives(y, z) ∧ Course(z)\nThus the query asks to return all pairs that consist of a student x and an academic y such that x is supervised by y and y gives a course. Although this information is not directly present in the ABox, because of the TBox it is easy to see that (john,mark) is a certain answer.\nApart from PEQs, we also study several fragments thereof. A conjunctive query (CQ) is a PEQ without disjunction. We generally assume that a CQ q(~x) takes the form ∃~y ϕ(~x, ~y), where ϕ(~x, ~y) is a conjunction of atoms of the form A(x) and r(x, y). It is easy to see that every PEQ q(~x) is equivalent to a disjunction ∨ i∈I qi(~x), where each qi(~x) is a CQ (such a disjunction is often called a union of conjunctive queries, or UCQ). To introduce relevant fragments of CQs, we recall two further DLs that we use here for querying purposes. EL concepts are constructed from NC and NR according to the syntax rule\nC,D := ⊤ | A | C ⊓D | ∃r.C\nand ELI concepts additionally admit inverse roles. If C is an ELI concept and x a variable, then C(x) is called an ELI query (ELIQ); if C is an EL concept, then C(x) is called an EL query (ELQ). Note that every ELIQ can be regarded as an acyclic CQ with one answer variable, and indeed this is an equivalent definition of ELIQs; in the case of ELQs, it is additionally the case that all edges are directed away from the answer variable. For example, the ELIQ ∃r.(A ⊓ ∃s−.B)(x) is equivalent to the acyclic CQ\n∃y1∃y2(r(x, y1) ∧A(y1) ∧ s(y2, y1) ∧B(y2)).\nIn what follows, we will not distinguish between an ELIQ and its translation into an acyclic CQ with one answer variable and freely apply notions introduced for PEQs also to ELIQs and ELQs. We also sometimes slightly abuse notation and use PEQ to denote the set of all positive existential queries, and likewise for CQ, ELIQ, and ELQ.\nExample 2. (1) Let T∃,r = {A ⊑ ∃r.A} and q(x) = ∃r.A(x). Then we have for any ABox A, T∃,r,A |= q(a) iff A(a) ∈ A or there are r(a, b), A(b) ∈ A.\n(2) Let T∃,l = {∃r.A ⊑ A} and q(x) = A(x). For any ABox A, T∃,l,A |= q(a) iff there is an r-path in A from a to some b with A(b) ∈ A; that is, there are r(a0, a1), . . . , r(an−1, an) ∈ A, n ≥ 0, with a0 = a, an = b, and A(b) ∈ A.\n(3) Consider an undirected graph G represented as an ABox A with assertions r(a, b), r(b, a) ∈ A iff there is an edge between a and b. Let A1, . . . , Ak,M be concept names. Then G is k-colorable iff Tk,A 6|= ∃xM(x), where\nTk = {Ai ⊓Aj ⊑ M | 1 ≤ i < j ≤ k}∪\n{Ai ⊓ ∃r.Ai ⊑ M | 1 ≤ i ≤ k}∪ {⊤ ⊑ ⊔ 1≤i≤k Ai}.\nWe now introduce the main complexity notions investigated in this paper. An ontology-mediated query (OMQ) is a a pair (T , q(~x)) with T a TBox T and q(~x) a query. The query evaluation problem for (T , q(~x)) is to decide, given an ABox A and ~a in Ind(A), whether T ,A |= q(~a). Instead of actually computing certain answers, we concentrate on the query evaluation problem, which is the decision problem version of query answering. In this paper, we are typically interested in joint complexity bounds for all OMQs based on a given TBox and query language.\nDefinition 3. Let T be an ALCFI-TBox and let Q ∈ {CQ,PEQ,ELIQ,ELQ}. Then • Q-evaluation w.r.t. T is in PTIME if for every q(~x) ∈ Q, the query evaluation problem for (T , q(~x)) is in PTIME.\n• Q-evaluation w.r.t. T is CONP-hard if there exists q(~x) ∈ Q such that the query evaluation problem for (T , q(~x)) is coNP-hard.\nExample 4. (1) PEQ-evaluation w.r.t. the TBoxes T∃,r and T∃,l from Example 2 is in PTIME. This follows from the fact that these TBoxes are EL TBoxes (TBoxes using only EL concepts) and it is well known that PEQ-evaluation w.r.t. EL-TBoxes is in PTIME [KL07]. (2) Consider the TBoxes Tk from Example 2 that express k-colorability. For k ≥ 3, CQ-evaluation w.r.t. Tk is CONP-hard since k-colorability is NP-hard. However, in contrast to the tractability of 2-colorability, CQ-evaluation w.r.t. T2 is still CONP-hard. This follows from Theorem 18 below and, intuitively, is the case because T2 ‘entails a disjunction’: for A = {B(a)}, we have T2,A |= A1(a) ∨A2(a), but neither T2,A |= A1(a) nor T2,A |= A2(a).\nIn addition to the classification of TBoxes according to whether query evaluation is in PTIME or CONP-hard, we are also interested in whether OMQs based on the TBox are rewritable into more classical database querying languages, in particular into Datalog.\nA Datalog rule ρ has the form S(~x) ← R1(~y1) ∧ · · · ∧ Rn(~yn) where n > 0, S is a relation symbol, and R1, . . . , Rn are relation symbols, that is, concept names and role names. We refer to S(~x) as the head of ρ and R1(~y1) ∧ · · · ∧ Rn(~yn) as its body. Every variable in the head of ρ is required to occur also in its body. A Datalog program Π is a finite set of Datalog rules with a selected goal relation goal that does not occur in rule bodies. Relation symbols that occur in the head of at least one rule are called intensional relation symbols (IDBs), the remaining symbols are called extensional relation symbols (EDBs). Note that, by definition, goal is an IDB. The arity of the program is the arity of the goal relation. Programs of arity zero are called Boolean.\nFor an ABox A, a Datalog program Π, and~a from Ind(A) of the same length as the arity of goal, we write A |= Π(~a) if Π returns ~a as an answer on A, defined in the usual way [CGT89]. A Datalog program Π is a Datalog-rewriting of an OMQ (T , q(~x)) if for all ABoxes A and ~a from Ind(A), T ,A |= q(~a) iff A |= Π(~a). In this case the OMQ (T , q(~x)) is called Datalog-rewritable. When working with DLs such as ALCFI that include functional roles, it is more natural to admit the use of inequalities in the bodies of Datalog rules instead of working with ‘pure’ programs. We refer to such extended programs as Datalog6= programs and accordingly speak of Datalog6=-rewritability.\nExample 5. (1) The OMQ (T∃,l, A(x)) from Example 2 expressing a form of reachability is rewritable into the Datalog program\ngoal(x) ← P (x), P (x) ← A(x), P (x) ← r(x, y) ∧ P (y).\n(2) The OMQ (Tk,∃xM(x)) from Example 2 is Datalog-rewritable iff k ≤ 2 since non-2-colorability can be expressed by a Datalog program but for k ≥ 3, non-k-colorability cannot be expressed by a Datalog program (in fact, not even by a Datalog6= program) [ACY91]. (3) The OMQ ({func(r)},∃xM(x)) is rewritable into the Datalog6= program\ngoal() ← r(x, y1) ∧ r(x, y2) ∧ y1 6= y2\nbut is not rewritable into pure Datalog.\nDefinition 6. Let T be an ALCFI-TBox and let Q ∈ {CQ,PEQ,ELIQ,ELQ}. Then T is Datalog6=-rewritable for Q if (T , q(~x)) is Datalog6=-rewritable for every q(~x) ∈ Q.\nExample 7. It is folklore that every EL-TBox is Datalog-rewritable for ELQ, ELIQ, CQ, and for PEQ. Thus, this applies in particular to the TBoxes T∃,l and T∃,r from Example 2. A concrete construction of Datalog-rewritings for ELIQs can be found in the proof of Theorem 24 below. In contrast, the TBox Tk from Example 2 is not Datalog6=-rewritable for ELQ when k ≥ 3 since the OMQ (Tk,∃xM(x)) is not Datalog6=-rewritable, by Example 5 (2).\nIt is well-known that Datalog6=-programs can be evaluated in PTIME [CGT89], and thus Datalog6=rewritability for Q of a TBox T implies that Q-evaluation w.r.t. T is in PTIME. We shall see later that the converse direction does not hold.\nWe will often be concerned with homomorphisms between ABoxes and between interpretations, defined next. Let A and B be ABoxes. A function h : Ind(A) → Ind(B) is a homomorphism from A to B if it satisfies the following conditions:\n(1) A(a) ∈ A implies A(h(a)) ∈ B and (2) r(a, b) ∈ A implies r(h(a), h(b)) ∈ B.\nWe say that h preserves I ⊆ NI if h(a) = a for all a ∈ I . Homomorphisms from an interpretation I to an interpretation J are defined analogously as functions h : ∆I → ∆J . Note that these two notions are in fact identical since, up to presentation, ABoxes and finite interpretations are the same thing. In what follows we will not always distinguish between the two presentations."
    }, {
      "heading" : "3. MATERIALIZABILITY",
      "text" : "We introduce materializability as a central notion for analyzing the complexity and rewritability of TBoxes. A materialization of a TBox T and ABox A for a class of queries Q is a model of T and A that gives the same answers to queries in Q as T and A do. It is not difficult to see that a materialization for ELIQs is not necessarily a materialization for CQs and that a materialization for ELQs is not necessarily a materialization for ELIQs. We shall call a TBox T materializable for a query language Q if for every ABox A that is consistent w.r.t. T , there is at least one materialization of T and A for Q. Interestingly, we show that materializability of ALCFI-TBoxes does not depend on whether one considers ELIQs, CQs, or PEQs. This result allows us to simply talk about materializable TBoxes, independently of the query language considered. The fundamental\nresult linking materializability of a TBox to the complexity of query evaluation is that query evaluation is CONP-hard w.r.t. non-materializable ALCFI-TBoxes. As a first application, we show that PTIME query evaluation and Datalog6=-rewritability of ALCFI-TBoxes also do not depend on the query language, and the same is true for CONP-hardness of query evaluation. As a side line, we also consider the case of ALCF where, additionally, materializability for ELIQs coincides with materializability for ELQs.\nDefinition 8. Let T be an ALCFI-TBox and Q ∈ {CQ,PEQ,ELIQ,ELQ}. Then (1) a model I of T and an ABoxA is a Q-materialization of T and A if for all queries q(~x) ∈ Q\nand ~a ⊆ Ind(A), we have I |= q(~a) iff T ,A |= q(~a); (2) T is Q-materializable if for every ABox A that is consistent w.r.t. T , there exists a Q-\nmaterialization of T and A.\nIn Point (1) of Definition 8, it is important that the materialization I of T and A is a model of T and A. In fact, for every ABox A that is consistent w.r.t. T , we find an interpretation I such that for every CQ q(~x) and ~a ⊆ Ind(A), I |= q(~a) iff T ,A |= q(~a); take, for example, the direct product of all (up to isomorphisms) countable models of T and A. Note that I is, in general, not a model of T .\nNote that a Q-materialization can be viewed as a more abstract version of the canonical or minimal or universal model as often used in the context of ‘Horn DLs’ such as EL and DL-Lite [LTW09, KLT+10, BO15] and more expressive ontology languages based on tuple-generating dependencies (tgds) [CGK13] as well as in data exchange [FKMP05]. In fact, the ELQ-materialization in the next example is exactly the ‘compact canonical model’ from [LTW09].\nExample 9. (1) Let T∃,l = {∃r.A ⊑ A} be as in Example 2 and let A be an ABox. Let I be the interpretation obtained from A by adding to AI all a ∈ Ind(A) such that there exists an r-path from a to some b with A(b) ∈ A. Then I is a PEQ-materialization of T and A and so T is PEQ-materializable.\n(2) Let T∃,r = {A ⊑ ∃r.A} be as in Example 2 and let A be an ABox with at least one assertion of the form A(a). To obtain an ELQ-materialization I of T and A, start with A as an interpretation, add a fresh domain element dr to ∆I and to AI , and extend rI with (a, dr) and (dr, dr) for all A(a) ∈ A. Thus T∃,r is ELQ-materializable.\nTrivially, every PEQ-materialization is a CQ-materialization, every CQ-materialization is an ELIQmaterialization and every ELIQ-materialization is an ELQ-materialization. Conversely, it follows directly from the fact that each PEQ is equivalent to a disjunction of CQs that every CQ-materialization is also a PEQ-materialization. In contrast, the following example demonstrates that ELQ-materializations are different from ELIQ-materializations. A similar argument separates ELIQ-materializations from CQ-materializations.\nExample 10. Let T∃,r be as in Example 9,\nA = {B1(a), B2(b), A(a), A(b)} and\nq(x) = (B1 ⊓ ∃r.∃r −.B2)(x),\nThen the ELQ-materialization MA from Example 9 is not a Q-materialization for any Q from the set of query languages ELIQ,CQ,PEQ. For example, we have MA |= q(a), but T ,A 6|= q(a). An ELIQ/CQ/PEQ-materialization of T and A is obtained by unfolding MA (see below): instead of using only one additional individual dr as a witness for ∃r.A, we attach to both a and b an infinite r-path of elements that satisfy A. Note that every CQ/PEQ-materialization of T∃,r and A must be infinite.\nWe will sometimes restrict our attention to materializations I that are countable and generated, i.e, every d ∈ ∆I is reachable from some a ∈ ∆I ∩ NI in the undirected graph\nGI = (∆ I , {{d, d′} | (d, d′) ∈\n⋃\nr∈NR\nrI}).\nThe following lemma shows that we can make that assumption without loss of generality.\nLemma 11. Let T be an ALCFI-TBox, A an ABox, and Q ∈ {CQ,PEQ,ELIQ,ELQ}. If I is a Q-materialization of T and A, then there exists a subinterpretation J of I that is a countable and generated Q-materialization of T and A.\nProof. Let I be a Q-materialization of T and A. To construct J we apply a standard selective filtration procedure to I . More precisely, we identify a sequence Ind(A) = S0 ⊆ S1 ⊆ · · · ⊆ ∆I\nand then define J to be the restriction of I to ⋃\ni Si. Let C be the set of all concepts of the form ∃r.C that occur in T and of all concepts ∃r.¬C such that ∀r.C occurs in T . Assume Si has already been defined. Then define Si+1 as the union of Si and, for every d ∈ Si and concept ∃r.C ∈ C with d ∈ (∃r.C)I , an arbitrary d′ ∈ ∆I with (d, d′) ∈ rI and d′ ∈ CI (unless such a d′ exists already in Si). It is easy to see that J is a countable and generated Q-materialization of T and A. ❏\n3.1. Model-Theoretic Characterizations of Materializability. We characterize materializations using simulations and homomorphisms. This sheds light on the nature of materializations and establishes a close connection between materializations and initial models as studied in model theory, algebraic specification, and logic programming [Mal71, MG85, Mak87].\nA simulation from an interpretation I1 to an interpretation I2 is a relation S ⊆ ∆I1 × ∆I2\nsuch that\n(1) for all A ∈ NC: if d1 ∈ AI1 and (d1, d2) ∈ S, then d2 ∈ AI2 ; (2) for all r ∈ NR: if (d1, d2) ∈ S and (d1, d′1) ∈ r I1 , then there exists d′2 ∈ ∆ I2 such that\n(d′1, d ′ 2) ∈ S and (d2, d ′ 2) ∈ r I2; (3) for all a ∈ ∆I1 ∩ NI: a ∈ ∆I2 and (a, a) ∈ S.\nNote that, by Condition (3), domain elements that are individual names need to be respected by simulations while other domain elements need not. In database parlance, the latter are thus treated as labeled nulls, that is, while their existence is important, their identity is not.\nWe call a simulation S an i-simulation if Condition (2) is satisfied also for inverse roles. Note that S is a homomorphism preserving ∆I1 ∩ NI if S is a function with domain ∆I . We remind the reader of the following characterizations of ELQs using simulations, ELIQs using i-simulations, and CQs using homomorphisms (see e.g. [LW10]). An interpretation I has finite outdegree if the undirected graph GI has finite outdegree.\nLemma 12. Let I and J be interpretations such that ∆I ∩ NI is finite, I is countable and generated, and J has finite outdegree. Then the following conditions are equivalent (where none of the assumed conditions on I and J is required for (2) ⇒ (1)).\n(1) For all ELIQs C(x) and a ∈ ∆I ∩ NI: if I |= C(a), then J |= C(a); (2) There is an i-simulation from I and J .\nThe same equivalence holds when ELIQs and i-simulations are replaced by ELQs and simulations, respectively. Moreover, the following conditions are equivalent (where none of the assumed conditions on I and J is required for (3) ⇒ (1)).\n(3) For all PEQs q(~x) and ~a ⊆ ∆I ∩ NI: if I |= q(~a), then J |= q(~a);\n(4) For all CQs q(~x) and ~a ⊆ ∆I ∩ NI: if I |= q(~a), then J |= q(~a); (5) There is a homomorphism from I to J preserving ∆I ∩ NI.\nProof. We prove the equivalence of (3)-(5). The equivalence of (1) and (2) is similar (both for ELIQs and ELQs) but simpler and left to the reader. The implication (3) ⇒ (4) is trivial. For the proof of (4) ⇒ (5), assume that I is countable and generated and let J have finite outdegree. We first assume that only a finite set Σ of concept and role names have a non-empty interpretation in I and then generalize the result to arbitrary I . Assume that (4) holds. First observe that for every finite subset X of ∆I there is a homomorphism hX preserving X ∩ NI from the subinterpretation I↾X of I induced by X into J : associate with every d ∈ X an individual variable xd and regard I↾X as the CQ qX(~x) = ∃~yϕ(~x, ~y) defined by setting\nϕ(~x, ~y) = ∃~y ∧\nd∈X∩AI\nA(xd) ∧ ∧\n(d,d′)∈(X×X)∩rI\nr(xd, xd′),\nwhere ~x comprises the individual variables in {xa | a ∈ X ∩ NI} and ~y comprises the individual variables xd with d ∈ X \\NI (qX is a CQ by our assumption that only finitely many concept and role names have non-empty interpretation). For the assignment π(xd) = d, we have I |=π ϕ(~x, ~y). Thus I |=π qX(~x) and so, by (2), J |=π qX(~x). Consequently, there exists an assignment π′ for qX(~x) in J which coincides with π on {xa | a ∈ X ∩ NI} such that J |=π′ ϕ(~x, ~y). Let hX(d) = π′(d) for d ∈ X. Then hX is a homomorphism from I↾X to J preserving X ∩ NI, as required.\nWe now lift the homomorphisms hX to a homomorphism h from I to J preserving ∆I ∩ NI. Since I is countable and generated, there exists a sequence X0 ⊆ X1 ⊆ · · · of finite subsets of ∆I\nsuch that X0 = ∆I ∩ NI, ⋃ i≥0 Xi = ∆ I , and for all d ∈ Xi there exists a path in Xi from some a ∈ X0 to d. By the observation above, we find homomorphisms hXi from I↾Xi to J preserving Xi∩NI, for i ≥ 0. Let d0, d1 . . . be an enumeration of ∆I . We define the required homomorphism h as the limit of a sequence h0 ⊆ h1 ⊆ · · · , where each hn has domain {d0, . . . , dn} and where we ensure for each hn and all d ∈ {d0, . . . , dn} that there are infinitely many j with hn(d) = h↾Xj(d). Observe that since J has finite outdegree and since for all d ∈ Xi, there exists a path in Xi from some a ∈ X0 to d, for each d ∈ ∆I there exist only finitely many distinct values in {h↾Xi(d) | i ≥ 0}. By the pigeonhole principle, there thus exist infinitely many j with the same value hXj (d). For h0(d0) we take such a value for d0. Assume hn has been defined and assume that the set I = {j | hn(d) = h↾Xj (d) for all d ∈ {d0, . . . , dn}} is infinite. Again by the pigeonhole principle, we find a value e ∈ ∆J such that hXj (dn+1) = e for infinitely many j ∈ I . We set hn+1(dn+1) = e. The function h = ⋃ i≥0 h0 is a homomorphism from I to J preserving ∆\nI ∩ NI, as required. To lift this result to arbitrary interpretations I , it is sufficient to prove that the homomorphisms hX still exist. This can be shown using again the pigeonhole principle. Let X ⊆ ∆I be finite. We may assume that for each d ∈ X, there exists a path in X from some a ∈ X ∩ NI, to d. We have shown that for each finite set Σ of concept and role names, there exists a homomorphism hΣX from the Σ-reduct IΣX of IX to J (I Σ X interprets only the symbols in Σ as non-empty). Since J has finite outdegree, infinitely many hΣX coincide. A straightforward modification of the pigeonhole argument above can now be used to construct the required homomorphism hX .\nFor the proof of (5) ⇒ (3), assume I |= q(~a) and let h be a homomorphism from I to J preserving ∆I ∩NI. Let π be an assignment for q(~x) in I witnessing I |= q(~a). Then the composition h ◦ π is an assignment for q(~x) in J witnessing J |= q(~a). ❏\nFor the next steps, we need some observations regarding the unfolding of interpretations into forestshaped interpretations. Let us first make precise what we mean by unfolding. The i-unfolding of an interpretation I is an interpretation J defined as follows. The domain ∆J of J consists of all words d0r1 . . . rndn with n ≥ 0, each di from ∆I and each ri a (possibly inverse) role such that\n(a) di ∈ NI iff i = 0; (b) (di, di+1) ∈ rIi+1 for 0 ≤ i < n; (c) if r−i = ri+1, then di−1 6= di+1 for 0 < i < n.\nFor d0 · · · dn ∈ ∆J , we set tail(d0 · · · dn) = dn. Now set\nAJ = {w ∈ ∆J | tail(w) ∈ AI} for all A ∈ NC rJ = (rI ∩ (NI × NI))∪\n{(σ, σrd) | σ, σrd ∈ ∆J } ∪ {(σr−d, σ) | σ, σr−d ∈ ∆J } for all r ∈ NR.\nWe say that an interpretation I is i-unfolded if it is isomorphic to its own i-unfolding. Clearly, every i-unfolding of an interpretation is i-unfolded.\nFor ALCF-TBoxes, it is not required to unfold along inverse roles. This is reflected in the unfolding of an interpretation I , where in contrast to the i-unfolding we use as the domain the set of all words d0r1 . . . rndn with n ≥ 0, each di from ∆I , and each ri a role name such that Conditions (a) and (b) above are satisfied. The interpretation of concept and role names remains the same. We call an interpretation I unfolded if it is isomorphic to its own unfolding. The following lemma summarizes the main properties of unfoldings. Its proof is straightforward and left to the reader.\nLemma 13. Let I be an interpretation, I i its i-unfolding, and Iu its unfolding. Then for every interpretation J , the following conditions are satisfied:\n(1) the function f(w) := tail(w), w ∈ ∆I i , is a homomorphism from I i to I preserving\n∆I ∩ NI; (2) the function f(w) := tail(w), w ∈ ∆I u\n, is a homomorphism from Iu to I preserving ∆I ∩ NI; (3) if there is an i-simulation from I to J , then there is a homomorphism from I i to J preserving ∆I ∩ NI; (4) if there is a simulation from I to J , then there is a homomorphism from Iu to J preserving ∆I ∩ NI; (5) if I is a model of T and A with T an ALCFI-TBox, then I i is a model of T and A; (6) if I is a model of T and A with T an ALCF-TBox, then Iu is a model of T and A.\nAn interpretation I is called hom-initial in a class K of interpretations if for every J ∈ K, there exists a homomorphism from I to J preserving ∆I ∩ NI. I is called sim-initial (i-sim-initial) in a class K of interpretations if for every J ∈ K, there exists a simulation (i-simulation) from I to J . The following theorem provides the announced characterization of materializations in terms of simulations and homomorphisms. In the following, the class of all models of T and A is denoted by Mod(T ,A).\nTheorem 14. Let T be an ALCFI-TBox, A an ABox, and let I ∈ Mod(T ,A) be countable and generated. Then I is\n(1) an ELIQ-materialization of T and A iff it is i-sim-initial in Mod(T ,A); (2) a CQ-materialization of T and A iff it is a PEQ-materialization of T and A iff it is hom-\ninitial in Mod(T ,A);\n(3) an ELQ-materialization of T and A iff it is sim-initial in Mod(T ,A), provided that T is an ALCF-TBox.\nThe ‘only if’ directions of all three points hold without any of the assumed conditions on I .\nProof. We show that (1) follows from Lemma 12 and Lemma 13; (2) and (3) can be proved similarly. We start with the direction from right to left. Assume that I is i-sim-initial in Mod(T ,A). Since I is a model of T and A, we have I |= C(a) whenever T ,A |= C(a) for any ELIQ C(x) and a ∈ Ind(A). Conversely, if T ,A 6|= C(a) then there exists a model J of T and A such that J 6|= C(a). There is an i-simulation from I to J . Thus, by the implication (2) ⇒ (1) from Lemma 12, we have I 6|= C(a) as required.\nFor the direction from left to right, assume that I is a materialization of T and A and take a model J of T and A. We have to construct an i-simulation from I to J . It actually suffices to construct an i-simulation from I to the i-unfolding J i of J : by Point (3) of Lemma 13, there is a homomorphism from J i to J and the composition of an i-simulation with a homomorphism is again an i-simulation.\nTo obtain an i-simulation from I to J i, we first identify a subinterpretation J ′ of J i that has finite outdegree and is still a model of T and A. By the implication (1) ⇒ (2) from Lemma 12 and since I is a materialization, there must then be an i-simulation from I to J ′. Clearly this is also an i-simulation from I to J i and we are done.\nIt thus remains to construct J ′, which is done by applying selective filtration to J i in exactly the same way as in the proof of Lemma 11. It can be verified that the outdegree of the resulting subinterpretation J ′ of J i is bounded by |T | + |A| and, therefore, finite. By construction, J ′ ∈ Mod(T ,A). ❏\nThe following example shows that the generatedness condition in Theorem 14 cannot be dropped. We leave it open whether the same is true for countability.\nExample 15. Let T = {A ⊑ ∃r.A,B ⊑ A} and A = {B(a)} and consider the interpretation I defined by\n∆I = {a} ∪ {0, 1, 2 . . .} ∪ {. . . ,−2′,−1′, 0′, 1′, 2′, . . . }\nAI = ∆I\nBI = {a}\nrI = {(a, 0)} ∪ {(n, n+ 1) | n ∈ N} ∪ {(n′, n′ + 1) | n ∈ Z}.\nThen I is a PEQ-materialization of T and A, but it is not hom-initial (and in fact not even siminitial) since the restriction of I to domain {a} ∪ {0, 1, 2 . . .} is also a model of T and A, but there is no homomorphism (and no simulation) from I to this restriction preserving {a}.\nAs an application of Theorem 14, we now show that materializability coincides for the query languages PEQ, CQ, and ELIQ (and that for ALCF-TBoxes, all these also coincide with ELQmaterializability).\nTheorem 16. Let T be an ALCFI-TBox. Then the following conditions are equivalent: (1) T is PEQ-materializable; (2) T is CQ-materializable; (3) T is ELIQ-materializable; (4) Mod(T ,A) contains an i-sim-initial I , for every ABox A that is consistent w.r.t. T ; (5) Mod(T ,A) contains a hom-initial I , for every ABox A that is consistent w.r.t. T .\nIf T is an ALCF-TBox, then the above is the case iff T is ELQ-materializable iff Mod(T ,A) contains a sim-initial I , for every ABox A that is consistent w.r.t. T .\nProof. The implications (1) ⇒ (2) and (2) ⇒ (3) are trivial. For (3) ⇒ (4), let I be an ELIQmaterialization of T and an ABox A. By Lemma 11, we may assume that I is countable and generated. By Lemma 14, Mod(T ,A) contains an i-sim-initial interpretation. For (4) ⇒ (5), assume that I ∈ Mod(T ,A) is i-sim-initial. By Points (3) and (5) of Lemma 13, the i-unfolding of I is hom-initial in Mod(T ,A) and (5) follows. (5) ⇒ (1) follows from Theorem 14. The implications for ALCF-TBoxes are proved similarly. ❏\nBecause of Theorem 16, we sometimes speak of materializability without reference to a query language and of materializations instead of PEQ-materializations.\n3.2. Materializability and CONP-hardness. We show that non-materializability implies CONPhardness of query evaluation. To this end, we first establish that materializability is equivalent to the disjunction property, which is sometimes also called convexity and plays a central role in attaining PTIME complexity for subsumption in DLs [BBL05], and for attaining PTIME data complexity for query answering with DL TBoxes [KL07].\nA TBox T has the ABox disjunction property for ELIQ (resp. ELQ) if for all ABoxes A, individuals a0, . . . , ak ∈ Ind(A), and ELIQs (resp. ELQs) C0(x), . . . , Cn(x), T ,A |= C0(a0) ∨ · · · ∨ Ck(ak) implies T ,A |= Ci(ai) for some i ≤ k.\nTheorem 17. An ALCFI- (ALCF-) TBox T is materializable iff it has the ABox disjunction property for ELIQs (ELQs).\nProof. For the nontrivial “if” direction, let A be an ABox that is consistent w.r.t. T and such that there is no ELIQ-materialization of T and A. Then T ∪ A ∪ Γ is not satisfiable, where\nΓ = {¬C(a) | T ,A 6|= C(a), a ∈ Ind(A), C(x) ELIQ}.\nIn fact, any satisfying interpretation would be an ELIQ-materialization. By compactness, there is a finite subset Γ′ of Γ such that T ∪ A ∪ Γ′ is not satisfiable, i.e. T ,A |= ∨ ¬C(a)∈Γ′ C(a). Since Γ′ ⊆ Γ, we have T ,A 6|= C(a) for all ¬C(a) ∈ Γ′. Thus, T lacks the ABox disjunction property. ❏\nBased on Theorems 16 and 17, we now establish that materializability is a necessary condition for query-evaluation to be it PTIME.\nTheorem 18. If an ALCFI-TBox T (ALCF-TBox T ) is not materializable, then ELIQ-evaluation (ELQ-evaluation) w.r.t. T is CONP-hard.\nProof. The proof is by reduction of 2+2-SAT, a variant of propositional satisfiability that was first introduced by Schaerf as a tool for establishing lower bounds for the data complexity of query answering in a DL context [Sch93]. A 2+2 clause is of the form (p1 ∨ p2 ∨ ¬n1 ∨ ¬n2), where each of p1, p2, n1, n2 is a propositional letter or a truth constant 0, 1. A 2+2 formula is a finite conjunction of 2+2 clauses. Now, 2+2-SAT is the problem of deciding whether a given 2+2 formula is satisfiable. It is shown in [Sch93] that 2+2-SAT is NP-complete.\nWe first show that if an ALCFI-TBox T is not materializable, then UELIQ-evaluation w.r.t. T is CONP-hard, where a UELIQ is a disjunction C0(x) ∨ · · · ∨ Ck(x), with each Ci(x) an ELIQ. We then sketch the modifications necessary to lift the result to ELIQ-evaluation w.r.t. T .\nSince T is not materializable, by Theorem 16 it does not have the disjunction property. Thus, there is an ABox A∨, individual names a1, . . . , ak ∈ Ind(A), and ELIQs C0(x), . . . , Ck(x) such\nthat T ,A∨ |= C0(a0) ∨ · · · ∨ Ck(ak), but T ,A∨ 6|= Ci(ai) for all i ≤ k. Assume w.l.o.g. that this sequence is minimal, i.e., T ,A∨ 6|= C0(a0)∨ · · · ∨Ci−1(ai−1)∨Ci+1(ai+1)∨ · · · ∨Ck(ak) for all i ≤ k. This clearly implies that for all i ≤ k,\n(∗) there is a model Ii of T and A∨ with I |= Ci(ai) and I 6|= Cj(aj) for all j 6= i. We will use A∨, the individuals a1, . . . , ak, and the ELIQs C0(x), . . . , Ck(x) to generate truth values for variables in the input 2+2 formula.\nLet ϕ = c0 ∧ · · · ∧ cn be a 2+2 formula in propositional letters z0, . . . , zm, and let ci = pi,1 ∨ pi,2 ∨ ¬ni,1 ∨ ¬ni,2 for all i ≤ n. Our aim is to define an ABox Aϕ with a distinguished individual name f and a UELIQ q(x) such that ϕ is unsatisfiable iff T ,Aϕ |= q(f). To start, we represent the formula ϕ in the ABox Aϕ as follows:\n• the individual name f represents the formula ϕ; • the individual names c0, . . . , cn represent the clauses of ϕ; • the assertions c(f, c0), . . . , c(f, cn), associate f with its clauses, where c is a role name that\ndoes not occur in T ; • the individual names z0, . . . , zm represent variables, and the individual names 0, 1 represent\ntruth constants; • the assertions ⋃\ni≤n\n{p1(ci, pi,1), p2(ci, pi,2), n1(ci, ni,1), n2(ci, ni,2)}\nassociate each clause with the variables/truth constants that occur in it, where p1, p2, n1, n2 are role names that do not occur in T .\nWe further extend Aϕ to enforce a truth value for each of the variables zi. To this end, add to Aϕ copies A0, . . . ,Am of A∨ obtained by renaming individual names such that Ind(Ai)∩ Ind(Aj) = ∅ whenever i 6= j. As a notational convention, let aij be the name used for the individual name aj ∈ Ind(A∨) in Ai for all i ≤ m and j ≤ k. Intuitively, the copy Ai of A is used to generate a truth value for the variable zi. To actually connect each individual name zi to the associated ABox Ai, we use role names r0, . . . , rk that do not occur in T . More specifically, we extend Aϕ as follows:\n• link variables zi to the ABoxes Ai by adding assertions rj(zi, aij) for all i ≤ m and j ≤ k; thus, truth of zi means that the concept ∃r0.C0 is true at zi and falsity means that one of the concepts ∃rj.Cj , j ≤ k, is true at zi; • to ensure that 0 and 1 have the expected truth values, add a copy of C0(x) viewed as an ABox with root 1′ and a copy of C2(x) viewed as an ABox with root 0′; add r0(1, 1′) and r1(0, 0\n′). Consider the query q0(x) = C(x) with\nC = ∃c.(∃p1.ff ⊓ ∃p2.ff ⊓ ∃n1.tt ⊓ ∃n2.tt)\nwhich describes the existence of a clause with only false literals and thus captures falsity of ϕ, where tt is an abbreviation for ∃r0.C0 and ff an abbreviation for the ELU -concept ∃r1.C1 ⊔ · · · ⊔ ∃rk.Ck. It is straightforward to show that ϕ is unsatisfiable iff T ,A |= q0(f). To obtain the desired UELIQ q(x), it remains to take q0(x) and distribute disjunction to the outside.\nWe now show how to improve the result from UELIQ-evaluation to ELIQ-evaluation. Our aim is to change the encoding of falsity of a variable zi from satisfaction of ∃r1.C1 ⊔ · · · ⊔ ∃rk.Ck at zi to satisfaction of ∃h.(∃r1.C1 ⊓ · · · ⊓ ∃rk.Ck), at zi, where h is an additional role that does not\noccur in T . We can then replace the concept ff in the query q0 with ∃h.(∃r1.C1 ⊓ · · · ⊓ ∃rk.Ck), which gives the desired ELIQ q(x).\nIt remains to modify Aϕ to support the new encoding of falsity. The basic idea is that each zi has k successors bi1, . . . , b i k reachable via h such that for 1 ≤ j ≤ k,\n• ∃rℓ.Cℓ is satisfied at bij for all ℓ = 1, . . . , j − 1, j + 1, . . . , k and • the assertion rj(bij , a i j) is in Aϕ.\nThus, ∃r1.C1 ⊓ · · · ⊓ ∃rk.Ck is satisfied at bij iff Cj is satisfied at a i j , for all j with 1 ≤ j ≤ k. In detail, the modification of Aϕ is as follows:\n• for 1 ≤ j ≤ k, add to Aϕ a copy of Cj viewed as an ABox, where the root individual name is dj ; • for all i ≤ m, replace the assertions rj(zi, aij), 1 ≤ j ≤ k, with the following: – h(zi, bi1), . . . , h(zi, b i k) for all i ≤ m;\n– rj(bij , a i j), r1(b i j , d1), . . . , rj−1(b i j , dj−1),\nrj+1(b i j , dj+1), . . . , rk(b i j , dk) for all i ≤ m and 1 ≤ j ≤ k.\nThis finishes the modified construction. Again, it is not hard to prove correctness.\nIt remains to note that, when T is an ALCF-TBox, then the above construction of q yields an ELQ instead of an ELIQ. ❏\nThe converse of Theorem 18 fails, i.e., there are TBoxes that are materializable, but for which ELIQevaluation is CONP-hard. In fact, materializations of such a TBox T and ABox A are guaranteed to exist, but cannot always be computed in PTIME (unless PTIME = CONP). Technically, this follows from Theorem 28 later on which states that for every non-uniform CSP, there is a materializable ALC-TBox for which Boolean CQ-answering has the same complexity, up to complementation of the complexity class.\n3.3. Complexity of TBoxes for Different Query Languages. We make use of our results on materializability to show that PTIME query evaluation w.r.t. ALCFI-TBoxes does not depend on whether we consider PEQs, CQs, or ELIQs, and the same is true for Datalog6=-rewritability. For ALCF-TBoxes, we can add ELQs to the list. Theorem 19 below gives a uniform explanation for the fact that, in the traditional approach to data complexity in OBDA, the complexity of evaluating PEQs, CQs, and ELIQs has turned out to be identical for almost all DLs. It allows us to (sometimes) speak of the ‘complexity of query evaluation’ without reference to a concrete query language.\nTheorem 19. For all ALCFI-TBoxes T , (1) PEQ-evaluation w.r.t. T is in PTIME iff CQ-evaluation w.r.t. T is in PTIME iff ELIQ-\nevaluation w.r.t. T is in PTIME; (2) T is Datalog6=-rewritable for PEQ iff it is Datalog6=-rewritable for CQ iff it is Datalog6=-\nrewritable for ELIQ (unless PTIME = CONP); (3) PEQ-evaluation w.r.t. T is CONP-hard iff CQ-evaluation w.r.t. T is CONP-hard iff ELIQ-\nevaluation w.r.t. T is CONP-hard. If T is an ALCF-TBox, then ELIQ can be replaced by ELQ in (1), (2), and (3). If T is an ALCI TBox, then Datalog6=-rewritability can be replaced by Datalog-rewritability in (2).\nProof. We start with Points (1) and (2), for which the “only if” directions are trivial. For the converse directions, we may assume by Theorem 18 that the TBox T is materializable. The implications from CQ to PEQ in Points (1) and (2) follow immediately from this assumption: one can first transform a given PEQ q(~x) into an equivalent disjunction of CQs ∨ i∈I qi(~x). CQ-materializability of T implies that, for any ABox A and ~a in Ind(A), T ,A |= q(~a) iff there exists i ∈ I such that T ,A |= qi(~a). Thus if CQ-evaluation w.r.t. T is in PTIME, evaluation of (T , q(~x)) is in PTIME. The same holds for Datalog6=-rewritability because the class of Datalog6=-queries is closed under finite union.\nWe now consider the implications from ELIQ to CQ (and from ELQ to CQ if T is a ALCFTBox) in Points (1) and (2), first concentrating on the PTIME case. The following claim is the main step of the proof. It states that for any CQ q(~x), we can reduce the evaluation of q(~x) w.r.t. T on an ABox A to evaluating quantifier-free CQs and ELIQs C(x) w.r.t. T (ELQs if T is an ALCF-TBox), both on A.\nClaim 1. For any materializable TBox T and CQ q(~x) with ~x = x1 · · · xn, one can construct a finite set Q of pairs (ϕ(~x, ~y), C), where\n• ϕ(~x, ~y) is a (possibly empty) conjunction of atoms of the form x = y or r(x, y), where r is a role name in q(~x) and\n• C is a finite set of ELIQs such that the following conditions are equivalent for any ABox A and ~a = a1 · · · an from Ind(A):\n(i) T ,A |= q(~a); (ii) there exists (ϕ(~x, ~y), C) ∈ Q and an assignment π in Ind(A) with π(xi) = ai for 1 ≤ i ≤ n,\nA |=π ϕ(~x, ~y), and T ,A |= C(π(x)) for all C(x) ∈ C.\nIf T is an ALCF-TBox, then one can choose ELQs instead of ELIQs in each C in Q.\nBefore we prove Claim 1, we show how the desired results follow from it. Let a CQ q(~x) be given and let Q be the set of pairs from Claim 1.\n• Assume that ELIQ-evaluation w.r.t. T is in PTIME. Then T ,A |= q(~a) can be decided in polynomial time since there are only polynomially many assignments π and for any such π, A |=π ϕ(~x, ~y) can be checked in polynomial time (using a naive algorithm) and T ,A |= C(π(x)) can be checked in polynomial time for each ELIQ C(x) ∈ C. • Assume that T is Datalog6=-rewritable for ELIQ. Let p = (ϕ(~x, ~y), C) ∈ Q. For each C(x) ∈ C, choose a Datalog6=-rewriting ΠC(x) of (T , C(x)), assume w.l.o.g that none of the chosen programs share any IDB relations, and that the goal relation of ΠC(x) is goalC . Let Πp be the Datalog6= program that consists of the rules of all the chosen programs, plus the following rule:\ngoal(~x) ← ϕ(~x, ~y) ∧ ∧\nC(x)∈C\ngoalC(x).\nThe desired Datalog6=-rewriting of (T , q(~x)) is obtained by taking the union of all the constructed Datalog6= queries, which can again be expressed in Datalog6=.\nThe implications from ELQs to CQs for ALCF-TBoxes in Points (1) and (2) follow in the same way since, then, each C in Q consists of ELQs only.\nFor the proof of Claim 1, we first require a technical observation that allows us to deal with subqueries that are not connected to an answer variable in the CQ q(~x). To illustrate, consider the query q0 = ∃xB(x). To prove Claim 1 for q0, we have to find a set Q of pairs (ϕ(~y), C) satisfying Conditions (i) and (ii). Clearly, in this case the components ϕ(~y) will be empty and so we have\nto construct a finite set C of ELIQs such that for any ABox A, T ,A |= ∃xB(x) iff there exists an ELIQ C(x) ∈ C and an assignment π in Ind(A) such that T ,A |= C(π(x)). An infinite set C with this property is given by the set of all ELIQs ∃~r.B(x), where ~r is a sequence r1 · · · rn of roles ri in T and ∃~r.B stands for ∃r1 · · · ∃rn.B—this follows immediately from the assumption that T is materializable and that, by Lemma 11, for any ABox A that is consistent w.r.t. T , there exists a generated CQ-initial model of T and ABox A. The following result states that it is sufficient to include in C the set of all ∃~r.B(x) with ~r of length bounded by n0 := 2(2(|T |+|C|) · 2|T |+ 1.\nClaim 2. Let C be an ELI-concept and assume that T ,A |= ∃xC(x). If T is materializable, then there exists a sequence of roles ~r = r1 · · · rn with ri in T and of length n ≤ n0 and an a ∈ Ind(A) such that T ,A |= ∃~r.C(a). If C is an EL-concept and T an ALCF-TBox, then the sequence ~r consists of role names in T .\nProof of Claim 2. Let I be a CQ-materialization of T and A. By Points (3) and (5) of Lemma 13, we may assume that I is i-unfolded. From T ,A |= ∃xC(x), we obtain CI 6= ∅. Let n be minimal such that there are a ∈ Ind(A) and d ∈ CI with n = distI(d, a) where distI(d, a) denotes the length of the shortest path from d to a in the undirected graph GI . If n ≤ n0, we are done. Otherwise fix an a ∈ Ind(A) and denote by M the set all e ∈ CI with n = distI(e, a). Let d0, . . . , dn with a = d0, dn = d, and (di, di+1) ∈ rIi+1 for i < n be the shortest path from a to d. Observe that T ,A |= ∃~r.C(a) for ~r = r0 · · · rn−1 since I is a materialization of T and A. We now employ a pumping argument to show that this leads to a contradiction. Let cl(T , C) denote the closure under single negation of the set of subconcepts of concepts in T and C . Set\ntIT ,C(e) = {D ∈ cl(T , C) | e ∈ D I}.\nAs n > n0, then there exist di and di+j with j > 1 and i+ j < n such that\ntIT ,C(di) = t I T ,C(di+j), t I T ,C(di+1) = t I T ,C(di+j+1), ri+1 = ri+j+1\nNow replace in I the interpretation induced by the subtree rooted at di+j+1 by the interpretation induced by the subtree rooted at di+1. We do the same construction for all elements of M and denote the resulting interpretation by J . One can easily show by induction that J is still a model of T and A, but now J 6|= ∃~r.C(a) and so T ,A 6|= ∃~r.C(a). This contradiction finishes the proof of Claim 2. For EL-concepts and ALCF-TBoxes, Claim 2 can be proved similarly by using an unfolded (rather than i-unfolded) materialization, which exists by Points (4) and (6) of Lemma 13.\nProof of Claim 1. Assume that T and q(~x) = ∃~xψ(~x, ~y) are given. We have to construct a set Q such that Conditions (i) and (ii) are satisfied. Let A be an ABox with T ,A |= q(~a), I a materialization of T and A that is i-unfolded, and π an assignment in I such that I |=π ψ(~x, ~y). We define a corresponding pair p = (ϕ(~x, ~z), C) to be included in Q (and these are the only pairs in Q).\nFor identifying ϕ(~x, ~z), set x ∼ y if π(x) = π(y) and denote by [x] the equivalence class of x w.r.t. “∼”. Let ϕ0 be the set of all atoms r([x], [y]) such that π(x), π(y) ∈ Ind(A) and there are x′ ∈ [x] and y′ ∈ [y] with r(x′, y′) in ψ. We obtain ϕ(~x, ~y) by selecting an answer variable y ∈ [x] for every [x] that contains such a variable and then replacing [x] by y in ϕ0, adding xi = xj to ϕ(~x, ~z) for any two (selected) answer variables xi, xj with xi ∼ xj , and by regarding the remaining equivalences classes [y] that do not contain answer variables as variables in ~z.\nWe now identify C. Assume w.l.o.g. that I uses the naming scheme of i-unravelings. Let a ∈ Ind(A). By Ia, we denote the subinterpretation of I induced by the set of all elements ar1d1 · · · rndn ∈ ∆\nI . Let M be a maximal connected component of ∆Ia ∩ {π(y) | y ∈ var(ψ)}. We associate with M an ELIQ to be included in C (and these are the only ELIQs in C).\nThe conjunctive query ϕM consists of all atoms r([x], [y]) such that π(x), π(y) ∈ M and there are x′ ∈ [x], y′ ∈ [y] with r(x′, y′) in ψ and all atoms A([x]) such that π(x) ∈ M and there is x′ ∈ [x] with A(x′) in ψ. We again assume that equivalence classes [x] that contain an answer variable (there is at most one such class in ϕM ) are replaced with an answer variable from [x] and regard the remaining equivalences classes as variables. Note that ϕM is tree-shaped since Ia is. We can thus pick a variable x0 with π(x0) ∈ M such that distI(a, π(x0)) is minimal. Let x be [x0] if [x0] contains no answer variable and, otherise, let x be the answer variable that [x0] has been replaced with. Let [y1], . . . , [ym] be the variables in ϕM that are distinct from x and consider the ELIQ ∃[y1] · · · ∃[ym]ϕM (x, [y1], . . . , [ym]), which we write as CM (x) where CM is an appropriate ELI-concept. We now distinguish the following cases:\n• π(x) = a. In this case, we include CM (x) in C; • otherwise, we still know that T ,A |= ∃xC(x). Thus, by Claim 2 there is a sequence\nof roles ~r = r1 · · · rn with ri in T and n ≤ n0 such that T ,A |= ∃~r.CM (a) for some a ∈ Ind(A) . In this case, we include ∃~r.CM (y) in C for some fresh individual variable y.\nThis finishes the construction of C and thus of Q. Clearly, Q is finite. The stated properties of Q follow directly from its construction. For ALCF-TBoxes and ELQs, Claim 1 can be proved similarly using an unfolded materialization (instead of an i-unfolded one) and the observation that in this case all CM ([x]) and ∃~r.CM (y) are ELQs (~r uses role names only by Claim 2).\nWe now turn our attention to Point (3). Here, the “if” directions are trivial and we prove the “only if” part. It suffices to show that if PEQ-evaluation w.r.t. a TBox T is CONP-hard, then so is ELIQ-evaluation. We start with showing the slightly simpler result that CONP-hardness of CQevaluation w.r.t. T implies CONP-hardness of UELIQ-evaluation, and then sketch the modifications required to strengthen the proof to attain the original statement.\nThus assume that evaluating the CQ q(~x) w.r.t. T is CONP-hard. We shall exhibit an UELIQ q′(x) such that for every ABox A and all ~a ∈ Ind(A), one can produce in polynomial time an ABox A′ with a distinguished individual a0 such that T ,A |= q(~a) iff T ,A′ |= q′(a0). Instead of constructing q′(~x) right away, we will start with describing the translation of A to A′. Afterwards, it will be clear how to construct q′(~x).\nThus, let A be an ABox and ~a from Ind(A). The construction of A′ builds on Claim 1 above. Let Q be the set of pairs from that claim and reserve a fresh individual name a0. To obtain the desired ABox A′, we extend A for every pair p = (ϕ(~x, ~y), C) in Q. Let C = Cp,1(x1), . . . , Cp,kp(xkp). Then\n• introduce a fresh individual name ap and fresh role names rp, r, rp,1, . . . , rp,kp ; • add the assertion rp(a0, ap); • for every assignment π in Ind(A) with A |=π ϕ(~x, ~y) and π(~x) = ~a, introduce\n– a fresh individual name ap,π and the assertion r(ap, ap,π); – the assertion rp,i(ap, π(xi)) for 1 ≤ i ≤ kp.\nFrom Claim 1, it is immediate that T ,A |= q(~a) iff T ,A′ |= q′(x) where q′(x) is the UELIQ ⊔ p∈Q q′(x) with Cp = ∃rp.∃r. ⊓ 1≤i≤kp ∃rp,i.Cp,i. Thus, evaluating q′(x) w.r.t. T is CONP-hard, as required. It remains to modify the reduction by replacing CQs with PEQs and UELIQs with ELIQs. The former is straightforward: every PEQ is equivalent to a finite disjunction of CQs, and thus we can construct A′ and q′(x) in essentially the same way as before; instead of considering all pairs from Q for a single CQ, we now use the union of all sets Q for the finitely many CQs in question. Finally, we can replace UELIQs with ELIQs by using the same construction as in the proof of Theorem 18: after adding some straightforward auxiliary structure to A′, one can replace a\ndisjunction of ELIQs by (essentially) their conjunction, which is again an ELIQ. Details are left to the reader. ❏\nWe remark that Theorem 19 can be extended to also cover rewritability into first-order (FO) queries, and that the proof is almost identical to that for Datalog6=-rewritability."
    }, {
      "heading" : "4. UNRAVELING TOLERANCE",
      "text" : "We develop a condition on TBoxes, called unraveling tolerance, that is sufficient for the TBox to be Datalog6=-rewritable for PEQ, and thus also sufficient for PEQ-evaluation w.r.t. the TBox being in PTIME. Unraveling tolerance strictly generalizes syntactic ‘Horn conditions’ such as the ones used to define the DL Horn-SHIQ, which was designed as a (syntactically) maximal DL with PTIME query evaluation [HMS07, EGOS08].\nUnraveling tolerance is based on an unraveling operation on ABoxes, in the same spirit as the unfolding of an interpretation into a tree interpretation we discussed above. Formally, the unraveling Au of an ABox A is the following (possibly infinite) ABox:\n• Ind(Au) is the set of sequences b0r0b1 · · · rn−1bn, n ≥ 0, with b0, . . . , bn ∈ Ind(A) and r0, . . . , rn−1 ∈ NR∪N − R such that for all i < n, we have ri(bi, bi+1) ∈ A and (bi−1, r − i−1) 6=\n(bi+1, ri) when i > 0; • for each C(b) ∈ A and α = b0r0 · · · rn−1bn ∈ Ind(Au) with bn = b, C(α) ∈ Au; • for each α = b0r0 · · · rn−1bn ∈ Ind(Au) with n > 0, rn−1(b0r0 · · · rn−1bn−1, α) ∈ Au.\nFor all α = b0 · · · bn ∈ Ind(Au), we write tail(α) to denote bn. Note that the condition (bi−1, r − i−1) 6= (bi+1, ri) is needed to ensure that functional roles can still be interpreted in a functional way after unraveling.\nDefinition 20 (Unraveling Tolerance). A TBox T is unraveling tolerant if for all ABoxes A and ELIQs q, we have that T ,A |= q implies (T ,Au) |= q.\nIt is not hard to prove that the converse direction ‘T ,Au |= q implies T ,A |= q’ is true for all ALCFI-TBoxes. Note that it is pointless to define unraveling tolerance for queries that are not necessarily tree shaped, such as CQs.\nExample 21. (1) The ALC-TBox T1 = {A ⊑ ∀r.B} is unraveling tolerant. This can be proved by showing that (i) for any (finite or infinite) ABox A, the interpretation I+A that is obtained from A by extending BI +\nA with all a ∈ Ind(A) that satisfy ∃r−.A in A (when viewed as an interpretation) is an ELIQmaterialization of T1 and A; and (ii) I + A |= C(a) iff I + Au |= C(a) for all ELIQs C(x) and a ∈ Ind(A). The proof of (ii) is based on a straightforward induction on the structure of the ELIconcept C . As illustrated by the ABox A = {r(a, b), A(a)} and the fact that Au,T |= B(b), the use of inverse roles in the definition of Au is crucial here despite the fact that T1 does not use inverse roles.\n(2) A simple example for an ALC-TBox that is not unraveling tolerant is\nT2 = {A ⊓ ∃r.A ⊑ B,¬A ⊓ ∃r.¬A ⊑ B}.\nFor A = {r(a, a)}, it is easy to see that we have T2,A |= B(a) (use a case distinction on the truth value of A at a), but T2,Au 6|= B(a).\nBefore we show that unraveling tolerance indeed implies PTIME query evaluation, we first demonstrate the generality of this property by relating it to Horn-ALCFI , the ALCFI-fragment of HornSHIQ. Different versions of Horn-SHIQ have been proposed in the literature, giving rise to different versions of Horn-ALCFI [HMS07, KRH07, EGOS08, Kaz09]. As the original definition from [HMS07] based on polarity is rather technical, we prefer to work with the following equivalent and less cumbersome definition. A Horn-ALCFI-TBox T is a finite set of concept inclusions L ⊑ R and functionality assertions where L and R are built according to the following syntax rules:\nR,R′ ::=⊤ | ⊥ | A | ¬A | R ⊓R′ | L → R | ∃r.R | ∀r.R\nL,L′ ::=⊤ | ⊥ | A | L ⊓ L′ | L ⊔ L′ | ∃r.L\nwith r ranging over NR ∪ N − R\nand L → R abbreviating ¬L ⊔ R. Whenever convenient, we may assume w.l.o.g. that T contains only a single concept inclusion ⊤ ⊑ CT where CT is built according to the topmost rule above.\nBy applying some simple transformations, it is not hard to show that every Horn-ALCFITBox according to the original polarity-based definition is equivalent to a Horn-ALCFI-TBox of the form introduced here. Although not important in our context, we note that even a polynomial time transformation is possible.\nTheorem 22. Every Horn-ALCFI-TBox is unraveling tolerant.\nProof. As a preliminary, we give a characterization of the entailment of ELIQs in the presence of Horn-ALCFI-TBoxes which is in the spirit of the chase procedure as used in database theory [FKMP05, CGK13] and of consequence-driven algorithms as used for reasoning in Horn description logics such as EL++ and Horn-SHIQ [BBL05, Kaz09, Krö10b].\nWe use extended ABoxes, i.e., finite sets of assertions C(a) and r(a, b) with C a potentially compound concept. An ELIU⊥-concept is a concept that is formed according to the second syntax rule in the definition of Horn-ALCFI . For an extended ABox A′ and an assertion C(a), C an ELIU⊥-concept, we write A′ ⊢ C(a) if C(a) has a syntactic match in A′, formally:\n• A′ ⊢ ⊤(a) is unconditionally true; • A′ ⊢ ⊥(a) if ⊥(b) ∈ A′ for some b ∈ Ind(A); • A′ ⊢ A(a) if A(a) ∈ A′; • A′ ⊢ C ⊓D(a) if A′ ⊢ C(a) and A′ ⊢ D(a); • A′ ⊢ C ⊔D(a) if A′ ⊢ C(a) or A′ ⊢ D(a); • A′ ⊢ ∃r.C(a) if there is an r(a, b) ∈ A′ such that A′ ⊢ C(b).\nNow for the announced characterization. Let T = {⊤ ⊑ CT } be a Horn-ALCFI-TBox and A a potentially infinite ABox (so that the characterization also applies to unravelings of ABoxes). We produce a sequence of extended ABoxes A0,A1, . . . , starting with A0 = A. In what follows, we use additional individual names of the form ar1C1 · · · rkCk with a ∈ Ind(A0), r1, . . . , rk roles that occur in T , and C1, . . . , Ck subconcept of concept in T . We assume that NI contains such names as needed and use the symbols a, b, . . . also to refer to individual names of this compound form. Each extended ABox Ai+1 is obtained from Ai by applying the following rules in a fair way:\nR1 if a ∈ Ind(Ai), then add CT (a). R2 if C ⊓D(a) ∈ Ai, then add C(a) and D(a); R3 if C → D(a) ∈ Ai and Ai ⊢ C(a), then add D(a); R4 if ∃r.C(a) ∈ Ai and func(r) /∈ T , then add r(a, arC) and C(arC); R5 if ∃r.C(a) ∈ Ai, func(r) ∈ T , and r(a, b) ∈ Ai, then add C(b);\nR6 if ∃r.C(a) ∈ Ai, func(r) ∈ T , and there is no r(a, b) ∈ Ai, then add r(a, arC) and C(arC); R7 if ∀r.C(a) ∈ Ai and r(a, b) ∈ Ai, then add C(b).\nLet Ac = ⋃ i≥0Ai be the completion of the original ABox A. 2 Note that Ac may be infinite even if A is finite, and that none of the above rules is applicable in Ac. We write ‘Ac ⊢ ⊥’ instead of ‘Ac ⊢ ⊥(a) for some a ∈ NC’. If A 6⊢ ⊥, then Ac corresponds to an interpretation Ic in the standard way, i.e.,\n∆Ic = Ind(Ac) AIc = {a | A(a) ∈ Ac} for all A ∈ NC rIc = {r(a, b) | r(a, b) ∈ Ac} for all r ∈ NR\nwhere in Ic we assume that only the individual names in Ind(A) are elements of NI.\nClaim 1. If Ac 6⊢ ⊥, then Ic is a PEQ-materialization of T and A.\nTo prove Claim 1 it suffices to show that there is a homomorphism h preserving Ind(A) into any model J of T and A and that Ic is a model of T and A. The homomorphism h can be constructed inductively following the construction of Ac. Similarly, following the construction of Ac it is readily checked that Ic is a model of T and A. Using Claim 1 and the easily proved fact that Ac 6⊢ ⊥ iff A is consistent w.r.t. T one can now prove\nClaim 2. T ,A |= C(a) iff Ac ⊢ C(a) or Ac ⊢ ⊥, for all ELIQs C(x) and a ∈ Ind(A).\nWe now turn to the actual proof of Theorem 22. Consider the application of the above completion construction to both the original ABox A and its unraveling Au. Recall that individuals in Au are of the form a0r0a1 · · · rn−1an. Consequently, individuals in Auc take the form a0r0a1 · · · rn−1ans1C1 · · · skCk. For a ∈ Ind(Ac) and α ∈ Ind(Auc ), we write a ∼ α if a and α are of the form ans1C1 · · · skCk and a0r0a1 · · · rn−1ans1C1 · · · skCk, respectively, with k ≥ 0. Note that, in particular, a ∼ a for all a ∈ Ind(A). The following claim can be shown by induction on i.\nClaim 3. For all a ∈ Ind(Ai) and α ∈ Ind(Aui ) with a ∼ α, we have (1) Ai ⊢ C(a) iff Aui ⊢ C(α) for all ELI-concepts C; (2) C(a) ∈ Ai iff C(α) ∈ Aui for all subconcepts C of concepts in T . Now, unraveling tolerance of T follows from Claims 2 and 3. ❏\nTheorem 22 shows that unraveling tolerance and Horn logic are closely related. Yet, the next example demonstrates that there are unraveling tolerant ALCFI-TBoxes that are not equivalent to any Horn sentence of FO. Since any Horn-ALCFI-TBox is equivalent to such a sentence, it follows that unraveling tolerant ALCFI-TBoxes strictly generalize Horn-ALCFI-TBoxes. This increased generality will pay off in Section 5 when we establish a dichotomy result for TBoxes of depth one.\nExample 23. Take the ALC-TBox\nT = {∃r.(A ⊓ ¬B1 ⊓ ¬B2) ⊑ ∃r.(¬A ⊓ ¬B1 ⊓ ¬B2)}.\nOne can show as in Example 21 (1) that T is unraveling tolerant; here, the materialization is actually A itself rather than some extension thereof, i.e., as far as ELIQ (and even PEQ) evaluation is concerned, T cannot be distinguished from the empty TBox.\n2Order of rule application has an impact on the shape of Ac, but is irrelevant for the remainder of the proof.\nIt is well-known that FO Horn sentences are preserved under direct products of interpretations [CK90]. To show that T is not equivalent to any such sentence, it thus suffices to show that T is not preserved under direct products. This is simple: let I1 and I2 consist of a single r-edge between elements d and e, and let e ∈ (A⊓B1⊓¬B2)I1 and e ∈ (A⊓¬B1⊓B2)I2; then the direct product I of I1 and I2 still has the r-edge between (d, d) and (e, e) and satisfies (e, e) ∈ (A⊓¬B1 ⊓¬B2)I , thus is not a model of T .\nWe next show that unraveling tolerance is indeed a sufficient condition for Datalog6=-rewritability (and thus for PTIME query evaluation). In Section 6, we will establish a connection between query evaluation under DL TBoxes and constraint satisfaction problems (CSPs). The Datalog6= program constructed in the proof of the following result resembles canonical monadic Datalog programs for CSPs [FV93]. Note that it is not clear how to attain a proof of Theorem 24 via the CSP connection: first, as we will also see in Section 6, functional roles break this connection; and second, canonical Datalog programs are available only for Boolean queries while we construct programs for unary queries.\nTheorem 24. Every unraveling tolerant ALCFI-TBox is Datalog6=-rewritable for PEQ.\nProof. Let T be an unraveling tolerant ALCFI-TBox. By Theorem 19, it suffices to show that T is Datalog6=-rewritable for ELIQ. Let A be an ABox and q = C0(x) an ELIQ. Recall from the proof of Theorem 19 that cl(T , C0) denotes the closure under single negation of the set of subconcepts of T and C0. For an interpretation I and d ∈ ∆I , we use tIT ,q(d) to denote the set of concepts C ∈ cl(T , C0) such that d ∈ CI . A T , q-type is a subset t ⊆ cl(T , C0) such that for some model I of T , we have t = tIT ,q(d). We use tp(T , q) to denote the set of all T ,q-types. For t, t ′ ∈ tp(T , q) and r a role, we write t r t′ if there are a model I of T and d, d′ ∈ ∆I such that tIT ,q(d) = t, tIT ,q(d ′) = t′, and (d, d′) ∈ rI .\nIntroduce, for every set T ⊆ tp(T , C0) a unary IDB relation PT . Define a Datalog6= program Π that consists of the following rules:\n(1) PT (x) ← A(x) for all concept names A ∈ cl(T , C0) and T = {t ∈ tp(T , q) | A ∈ t}; (2) PT (x) ← PT0(x) ∧ r(x, y) ∧ PT1(y) for all T0, T1 ⊆ tp(T , q) and all role names r that\noccur in cl(T , C0) and their inverses, where T = {t ∈ T0 | ∃t′ ∈ T1 : t r t′}; (3) PT0∩T1(x) ← PT0(x) ∧ PT1(x) for all T0, T1 ⊆ tp(T , q); (4) goal(x) ← PT (x) for all T ⊆ tp(T , q) such that t ∈ T implies C0 ∈ T ; (5) goal(x) ← P∅(y); (6) goal(x) ← r(y, z1) ∧ r(y, z2) ∧ z1 6= z2 for all func(r) ∈ T .\nTo show that Π is a rewriting of the OMQ (T , C0(x)), it suffices to establish the following.\nClaim. A |= Π(a0) iff T ,A |= C0(a0) for all ABoxes A and a0 ∈ Ind(A).\nThe “if” direction is straightforward: by induction on the number of rule applications, one can show that whenever Π derives PT (a), then every model of T and A satisfies tIT ,q(a) ∈ T . By definition of the goal rules of Π, A |= Π(a0) thus implies that every model of T and A makes C0(a0) true or that A is inconsistent w.r.t. T . Consequently, T ,A |= C0(a0).\nFor the “only if” direction, it suffices to show that A 6|= Π(a0) implies T ,Au 6|= C0(a0) since T is unraveling tolerant. Because of the rules in Π of the form (3), for every a ∈ Ind(A) we can find a unique minimal Ta such that PTa(a) is derived by Π. Observe that, A(α) ∈ A\nu, tail(α) = a, and t ∈ Ta implies A ∈ t because of the rules of the form (1) in Π and by construction of Au.\nWe first associate with every α ∈ Ind(Au) a concrete T , q-type tα ∈ Ttail(α). To start, we choose ta ∈ Ta arbitrarily for all a ∈ Ind(A). Now assume that tα has already been chosen and that\nβ = αrb ∈ Ind(Au). Then r(tail(α), b) ∈ A. Because of the rules in Π of the form (2) and (5), we can thus choose tβ ∈ Tb such that tα r tβ . In this way, all types tα will eventually be chosen. We now construct an interpretation I , starting with\n∆I = Ind(Au)\nAI = {α | A ∈ tα} for all concept names A\nrI = {(α, β) | r(α, β) ∈ Au} for all role names r.\nNext, consider every α ∈ Ind(Au) and every ∃r.C ∈ tα such that Au does not contain an assertion r(α, β) with C ∈ tβ . First assume that func(r) 6∈ T . There must be a T , q-type t such that tα r t and C ∈ t. Choose a model Jα,∃r.C of T and D = ⊓ ta ⊓ ∃r.⊓ t, a d ∈ DJα,∃r.C , and an e ∈ (⊓ t)Jα,∃r.C with (d, e) ∈ rJα,∃r.C . W.l.o.g., we can assume that Jα,∃r.C is tree-shaped with root d. Let J−α,∃r.C be obtained from Jα,∃r.C by dropping the subtree rooted at e. Now disjointly add J−α,∃r.C to I , additionally including (a, d) in r I . Now assume that func(r) ∈ T . Then, if there exists r(α, β) ∈ Au, then C ∈ tβ as otherwise we do not have tα r tβ . Thus, assume there is no r(α, β) ∈ Au. There must be a T , q-type t such that tα r t and C ∈ t. We then have D ∈ t for all ∃r.D ∈ tα and so construct only a single J − α,∃r.C for the role r and disjointly add J − α,∃r.C to I , additionally including (a, d) in rI . This finishes the construction of I . The following claim can be proved by induction on C , details are omitted.\nClaim. For all C ∈ cl(T , C0) : (a) α ∈ CI iff C ∈ tα for all α ∈ Ind(Au) and\n(b) d ∈ CJα,∃r.D iff d ∈ CI for all Jα,∃r.D and all d ∈ ∆ J− α,∃r.D .\nBy construction of I and since A(α) ∈ Au implies A ∈ tα, I is a model of A. Due to the rules in Π that are of the form (4), Point (a) of the claim yields I 6|= C0(a0). Finally, we observe that I is a model of T . The concept inclusions in T are satisfied by the above claim, since C ⊑ D ∈ T means that C ∈ t implies D ∈ t for every T , q-type t, and since each Jα,∃r.C is a model of T . Due to the rules in Π that are of the form (6) and since each Jα,∃r.C is a model of T , all functionality assertions in T are satisfied as well. Summing up, we have shown that T ,Au 6|= C0(a0), as required. ❏\nTogether with Theorems 19 and 22, Theorem 24 also reproves the known PTIME upper bound for the data complexity of CQ-evaluation in Horn-ALCFI [EGOS08].\nBy Theorems 18 and 24, unraveling tolerance implies materializability unless PTIME = NP. Based on the disjunction property, this implication can also be proved without the side condition.\nTheorem 25. Every unraveling tolerant ALCFI-TBox is materializable.\nProof. We show the contrapositive using a proof strategy that is very similar to the second step in the proof of Theorem 18. Thus, take an ALCFI-TBox T that is not materializable. By Theorem 16, T does not have the disjunction property. Thus, there are an ABox A∨, ELIQs C0(x0), . . . , Ck(xk), and a1, . . . , ak ∈ Ind(A∨) such that T ,A∨ |= C0(a0) ∨ · · · ∨ Ck(ak), but T ,A∨ 6|= Ci(ai) for all i ≤ k. Let Ai be Ci viewed as a tree-shaped ABox with root bi, for all i ≤ k. Assume w.l.o.g. that none of the ABoxes A∨,A0, . . . ,Ak share any individual names and reserve a fresh individual name b and role names r, r0, . . . , rk that do not occur in T . Construct an ABox\nA = A∨ ∪ A0 ∪ · · · ∪ Ak ∪ {r(b, b0), . . . , r(b, bk)} ∪ {r0(bj , b0), . . . , rj−1(bj , bj−1), rj+1(bj , bj+1), . . . , rk(bj , bk)}\n∪ {r0(b0, a0), . . . , rk(bk, ak)}\nand an ELIQ q = ∃r.(∃r0.C0 ⊓ · · · ⊓ ∃rk.Ck)(x). By the following claim, A and q witness that T is not unraveling tolerant.\nClaim. T ,A |= q(b), but T ,Au 6|= q(b).\nProof. “T ,A |= q(b)”. Take a model I of T and A. By construction of A, we have bIi ∈ (∃rj.Cj) I whenever i 6= j. Due to the edges r0(b0, a0), . . . , rk(bk, ak) and since T ,A∨ |= C0(a0) ∨ · · · ∨ Ck(ak), we thus find at least one bi such that bIi ∈ (∃ri.Ci) I . Consequently, I |= q(b).\n“T ,Au 6|= q(b)” (sketch). Consider the elements brbiriai in Au. Each such element is the root of a copy of the unraveling Au∨ of A∨, restricted to those individuals in A∨ that are reachable from ai. Since T ,A∨ 6|= Ci(ai), we find a model Ii of T and A∨ with a Ii i /∈ C Ii i . By unraveling I , we obtain a model Iui of T and A u ∨ with a Iui i /∈ C Iui i . Combining the models I u 0 , . . . ,I u k in a suitable way, one can craft a model I of T and Au∨ such that brbiria I i /∈ C I i for all i ≤ k. Consequently, I 6|= q(b). ❏"
    }, {
      "heading" : "5. DICHOTOMY FOR DEPTH ONE",
      "text" : "In practical applications, the concepts used in TBoxes are often of very limited quantifier depth. Motivated by this observation, we consider TBoxes of depth one which are sets of CIs C ⊑ D such that the maximum nesting depth of the constructors ∃r.E and ∀r.E in C and D is one. To confirm that this is indeed a practically relevant case, we have analyzed the 429 ontologies in the BioPortal repository,3 finding that after removing all constructors that are not part of ALCFI, more than 80% of them are of depth one. The main result of this section is a dichotomy between PTIME and CONP for TBoxes of depth one which is established by proving a converse of Theorem 25, that is, showing that materializability implies unraveling tolerance (and thus PTIME query evaluation and even Datalog6=-rewritability by Theorem 24) for TBoxes of depth one. Together with Theorem 18, which says that non-materializability implies CONP-hardness, this yields the dichotomy.\nWe remark that the same strategy cannot be used to obtain a dichotomy in the case of unrestricted depth. In particular, the well-known technique of rewriting a TBox into depth one by introducing fresh concept names can change its complexity because it enables querying for concepts such as ¬A or ∀r.A which are otherwise ‘invisible’ to (positive existential) queries. For TBoxes of unrestricted depth (and even in ALC) it is in fact neither the case that PTIME query evaluation implies unraveling tolerance nor that PTIME query evaluation implies Datalog6= rewritability nor that materializability implies PTIME query evaluation. As an example for the former, we show in Section 6 how the TBox T2 from Example 2, which encodes 2-colorability, can be modified to have PTIME query evaluation. However, 2-colorability is not invariant under tree unravelings and, consequently, T2 is not unraveling tolerant. Also the latter two statements follow from results established in Section 6.\nTheorem 26. Every materializable ALCFI-TBox of depth one is unraveling tolerant.\n3The ontologies are available at https://bioportal.bioontology.org/ontologies.\nProof. Let T be a materializable TBox of depth one, A an ABox, C0(x) an ELIQ, and a0 ∈ Ind(A) such that T ,Au 6|= C0(a0). We have to show that T ,A 6|= C0(a0). It follows from T ,Au 6|= C0(a0) that Au is consistent w.r.t. T . There must thus be a materialization Iu for T and Au, despite the fact that Au is infinite: by Theorem 26, T has the disjunction property and the argument from the proof of Theorem 26 that the disjunction property implies materializability goes through without modification also for infinite ABoxes. Our aim is to turn Iu into a model I of A and T such that I 6|= C0(a0). To achieve this, we first uniformize Iu in a suitable way.\nWe assume w.l.o.g. that Iu has forest-shape, i.e., that Iu can be constructed by selecting a tree-shaped interpretation Iα with root α for each α ∈ Ind(Au), then taking the disjoint union of all these interpretations, and finally adding role edges (α, β) to rI u\nwhenever r(α, β) ∈ Au. In fact, to achieve the desired shape we can take the i-unfolding of Iu defined and analysed in Lemmas 13 and 14, where we start the i-unfolding from the elements of Ind(Au) ⊆ ∆I u\n. We start with exhibiting a self-similarity inside the unraveled ABox Au and inside Iu.\nClaim 1. For all α, β ∈ Ind(Au) with tail(α) = tail(β), (1) Au |= C(α) iff Au |= C(β) for all ELIQs C(x); (2) α ∈ CI u iff β ∈ CI u for all concepts C built only from concept names, ¬, and ⊓.\nTo establish Point (1), take α, β ∈ Ind(Au) such that tail(α) = tail(β) and Au 6|= C(α). Then there is a model I of Au and T such that I 6|= C(α). One can find a model J of Au and T such that J 6|= C(β), as follows. By construction of Au, there is an isomorphism ι : Ind(Au) → Ind(Au) with ι(α) = β such that A(γ) ∈ Au iff A(ι(γ)) ∈ Au and r(γ, γ′) ∈ Au iff r(ι(γ), ι(γ′)) ∈ Au for all γ ∈ Ind(Au), all concept names A, and all role names r. We obtain J from I by renaming each γ ∈ Ind(Au) with ι(γ). Point (2) can be proved by a straightforward induction on C . The base case uses Point (1) and the fact that Iu is a materialization of T and A. This finishes the proof of Claim 1.\nNow for the announced uniformization of Iu. What we want to achieve is that for all α, β ∈ Ind(Au), tail(α) = tail(β) implies Iα = Iβ (recall that Iα is the tree component of Iu rooted at α, and likewise for Iβ). Construct the interpretation J u as follows:\n• for each α ∈ Ind(Au) with tail(α) = a, take a copy Jα of Ia with the root a renamed to α; • then J u is the disjoint union of all interpretations Jα, α ∈ Ind(Au), extended with a role\nedge (α, β) ∈ rJ u whenever r(α, β) ∈ Au.\nOur next aim is to show that J u is as required, that is, it is a model of T and Au and satisfies J u 6|= C0(a0).\nIt is indeed straightforward to verify that J u is a model of Au: all role assertions are satisfied by construction; moreover, A(α) ∈ Au implies A(a) ∈ Au where a = tail(α) , thus a ∈ AIu and α ∈ AJu .\nNext, we show that J u is a model of T . Let f : ∆J u → ∆I u be a mapping that assigns to\neach domain element of J u the original element in Iu of which it is a copy.\nClaim 2. d ∈ CJ u iff f(d) ∈ CI u for all d ∈ ∆J u and ALCI-concepts C of depth one.\nThe proof of claim 2 is by induction on the structure of C . We assume w.l.o.g. that C is built only from the constructors ¬, ⊓, and ∃r.C . The base case, where C is a concept name, is an immediate consequence of the definition of J u. The case where C = ¬D and C = D1 ⊓D2 is routine. It thus remains to consider the case C = ∃r.D, where D is built from ¬ and ⊓ only.\nFirst let d ∈ CJ u . Then there is a (d, e) ∈ rJ u with e ∈ DJ u . First assume that the edge\n(d, e) was added to rJ u because d = α and e = β for some α, β ∈ Ind(Au) with r(α, β) ∈ Au. Let tail(α) = a and tail(β) = b. Then we have f(α) = a and f(β) = b. By construction of\nAu, r(α, β) ∈ Au implies that β = αrb or α = βr−a. In both cases we have r(a, b) ∈ A, thus r(a, arb) ∈ Au, thus (a, arb) ∈ rI u . Since β = e ∈ DJ u , induction hypothesis yields that b ∈ DI u . From Point (2) of Claim 1, we obtain arb ∈ DI u\nand we are done. Now assume that there is an α ∈ Ind(Au) such that (d, e) ∈ Jα. By construction of J u, we then have (f(d), f(e)) ∈ rI u and induction hypothesis yields f(e) ∈ DI u .\nNow let f(d) ∈ CI u . Then there is an (f(d), e) ∈ rI u with e ∈ DI u . First assume that f(d) = α and e = β for some α, β ∈ Ind(Au) with r(α, β) ∈ Au. Since f(d) ∈ Ind(Au), we must have d = γ ∈ Ind(Au) and f(d) = a ∈ Ind(A) with tail(γ) = a. By construction of Au, r(a, β) ∈ Au implies that β = arb, thus r(a, b) ∈ A, thus r(γ, δ) ∈ Au with (i) δ = γrb or (ii) γ = δr−a and tail(δ) = b. Since arb = e ∈ DI u\n, Point (2) of Claim 1 yields b ∈ DIu . Since tail(δ) = b implies f(δ) = b, induction hypothesis yields δ ∈ DJ u and we are done. Now assume that there is an α ∈ Ind(Au) such that (f(d), e) ∈ Iα. By construction of J u, f(d) being in Iα implies that α = a for some a ∈ Ind(A) and that there is an α′ ∈ Ind(Au) such that d is in Jα′ and tail(α′) = a. Again by construction of J u, we thus find an e′ in Jα′ with f(e′) = e and (d, e′) ∈ rJα′ ⊆ rJ u . Induction hypothesis yields e′ ∈ DJ u . This finishes the proof of Claim 2.\nIt follows from Claim 2 that J u satisfies all CIs in T . To show that J u is a model of T , it remains to show that J u satisfies all functionality assertions. Thus, let func(r) ∈ T and d ∈ ∆J u . If d /∈ Ind(Au), then it is straightforward to verify that, by construction of J u, d has at most one r-successor in J u. Now assume d = α ∈ Ind(Au) and let tail(α) = a. By construction of J u and Au, α has the same number of r-successors in J u as a in Iu. Since Iu satisfies func(r), α can have at most one r-successor in J u.\nThe final condition that J u should satisfy is J u 6|= C0(a0). Assume to the contrary. We view C0(x0) as a (tree-shaped) CQ. Take a homomorphism h from C0(x0) to J u with h(x0) = a0. (In this proof we consider homomorphisms that do not have to preserve any individual names.) Let the CQ q(x) be obtained from C0(x0) by identifying variables y1, y2 whenever h(y1) = h(y2). To achieve a contradiction, it suffices to exhibit a homomorphism h′ from q(x0) to Iu with h′(x0) = a0. We start with setting h′(x) = h(x) whenever h(x) ∈ Ind(Au). Let q′ be obtained from q(x0) by dropping all role atoms r(x, y) with h′(x) and h′(y) already defined (which are satisfied under h′ by construction of J u and since Iu is a model of A). Because of the forest shape of J u and by construction, q′ is a disjoint union of ELIQs such that, in each ELIQ C(x) contained in q′, h′ is defined for the root x of C(x), but not for any other variable in it. Consequently, it suffices to show that whenever Jα |= C(α) for some ELIQ C(x) and α ∈ Ind(Au), then Iu |= C(α); the remaining part of h′ can then be constructed in a straightforward way. Now Jα |= C(α) implies Ia |= C(a) where a = tail(α) by choice of Jα, which yields Iu |= C(a) and thus Iu |= C(α) by Point (1) of Claim 1.\nThis finishes the construction and analysis of the uniform model J u. It remains to convert J u\ninto a model I of T and the original ABox A such that I 6|= C0(a0)q:\n• take the disjoint union of the components Ja of J u, for each a ∈ Ind(A); • add the edge (a, b) to rI whenever r(a, b) ∈ A.\nIt is straightforward to verfiy that I is a model of A: all role assertions are satisfied by construction of I; moreover, A(a) ∈ A implies A(a) ∈ Au implies a ∈ AJ u implies a ∈ AI . To show that I is a model of T and that I 6|= C0(a0), we first observe the following. A bisimulation between interpretations I1 and I2 is a relation S ⊆ ∆I1 ×∆I2 such that\n(1) for all A ∈ NC and (d1, d2) ∈ S: d1 ∈ AI1 iff d2 ∈ AI2 ; (2) for all r ∈ NR ∪ {s− | s ∈ NR}: if (d1, d2) ∈ S and (d1, d′1) ∈ r\nI1 , then there exists d′2 ∈ ∆ I2 such that (d′1, d ′ 2) ∈ S and (d2, d ′ 2) ∈ r I2;\n(3) for all r ∈ NR ∪ {s− | s ∈ NR}: if (d1, d2) ∈ S and (d2, d′2) ∈ r I2 , then there exists\nd′1 ∈ ∆ I1 such that (d′1, d ′ 2) ∈ S and (d1, d ′ 1) ∈ r I2 .\nRecall that, whenever there is a bisimulation S between I1 and I2 with (d, e) ∈ S, then d ∈ CI1 iff e ∈ CI2 for all ALCI-concepts C [GO07, LPW11].\nClaim 3. There is a bisimulation S between J u and I such that (a, a) ∈ S for all a ∈ Ind(A).\nSince J u is uniform in the sense that Jα is isomorphic to Jβ whenever tail(α) = tail(β), we find a bisimulation between Jα and Ja whenever tail(α) = a. It can be verified that the union of all these bisimulations qualifies as the desired bisimulation S for Claim 3. Thus, Claim 3 is proved.\nIt follows from Claim 3 that I satisfies all concept inclusions in T , and that I 6|= C0(a0). It thus remains to verify that I also satisfies all functionality assertions in T . This can be done in the same way in which we have verified that J u satisfies all those assertions. ❏\nThe desired dichotomy follows: If an ALCFI-TBox T of depth one is materializable, then PEQ-evaluation w.r.t. T is in PTIME and Datalog6=-rewritable by Theorems 26 and 24. Otherwise, ELIQ-evaluation w.r.t. T is CONP-complete by Theorem 18.\nTheorem 27 (Dichotomy). For every ALCFI-TBox T of depth one, one of the following is true: • Q-evaluation w.r.t. T is in PTIME for any Q ∈ {PEQ,CQ,ELIQ} (and Datalog6=-rewritable); • Q-evaluation w.r.t. T is CONP-complete for any Q ∈ {PEQ,CQ,ELIQ}.\n6. QUERY EVALUATION IN ALC/ALCI = CSP\nWe show that query evaluation w.r.t. ALC- and ALCI-TBoxes has the same computational power as non-uniform CSPs in the following sense:\n(1) for every CSP, there is an ALC-TBox T such that the CSP can be reduced in polynomial time to the complement of evaluating an OMQ (T ,∃xM(x)) and, conversely, for every OMQ (T , q) query evaluation can be reduced in polynomial time to the CSP’s complement; (2) for every OMQ (T , q) with T an ALCI-TBox and q an ELIQ, there is a CSP such that the complement of the CSP and the query evaluation problem for the (T , q) are reducible to each other in polynomial time.\nThis result has many interesting consequences. In particular, the Feder-Vardi conjecture holds if and only if there is a PTIME/CONP-dichotomy for query evaluation w.r.t. ALC-TBoxes (equivalently: w.r.t. ALCI-TBoxes). Remarkably, all this is true already for materializable TBoxes. By Theorem 19 and since we carefully choose the appropriate query language in each technical result below, it furthermore holds for any of the query languages ELIQ, CQ, and PEQ (and ELQ for ALC-TBoxes).\nWe begin by introducing CSPs. Since every CSP is equivalent to a CSP with a single predicate that is binary, up to polynomial time reductions [FV93], we consider CSPs over unary and binary predicates (concept names and role names) only. A signature Σ is a finite set of concept and role names. An ABox A is a Σ-ABox if all concept and role names in A are in Σ. For two finite ΣABoxes A and B, we write A → B if there is a homomorphism from A to B that does not have to preserve any individual names. Any Σ-ABox B gives rise to the following (non-uniform) constraint satisfaction problem\n• CSP(B): given a finite Σ-ABox A, decide whether A → B.\nB is called the template of CSP(B). Many algorithmic problems can be given in the form CSP(B). For example, k-colorability is CSP(Ck), where Ck is the {r}-ABox containing r(i, j) for all 1 ≤ i 6= j ≤ k.\nWe now formulate and prove Points (1) and (2) from above, starting with (1).\nTheorem 28. For every template B, one can construct in polynomial time a materializable ALCTBox TB such that, for a distinguished concept name M , the following hold:\n(1) CSP(B) is polynomial time reducible to the complement of the query evaluation problem for (TB,∃xM(x)); (2) the query evaluation problem for (TB, q) is polynomial time reducible to the complement of CSP(B), for all PEQs q.\nOur approach to proving Theorem 28 is to generalize the reduction of k-colorability to query evaluation w.r.t. ALC-TBoxes discussed in Examples 2 and 4, where the main challenge is to overcome the observation from Example 4 that PTIME CSPs such as 2-colorability may be translated into CONP-hard TBoxes. Note that this is due to the disjunction in the TBox Tk of Example 2, which causes non-materializability. Our solution is to replace the concept names A1, . . . , Ak in Tk with suitable compound concepts that are ‘invisible to the (positive existential) query’. Unlike the original depth one TBox Tk, the resulting TBox is of depth three. We first define and analyze the replacement of concept names by compound concepts in some detail (as this will be reused later in the paper again) and then return to the proof of Theorem 28.\nLet Σ be a set of concept names. For any B ∈ Σ, let ZB be a fresh concept name and let rB and sB be fresh role names. The abstraction of B is the ALC-concept HB := ∀rB.∃sB.¬ZB. The Σ-abstraction C ′ of a (potentially compound) concept C is obtained from C by replacing every B ∈ Σ with HB. The Σ-abstraction of a TBox T is obtained from T by replacing all concepts in T with their Σ-abstractions. We associate with Σ an auxiliary TBox\nT ∃ = {⊤ ⊑ ∃rB .⊤,⊤ ⊑ ∃sB.ZB | B ∈ Σ}\nFinally, T ′ ∪ T ∃ is called the enriched Σ-abstraction of T and Σ. In what follows, we are going to replace TBoxes T with their enriched abstractions. The following example shows that the TBox T ∃ is crucial for hiding the concept names in Σ: without T ∃, disjunctions in T over concept names from Σ can still induce disjunctions in the Σ-abstraction.\nExample 29. Let T = {A ⊑ ¬B1 ⊔ ¬B2} and Σ = {B1, B2}. Then T ′ = {A ⊑ ¬HB1 ⊔ ¬HB2} is the Σ-abstraction of T . For A = {A(a)}, we derive T ′,A |= ∃rB1 .⊤(a) ∨ ∃rB2 .⊤(a) but T ′,A 6|= ∃rB1 .⊤(a) and T ′,A 6|= ∃rB2(a).⊤. Thus T ′ does not have the ABox disjunction property and is not materializable. In contrast, it follows from Lemma 30 below that T ′∪T ∃ is materializable and, in fact, T ′ ∪ T ∃,A |= q(a) iff T ∃,A |= q(a) holds for all PEQs q.\nWe say that a TBox T admits trivial models if the singleton interpretation I with XI = ∅ for all X ∈ NC ∪ NR is a model of T . Moreover, we write A|Σ to denote the ABox obtained from the ABox A by removing all assertions in A that use a symbol that is not in Σ, and likewise for AΣ and symbols that are in Σ. An ABox A is strongly Σ-consistent w.r.t. a TBox T if there exists a model I of T and A|Σ such that ∆\nI = Ind(A), AI = {a | A(a) ∈ A} for all A 6∈ Σ, and rI = {(a, b) | r(a, b) ∈ A} for all role names r 6∈ Σ. Thus, strong Σ-consistency formalizes the intuition that we regard the symbols in Σ as existentially quantified second-order variables. The following lemma summarizes the main properties of abstractions. Points (1) and (2) establish a close link between the original TBox and its enriched abstraction. Points (3) and (4) together state that query evaluation is tractable for the enriched abstraction of a TBox T for ABoxes that are strongly Σ-consistent w.r.t. T .\nLemma 30. Assume that T admits trivial models and let Σ be a finite set of concept names and T ′ ∪ T ∃ the enriched Σ-abstraction of T . Then for every ABox A and all ALCI concepts C not using the fresh symbols from Σ-abstractions:\n(1) A|Σ is consistent w.r.t. T iff A is consistent w.r.t. T ′ ∪ T ∃; (2) for all a ∈ Ind(A) and the Σ-abstraction C ′ of C:\nT ,A|Σ |= C(a) iff T ′ ∪ T ∃,A |= C ′(a)\nand if C is a concept name:\nT ,A|Σ |= ∃xC(x) iff T ′ ∪ T ∃,A |= ∃xC ′(x);\n(3) T ∃ is Datalog6=-rewritable for PEQs; (4) if A is strongly Σ-consistent w.r.t. T , then\nT ′ ∪ T ∃,A |= q(~a) iff T ∃,A |= q(~a)\nfor all PEQs q and all ~a.\nProof. Observe that (1) follows from (2) as we can choose C = ⊥. Thus we prove (2). Let C ′ be the Σ-abstraction of C .\nWe first consider (⇒). Assume T ′ ∪ T ∃,A 6|= C ′(a). Take a model I of T ′ ∪ T ∃ and A that witnesses this. Define an interpretation J in the same way as I except that BJ := HIB for all B ∈ Σ. It is straightforward to show for all d ∈ ∆I that d ∈ DJ iff d ∈ D′I holds for all ALCI-concepts D not using the fresh symbols from Σ-abstractions and their Σ-abstractions D′. Thus J is a model of T and A|Σ and shows that T ,A|Σ 6|= C(a) if T\n′∪T ∃,A 6|= C ′(a). The same proof shows that (⇒) holds for queries of the form ∃xC(x) and ∃xC ′(x) as well (even if C is not a concept name).\nNow consider (⇐). Assume T ,A|Σ 6|= C(a) or T ,A|Σ 6|= ∃xA(x) (where A is a concept name). Let I be a model of T and A|Σ that witnesses this. Construct a model Ican of T\n′ ∪ T ∃ and A as follows: ∆Ican is the set of words w = dv1 · · · vn such that d ∈ ∆I and vi ∈ {rB , sB , s̄B | B ∈ Σ} where vi 6= s̄B if (i) i > 2 or (ii) i = 2 and (d 6∈ HIB or v1 6= rB). Now let\nAIcan = AI for all concept names A 6∈ Σ\nBIcan = {d ∈ Ind(A) | B(d) ∈ A} for all B ∈ Σ\nZIcanB = Z I B ∪ {w | tail(w) = sB} for all B ∈ Σ\nrIcan = rI for all r 6∈ {rB , sB | r ∈ Σ} rIcanB = r I B ∪ {(w,wrB) | wrB ∈ ∆ Ican} for all r ∈ Σ sIcanB = s I B ∪ {(w,wsB) | wrB ∈ ∆ Ican} ∪ {(w,ws̄B) | ws̄B ∈ ∆ Ican} for all r ∈ Σ\nBy construction of Ican, we have H Ican B = B I for all B ∈ Σ. Thus for all concepts D (not using symbols from Σ-abstractions) and their Σ-abstractions D′ and all d ∈ ∆I , we have d ∈ D′Ican iff d ∈ DI . Thus, the CIs of T ′ hold in all d ∈ ∆I since the CIs of T hold in all d ∈ ∆I . The CIs of T ′ also hold in all d ∈ ∆Ican \\∆I since T admits trivial models. Thus Ican is a model of T ′. Since Ican is a model of T ∃ by construction, it follows that Ican is a model of T ′ ∪ T ∃. It also follows that Ican shows T ′ ∪ T ∃,A 6|= C ′(a) if I shows that T ,A|Σ 6|= C(a) and that Ican shows that T ′ ∪ T ∃,A 6|= ∃xA′(x) if I shows that T ,A|Σ 6|= ∃xA(x).\n(3) is a consequence of the fact that T ∃ can be viewed as a TBox formulated in the description logic DL-LiteR and that any OMQ (T , q) with T a DL-LiteR-TBox and q a PEQ is known to be rewritable into a union of CQs [CDGL+07, ACKZ09].\n(4) Assume that A is strongly Σ-consistent w.r.t. T and that T ∃,A 6|= q(~a). We show T ′ ∪ T ∃,A 6|= q(~a). Note first that one can construct a hom-initial model I∃A of T\n∃ and A in the same way as Ican was constructed from I above (by replacing I with the interpretation IA corresponding to A and not using the symbols s̄B in the construction). Thus, ∆I ∃ A is the set of words w = av1 · · · vn such that a ∈ Ind(A) and vi ∈ {rB , sB , | B ∈ Σ}. We have I∃A 6|= q(~a). Now, as A is strongly Σ-consistent w.r.t. T , there is a model I of T and A|Σ with ∆\nI = Ind(A) and AI = {a | A(a) ∈ A} for all A 6∈ Σ, and rI = {(a, b) | r(a, b) ∈ A} for all role names r. Construct the model Ican of T ′ ∪ T ∃ and A in the same way as in the proof of (2). Define a mapping h : Ican → I∃A by setting h(w) = w\n′, where w′ is obtained from w by replacing every s̄B by sB. One can show that h is a homomorphism. Thus Ican 6|= q(~a) and so T ′ ∪ T ∃,A 6|= q(~a), as required. The converse direction is trivial. ❏\nWe are now ready to prove Theorem 28.\nProof of Theorem 28. Assume a Σ0-template B is given. We construct the TBox TB in two steps. First take for any d ∈ Ind(B) a concept name Ad and define a TBox HB with the following CIs:\ndom ⊑ ⊔ d∈Ind(B) Ad\nAd ⊓Ae ⊑ ⊥ for all d, e ∈ Ind(B), d 6= e\nAd ⊓ ∃r.Ae ⊑ ⊥ for all d, e ∈ Ind(B), r ∈ Σ0, r(d, e) 6∈ B\nAd ⊓A ⊑ ⊥ for all d ∈ Ind(B), A ∈ Σ0, A(d) 6∈ B.\nHere dom ⊑ ⊔ d∈Ind(B) Ad stands for the set of CIs\n∃r.⊤ ⊑ ⊔ d∈Ind(B) Ad, A ⊑ ⊔ d∈Ind(B) Ad, ⊤ ⊑ ∀r.( ⊔ d∈Ind(B) Ad)\nwhere r and A range over all role and concept names in Σ0, respectively. We use a CI of the form dom ⊑ C rather than ⊤ ⊑ C to ensure that the TBox HB admits trivial models. Let M be a fresh concept name and set Σ = {Ad | d ∈ Ind(B)}. Then the following can be proved in a straightforward way.\nClaim 1. For any ABox A the following conditions are equivalent: (1) HB,A|Σ∪{M} 6|= ∃xM(x); (2) A|Σ is consistent w.r.t. HB; (3) A|Σ0 → B. Thus, CSP(B) and the complement of the query evaluation problem for (HB,∃xM(x)) are reducible to each other in polynomial time. Because of the disjunctions, however, the query evaluation problem w.r.t HB is typically CONP-hard even if CSP(B) is in PTIME. We thus ‘hide’ the concept names Ad by replacing them with their abstractions HAd . Let H ′ B ∪ T\n∃ be the enriched Σabstraction of HB. From Claim 1 and Lemma 30 (1) according to which A|Σ is consistent w.r.t. HB iff A is consistent w.r.t. H′B ∪ T ∃, we obtain\nClaim 2. For any ABox A, the following conditions are equivalent: (1) H′B ∪ T ∃,A|{M} 6|= ∃xM(x);\n(2) A is consistent w.r.t. H′B ∪ T ∃; (3) A|Σ0 → B.\nLet TB = H′B ∪ T ∃ be the enriched Σ-abstraction of HB. We show that TB is as required to prove Theorem 28.\n(1) We have to show that CSP(B) is reducible in polynomial time to the complement of the query evaluation problem for (TB,∃xM(x)). But given a Σ0-ABox A, we have by Claim 2 that A → B iff TB,A |= ∃xM(x).\n(2) For the converse reduction, let q be a PEQ. We have to show that the query evaluation problem for (TB, q) is reducible in polynomial time to the complement of CSP(B). Let A be an ABox and ~a from Ind(A). We show that the following are equivalent:\n(a) TB,A |= q(~a); (b) A|Σ0 6→ B or T ∃,A |= q(~a).\nRegarding (b), we remark that by Lemma 30 (3) T ∃,A |= q(~a) can be checked in polynomial time and thus can be checked as part of the reduction. First assume that (a) holds. If A|Σ0 → B, then by Claim 1 the ABox A|Σ is consistent w.r.t. HB. Thus there is a model I of HB and A|Σ satisfying ∆I = Ind(A) and AI = {a | A(a) ∈ A} for all concept names A 6∈ Σ and rI = {(a, b) | r(a, b) ∈ A} for all role names r. Thus, A is strongly Σ-consistent w.r.t. HB. By Lemma 30 (4) we have TB,A |= q(~a) iff T ∃,A |= q(~a) for all PEQs q and all ~a, as required.\nConversely, assume (b) holds. If A|Σ0 6→ B, then by Claim 2 A is not consistent w.r.t. TB and so TB,A |= q(~a). If T ∃,A |= q(~a), then TB,A |= q(~a) since T ∃ ⊆ TB. ❏\nThe following converse of Theorem 28 is proved in [BtCLW14].\nTheorem 31. For every ALCI-TBox T and ELIQ C(x), one can compute a template B in exponential time such that the query evaluation problem for (T , C(x)) and the complement of CSP(B) are polynomial time reducible to each other.\nThe proof of Theorem 31 given in [BtCLW14] proceeds in two steps. To deal with answer variables, it uses generalized CSPs with constants, defined by a finite set of templates (instead of a single one) and admitting the inclusion of constant symbols in the signature of the CSP (instead of only relation symbols). One shows that (i) for every OMQ (T , C(x)), one can construct a generalized CSP with a single constant whose complement is mutually reducible in polynomial time with the query evaluation problem for (T , C(x)) and (ii) every generalized CSP with constants is mutually reducible in polynomial time with some standard CSP. For the reader’s convenience, we illustrate the construction of the template from a given OMQ, concentrating on Boolean ELIQs which are of the form ∃xC(x) with C(x) an ELIQ. In this special case, one can avoid the use of generalized CSPs with constants.\nTheorem 32. Let T be an ALCI-TBox, q = ∃xC(x) with C an ELIQ, and Σ the signature of T and q. Then one can construct (in time single exponential in |T |+ |C|) a Σ-template BT ,q such that for all ABoxes A:\n(HomDual) T ,A |= q iff A|Σ 6→ BT ,q\nProof. Assume T and q = ∃xC(x) are given. We use the notation from the proof of Theorem 24. Thus, cl(T , C) denotes the closure under single negation of the set of subconcepts of T and C , tp(T , q) denotes the set of T , q-types and for t, t′ ∈ tp(T , q) we write t r t′ if t and t′ can be satisfied in domain elements of a model of T that are related by r. Now, a T , q-type t omits q if it is satisfiable in a model I of T with CI = ∅. Let BT ,q be the set of assertions A(t) such t omits q and A ∈ t and r(t, t′) such that t and t′ omit q and t r t′. It is not difficult to show that condition (HomDual) holds for all ABoxes A. Observe that BT ,q can be constructed in exponential time since the set of T , q-types omitting q can be constructed in exponential time. ❏\nExample 33. Let T = {A ⊑ ∀r.B} and define q = ∃xB(x). Then BT ,q is defined, up to isomorphism, as {r(a, a), r(a, b), A(b), r(a, c)}.\nAs a consequence of Theorems 28 and 31, we obtain the following.\nTheorem 34. There is a dichotomy between PTIME and CONP for CQ-evaluation w.r.t. ALCTBoxes if and only if the Feder-Vardi conjecture is true. The same is true for ALCI-TBoxes, for ELIQs, and for PEQs. For ALC-TBoxes, it additionally holds for ELQs.\nProof. Let CSP(B) be an NP-intermediate CSP, i.e., a CSP that is neither in PTIME nor NP-hard. Take the TBox TB from Theorem 28. By Point 1 of that theorem, CQ-evaluation w.r.t. T is not in PTIME. By Point 2, CQ-evaluation w.r.t. TB is not CONP-hard.\nConversely, let T be an ALC-TBox for which CQ-evaluation w.r.t. T is neither in PTIME nor CONP-hard. Then by Theorem 19, the same holds for ELIQ-evaluation w.r.t. T . It follows that there is a concrete ELIQ q such that query evaluation for (T , q) is CONP-intermediate. By Theorem 31, there is a template B such that evaluating (T , q) is mutually reducible in polynomial time with the complement of CSP(B). Thus CSP(B) is NP-intermediate, as required. ❏\nObserve that the TBox constructed in the proof of Theorem 28 has depth three. Thus, a dichotomy between PTIME and CONP for CQ-evaluation w.r.t. ALC-TBoxes of depth three would imply that the Feder-Vardi conjecture is true. On the other hand, we have proved a dichotomy between PTIME and CONP for CQ-evaluation w.r.t. ALCIF-TBoxes of depth one. The behavior of TBoxes of depth two remains open.\n7. NON-DICHOTOMY AND UNDECIDABILITY IN ALCF\nWe show that the complexity landscape of query evaluation w.r.t. ALCF-TBoxes is much richer than for ALCI, and in fact too rich to be fully manageable. In particular, we prove that for CQevaluation, there is no dichotomy between PTIME and CONP (unless PTIME = NP). We also establish that materializability, Datalog6=-rewritability, PTIME query evaluation, and CONP-hardness of query evaluation are undecidable. We start with the undecidability proofs, which are by reduction of an undecidable rectangle tiling problem and reuse the ‘hidden concepts’ introduced in the previous section. Next, the TBox from that reduction is adapted to prove the non-dichotomy result by an encoding of the computations of nondeterministic polynomial time Turing machines (and again using hidden concepts). The basis for the technical development in this section is a TBox constructed in [BBLW16] to prove the undecidability of query emptiness in ALCF .\nAn instance of the finite rectangle tiling problem is given by a triple P = (T,H, V ) with T a finite set of tile types including an initial tile Tinit to be placed on the lower left corner and a final tile Tfinal to be placed on the upper right corner, H ⊆ T× T a horizontal matching relation, and V ⊆ T×T a vertical matching relation. A tiling for (T,H, V ) is a map f : {0, . . . , n}×{0, . . . ,m} → T such that n,m ≥ 0, f(0, 0) = Tinit, f(n,m) = Tfinal, (f(i, j), f(i + 1, j)) ∈ H for all i < n, and (f(i, j), f(i, j + 1)) ∈ V for all i < m. We say that P admits a tiling if there exists a map f that is a tiling for P. It is undecidable whether an instance of the finite rectangle tiling problem admits a tiling.\nNow let P = (T,H, V ) be a finite rectangle tiling problem with T = {T1, . . . , Tp}. We regard the tile types in T as concept names and set Σg = {T1, . . . , Tp, x, y, x̂, ŷ}, where x, y, x̂, and ŷ are functional role names. The TBox TP is defined as the following set of CIs, where (Ti, Tj , Tℓ) range over all triples from T such that (Ti, Tj) ∈ H and (Ti, Tℓ) ∈ V and where for e ∈ {c, x, y}\nthe concept Be ranges over all conjunctions L1 ⊓ L2 with Li ∈ {Ze,i,¬Ze,i}, for concept names Ze,i (i = 1, 2):\nTfinal ⊑ Y ⊓ U ⊓R\n∃x.(U ⊓ Y ⊓ Tj) ⊓ Ix ⊓ Ti ⊑ U ⊓ Y\n∃y.(R ⊓ Y ⊓ Tℓ) ⊓ Iy ⊓ Ti ⊑ R ⊓ Y\n∃x.(Tj ⊓ Y ⊓ ∃y.Y ) ⊓ ∃y.(Tℓ ⊓ Y ⊓ ∃x.Y ) ⊓ Ix ⊓ Iy ⊓ C ⊓ Ti ⊑ Y\nY ⊓ Tinit ⊑ A\nBx ⊓ ∃x.∃x̂.Bx ⊑ Ix\nBy ⊓ ∃y.∃ŷ.By ⊑ Iy\n∃x.∃y.Bc ⊓ ∃y.∃x.Bc ⊑ C\n⊔ 1≤s<t≤p Ts ⊓ Tt ⊑ ⊥\nU ⊑ ∀y.⊥ R ⊑ ∀x.⊥ U ⊑ ∀x.U R ⊑ ∀y.R\nY ⊓ Tinit ⊑ D ⊓ L D ⊑ ∀ŷ.⊥ L ⊑ ∀x̂.⊥ D ⊑ ∀x.D ⊓ ∀x̂.D L ⊑ ∀y.L ⊓ ∀ŷ.L\nWith the exception of the CIs in the last line, the TBox TP has been defined and analyzed in [BBLW16]. Here, we briefly give intuition and discuss its main properties. The role names x and y are used to represent horizontal and vertical adjacency of points in a rectangle. The role names x̂ and ŷ are used to simulate the inverses of x and y. The concept names in TP serve the following puroposes:\n• U , R, L, and D mark the upper, right, left, and lower (‘down’) border of the rectangle. • In the Bc concepts, the concept names Zc,1 and Zc,2 serve as second-order variables and\nensure that a flag C is set at positions where the grid cell is closed. • In the concepts Bx and By, the concept names Zx,1, Zx,2, Zy,1, Zy,2 also serve as second-\norder variables and ensure that flags Ix and Iy are set at positions where x and x̂ as well as y and ŷ are inverse to each other. • The concept name Y is propagated through the grid from the upper right corner to the lower left one, ensuring that these flags are set everywhere, that every position of the grid is labeled with at least one tile type, and that the horizontal and vertical matching conditions are satisfied. • Finally, when the lower left corner of the grid is reached, the concept name A is set as a flag.\nBecause of the use of the concepts Be, CQ evaluation w.r.t. TP is coNP-hard: we leave it as an exercise to the reader to verify that TP does not have the ABox disjunction property. TP without the three CIs involving the concepts Be, however, is (equivalent to) a Horn-ALCF TBox and thus enjoys PTIME CQ-evaluation. It can also be verified that TP admits trivial models. Call a Σg-ABox A an grid ABox (with initial individual a) if A represents a grid along with a proper tiling for P. In detail, we require that there is a tiling f for P with domain {0, . . . , n}×{0, . . . ,m} and a bijection g : {0, . . . , n} × {0, . . . ,m} → Ind(A) with g(0, 0) = a such that\n• for all j < n, k ≤ m: T (g(j, k)) ∈ A iff T = f(j, k); • for all b1, b2 ∈ Ind(A): x(b1, b2) ∈ A iff x̂(b2, b1) ∈ A iff there are j < n, k ≤ m such\nthat (b1, b2) = (g(j, k), g(j + 1, k)); • for all b1, b2 ∈ Ind(A): y(b1, b2) ∈ A iff ŷ(b2, b1) ∈ A iff there are j ≤ n, k < m such that (b1, b2) = (g(j, k), g(j, k + 1)).\nClearly, if P admits a tiling then a grid ABox exists and for any grid ABox A, TP,A |= A(a) for the (uniquely determined) initial individual a of A. The following summarizes relevant properties of Σg-ABoxes that follow almost directly from the analysis of TP in [BBLW16]. We say that an ABox A contains an ABox A′ if A′ ⊆ A and that A contains a closed ABox A if, additionally, r(a, b) ∈ A and a ∈ Ind(A′) implies r(a, b) ∈ A′ for r ∈ {x, y, x̂, ŷ}. Moreover, we say that inconsistency of (Σ-)ABoxes w.r.t. a TBox T is Datalog6=-rewritable if there is a Boolean Datalog6=-program Π such that for any (Σ-)ABox A, A |= Π() iff A is inconsistent w.r.t. T .\nLemma 35. Let P be a finite rectangle tiling problem. Then the following holds. (1) Inconsistency of Σg-ABoxes w.r.t. TP is Datalog6=-rewritable. (2) If a Σg-ABox A is consistent w.r.t. TP, then it is Σg-strongly consistent w.r.t. TP and A\ncontains • closed grid ABoxes A1, . . . ,An, n ≥ 0, with mutually disjoint sets Ind(Ai) and • a (possibly empty) Σg-ABox A′ disjoint from A1 ∪ · · · ∪ An such that A = A1 ∪ · · · ∪ An ∪ A′ and TP,A |= A(a) iff a is the initial node of some Ai. Moreover, there is a model I witnessing Σg-strong consistency w.r.t. TP that satisfies a ∈ AI iff a is the initial node of some Ai.\nProof. (1) Assume a Σg-ABox A is given. Apply the following rules exhaustively to A: (a) add Ix(a) to A if there exists b with x(a, b), x̂(b, a) ∈ A; (b) add Iy(a) to A if there exists b with y(a, b), ŷ(b, a) ∈ A; (c) add C(a) to A if there exist a1, a2, b with x(a, a1), y(a, a2), y(a1, b), x(a2, b) ∈ A. Denote the resulting ABox by A†. Now remove the three CIs involving the concepts Be from TP and denote by T †P the resulting TBox. Using the analysis of the CIs involving the concepts Be in [BBLW16], one can show that A is consistent w.r.t. TP iff A† is consistent w.r.t. T † P. Since the latter is a Horn-ALCF -TBox, it is unraveling tolerant and one can build a Datalog6=-rewriting of the inconsistency of Σg-ABoxes w.r.t. T † P, essentially as in the proof of Theorem 24. Finally, the obtained program can be modified so as to behave as if started on A† when started on A, by implementing rules (a) to (c) as Datalog rules.\n(2) This is almost a direct consequence of the properties established in [BBLW16]. In particular, one finds the desired model I from the ‘moreover’ part by applying the three rules from the proof of Point (1) and then applying the CIs in T †P as rules. The only condition on the decomposition of the ABox A into A = A1∪ · · · ∪An ∪A′ that does not follow from [BBLW16] is that the containment of A1, . . . ,An in A is closed also for the role names x̂ and ŷ. To ensure this condition, we use the CIs that mention L and D that were not present in the TBox used in that paper. In fact, the following two properties follow directly from these CIs: (i) the individuals c reachable along an x-path in A from some a with TP,A |= A(a) all satisfy TP,A |= D(c) and so do not have an x̂-successor; and (ii) the individuals c reachable along a y-path in A from some a with TP,A |= A(a) all satisfy TP,A |= L(c) and so do not have a ŷ-successor. (i) and (ii) together with the properties established in [BBLW16] entail that the containment of A1, . . . ,An in A is closed also for the role names x̂ and ŷ, as required. ❏\nNote that it follows from Lemma 35 (2) that if A is consistent w.r.t. T , then the sequence A1, . . . ,An is empty iff TP,A 6|= ∃xA(x) (and A′ is non-empty since ABoxes are non-empty). In particular this must be the case when P does not admit a tiling. In the proof Lemma 36 below, this is actually\nall we need from from Lemma 35 (2). In full generality, it will only be used in the proof of nondichotomy later on. We also remark that the decomposition A1 ∪ · · · ∪ An ∪A′ of A in Lemma 35 (2) is unique.\nLet T = TP∪{A ⊑ B1⊔B2}, where B1 and B2 are fresh concept names. Set Σ = sig(TP)\\Σg and let T ′ ∪ T ∃ be the enriched Σ-abstraction of T .\nLemma 36.\n(1) If P admits a tiling, then CQ-evaluation w.r.t. T ′ ∪ T ∃ is CONP-hard and T ′ ∪ T ∃ is not materializable. (2) If P does not admit a tiling, then CQ-evaluation w.r.t. T ′ ∪ T ∃ is Datalog6=-rewritable and T ′ ∪ T ∃ is materializable.\nProof. (1) If P admits a tiling, then there is a grid ABox A with initial node a. A uses symbols from Σg, only. We have TP,A |= A(a) and A is consistent w.r.t. TP. Thus T ,A |= B1⊔B2(a) and T ,A 6|= Bi(a) for i = 1, 2. By Lemma 30 (2), T ′∪T ∃,A |= B1⊔B2(a) and T ′∪T ∃,A 6|= Bi(a) for i = 1, 2. Thus T ′ ∪ T ∃ does not have the ABox disjunction property. It follows that T ′ ∪ T ∃ is not materializable and that CQ-evaluation w.r.t. T ′ ∪ T ∃ is CONP-hard.\n(2) Assume that P does not admit a tiling. Let q be a PEQ. We show how to construct a Datalog6=-rewriting Π of (T ′ ∪ T ∃, q). On ABoxes A that are inconsistent w.r.t. T ′ ∪ T ∃, Π is supposed to return all tuples over Ind(A) of the same arity as q. By Lemma 30 (1), an ABox A is consistent w.r.t. T ′ ∪ T ∃ iff A|Σ is consistent w.r.t. T . It thus follows from Lemma 35 (1) that inconsistency of ABoxes w.r.t. T ′ ∪ T ∃ is Datalog6=-rewritable. From a concrete rewriting, we can build a Datalog6=-program Π0 that checks inconsistency and, if successful, returns all answers.\nNow for ABoxes A that are consistent w.r.t. T ′ ∪ T ∃. By Lemma 30 (1), A|Σ is consistent w.r.t. TP. Since P does not admit a tiling and by Lemma 35 (2), TP,A|Σ 6|= ∃xA(x). Thus, by Lemma 35 (2) we find a model I of TP and A|Σ such that ∆\nI = Ind(A), AI = {a | A(a) ∈ A} for all A 6∈ Σ, rI = {(a, b) | r(a, b) ∈ A} for all role names r, and AI = ∅. Since AI = ∅, I is a model of T . From Lemma 30 (4), we thus obtain that T ′ ∪ T ∃,A |= q(~a) iff T ∃,A |= q(~a), for all ~a. By Lemma 30 (3), (T ∃, q) is Datalog6=-rewritable into a program Π1.\nThe desired program Π is simply the union of Π0 and Π1, assuming disjointness of IDB relations. ❏\nLemma 36 implies the announced undecidability results.\nTheorem 37. For ALCF-TBoxes T , the following problems are undecidable (Points 1 and 2 are subject to the side condition that PTIME 6= NP):\n(1) CQ-evaluation w.r.t. T is in PTIME; (2) CQ-evaluation w.r.t. T is CONP-hard; (3) T is Datalog6=-rewritable; (4) T is materializable.\nWe now come to the proof of non-dichotomy.\nTheorem 38. For every language L ∈ CONP, there exists an ALCF-TBox T such that, for a distinguished concept name M0, the following holds:\n(1) L is polynomial time reducible to the evaluation of (T ,∃xM0(x)); (2) the evaluation of (T , q) is polynomial time reducible to L, for all PEQs q.\nTo prove Theorem 38 let L ∈ CONP. Take a non-deterministic polynomial time Turing Machine M that recognizes the complement of L. Let M = (Q,Γ0,Γ1,∆, q0, qa, qr) with Q a finite set of states, Γ0 and Γ1 finite input and tape alphabets such that Γ0 ⊆ Γ1 and Γ1 \\ Γ0 contains the blank symbol β, q0 ∈ Q the starting state, ∆ ⊆ Q × Γ1 × Q × Γ1 × {L,R} the transition relation, and qa, qr ∈ Q the accepting and rejecting states. Denote by L(M) the language recognized by M . We can assume w.l.o.g. that there is a fixed symbol γ0 ∈ Γ0 such that all words accepted by M are of the form γ0v with v ∈ (Γ0 \\ {γ0})∗; in fact, it is easy to modify M to satisfy this property without changing the complexity of its word problem. We also assume that for any input v ∈ Γ∗0, M uses exactly |v|k1 cells for the computation, halts after exactly |v|k2 steps in the accepting or rejecting state, and does not move to the left of the starting cell.\nTo represent inputs to M and to provide the space for simulating computations, we use grid ABoxes as in the proof of Theorem 37, where the tiling of the bottom row represents the input word followed by blank symbols. As the set of tile types, we use T = Γ0 ∪ {β, T, Tfinal} where T is a ‘default tile’ that labels every position except those in the bottom row and the upper right corner. Identify Tinit with γ0 and let Σg = Γ0∪{β, T, Tfinal}∪{x, y, x̂, ŷ}. Consider the TBox TPM defined above, for PM = (T,H, V ) with\nH = {(γ0, γ), (γ, γ ′), (γ, β), (β, β), (T, T ), (T, Tfinal) | γ, γ ′ ∈ Γ0 \\ {γ0}}\nV = {(γ, T ), (β, T ), (T, T ), (T, Tfinal), (γ, Tfinal), (β, Tfinal) | γ ∈ Γ0}.\nRecall that TPM checks whether a given Σg-ABox contains a grid structure with a tiling that respects H , V , Tinit, and Tfinal, and derives the concept name A at the lower left corner of such grids. We now construct a TBox TM that, after the verification has finished, initiates a computation of M on the grid. In addition to the concept names in TPM , TM uses concept names Aγ and Aq,γ for all γ ∈ Γ1 and q ∈ Q to represent symbols written during the computation (in contrast to the elements of Γ1 as concept names, used to encode the input word) and to represent the state and head position. In detail, TM contains the following CIs:\n• When the verification of the grid has finished, A floods the ABox:\nA ⊑ ∀r.A for all r ∈ {x, y, x̂, ŷ}.\n• The initial configuration is as required:\nγ0 ⊓A ⊑ Aq0,γ γ ⊓A ⊑ Aγ for all γ ∈ (Γ0 ∪ {β}) \\ {γ0}.\n• For every (q, γ) ∈ Q× Γ1, the transition relation of M is satisfied:\nAq,γ ⊓A ⊑ ⊔ (q,γ,q′,γ′,L)∈∆ ∃y.(Aγ′ ⊓ ⊔ γ′′∈Γ1 ∃x̂.Aq′,γ′′) ⊔\n⊔ (q,γ,q′,γ′,R)∈∆ ∃y.(Aγ′ ⊓ ⊔ γ′′∈Γ1 ∃x.Aq′,γ′).\n• The symbol written on a cell does not change if the head is not on the cell:"
    }, {
      "heading" : "Aγ ⊓A ⊑ ∀y.Aγ for all γ ∈ Γ1",
      "text" : "• The rejecting state is never reached:\nAqr,γ ⊓A ⊑ ⊥ for all γ ∈ Γ1.\nLet T = TPM ∪ TM . We are going to show that an appropriate extended abstraction of T satisfies Conditions (1) and (2) of Theorem 38. We start with the following lemma which summarizes two important properties of T .\nLemma 39.\n(1) T admits trivial models. (2) For any Σg-ABox A, A is consistent w.r.t. T iff the following two conditions hold:\n(a) A is consistent w.r.t. TPM ; (b) let A = A1 ∪ · · · ∪ An ∪ A′ be the decomposition of A given in Lemma 35 (2) and\nassume that Ai is the ni × mi-grid ABox with input vi for 1 ≤ i ≤ n. Then the following hold for 1 ≤ i ≤ n:\n(i) ni ≥ |vi|k1 and mi ≥ |vi|k2 and (ii) vi ∈ L(M).\nMoreover, if A is consistent w.r.t. T , then it is strongly Σg-consistent w.r.t. T .\nProof. Since (1) follows directly from the shape of the CIs in T , we concentrate on (2). Assume first that A is consistent w.r.t. T . Then A is consistent w.r.t. TPM and so we can assume that there is a decomposition A1∪· · · An∪A′ of A as in Lemma 35 (2). By definition, each Ai is an ni×mi-grid ABox with input vi. Since A is consistent w.r.t. T , there is a model I of A and T . By the first CIs of TM and since the initial node a of each Ai must be in AI by Lemma 35, Ind(Ai) ⊆ AI for each i. Thus the restriction of I to Ind(Ai) simulates an accepting computation of M starting with vi. But since every computatation of M starting with a word of length n requires at least nk1 space and mk2 time and the containment of Ai in A is closed for the role names x and y, this is impossible if ni < |vi|\nk1 or mi < |vi|k2 and also if vi 6∈ L(M). Thus (i) and (ii) hold, as required. For the converse direction, assume that (a) and (b) hold. Since A is consistent w.r.t. TPM , there is a decomposition A1 ∪ · · · ∪ An ∪ A′ of A as in Lemma 35 (2). Also by Lemma 35 (2), there is a model I that witnesses strong Σg-consistency of A w.r.t. TPM such that a ∈ A\nI iff a is the initial node of some Ai. We construct a model I ′ of T by modifying I as follows: with the exception of A, the symbols of TPM are interpreted in the same way as in I and thus I\n′ is a model of TPM . To satisfy the first CI of TM , we set AI ′ = Ind(A1 ∪ · · · ∪ An). Note that this suffices since the containment of each Ai in A is closed for the role names x and y. The remaining symbols from TM are now interpreted in such a way that they describe on each Ai an accepting computation for vi. This is possible since vi ∈ L(M), ni ≥ |vi|k1 and mi ≥ |vi|k2 , and each computation of M starting with a word v of length n requires at most nk1 space and mk2 time. It can be verified that I ′ is a model of TM ; note that since A is a conjunct of the left hand side of every CI in TM , the CIs in TM are trivially satisfied in every node d ∈ ∆I \\ Ind(A1 ∪ · · · ∪An). Thus I ′ satisfies T and A and we have proved consistency of A w.r.t. T , as required.\nFor the ‘moreover’ part of the lemma, it suffices to observe that I ′ witnesses strong Σgconsistency of A w.r.t. T . ❏\nWe are now in the position to prove non-dichotomy.\nProof of Theorem 38. Let L ∈ CONP and let M and T be the TM and TBox from above. Set Σ = sig(T )\\Σg and let T ′∪T ∃ be the enriched Σ-abstraction of T . Thus, the only concept names that we are not ‘hiding’ are the concept names in Σg. We show that T satisfies Points (1) and (2) from Theorem 38.\n(1) It suffices to give a polynomial time reduction from L(M) to the complement of evaluating (T ′ ∪ T ∃,∃xM0(x)) (note that M0 does not occur in any of the involved TBoxes). Assume that an input word v for M is given. If v is not from γ0(Γ0 \\ {γ0}), then reject. Otherwise, construct in polynomial time the |v|k1×|v|k2 -grid ABox A with input v. Observe that A is consistent w.r.t. TPM and has the trivial decomposition A = A1 in Lemma 35 (2). Thus Lemma 39 (2) implies that v ∈ L(M) iff A is consistent w.r.t. T . The latter condition is equivalent to T ,A 6|= ∃xM0(x) since\nM0 does not occur in A or T . Since T admits trivial models, Lemma 30 (2) thus yields v ∈ L(M) iff T ′ ∪ T ∃,A 6|= ∃xM0(x).\n(2) We first make the following observation.\nClaim 1. T ′ ∪ T ∃,A |= q(~a) iff • A|Σg is not consistent w.r.t. T or • T ∃,A |= q(~a).\nFor the ‘only if’ direction, observe that if A|Σg is consistent w.r.t. T , then Lemma 39 yields that A is strongly Σg-consistent w.r.t. T . Thus, by Lemma 30 (4), T ′ ∪ T ∃,A |= q(~a) iff T ∃,A |= q(~a). For the ‘if’ direction, observe that if A|Σg is not consistent w.r.t. T , then by Lemma 30 (1) A is not consistent w.r.t. T ′ ∪ T ∃. This finishes the proof of the claim.\nBy Lemma 30 (3), T ∃,A |= q(~a) can be decided in polynomial time. Thus, Claim 1 implies that it suffices to give a polynomial time reduction of ABox consistency w.r.t. T to L(M). But Lemma 39 (2) provides a polynomial reduction of ABox consistency w.r.t. T to L(M) since\n• Condition (a) of Lemma 39 (2) can be checked in polynomial time (by Lemma 35 (1)); • the decomposition of A in Condition (b) of Lemma 39 (2) as well as the words vi, 1 ≤ i ≤ n, can be computed in polynomial time; • and Point (i) of Condition (b) can be checked in polynomial time.\nIt thus remains to check whether vi ∈ L(M) for 1 ≤ i ≤ n. This finishes the proof of Theorem 38.\nTheorems 38 and 19 imply that that there is no PTIME/CONP-dichotomy, unless PTIME = NP. Observe that the TBoxes constructed in the undecidability and the non-dichotomy proof are both of depth four. This can be easily reduced to depth three: recall that the TBoxes of depth four are obtained from TBoxes T of depth two by taking their enriched Σ-abstractions. One can obtain a TBox of depth three (for which query evaluation has the same complexity up to polynomial time reductions) by first replacing in T compound concepts C in the scope of a single value or existential restriction by fresh concept names AC and adding AC ≡ C to T . Then the fresh concept names are added to the signature Σ and one constructs the enriched abstraction of the resulting TBox for the extended signature. This TBox is as required. Thus, our undecidability and non-dichotomy results hold for ALCF TBoxes of depth three already."
    }, {
      "heading" : "8. DISCUSSION",
      "text" : "We have studied the complexity of query evaluation in the presence of an ontology formulated in a DL between ALC and ALCFI , focussing on the boundary between PTIME and CONP. For ALCFI-TBoxes of depth one (which covers the vast majority of practically relevant cases), our results are very positive: there is a dichotomy between PTIME and CONP and it can be precisely characterized in terms of unraveling tolerance and materializability. Moreover and unlike in the general case, PTIME complexity coincides with rewitability into Datalog6=. The case of higher or unrestricted depth is harder to analyze. We have shown that for ALC- and ALCI-TBoxes of depth three, the existence of a dichotomy between PTIME and CONP is equivalent to the Feder-Vardi conjecture that there is a dichotomy between PTIME and NP for CSPs with finite template—the case of depth two remains as an open problem. For ALCF TBoxes of depth three we have shown that there is no dichotomy unless PTIME = NP and that deciding whether a given TBox admits PTIME query evaluation is undecidable, and so are related questions.\nSeveral interesting research questions remain. We briefly discuss three possible directions.\n(1) Is it decidable whether a given ALC- or ALCI-TBox admits PTIME query evaluation and, closely related, whether it is unraveling tolerant and whether it is materializable? We conjecture that this is indeed the case for TBoxes of depth one, but we have no conjecture for TBoxes of larger depth. It is interesting to point out that unraveling tolerance is decidable for OMQs whose TBox is formulated in ALCI (where a concrete query is given, unlike in the case of unraveling tolerance of TBoxes); in that case, unraveling tolerance is equivalent to rewritability into monadic Datalog [FKL]. It would also be interesting to study more general notions of unraveling tolerance based on unravelings into structures of bounded treewidth rather than into real trees.\n(2) It would be interesting to study additional complexity classes such as LOGSPACE, NLOGSPACE, and AC0. It is known that all these classes occur even for ALC TBoxes of depth one, see e.g. [CDL+13]. For example, CQ-evaluation w.r.t. the depth one EL-TBox {∃r.A ⊑ A}, which encodes reachability in directed graphs, is NLOGSPACE-complete. It would thus be interesting to identify further dichotomies such as between NLOGSPACE and PTIME. We conjecture that for ALCFI-TBoxes of depth one, it is decidable whether query evaluation is in PTIME, NLOGSPACE, LOGSPACE, and AC0.\n(3) Apart from deciding whether query evaluation w.r.t. a given TBox has a certain complexity, it is also interesting to decide whether the TBox admits rewritability into relevant query languages such as FO-queries or Datalog queries. In the context of OMQs, several results have been obtained, see e.g. [BLW13, HLSW15, BHLW16] for FO-rewritability of OMQs whose TBox is formulated in a Horn DL and [BtCLW14, FKL] for FO- and Datalog-rewritability of OMQs whose TBox is formulated in ALC or an extension thereof. In the TBox (rather than OMQ) case, a first relevant result has been established in [LW11] where it is shown that that FO-rewritability is decidable for materializable ALCFI-TBoxes of depth one. This underlines the importance of deciding materializability, which would allow to lift this result to (otherwise unrestricted) ALCFI-TBoxes of depth one.\nAcknowledgments. Carsten Lutz was supported by ERC consolidator grant 647289. Frank Wolter was supported by EPSRC grant EP/M012646/1."
    } ],
    "references" : [ {
      "title" : "The complexity of satisfiability problems: Refining Schaefer’s theorem",
      "author" : [ "Eric Allender", "Michael Bauland", "Neil Immerman", "Henning Schnoor", "Heribert Vollmer" ],
      "venue" : "In MFCS,",
      "citeRegEx" : "Allender et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Allender et al\\.",
      "year" : 2005
    }, {
      "title" : "The DL-Lite family and relations",
      "author" : [ "Alessandro Artale", "Diego Calvanese", "Roman Kontchakov", "Michael Zakharyaschev" ],
      "venue" : "J. Artif. Intell. Res. (JAIR),",
      "citeRegEx" : "Artale et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2009
    }, {
      "title" : "On datalog vs. polynomial time",
      "author" : [ "Foto N. Afrati", "Stavros S. Cosmadakis", "Mihalis Yannakakis" ],
      "venue" : "In PODS,",
      "citeRegEx" : "Afrati et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Afrati et al\\.",
      "year" : 1991
    }, {
      "title" : "Constraint satisfaction problem and universal algebra",
      "author" : [ "Libor Barto" ],
      "venue" : "SIGLOG News,",
      "citeRegEx" : "Barto.,? \\Q2014\\E",
      "shortCiteRegEx" : "Barto.",
      "year" : 2014
    }, {
      "title" : "Pushing the EL envelope. In IJCAI, pages 364–369",
      "author" : [ "Franz Baader", "Sebastian Brandt", "Carsten Lutz" ],
      "venue" : "Professional Book Center,",
      "citeRegEx" : "Baader et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2005
    }, {
      "title" : "Query and predicate emptiness in ontology-based data access",
      "author" : [ "Franz Baader", "Meghyn Bienvenu", "Carsten Lutz", "Frank Wolter" ],
      "venue" : "J. Artif. Intell. Res. (JAIR),",
      "citeRegEx" : "Baader et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2016
    }, {
      "title" : "Querying the guarded fragment",
      "author" : [ "Vince Barany", "Georg Gottlob", "Martin Otto" ],
      "venue" : "In LICS,",
      "citeRegEx" : "Barany et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Barany et al\\.",
      "year" : 2010
    }, {
      "title" : "First order-rewritability and containment of conjunctive queries in Horn description logics",
      "author" : [ "Meghyn Bienvenu", "Peter Hansen", "Carsten Lutz", "Frank Wolter" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Bienvenu et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Bienvenu et al\\.",
      "year" : 2016
    }, {
      "title" : "Classifying the complexity of constraints using finite algebras",
      "author" : [ "Andrei A. Bulatov", "Peter Jeavons", "Andrei A. Krokhin" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "Bulatov et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Bulatov et al\\.",
      "year" : 2005
    }, {
      "title" : "First-order rewritability of atomic queries in horn description logics",
      "author" : [ "Meghyn Bienvenu", "Carsten Lutz", "Frank Wolter" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Bienvenu et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Bienvenu et al\\.",
      "year" : 2013
    }, {
      "title" : "Walking the complexity lines for generalized guarded existential rules",
      "author" : [ "Jean-Francois Baget", "Marie-Laure Mugnier", "Sebastian Rudolph", "Michael Thomazo" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Baget et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Baget et al\\.",
      "year" : 2011
    }, {
      "title" : "Ontology-mediated query answering with data-tractable description logics",
      "author" : [ "Meghyn Bienvenu", "Magdalena Ortiz" ],
      "venue" : "In Reasoning Web,",
      "citeRegEx" : "Bienvenu and Ortiz.,? \\Q2015\\E",
      "shortCiteRegEx" : "Bienvenu and Ortiz.",
      "year" : 2015
    }, {
      "title" : "Ontology-based data access: A study through disjunctive datalog, CSP, and MMSNP",
      "author" : [ "Meghyn Bienvenu", "Balder ten Cate", "Carsten Lutz", "Frank Wolter" ],
      "venue" : "ACM Trans. Database Syst.,",
      "citeRegEx" : "Bienvenu et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Bienvenu et al\\.",
      "year" : 2014
    }, {
      "title" : "A dichotomy theorem for constraints on a three-element set",
      "author" : [ "Andrei A. Bulatov" ],
      "venue" : "In FOCS,",
      "citeRegEx" : "Bulatov.,? \\Q2002\\E",
      "shortCiteRegEx" : "Bulatov.",
      "year" : 2002
    }, {
      "title" : "On the CSP dichotomy conjecture",
      "author" : [ "Andrei A. Bulatov" ],
      "venue" : "In CSR,",
      "citeRegEx" : "Bulatov.,? \\Q2011\\E",
      "shortCiteRegEx" : "Bulatov.",
      "year" : 2011
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Riccardo Rosati" ],
      "venue" : "J. of Autom. Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Data complexity of query answering in description logics",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Riccardo Rosati" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2013
    }, {
      "title" : "Taming the infinite chase: Query answering under expressive relational constraints",
      "author" : [ "Andrea Calı", "Georg Gottlob", "Michael Kifer" ],
      "venue" : "J. Artif. Intell. Res. (JAIR),",
      "citeRegEx" : "Calı̀ et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Calı̀ et al\\.",
      "year" : 2013
    }, {
      "title" : "View-based query processing and constraint satisfaction",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Moshe Y. Vardi" ],
      "venue" : "In LICS,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2000
    }, {
      "title" : "Reasoning on regular path queries",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Moshe Y. Vardi" ],
      "venue" : "SIGMOD Record,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2003
    }, {
      "title" : "View-based query containment",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Moshe Y. Vardi" ],
      "venue" : "In PODS,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2003
    }, {
      "title" : "What you always wanted to know about datalog (and never dared to ask)",
      "author" : [ "Stefano Ceri", "Georg Gottlob", "Letizia Tanca" ],
      "venue" : "IEEE Trans. Knowl. Data Eng.,",
      "citeRegEx" : "Ceri et al\\.,? \\Q1989\\E",
      "shortCiteRegEx" : "Ceri et al\\.",
      "year" : 1989
    }, {
      "title" : "Model Theory, volume 73 of Studies in Logic and the Foundations of Mathematics",
      "author" : [ "C.C. Chang", "H. Jerome Keisler" ],
      "venue" : null,
      "citeRegEx" : "Chang and Keisler.,? \\Q1990\\E",
      "shortCiteRegEx" : "Chang and Keisler.",
      "year" : 1990
    }, {
      "title" : "Query answering in the description logic Horn-SHIQ",
      "author" : [ "Thomas Eiter", "Georg Gottlob", "Magdalena Ortiz", "Mantas Simkus" ],
      "venue" : "In JELIA,",
      "citeRegEx" : "Eiter et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2008
    }, {
      "title" : "Data exchange: semantics and query answering",
      "author" : [ "Ronald Fagin", "Phokion G. Kolaitis", "Renée J. Miller", "Lucian Popa" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "Fagin et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Fagin et al\\.",
      "year" : 2005
    }, {
      "title" : "Monotone monadic SNP and constraint satisfaction",
      "author" : [ "Tomás Feder", "Moshe Y. Vardi" ],
      "venue" : "In STOC,",
      "citeRegEx" : "Feder and Vardi.,? \\Q1993\\E",
      "shortCiteRegEx" : "Feder and Vardi.",
      "year" : 1993
    }, {
      "title" : "Conjunctive query answering for the description logic SHIQ",
      "author" : [ "Birte Glimm", "Carsten Lutz", "Ian Horrocks", "Ulrike Sattler" ],
      "venue" : "JAIR, 31:157–204,",
      "citeRegEx" : "Glimm et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Glimm et al\\.",
      "year" : 2008
    }, {
      "title" : "Model theory of modal logic",
      "author" : [ "Valentin Goranko", "Martin Otto" ],
      "venue" : "In Handbook of Modal Logic,",
      "citeRegEx" : "Goranko and Otto.,? \\Q2007\\E",
      "shortCiteRegEx" : "Goranko and Otto.",
      "year" : 2007
    }, {
      "title" : "Efficient query rewriting in the description logic EL and beyond",
      "author" : [ "Peter Hansen", "Carsten Lutz", "Inanç Seylan", "Frank Wolter" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Hansen et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Hansen et al\\.",
      "year" : 2015
    }, {
      "title" : "Reasoning in description logics by a reduction to disjunctive datalog",
      "author" : [ "Ullrich Hustadt", "Boris Motik", "Ulrike Sattler" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2007
    }, {
      "title" : "On the complexity of h-coloring",
      "author" : [ "Pavol Hell", "Jaroslav Nesetril" ],
      "venue" : "J. Comb. Theory, Ser. B,",
      "citeRegEx" : "Hell and Nesetril.,? \\Q1990\\E",
      "shortCiteRegEx" : "Hell and Nesetril.",
      "year" : 1990
    }, {
      "title" : "Consequence-driven reasoning for Horn-SHIQ ontologies",
      "author" : [ "Yevgeny Kazakov" ],
      "venue" : null,
      "citeRegEx" : "Kazakov.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kazakov.",
      "year" : 2009
    }, {
      "title" : "Data complexity in the EL family of description logics",
      "author" : [ "Adila Krisnadhi", "Carsten Lutz" ],
      "venue" : "In LPAR,",
      "citeRegEx" : "Krisnadhi and Lutz.,? \\Q2007\\E",
      "shortCiteRegEx" : "Krisnadhi and Lutz.",
      "year" : 2007
    }, {
      "title" : "The combined approach to query answering in DL-Lite",
      "author" : [ "Roman Kontchakov", "Carsten Lutz", "David Toman", "Frank Wolter", "Michael Zakharyaschev" ],
      "venue" : "In KR,",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2010
    }, {
      "title" : "Complexity boundaries for Horn description logics",
      "author" : [ "Markus Krötzsch", "Sebastian Rudolph", "Pascal Hitzler" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Krötzsch et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2007
    }, {
      "title" : "Tree dualities for constraint satisfaction",
      "author" : [ "Andrei A. Krokhin" ],
      "venue" : "In CSL,",
      "citeRegEx" : "Krokhin.,? \\Q2010\\E",
      "shortCiteRegEx" : "Krokhin.",
      "year" : 2010
    }, {
      "title" : "Efficient inferencing for OWL EL",
      "author" : [ "Markus Krötzsch" ],
      "venue" : "In JELIA, pages 234–246,",
      "citeRegEx" : "Krötzsch.,? \\Q2010\\E",
      "shortCiteRegEx" : "Krötzsch.",
      "year" : 2010
    }, {
      "title" : "A new line of attack on the dichotomy conjecture",
      "author" : [ "Gábor Kun", "Mario Szegedy" ],
      "venue" : "In STOC,",
      "citeRegEx" : "Kun and Szegedy.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kun and Szegedy.",
      "year" : 2009
    }, {
      "title" : "An introduction to description logics and query rewriting",
      "author" : [ "Roman Kontchakov", "Michael Zakharyaschev" ],
      "venue" : "In Reasoning Web,",
      "citeRegEx" : "Kontchakov and Zakharyaschev.,? \\Q2014\\E",
      "shortCiteRegEx" : "Kontchakov and Zakharyaschev.",
      "year" : 2014
    }, {
      "title" : "A characterisation of first-order constraint satisfaction problems",
      "author" : [ "Benoit Larose", "Cynthia Loten", "Claude Tardif" ],
      "venue" : "Logical Methods in Computer Science,",
      "citeRegEx" : "Larose et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Larose et al\\.",
      "year" : 2007
    }, {
      "title" : "Description logic tboxes: Model-theoretic characterizations and rewritability",
      "author" : [ "Carsten Lutz", "Robert Piro", "Frank Wolter" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Lutz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2011
    }, {
      "title" : "Ontology-based data access with closed predicates is inherently intractable (sometimes)",
      "author" : [ "Carsten Lutz", "Inanç Seylan", "Frank Wolter" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "Lutz et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2013
    }, {
      "title" : "Ontology-mediated queries with closed predicates. In IJCAI, pages 3120–3126",
      "author" : [ "Carsten Lutz", "Inanç Seylan", "Frank Wolter" ],
      "venue" : null,
      "citeRegEx" : "Lutz et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2015
    }, {
      "title" : "Conjunctive query answering in the description logic EL using a relational database system",
      "author" : [ "Carsten Lutz", "David Toman", "Frank Wolter" ],
      "venue" : null,
      "citeRegEx" : "Lutz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2009
    }, {
      "title" : "Deciding inseparability and conservative extensions in the description logic EL",
      "author" : [ "Carsten Lutz", "Frank Wolter" ],
      "venue" : "J. Symb. Comput.,",
      "citeRegEx" : "Lutz and Wolter.,? \\Q2010\\E",
      "shortCiteRegEx" : "Lutz and Wolter.",
      "year" : 2010
    }, {
      "title" : "Non-uniform data complexity of query answering in description logics",
      "author" : [ "Carsten Lutz", "Frank Wolter" ],
      "venue" : "In Description Logics,",
      "citeRegEx" : "Lutz and Wolter.,? \\Q2011\\E",
      "shortCiteRegEx" : "Lutz and Wolter.",
      "year" : 2011
    }, {
      "title" : "Non-uniform data complexity of query answering in description logics. In KR",
      "author" : [ "Carsten Lutz", "Frank Wolter" ],
      "venue" : null,
      "citeRegEx" : "Lutz and Wolter.,? \\Q2012\\E",
      "shortCiteRegEx" : "Lutz and Wolter.",
      "year" : 2012
    }, {
      "title" : "Why Horn formulas matter in computer science: Initial structures and generic examples",
      "author" : [ "Johann A. Makowsky" ],
      "venue" : "J. Comput. Syst. Sci.,",
      "citeRegEx" : "Makowsky.,? \\Q1987\\E",
      "shortCiteRegEx" : "Makowsky.",
      "year" : 1987
    }, {
      "title" : "The metamathematics of algebraic systems, collected papers:1936-1967",
      "author" : [ "Anatoli I. Malcev" ],
      "venue" : null,
      "citeRegEx" : "Malcev.,? \\Q1971\\E",
      "shortCiteRegEx" : "Malcev.",
      "year" : 1971
    }, {
      "title" : "Initiality, induction, and computability",
      "author" : [ "Jose Meseguer", "Joseph A. Goguen" ],
      "venue" : null,
      "citeRegEx" : "Meseguer and Goguen.,? \\Q1985\\E",
      "shortCiteRegEx" : "Meseguer and Goguen.",
      "year" : 1985
    }, {
      "title" : "Data complexity of query answering in expressive description logics via tableaux",
      "author" : [ "Magdalena Ortiz", "Diego Calvanese", "Thomas Eiter" ],
      "venue" : "J. of Autom. Reasoning,",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "Antonella Poggi", "Domenico Lembo", "Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini", "Riccardo Rosati" ],
      "venue" : "J. Data Semantics,",
      "citeRegEx" : "Poggi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Poggi et al\\.",
      "year" : 2008
    }, {
      "title" : "The limits of querying ontologies",
      "author" : [ "Riccardo Rosati" ],
      "venue" : "In ICDT, volume 4353 of LNCS,",
      "citeRegEx" : "Rosati.,? \\Q2007\\E",
      "shortCiteRegEx" : "Rosati.",
      "year" : 2007
    }, {
      "title" : "The complexity of satisfiability problems",
      "author" : [ "Thomas J. Schaefer" ],
      "venue" : "In STOC, pages 216–226,",
      "citeRegEx" : "Schaefer.,? \\Q1978\\E",
      "shortCiteRegEx" : "Schaefer.",
      "year" : 1978
    }, {
      "title" : "On the complexity of the instance checking problem in concept languages with existential quantification",
      "author" : [ "Andrea Schaerf" ],
      "venue" : "J. of Intel. Inf. Systems,",
      "citeRegEx" : "Schaerf.,? \\Q1993\\E",
      "shortCiteRegEx" : "Schaerf.",
      "year" : 1993
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We analyze the data complexity of ontology-mediated querying where the ontologies are formulated in a description logic (DL) of the ALC family and queries are conjunctive queries, positive existential queries, or acyclic conjunctive queries. Our approach is non-uniform in the sense that we aim to understand the complexity of each single ontology instead of for all ontologies formulated in a certain language. While doing so, we quantify over the queries and are interested, for example, in the question whether all queries can be evaluated in polynomial time w.r.t. a given ontology. Our results include a PTIME/CONP-dichotomy for ontologies of depth one in the description logic ALCFI, the equivalence of a PTIME/CONP-dichotomy for ALCand ALCI-ontologies of unrestricted depth to the famous dichotomy conjecture for CSPs by Feder and Vardi, and the failure of PTIME/CONP-dichotomy theorem for ALCF -ontologies. Regarding the latter DL, we also show that it is undecidable whether a given ontology admits PTIME query evaluation.",
    "creator" : "LaTeX with hyperref package"
  }
}