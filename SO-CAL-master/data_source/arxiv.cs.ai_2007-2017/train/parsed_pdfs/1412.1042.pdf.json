{
  "name" : "1412.1042.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "A CSP implementation of the bigraph embedding problem",
    "authors" : [ "Marino Miculan", "Marco Peressotti" ],
    "emails" : [ "marino.miculan@uniud.it", "marco.peressotti@uniud.it" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Bigraphical Reactive Systems (BRSs) [14, 19] are a flexible and expressive meta-model for ubiquitous computation. System states are represented by bigraphs, which are compositional data structures describing at once both the locations and the logical connections of (possibly nested) components of a system. Like graph rewriting [24], the dynamic behaviour of a system is defined by a set of (parametric) reaction rules, which can modify a bigraph by replacing a redex with a reactum, possibly changing agents’ positions and connections.\nBRSs have been successfully applied to the formalization of a broad variety of domain-specific calculi and models, from traditional programming languages to process calculi for concurrency and mobility, from context-aware systems to web-service orchestration languages, from business processes to systems biology; a non exhaustive list is [2,4,5,8,16,18]. Very recently bigraphs have been used in structure-aware agent-based computing for modelling the structure of the (physical) world where the agents operates (e.g., drones, robots, etc.) [20].\nBeside their normative and expressive power, BRSs are appealing because they provide a range of interesting general results and tools, which can be readily instantiated with the specific model under scrutiny: simulation tools, systematic construction of compositional bisimulations [14], graphical editors [9], general model checkers [23], modular composition [22], stochastic extensions [15], etc.\nIn this paper, we give an implementation for a crucial problem that virtually all these tools have to deal with, i.e., the matching a bigraph inside an agent. Roughly, this can be stated as follows: given R and A, we have to find (all, or some) C,D such that A = C ◦ R ◦D. Clearly this is required by any simulation tool (in order to apply a reaction rule, we have to match the redex inside the agent, and then replace it with the reactum), but also in other tools, e.g., for implementing “find&replace” in graphical editors, for occurrence checks in sortings [1] and model checkers, for refinements in architectural design tools, etc.\nar X\niv :1\n41 2.\n10 42\nv1 [\ncs .L\nO ]\n1 D\nec 2\n01 4\nLike the similar and well-known subgraph isomorphism problem, bigraph matching is NPcomplete (see [3]). However, using the theory of Fixed Parameter Tractability it can be shown that the exponential explosion depends only on the size (more precisely, the width) of the redex to be found, and not on the size of the agent. In most practical cases, this width is constant and small (e.g. ≤ 3), hence the problem becomes feasible.\nA (rather ad-hoc) implementation of bigraph matching has been given in the BPLTool [7]; this was based on a term-based representation of agents and rules, in the spirit of term rewriting systems. More recently, a more graphical-oriented approach has been preferred. Højsgaard have introduced the notion of bigraph embedding [11], which is a function from nodes and edges of the redex to nodes and edges of the agent, describing how the former is embedded in the latter. Although embeddings and matchings are basically equivalent, embeddings turn out to be more useful especially in connection with Gillespie-like algorithms for stochastic simulations [11], because they allow for a simpler calculation of interference between redexes. In fact, embeddings are at the core of the Bigraphic Abstract Machine [21], a general abstract machine for implementing various kinds of BRSs, with several possible execution strategies.\nFor these reasons, in this paper we focus on the bigraph embedding problem. More precisely, we translate the embedding problem to a constraint satisfaction problem (CSP), whose solutions correspond to bigraph embeddings. Instead of defining directly a CSP for the bigraph embedding problem we take advantage of bigraphs being the “merge” of two graphical structures (called link graphs and place graphs respectively): initially we define the encoding for embeddings of these two orthogonal structures separately and then combine them by means of some consistency constraints reflecting the interplay between link and place structures. This split mimics the peculiar structure of bigraphs and allows us to factor the exposition of the problem, its encoding and the accompanying adequacy results. An implementation based on the CHOCO solver is available in LibBig (available at http://mads.dimi.uniud.it/), an extensible library for manipulating bigraphical reactive systems. However, this is an implementation choice mainly due to the use of Java, but the results of this paper can be implemented in any solver capable of handling the integer solutions of a linear equation system.\nWe do not provide an exhaustive discussion of experimental results because the encoding proposed is “solver-independent” and moreover, because there is no widely-acknowledged benchmark suit for this problem. In fact, finding a reasonably representative set of instances still is an open question.\nSynopsis In Section 2 we briefly recall the notion of bigraphs and bigraphical reactive systems and in Section 3 present the bigraph embedding problem, its complexity and how it can be divided in two sub-problems, by taking advantage of the components of bigraphs. The implementation of the bigraph embedding problem as a constraint satisfaction problem and the adequacy results are presented in Sections 4. Conclusions, with some experimental evaluations, and some directions for future work are in Section 5."
    }, {
      "heading" : "2 Bigraphical reactive systems",
      "text" : "In this section we briefly recall the notion of Bigraphical Reactive Systems (BRS) referring the interested reader to [19].\nThe key point of BRSs is that “the model should consist in some sort of reconfigurable space”. Agents may interact in this space, even if they are spatially separated. This means that two agents may be adjacent in two ways: they may be at the same place, or they may be connected by a link. This leads to the definition of bigraphs as a data structure for representing the state of the\nsystem. A bigraph can be seen as enriched hyper-graph combining two independent graphical structures over the same set of nodes: a hierarchy of places, and a hyper-graph of links.\nDefinition 1 (Bigraph [19, Def. 2.3]). A bigraph graph G over a given signature Σ (i.e. a set of types, called controls, denoting a finite arity) is a an object\n(VG, EG, ctrlG, prntG, linkG) : 〈nG, XG〉 → 〈mG, YG〉\ncomposed by two substructures (Figure 1): a place graph GP = (VG, ctrlG, prntG) : nG → mG and a link graph GL = (VG, EG, ctrlG, linkG) : XG → YG. The set VG is a finite set of nodes and to each of them is assigned a control in Σ by the control map ctrlG : VG → Σ. The set EG is a finite set of names called edges.\nThese structures presents an inner interface (composed by nG and XG) and an outer one (mG, YG) along which can be composed with other of their kind as long as they do not share any node or edge. In particular, XG and YG are finite sets of names and nG and mG are finite ordinals that index sites and roots respectively.\nOn the side of GP , nodes, sites and roots are organized in a forest described by the parent map prntG : VG ⊎ nG → VG ⊎mG such that sites are leaves and roots are exactly mG.\nOn the side of GL, nodes, edges and names of the inner and outer interface forms a hypergraph described by the link map linkG : PG ⊎XG → EG ⊎ YG which is a function from XG and ports PG (i.e. elements of the finite ordinal associated to each node by its control) to edges EG and names in YG.\nThe dynamic behaviour of a system is described in terms of reactions of the form a _ a′ where a, a′ are agents, i.e. bigraphs with inner interface 〈0, ∅〉. Reactions are defined by means of graph rewrite rules, which are pairs of bigraphs (RL, RR) equipped with a function η from the sites of RR to those of RL called instantiation rule. A bigraphical encoding for the open reaction rule of the Ambient Calculus is shown in Figure 2 where redex and reactum are the bigraph on the left and the one on the right respectively and the instantiation rule is drawn in red. A rule fires when its redex can be embedded into the agent; then, the matched part is replaced by the reactum and the parameters (i.e. the substructures determined by the sites of the redex) are instantiated accordingly with η."
    }, {
      "heading" : "3 Bigraph embeddings",
      "text" : "In this Section we briefly recall the notion of bigraph embedding. The following definitions are taken from [11], with minor modification to simplify the presentation of the equivalent CSP\n] ]\n] ]\n0 open\n1\namb\nx\n0 1\nx\nopenx. 0 ‖ ambx. 1 _ 0 ‖ 1\nFigure 2: Open reaction rule of the Ambient Calculus.\nformulation (cf. Section 4). As usual, we shall exploit the orthogonality of the link and place graphs, by defining link and place graph embeddings separately and then combine them to extend the notion to bigraph.\nLink graph Intuitively an embedding of link graphs is a structure preserving map from one link graph (the guest) to another (the host). As one would expect from a graph embedding, this map contains a pair of injections: one for the nodes and one for the edges (i.e., a support translation). The remaining of the embedding map specifies how names of the inner and outer interfaces should be mapped into the host link graph. Outer names can be mapped to any link; here injectivity is not required since a context can alias outer names. Dually, inner names can mapped to hyper-edges linking sets of points in the host link graph and such that every point is contained in at most one of these sets.\nDefinition 2 (Link graph embedding [11, Def 7.5.1]). Let G : XG → YG and H : XH → YH be two concrete link graphs. A link graph embedding φ : G →֒ H is a map φ , φv ⊎ φe ⊎ φi ⊎ φo (assigning nodes, edges, inner and outer names respectively) subject to the following conditions:\n(LGE-1) φv : VG  VH and φe : EG  EH are injective;\n(LGE-2) φi : XG  ℘(XH ⊎ PH) is fully injective: ∀x 6= x′ : φi(x) ∩ φi(x′) = ∅;\n(LGE-3) φo : YG → EH ⊎ YH in an arbitrary partial map; (LGE-4) img(φe) ∩ img(φo) = ∅ and img(φport) ∩⋃ img(φi) = ∅; (LGE-5) φp ◦ link−1G ∣∣ EG = link−1H ◦ φe;\n(LGE-6) ctrlG = ctrlH ◦ φv;\n(LGE-7) ∀p ∈ XG ⊎ PG : ∀p′ ∈ (φp)(p) : (φh ◦ linkG)(p) = linkh(p′)\nwhere φp , φi ⊎ φport, φh , φe ⊎ φo and φport : PG  PH is φport(v, i) , (φv(v), i)).\nThe first three conditions are on the single sub-maps of the embedding. Condition (LGE-4) ensures that no components (except for outer names) are identified; condition (LGE-5) imposes that points connected by the image of an edge are all covered. Finally, conditions (LGE-6) and (LGE-7) ensure that the guest structure is preserved i.e. node controls and point linkings are preserved.\nFigure 2: pen reaction rule of the bient alculus.\nfor ulation (cf. Section 4). s usual, e shall exploit the orthogonality of the link and place graphs, by defining link and place graph e beddings separately and then co bine the to extend the notion to bigraph.\nLink graph Intuitively an e bedding of link graphs is a structure preserving ap fro one link graph (the guest) to another (the host). s one would expect fro a graph e bedding, this ap contains a pair of injections: one for the nodes and one for the edges (i.e., a support translation). The re aining of the e bedding ap specifies how na es of the inner and outer interfaces should be apped into the host link graph. uter na es can be apped to any link; here injectivity is not required since a context can alias outer na es. ually, inner na es can\napped to hyper-edges linking sets of points in the host link graph and such that every point is contained in at ost one of these sets.\nefinition 2 (Link graph e bedding [11, ef 7.5.1]). Let : G YG and : H YH be two concrete link graphs. A link graph e bedding φ : ↪ is a ap φ φv ] φe ] φi ] φo (assigning nodes, edges, inner and outer na es respectively) subject to the following conditions:\n(L -1) φv : VG VH and φe : EG EH are injective;\n(L -2) φi : G ℘( H ] PH) is fully injective: ∀x 6 x′ : φi(x) ∩ φi(x′) ∅;\n(L -3) φo : YG EH ] YH in an arbitrary partial ap;\n(L E-4) i g(φe) ∩ i g(φo) ∅ and i g(φport) ∩ i g(φi) ∅; (L E-5) φp ◦ link−1G ∣∣ EG link−1H ◦ φe;\n(L E-6) ctrlG ctrlH ◦ φv;\n(L E-7) ∀p ∈ G ] PG : ∀p′ ∈ (φp)(p) : (φh ◦ linkG)(p) linkh(p′)\nwhere φp φi ] φport, φh φe ] φo and φport : PG PH is φport(v, i) (φv(v), i)).\nThe first three conditions are on the single sub- aps of the e bedding. Condition (L E-4) ensures that no co ponents (except for outer na es) are identified; condition (L E-5) i poses that points connected by the i age of an edge are all covered. Finally, conditions (L E-6) and (L E-7) ensure that the guest structure is preserved i.e. node controls and point linkings are preserved.\nPlace graph Like link graph embeddings, place graph embeddings are just a structure preserving injective map from nodes along with suitable maps for the inner and outer interfaces. In particular, a site is mapped to the set of sites and nodes that are “put under it” and a root is mapped to the host root or node that is “put over it” splitting the host place graphs in three parts: the guest image, the context and the parameter (which are above and below the guest image).\nDefinition 3 (Place graph embedding [11, Def 7.5.4]). Let G : nG → mG and H : nH → mH be two concrete place graphs. A place graph embedding φ : G ↪→ H is a map φ , φv ] φs ] φr (assigning nodes, sites and regions respectively) subject to the following conditions:\n(PGE-1) φv : VG VH is injective;\n(PGE-2) φs : nG ℘(nH ] VH) is fully injective;\n(PGE-3) φr : mG → VH ]mH in an arbitrary map; (PGE-4) img(φv) ∩ img(φr) = ∅ and img(φv) ∩⋃ img(φs) = ∅;\n(PGE-5) ∀r ∈ mG : ∀s ∈ nG : prnt∗H ◦ φr(r) ∩ φs(s) = ∅; (PGE-6) φc ◦ prnt−1G ∣∣ VG = prnt−1H ◦ φv;\n(PGE-7) ctrlG = ctrlH ◦ φv;\n(PGE-8) ∀c ∈ nG ] VG : ∀c′ ∈ φc(c) : (φf ◦ prntG)(c) = prntH(c′); where prnt∗H(c) = ⋃ i<ω prnt i(c), φf , φv ] φr, and φc , φv ] φs.\nConditions in the above definition follows the structure of Definition 2, the main notable difference is (PGE-5) which states that the image of a root can not be the descendant of the image of another. Conditions (PGE-1), (PGE-2) and (PGE-3) are on the three sub-maps composing the embedding; conditions (PGE-4) and (PGE-5) ensure that no components are identified; (PGE-6) imposes surjectivity on children and the last two conditions require the guest structure to be preserved by the embedding map.\nBigraph Finally, bigraph embeddings can now be defined as maps being composed by an embedding for the link graph with one for the place graph consistently with the interplay of these two substructures. In particular, the interplay is captured by a single additional condition ensuring that points in the image of an inner names reside in the parameter defined by the place graph embedding (i.e. are inner names or ports of some node under a site image).\nDefinition 4 (Bigraph embedding [11, Def 7.5.14]). Let G : 〈nG, XG〉 → 〈mG, YG〉 and H : 〈nH , XH〉 → 〈mH , YH〉 be two concrete bigraphs. A bigraph embedding φ : G ↪→ H is a map given by a place graph embedding φP : GP ↪→ HP and a link graph embedding φL : GL ↪→ HL subject to the consistency condition:\n(BGE-1) img(φi) ⊆ XH ] {(v, i) ∈ PH | ∃s ∈ nG : k ∈ N : prntkH(v) ∈ φs(s)}.\nNP-completeness Despite their apparent complexity, the conditions maps have to satisfy to be considered bigraph embeddings may give some information and guidance in the construction of these maps. However the problem remains NP-complete as demonstrated in [3]. We recall their results to make this paper self contained. The authors focus on labelled forest embedding which covers the case of place graphs embeddings but not link graphs. In Section 4.1 we prove that the link graph embedding problem corresponds to an admissibility problem for a specific flow network. Therefore, the result presented in [3] will suffice to justify our approach.\nTo prove that the labelled forest pattern is NP-complete, in [3, §3] a reduction from 3-Sat is provided. The proposed reduction uses the RainbowAntichain problem as a middle step (introduced in loc. cit.). An instance of this problem is a tree T (V, E) with nodes V and edges E , and a finite set of colours P, said palette. Some of the nodes in T have been coloured with one or more colours taken from P. The problem asks to decide whatever exists a colourful subset of nodes R ⊂ V where each colour c of P has exactly one representative node coloured with c and for no pair of u, v ∈ R of distinct nodes u is an ancestor of v.\nTheorem 1 ([3, Th. 8]). The RainbowAntichain problem is NP-complete.\nIt is the straightforward to see that an instance T , P = (c0, . . . , cn−1) of RainbowAntichain can be reduced to a forest pattern matching, namely, one that embeds the forest (c0[0], . . . , cn−1[n − 1]) – every tree has only a node, labelled with a colour of the palette, and a hole/site – into T . This states that the forest pattern matching problem is NP-complete. Formally,\nTheorem 2 ([3, Th. 9]). The labelled forest embedding problem is NP-complete.\nThis proves that deciding the existence of a place graph embedding (which can be seen as labelled forest pattern matching) of a given guest into a given host is NP-complete. Moreover, we are interested in listing all of them thus making CSP a viable approach."
    }, {
      "heading" : "4 Implementing the embedding problem in CSP",
      "text" : "In this Section we present the main contribution of the paper i.e. a constraint satisfaction problem that models bigraph embedding problem. The encoding is based solely on integer linear constraints and is proven to be sound and complete.\nInitially, we present the encoding for the link graph embedding problem and for the place graph embedding problem. Then we combine them providing some additional “gluing constraints” to ensure the consistency of the two sub-problems. The resulting encodings contains 34 constraint families (reflecting the size of the problem definition, cf. in Section 3) and hence taking advantage of the orthogonality of link and place structures is mandatory for the sake of both exposition and adequacy proofs. We shall remark that, despite the constraint families are quite numerous, the overall number of variables and constraints produced by the encoding is polynomially bounded with respect to the support cardinality of the involved bigraphs."
    }, {
      "heading" : "4.1 Link Graphs",
      "text" : "Let us fix the guest and host concrete bigraphs: G : XG → YG and H : XH → YH . We characterize the embeddings of G into H as the solutions of a suitable multi-flux problem which we denote as LGE[G,H]. The main idea is to see the host points (i.e. ports and inner names) and handles (i.e. edges and outer names) as sources and sinks respectively: each point outputs a flux unit and each handle inputs one unit for each point it links. Units flows towards each point\nhandle following H hyper-edges and optionally taking a “detour” along the linking structure of the guest G (provided that some conditions regarding structure preservation are met). Figure 3 and Figure 4 contain a sketch of the flux problem and its formal definition respectively.\nThe flux network reflects the linking structure and contains an edge connecting each point to its handle; these edges have an integer capacity limited to 1 and are represented by the variables defined in (2). The remaining edges of the network are organised in two complete biparted graphs: one between guest and host handles and one between guest and host points. Edges of the first sub-network are described by the variables in (1) and their capacity is bounded by the number of points linked by the host handle since this is the maximum acceptable flux and corresponds to the case where each point passes through the same hyper-edge of the guest link graph. Edges of the second sub-network are described by the variables in (3) and, like the first group of links, have their capacity limited to 1; to be precise, some of these variables will never assume a value different from 0 because host points can receive flux from anything but the host ports (as expressed by constraint (9)). Edges for the link structure of the guest are presented implicitly in the flux preservation constraints (see constraint (7)). In order to fulfil the injectivity conditions of link embeddings, some additional flux variables (whereas the previous are network variables) are defined by (4). These are used to keep track and separate each flux on the bases of the points handle1.\nThe constraint families (5) and (6) define the outgoing and ingoing flux of host points and handles respectively. The firsts have to send exactly one unit considering every edge they are involved into and the seconds receive one unit for each of their point regardless if this unit comes from the point directly or from a handle of the guest.\nThe linking structure of the guest graph is encoded by the constraint family (7) which states that flux is preserved while passing through the guest i.e. the output of each handle has to match the overall input of the points it connects.\nConstraints (8), (9), (18), (19) and (20) shape the flux in the sub-network linking guest and host points. Specifically, (8) requires that each point from the guest receives exactly one unit or, the other way round, that guest points are assigned with disjoint sets of points from the host.\n1The problem can be presented without the additional flux variables, but we found this approach more readable.\nConstraints (9), (18) and (19) disable edges between guest ports and host inner names, between mismatching ports of matching nodes and between ports of mismatching nodes. Finally, the flux of ports belonging to the same node has to act compactly i.e. if there is flux between the i-th ports of two nodes, then, there should be flux between every other matching ports as expressed by (20).\nConstraints (10), (11) and (12) relates flux and network variables ensuring that the formers assume a true value if, and only, if there is actual flux between the corresponding guest and host handles. In particular, (11) propagates the information about the absence of flux between handles disabling the sub-network linking handles points and, vice versa, (12) propagates the information in the other way disabling flux between handles if there is no flux between their points.\nThe remaining constraints prevent fluxes from mixing. Constraint (13) requires guest handles to send their output to exactly one destination thus renders the sub-network between handles a function assigning guest handles to host handles. This mapping is subject to some additional conditions when edges are involved: (16) and (17) ensure that the edges are injectively mapped to edges only, (15) forbids host outer names to receive flux from an edge and an outer name at the same time. Finally, constraint (14) states that the output of host points cannot bypass the guest if there is flux between its handle and an edge from the guest.\nAdequacy Let ~N be a solution of LGE[G,H]. The corresponding link graph embedding φ : G ↪→ H is defined as follows:\nφv(v) , v′ ∈ VH : ∃i : N(v,i),(v′,i) = 1 φe(e) , e′ ∈ EH : Fe,e′ = 1 φo(y) , y′ ∈ YH : Fy,y′ = 1 φi(x) , {x′ ∈ XH ] PH | Nx′,x = 1}\nThe components of φ just defined are well-given and compliant with Definition 2. On the other way round, let φ : G ↪→ H be a link graph embedding. The corresponding solution ~N of LGE[G,H] is defined as follows:\nNp,p′ ,    1 if p′ ∈ XG ∧ p ∈ φi(p′) 1 if p′ = (v, i) ∧ p = (φv(v), i) 0 otherwise Np,h′ , {\n1 if h′ = linkHp ∧ @p′ : Np,p′ = 1 0 otherwise\nNh,h′ ,    1 if h ∈ EH ∧ h′ ∈ EG ∧ h = φe(h′) 1 if h ∈ YH ∧ h′ ∧ h = φo(h′) 0 otherwise\nClearly Fh,h′ = 1 4⇐⇒ Nh,h′ 6= 0. Then it is easy to check that every constraint of LGE[G,H] is satisfied by the solution just defined. The constraint satisfaction problem in Figure 4 is sound and complete with respect to the link graph embedding problem given in Definition 2.\nProposition 3 (Adequacy of LGE). For any two concrete link graphs G and H, there is a bijective correspondence between the link graph embeddings of G into H and the solutions of LGE[G,H]."
    }, {
      "heading" : "4.2 Place Graphs",
      "text" : "Let us fix the guest and host place graphs: G : nG → mG and H : nH → mH . We characterize the embeddings of G into H as the solutions of the constraint satisfaction problem in Figure 5.\nThe problem is a direct encoding of Definition 3 as a matching problem presented, as usual, as a biparted graph. Sites, nodes and roots of the two place graphs are represented as nodes and parted into the guest and the host ones. For convenience of exposition, graph is complete.\nEdges are modelled by the boolean variables defined in (21); these are the only variables used by the problem. So far a solution is nothing more than a relation between the components of guest and host containing only those pairs connected by an edge assigned a non-zero value. To capture exactly those assignments that are actual place graph embeddings some conditions have to be imposed.\nConstraints (22) and (23) prevent roots and sites from the host to be matched with nodes or sites and nodes or roots respectively. (24) disables matching between nodes decorated with different controls. Constraint (25) prevents any matching for host nodes under a passive context (i.e. have an ancestor labelled with a passive control). (26) propagates the matching along the parent map from children to parents. Constraints (27) and (28) ensure that the matching is a function when restricted to guest nodes and roots (the codomain restriction follows by (22) and\n(23)). (29) says that if a node from the host cannot be matched with a root or a node/site from the guest at the same time; moreover, if the host node is matched with a node then it cannot be matched to anything else.\nThe remaining constraints are the counterpart of (26) and propagate matchings from parents to children. (30) applies on matchings between nodes and says that if parents are matched, then children from the host node are covered by children from the guest node. In particular, the matching is a perfect assignment when restricted to guest children that are nodes (because of (29)) and is a surjection on those that are sites. (31) imposes a similar condition on matchings between guest roots and host nodes. Specifically, it says that the matching have to cover child nodes from the guest (moreover, it is injective on them) leaving child sites to match whatever remains ranging from nothing to all unmatched children. Finally, (32) prevent matching from happening inside a parameter.\nAdequacy Let ~M be a solution of PGE[G,H]. The corresponding place graph embedding φ : G ↪→ H is defined as follows:\nφv(g) , h ∈ VH : ∃i : Mh,g = 1 φs(g) , {h ∈ nh ] VH |Mh,g = 1} φr(g) , h ∈ mH ] VH : Mh,g = 1\nThe components of φ just defined are well-given and compliant with Definition 3. On the opposite direction, let φ : G ↪→ H be a place graph embedding. The corresponding solution ~M of PGE[G,H] is defined as follows:\nMh,g ,    1 if g ∈ VG ∧ h = φv(g) 1 if g ∈ mG ∧ h = φr(g) 1 if g ∈ nG ∧ h ∈ φs(g) 0 otherwise\nIt is easy to check that every constraint of PGE[G,H] is satisfied by the solution just defined. The constraint satisfaction problem in Figure 5 is sound and complete with respect to the place graph embedding problem given in Definition 3.\nProposition 4 (Adequacy of PGE). For any two concrete place graphs G and H, there is a bijective correspondence between the place graph embeddings of G into H and the solutions of PGE[G,H]."
    }, {
      "heading" : "4.3 Bigraphs",
      "text" : "Let G : 〈nG, XG〉 → 〈mG, YG〉 and H : 〈nH , XH〉 → 〈mH , YH〉 be two concrete bigraphs. By taking advantage of the orthogonality of the link and place structure we can define the constraint satisfaction problem capturing bigraph embeddings by simply composing the constraints given above for the link and place graph embeddings and by adding just two consistency constraints to relate the solutions of the two problems.\nThese additional constraint families are reported in Figure 6. The family (33) ensures that solutions for LGE[G,H] and PGE[G,H] agree on nodes since the map φv has to be shared by the corresponding link and place embeddings. The family (34) ensures that ports are in the image of inner names (i.e. send their flux unit to them) only if their node is part of the parameter i.e. only if it is matched to a site from the guest or it descends from a node that is so.\nIt is easy to check that (34) corresponds exactly to condition (BGE-1). Therefore, from Proposition 3 and Proposition 4, the constraint satisfaction problem defined by Figures 4, Figure 5 and Figure 6 is sound and complete with respect to the bigraph embedding problem given in Definition 4 as stated by below.\nProposition 5 (Adequacy of BGE). For any two concrete bigraphs G and H, there is a bijective correspondence between the bigraph embeddings of G into H and the solutions of BGE[G,H]."
    }, {
      "heading" : "5 Conclusions and future works",
      "text" : "In this paper, we have presented a sound and complete algorithm for solving the bigraph embedding problem, based on a constraint satisfaction problem. The resulting model is compact and composed by a number of variables and linear constraints, polynomially bounded by the size of the guest and host bigraphs. Remarkably, this algorithm does not require hosts to be ground.\nThe CSP approach offers a great flexibility, e.g. allowing to move execution strategies upstream into CSP calculation. An example can be found in this paper: in practice, the notion of active/passive contexts defines an execution strategy.\nThis approach naturally suggests several interesting extensions of the bigraphic model itself. We can think of weighted bigraphs, where nodes and edges can be given “weights”, and firing a rule has a cost related to the nodes involved. This extension would lead us to consider “approximated embeddings”: a guest can be embedded up-to some distance based on costs (e.g. missing controls, or quantitative differences between controls,. . . ). In both cases, our implementation can be straightforwardly adapted just by adding a cost function, in order to give the optimal matchings; this would be far more efficient and easier to implement than dealing with these issues at the level of strategies (if possible at all).\nThe proposed approach can be easily applied also to extensions of the bigraphs, e.g. directed bigraphs [10], bigraphs with sharing [6] or local bigraphs. An interesting direction would be to extend the algorithm also to stochastic and probabilistic bigraphs [15] which will offer useful modelling and verification tools for quantitative aspects, e.g. for biological problems [2, 8].\nThe algorithm has been successfully integrated into LibBig, an extensible library for manipulating bigraphical reactive systems. This library can be used for implementing a wide range of tools and it can be adapted to support several extensions of bigraphs. Approximated and weighted embeddings are supported too but are still an experimental feature. In fact, the theoretical foundations and implications of these extensions have not been fully investigated yet suggesting another line of research.\nThe empirical evaluation of the implementation available in LibBig looks promising. It cannot be considered a rigorous experimental validation mainly because performance depends on the solver, and the model is not optimized for any particular solver. Moreover, up to now there are no “official” (or “widely recognized”) benchmarks for the bigraph embedding problem. An algorithm for the bigraph matching problem is proposed in [7], based on a translation into a term\nmatching problem; this algorithm is at the core of BPLTool. In [25] Sevegnani et. al. presented a SAT based algorithm for deciding the matching problem in bigraphs with sharing. To the best of the authors knowledge, the approach of [25] is the nearest to the solution presented in this paper. However, an accurate and fair comparison of algorithms for computing bigraph embeddings/matchings is difficult because of the aforementioned reasons and because of the different bigraph variants these algorithms deal with (e.g., the matching algorithm of the model checker BigMC does not support inner names).\nA decentralized algorithm for computing bigraphical embeddings has been proposed in [17] and is at the core of the distributed bigraphical machine.\nAcknowledgements We thank Alessio Mansutti and the participants to MeMo’14 for fruitful discussions on preliminary version of this paper. This work is partially supported by MIUR PRIN project 2010LHT4KM, CINA."
    }, {
      "heading" : "A NP-completeness of the bigraph embedding problem",
      "text" : "In [3] the authors proved that the labelled forest embedding problem is NP-Complete. This result covers the case of place graphs embeddings but not link graphs. However, the latter correspond to an admissibility problem for a specific flow network and hence their results will suffice to justify our approach.\nTo prove that the labelled forest pattern is NP-complete, in [3, §3] a reduction from 3-Sat is provided. The proposed reduction uses the RainbowAntichain problem as a middle step. An instance of this problem (introduced in [3]) is a tree T (V, E) with nodes V and edges E , and a finite set of colours P, said palette. Some of the nodes in T have been coloured with one or more colours taken from P. The problem asks to decide whatever exists a colourful subset of nodes R ⊂ V where each colour c of P has exactly one representative node coloured with c and for no pair of u, v ∈ R of distinct nodes u is an ancestor of v.\nTheorem 6 ([3, Th. 8]). The RainbowAntichain problem is NP-complete.\nProof. RainbowAntichain is in NP, since, given a set of nodes R, checking whatever R us a rainbow anti-chain for T can be easily done in polynomial time by breadth-first visit of T , and for each v ∈ R found, firsti increase the node counter nc, then the colour counter p[i] (with 1 ≤ i ≤ |P|) if v has a colour ci ∈ P. The check fails whether nc > |P| or p[j] = 0 for some j, otherwise R is a rainbow anti-chain for T .\nLet C = {c1, . . . cm} be an instance of 3-Sat on variables {x1, . . . , xn}. From C we define a coloured tree T as follows. Let r be the root node which is left uncoloured. For each variable xi let xi and x̄i be child nodes of r, and color them with fresh colour cxi , distinct for each variable. For each clause cj ∈ C. let c1j , c2j and c3j be children nodes of li in T if cj contains li as negated, and assign to each of them a fresh colour ccj , distinct for each clause. An example of construction for c1 = (x̄1 ∨ x2 ∨ x̄3), c2 = (x1 ∨ x2 ∨ x3) is shown below.\nr\nx1\nc11\nx̄1\nc12\nx2 x̄2\nc21 c 2 2\nx3\nc31\nx̄3\nc32\nLet ϕ be a truth assignment satisfying the formula C. By construction, selecting only literal nodes li which are satisfied by ϕ, we obtain a rainbow anti-chain R′ in T for the palette {cxi | 1 ≤ i ≤ n}. Now, we extend R′ to R adding all clause nodes which are not children of an element in R′. Such R is clearly an anti-chain for T , but we must ensure that is colourful and no more than one representative per colour is taken. To do this, it suffices to prove that R is colourful, indeed if a colour occurs more than one in R we remove the others. By hypothesis, each clause cJ is satisfied by ϕ, hencecJ has at least one literal li such that ϕ(li) is true. By construction of T , there exist a node ckj , with 1 ≤ k ≤ 3, child of l̄i, hence already in R. This holds for all clauses cj , hence R is colourful.\nControversy, letR be a rainbow anti-chain for T . Let the boolean function ϕ over {x1, . . . , xn} be defined by ϕ(xi) = T if xi is a node in R and ϕ(xi) = F otherwise. Since R has exactly one representative per colour, no opposite literals are in R, hence ϕ is a truth assignment for C. By colourfulness of R, for all colours ccJ (1 ≤ j ≤ m) there exists a node ckj ∈ R (1 ≤ k ≤ 3) such that ckj has a colour ccj . By construction on T , each cKj ∈ R is a children of a literal node li /∈ R,\nand moreover the clause cj contains l̄j . Since lj /∈ R, by definition ϕ(l̄i) = T, hence ϕ(cj) = T. This holds for all 1 ≤ j ≤ m, hence ϕ satisfies C.\nIn [3] labelled trees are described by terms of a language inspired to the ambient calculus and quotiented by the usual structural congruence. Then ambients corresponds to labelled subtrees; the null process to the empty tree; variables are leaves; parallel processes to siblings (with the additional requirement for disjoint variables to ensure a tree structure). This allows to represent grafting as (simultaneous) substitution. An embedding of a labelled forest (with variables #»\nZ) #» S ( #»\nZ) into a tree T (denoted as T #»S ) can be described by a tree C( #»X), said context, and a forest #»\nD, whose trees are called parameters, such that T ≡ (C{ #»S/ #»X}){ #»D/ #»Z}. It is the straightforward to see that an instance T , P = (c0, . . . , cn−1) of RainbowAntichain can be reduced to a forest pattern matching, namely, one that embeds the forest (c0[0], . . . , cn−1[n − 1]) – every tree has only a node, labelled with a colour of the palette, and a hole/site – into T . This states that the forest pattern matching problem is NP-complete. Formally,\nTheorem 7 ([3, Th. 9]). The labelled forest embedding problem is NP-complete.\nProof. Given a solution (C, #» D) for T #»S , checking that T ≡ (C{ #»S/ #»X}){ #»D/ #»Z} corresponds to a tree isomorphism test, which is in P for [12, 13]. Let a coloured tree T and a palette P = {c1, . . . , cn} be and instance of the RainbowAntichain problem. Let us transform T into a tree term T as follows. If T is a single node v (a leaf) T is the empty tree labelled with m (m[nil]) where m = c if v has color c, otherwise m = ∗, a fresh name not in P denoting an uncoloured node. If T has root r and T1, . . . , Tk are the (children) subtrees of r, T is m[T1| . . . |Tk], where m is as above for r, and T1, . . . , Tk are transformed trees of T1, . . . , Tk. Suppose (C, #» D) be a solution for T #»S = (c1[x1], . . . , ck[xn]). In C, each ci[xi] is grafted into a variable zi ∈ vars(C). Since variables can appear in terms only as leaves, in the transformation T of T , we have found a rainbow anti-chain for P, since the matching forest #»S has all the colors in P exactly once.\nAssume that T has a rainbow anti-chain R. In order to recover context C and parameters #»D, which are a solution for T (c1[x1], . . . , ck[xn]), it suffices to apply the construction explained above with some adjustments: we obtain C applying the transformation from the root of T , but if a node in R is reached it is transformed by a fresh variable zi (1 ≤ i ≤ n) one for each element in R; Dj ’s are recovered applying the original transformation starting from the subtrees rooted at the children of nodes in R. It is straightforward to prove that T ≡ (C{c1[x1]/z1, . . . , ck[xn]/ zn}){ #» D/ #» X}, for X = {x1, . . . , xn}.\nThis proves that deciding the existence of a place graph embedding (which can be seen as labelled forest pattern matching) of a given redex into an agent is NP-complete. Moreover, we are interested in listing all of them thus making CSP a viable approach."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "<lb>A crucial problem for many results and tools about bigraphs and bigraphical reactive<lb>systems is bigraph embedding. An embedding is more informative than a bigraph matching,<lb>since it keeps track of the correspondence between the various components of the redex<lb>(guest) within the agent (host). In this paper, we present an algorithm for computing<lb>embeddings based on a reduction to a constraint satisfaction problem. This algorithm, that<lb>we prove to be sound and complete, has been successfully implemented in LibBig, a library<lb>for manipulating bigraphical reactive systems. This library can be used for implementing a<lb>wide range of tools, and it can be adapted to various extensions of bigraphs.",
    "creator" : "LaTeX with hyperref package"
  }
}