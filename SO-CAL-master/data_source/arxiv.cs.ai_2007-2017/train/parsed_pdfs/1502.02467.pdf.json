{
  "name" : "1502.02467.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Structural Decompositions for Problems with Global Constraints",
    "authors" : [ "Evgenij Thorstensen" ],
    "emails" : [ "evgenit@ifi.uio.no" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Such implicitly represented constraints, known as global constraints, are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. In recent years, a variety of restrictions on the structure of CSP instances have been shown to yield tractable classes of CSPs. However, most such restrictions fail to guarantee tractability for CSPs with global constraints. We therefore study the applicability of structural restrictions to instances with such constraints.\nWe show that when the number of solutions to a CSP instance is bounded in key parts of the problem, structural restrictions can be used to derive new tractable classes. Furthermore, we show that this result extends to combinations of instances drawn from known tractable classes, as well as to CSP instances where constraints assign costs to satisfying assignments.\nKeywords Tractability · Global constraints · Structural restrictions"
    }, {
      "heading" : "1 Introduction",
      "text" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28]. Constraints can either be represented explicitly, by a table of allowed assignments, or implicitly, by specialized algorithms provided by the constraint solver. These algorithms may take as a parameter a description that specifies exactly which kinds of assignments a particular instance of a constraint should allow. Such implicitly represented constraints are known\nE. Thorstensen Department of Informatics, University of Oslo, Norway E-mail: evgenit@ifi.uio.no\nA preliminary version of this paper appeared in Proceedings of the 19th International Conference on Principles and Practice of Constraint Programming (CP 2013).\nar X\niv :1\n50 2.\n02 46\n7v 1\n[ cs\n.A I]\n9 F\neb 2\n01 5\nas global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].\nThe theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33]. In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33]. However, much of this theoretical work has focused on problems where each constraint is explicitly represented, and most known structural restrictions fail to yield tractable classes for problems with global constraints. This is the case even when the global constraints are fairly simple, such as overlapping difference constraints with acyclic hypergraphs [30].\nTheoretical work on global constraints has to a large extent focused on developing efficient algorithms to achieve various kinds of local consistency for individual constraints. This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [6,37]. Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [7]. These techniques allow faster implementations of algorithms for individual constraints, but do not shed much light on the complexity of problems with multiple overlapping global constraints, which is something that practical problems frequently require.\nAs such, in this paper we investigate the properties of explicitly represented constraints that allow structural restrictions to guarantee tractability. Identifying such properties will allow us to find global constraints that also possess them, and lift structural restrictions to instances with such constraints.\nAs discussed in [9], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity. Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation. In contrast, we will use a definition of global constraints, used also in [14], that allows us to discuss different representations in a uniform manner. Armed with this definition, we obtain results that rely on a relationship between the size of a global constraint and the number of its satisfying assignments.\nFurthermore, as our definition is general enough to capture arbitrary problems in NP, we demonstrate how our results can be used to decompose a constraint problem into smaller constraint problems (as opposed to individual constraints), and when such decompositions lead to tractability. The results that we obtain on this topic extend previous research by Cohen and Green [10]. In addition to being more general, our results arguably use simpler theoretical machinery.\nFinally, we show how our results can be extended to weighted CSP [21,22], that is, CSP where constraints assign costs to satisfying assignments, and the goal is to find an optimal solution."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "In this section, we define the basic concepts that we will use throughout the paper. In particular, we give a precise definition of global constraints and of structural decompositions.\n2.1 Global Constraints\nDefinition 1 (Variables and assignments) Let V be a set of variables, each with an associated finite set of domain elements. We denote the set of domain elements (the domain) of a variable v by D(v). We extend this notation to arbitrary subsets of variables, W , by setting D(W ) =\n⋃ v∈W D(v).\nAn assignment of a set of variables V is a function θ : V → D(V ) that maps every v ∈ V to an element θ(v) ∈ D(v). We write V(θ) for the set of variables V .\nWe denote the restriction of θ to a set of variablesW ⊆ V by θ|W . We also allow the special assignment ⊥ of the empty set of variables. In particular, for every assignment θ, we have θ|∅ = ⊥.\nDefinition 2 (Projection) Let Θ be a set of assignments of a set of variables V . The projection of Θ onto a set of variables X ⊆ V is the set of assignments πX(Θ) = {θ|X | θ ∈ Θ}.\nNote that when Θ = ∅ we have πX(Θ) = ∅, but when X = ∅ and Θ 6= ∅, we have πX(Θ) = {⊥}.\nDefinition 3 (Disjoint union of assignments) Let θ1 and θ2 be two assignments of disjoint sets of variables V1 and V2, respectively. The disjoint union of θ1 and θ2, denoted θ1 ⊕ θ2, is the assignment of V1 ∪ V2 such that (θ1 ⊕ θ2)(v) = θ1(v) for all v ∈ V1, and (θ1 ⊕ θ2)(v) = θ2(v) for all v ∈ V2.\nGlobal constraints have traditionally been defined, somewhat vaguely, as constraints without a fixed arity, possibly also with a compact representation of the constraint relation. For example, in [29] a global constraint is defined as “a constraint that captures a relation between a non-fixed number of variables”.\nBelow, we offer a precise definition similar to the one in [6], where the authors define global constraints for a domain D over a list of variables σ as being given intensionally by a function D|σ| → {0, 1} computable in polynomial time. Our definition differs from this one in that we separate the general algorithm of a global constraint (which we call its type) from the specific description. This separation allows us a better way of measuring the size of a global constraint, which in turn helps us to establish new complexity results.\nDefinition 4 (Global constraints) A global constraint type is a parameterized polynomialtime algorithm that determines the acceptability of an assignment of a given set of variables.\nEach global constraint type, e, has an associated set of descriptions, ∆(e). Each description δ ∈ ∆(e) specifies appropriate parameter values for the algorithm e. In particular, each δ ∈ ∆(e) specifies a set of variables, denoted by V(δ). We write |δ| for the number of bits used to represent δ.\nA global constraint e[δ], where δ ∈ ∆(e), is a function that maps assignments of V(δ) to the set {0, 1}. Each assignment that is allowed by e[δ] is mapped to 1, and each disallowed assignment is mapped to 0. The extension or constraint relation of e[δ] is the set of assignments, θ, of V(δ) such that e[δ](θ) = 1. We also say that such assignments satisfy the constraint, while all other assignments falsify it.\nWhen we are only interested in describing the set of assignments that satisfy a constraint, and not in the complexity of determining membership in this set, we will sometimes abuse notation by writing θ ∈ e[δ] to mean e[δ](θ) = 1.\nAs can be seen from the definition above, a global constraint is not usually explicitly represented by listing all the assignments that satisfy it. Instead, it is represented by some description δ and some algorithm e that allows us to check whether the constraint relation of e[δ] includes a given assignment. To stay within the complexity class NP, this algorithm is required to run in polynomial time. As the algorithms for many kinds of global constraints are built into modern constraint solvers, we measure the size of a global constraint’s representation by the size of its description.\nExample 1 (EGC) A very general global constraint type is the extended global cardinality constraint type [37]. This form of global constraint is defined by specifying, for every domain element a, a finite set of natural numbers K(a), called the cardinality set of a. The constraint requires that the number of variables which are assigned the value a is in the set K(a), for each possible domain element a.\nUsing our notation, the description δ of an EGC global constraint specifies a functionKδ : D(V(δ))→ P(N) that maps each domain element to a set of natural numbers. The algorithm for the EGC constraint then maps an assignment θ to 1 if and only if, for every domain element a ∈ D(V(δ)), we have that |{v ∈ V(δ) | θ(v) = a}| ∈ Kδ(a).\nExample 2 (Table and negative constraints) A rather degenerate example of a a global constraint type is the table constraint.\nIn this case the description δ is simply a list of assignments of some fixed set of variables, V(δ). The algorithm for a table constraint then decides, for any assignment of V(δ), whether it is included in δ. This can be done in a time which is linear in the size of δ and so meets the polynomial time requirement.\nNegative constraints are complementary to table constraints, in that they are described by listing forbidden assignments. The algorithm for a negative constraint e[δ] decides, for any assignment of V(δ), whether it is not included in δ. Observe that disjunctive clauses, used to define propositional satisfiability problems, are a special case of the negative constraint type, as they have exactly one forbidden assignment.\nWe observe that any global constraint can be rewritten as a table or negative constraint. However, this rewriting will, in general, incur an exponential increase in the size of the description.\nAs can be seen from the definition above, a table global constraint is explicitly represented, and thus equivalent to the usual notion of an extensionally represented constraint.\nIn some cases, particularly for table constraints, we will make use of the standard notion of a relational join, which we define below.\nDefinition 5 (Constraint join) A global constraint ej [δj ] is the join of two global constraints e1[δ1] and e2[δ2] whenever V(δj) = V(δ1) ∪ V(δ2), and θ ∈ ej [δj ] if and only if θ|V(δ1) ∈ e1[δ1] and θ|V(δ2) ∈ e2[δ2].\nDefinition 6 (CSP instance) An instance of the constraint satisfaction problem (CSP) is a pair 〈V,C〉 where V is a finite set of variables, and C is a set of global constraints such that V = ⋃ e[δ]∈C V(δ). In a CSP instance, we call V(δ) the scope of the constraint e[δ]. A classic CSP instance is one where every constraint is a table constraint. A solution to a CSP instance P = 〈V,C〉 is an assignment θ of V which satisfies every global constraint, i.e., for every e[δ] ∈ C we have θ|V(δ) ∈ e[δ]. We denote the set of solutions to P by sol(P ).\nThe size of a CSP instance P = 〈V,C〉 is |P | = |V |+ ∑ v∈V |D(v)|+ ∑ e[δ]∈C |δ|.\nNote that this definition disallows CSP instances with variables that are not in the scope of any constraint. Since a variable that is not in the scope of any constraint can be assigned any value from its domain, excluding such variables can be done without loss of generality. While this condition is strictly speaking not necessary, it will allow us to simplify some proofs later on. In particular, it entails that the set of solutions to a CSP instance is precisely the set of assignments satisfying the constraint obtained by taking the join of every constraint in the CSP instance.\nTo illustrate these definitions, consider the connected graph partition problem (CGP) [18, p. 209], formally defined below. Informally, the CGP is the problem of partitioning the vertices of a graph into bags of a given size while minimizing the number of edges that have endpoints in different bags.\nProblem 1 (Connected graph partition (CGP)) We are given an undirected and connected graph 〈V,E〉, as well as α, β ∈ N. Can V be partitioned into disjoint sets V1, . . . , Vm, for some m, with |Vi| ≤ α such that the set of broken edges E′ = {{u, v} ∈ E | u ∈ Vi, v ∈ Vj , i 6= j} has cardinality β or less?\nExample 3 (The CGP encoded with global constraints) Given a connected graph G = 〈V,E〉, α, and β, we build a CSP instance 〈A∪B,C〉 as follows. The set A will have a variable v for every v ∈ V with domain D(v) = {1, . . . , |V |}, while the set B will have a boolean variable e for every edge in E.\nThe set of constraints C will have an EGC constraint Cα on A with K(i) = {0, . . . , α} for every 1 ≤ i ≤ |V |. Likewise, C will have an EGC constraint Cβ on B with K(0) = {0, . . . , |E|} and K(1) = {0, . . . , β}.\nFinally, to connect A and B, the set C will have for every edge {u, v} ∈ E, with corresponding variable e ∈ B, a table constraint on {u, v, e} requiring θ(u) 6= θ(v) → θ(e) = 1.\nAs an example, Figure 1 shows this encoding for the CGP on the graph C5, that is, a simple cycle on five vertices.\nThis encoding follows the definition of Problem 1 quite closely, and can be done in polynomial time.\n2.2 Structural Restrictions\nIn recent years, there has been a flurry of research into identifying tractable classes of classic CSP instances based on structural restrictions, that is, restrictions on the\nhypergraphs of CSP instances. Below, we present and discuss a few representative examples. In Sections 3 and 4, we will show how these techniques can be applied to CSP instance with global constraints. To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].\nDefinition 7 (Hypergraph) A hypergraph 〈V,H〉 is a set of vertices V together with a set of hyperedges H ⊆ P(V ).\nGiven a CSP instance P = 〈V,C〉, the hypergraph of P , denoted hyp(P ), has vertex set V together with a hyperedge V(δ) for every e[δ] ∈ C.\nDefinition 8 (Tree decomposition) A tree decomposition of a hypergraph 〈V,H〉 is a pair 〈T, χ〉 where T is a tree and χ is a labelling function from nodes of T to subsets of V , such that\n1. for every v ∈ V , there exists a node t of T such that v ∈ χ(t), 2. for every hyperedge h ∈ H, there exists a node t of T such that h ⊆ χ(t), and 3. for every v ∈ V , the set of nodes {t | v ∈ χ(t)} induces a connected subtree of T .\nDefinition 9 (Width function) Let G = 〈V,H〉 be a hypergraph. A width function on G is a function f : P(V )− {∅} → R+ that assigns a positive real number to every nonempty subset of vertices of G. A width function f is monotone if f(X) ≤ f(Y ) whenever X ⊆ Y .\nLet 〈T, χ〉 be a tree decomposition of G, and f a width function on G. The f-width of 〈T, χ〉 is max({f(χ(t)) | t node of T}). The f-width of G is the minimal f -width over all its tree decompositions.\nIn other words, a width function on a hypergraph G tells us how to assign weights to nodes of tree decompositions of G.\nDefinition 10 (Treewidth) Let f(X) = |X| − 1. The treewidth tw(G) of a hypergraph G is the f -width of G.\nLet G = 〈V,H〉 be a hypergraph, and X ⊆ V . An edge cover of X is any set of hyperedges H ′ ⊆ H that satisfies X ⊆ ⋃ H ′. The edge cover number ρ(X) of X is the size of the smallest edge cover of X. It is clear that ρ is a width function.\nDefinition 11 ([1, Chapter 2]) The generalized hypertree width ghw(G) of a hypergraph G is the ρ-width of G.\nNext, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [27].\nDefinition 12 (Fractional edge cover) Let G = 〈V,H〉 be a hypergraph, and X ⊆ V . A fractional edge cover for X is a function γ : H → [0, 1] such that ∑ v∈h∈H γ(h) ≥ 1\nfor every v ∈ X. We call ∑ h∈H γ(h) the weight of γ. The fractional edge cover number ρ∗(X) of X is the minimum weight over all fractional edge covers for X. It is known that this minimum is always rational [27]. We furthermore define ρ∗(G) = ρ∗(V ).\nDefinition 13 The fractional hypertree width fhw(G) of a hypergraph G is the ρ∗width of G.\nFor a class of hypergraphs H and a notion of width α, we write α(H) for the maximal α-width over the hypergraphs in H. If this is unbounded we write α(H) =∞; otherwise α(H) <∞.\nBounding any of the above width measures by a constant can be used to guarantee tractability for classes of CSP instances where all constraints are table constraints.\nTheorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs. For every α ∈ {tw, ghw, fhw}, any class of classic CSP instances whose hypergraphs are in H is tractable if α(H) <∞.\nTo go beyond fractional hypertree width, Marx [33] recently introduced the concept of submodular width. This concept uses a set of width functions satisfying a condition (submodularity), and considers the f -width of a hypergraph for every such function f .\nDefinition 14 (Submodular width function) Let G = 〈V,H〉 be a hypergraph. A width function f on G is edge-dominated if f(h) ≤ 1 for every h ∈ H.\nAn edge-dominated width function f on G is submodular if for every pair of sets X,Y ⊆ V , we have f(X) + f(Y ) ≥ f(X ∩ Y ) + f(X ∪ Y ).\nDefinition 15 (Submodular width) Let G be a hypergraph. The submodular width subw(G) of G is the supremum of the f -widths of G taken over all monotone, edgedominated, submodular width functions f on G.\nFor a class of hypergraphs H, we write subw(H) for the maximal submodular width over the hypergraphs in H. If this is unbounded we write subw(H) = ∞; otherwise subw(H) <∞.\nUnlike for fractional hypertree width and every other structural restriction discussed so far, the running time of the algorithm given by Marx for classic CSP instances with bounded submodular width has an exponential dependence on the number of vertices in the hypergraph of the instance. The class of classic CSP instances with bounded submodular width is therefore not known to be tractable. However, this class is what is called fixed-parameter tractable [16,17].\nDefinition 16 (Fixed-parameter tractable) A parameterized problem instance is a pair 〈k, P 〉, where P is a problem instance, such as a CSP instance, and k ∈ N a parameter.\nLet S be a class of parameterized problem instances. We say that S is fixedparameter tractable (in FPT) if there is a computable function f of one argument, as well as a constant c, such that every problem 〈k, P 〉 ∈ S can be solved in time O(f(k)× |P |c).\nThe function f can be arbitrary, but must only depend on the parameter k. For CSP instances, one possible parameterization is by the size of the hypergraph of an instance, measured by the number of vertices. Since the hypergraph of an instance has a vertex for every variable, for every CSP instance P = 〈V,C〉 we consider the parameterized instance 〈|V |, P 〉.\nTheorem 2 ([33]) Let H be a class of hypergraphs. If subw(H) <∞, then a class of classic CSP instances whose hypergraphs are in H is in FPT.\nThe three structural restrictions that we have just presented form a hierarchy [27, 33]: For every hypergraph G, subw(G) ≤ fhw(G) ≤ ghw(G) ≤ tw(G).\nAs the example below demonstrates, Theorem 1 does not hold for CSP instances with arbitrary global constraints, even if we have a fixed, finite domain. The only exception is the restriction of Theorem 1 to treewidth, as bounded treewidth implies bounded arity for every hyperedge.\nExample 4 The NP-complete problem of 3-colourability [18] is to decide, given a graph 〈V,E〉, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.\nWe may reduce this problem to a CSP with EGC constraints (cf. Example 1) as follows: Let V be the set of variables for our CSP instance, each with domain {r, g, b}. For every edge 〈v, w〉 ∈ E, we post an EGC constraint with scope {v, w}, parameterized by the function K such that K(r) = K(g) = K(b) = {0, 1}. Finally, we make the hypergraph of this CSP instance have low width by adding an EGC constraint with scope V parameterized by the function K′ such that K′(r) = K′(g) = K′(b) = {0, . . . , |V |}. This reduction clearly takes polynomial time, and the hypergraph G of the resulting instance has ghw(G) = fhw(G) = subw(G) = 1.\nAs the constraint with scope V allows all possible assignments, any solution to this CSP is also a solution to the 3-colourability problem, and vice versa.\nLikewise, Theorem 2 does not hold for CSP instances with arbitrary global constraints if we allow the variables unbounded domain size, that is, change the above example to allow each variable its own set of colours. In other words, the structural restrictions cannot yield tractable classes of CSP instances with arbitrary global constraints. With that in mind, in the rest of the paper we will identify properties of extensionally represented constraints that these structural restrictions exploit to guarantee tractability. Then, we are going to look for restricted classes of global constraints that possess these properties. To do so, we will use the following definitions.\nDefinition 17 (Constraint catalogue) A constraint catalogue is a set of global constraints. A CSP instance 〈V,C〉 is said to be over a constraint catalogue Γ if for every e[δ] ∈ C we have e[δ] ∈ Γ .\nDefinition 18 (Restricted CSP class) Let Γ be a constraint catalogue, and let H be a class of hypergraphs. We define CSP(H, Γ ) to be the class of CSP instances over Γ whose hypergraphs are in H.\nDefinition 18 allows us to discuss classic CSP instances alongside instances with global constraints. Let Ext be the constraint catalogue containing all table global constraints. The classic CSP instances are then precisely those that are over Ext. In particular, we can now restate Theorems 1 and 2 as follows.\nTheorem 3 Let H be a class of hypergraphs. For every α ∈ {tw, ghw, fhw}, the class of CSP instances CSP(H,Ext) is tractable if α(H) <∞. Furthermore, if subw(H) <∞ then CSP(H,Ext) is in FPT."
    }, {
      "heading" : "3 Properties of Extensional Representation",
      "text" : "We are going to start our investigation by considering fractional hypertree width in more detail. To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [27] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance. The following definition formalizes what we mean by “parts”, and is required to state the algorithm that Grohe and Marx use in their paper.\nDefinition 19 (Constraint projection) Let e[δ] be a global constraint. The projection of e[δ] onto a set of variables X ⊆ V(δ) is the constraint pjX(e[δ]) such that µ ∈ pjX(e[δ]) if and only if there exists θ ∈ e[δ] with θ|X = µ.\nFor a CSP instance P = 〈V,C〉 and X ⊆ V we define pjX(P ) = 〈X,C′〉, where C′ is the set containing for every e[δ] ∈ C such that X ∩ V(δ) 6= ∅ the constraint pjX∩V(δ)(e[δ]).\n3.1 Algorithm for Enumerating All Solutions\nThe algorithm is given as Algorithm 1, and is essentially the usual recursive search algorithm for finding all solutions to a CSP instance by considering smaller and smaller sub-instances using constraint projections.\nTo show that Algorithm 1 does indeed find all solutions, we will use the following property of constraint projections.\nLemma 1 Let P = 〈V,C〉 be a CSP instance. For every X ⊆ V , we have sol(pjX(P )) ⊇ πX(sol(P )).\nProof Given P = 〈V,C〉, let X ⊆ V be arbitrary, and let C′ = {e[δ] ∈ C | X ∩ V(δ) 6= ∅}. For every θ ∈ sol(P ) and constraint e[δ] ∈ C′ we have that θ|V(δ) ∈ e[δ] since θ is a solution to P . By Definition 19, it follows that for every e[δ] ∈ C′, θ|X∩V(δ) ∈ pjX∩V(δ)(e[δ]). Since the set of constraints of pjX(P ) is the least set containing for each e[δ] ∈ C′ the constraint pjX∩V(δ)(e[δ]), we have θ|X ∈ sol(pjX(P )), and hence sol(pjX(P )) ⊇ πX(sol(P )). Since X was arbitrary, the claim follows. ut\nTheorem 4 (Correctness of Algorithm 1) For every CSP instance P , we have that EnumSolutions(P ) = sol(P ).\nAlgorithm 1 Enumerate all solutions of a CSP instance procedure EnumSolutions(CSP instance P = 〈V,C〉) . Returns sol(P )\nSolutions← ∅ if V = ∅ then\nreturn {⊥} . The empty assignment else\nw ← chooseVar(V ) . Pick a variable from V Θ = EnumSolutions(pjV−{w}(P )) for θ ∈ Θ do\nfor a ∈ D(w) do θ′(w) = a if θ ⊕ θ′ is a solution to P then\nSolutions.add(θ ⊕ θ′) end if θ′ ← ⊥\nend for end for\nend if return Solutions\nend procedure\nProof The proof is by induction on the set of variables V in P . For the base case, if V = ∅, the empty assignment is the only solution.\nOtherwise, choose a variable w ∈ V , and let X = V − {w}. By induction, we can assume that EnumSolutions(pjX(P )) = sol(pjX(P )). Since for every θ ∈ sol(P ) there exists a ∈ D(w) such that θ = θ|X ∪ 〈w, a〉, and furthermore θ|X ∈ πX(sol(P )), it follows by Lemma 1 that θ|X ∈ sol(pjX(P )). Since Algorithm 1 checks every assignment of the form µ ∪ 〈w, a〉 for every µ ∈ sol(pjX(P )) and a ∈ D(w), it follows that EnumSolutions(P ) = sol(P ). ut\nThe time required for this algorithm depends on three key factors, which we are going to enumerate and discuss below. Let\n1. s(P ) be the maximum of the number of solutions to each of the instances pjW (P ), for W ⊆ V , 2. c(P ) be the maximum time required to check whether an assignment is a solution to pjW (P ), for W ⊆ V , and 3. b(P ) be the maximum time required to construct any instance pjW (P ), forW ⊆ V .\nThere are |V | calls to EnumSolutions. For each call, we need b(P ) time to construct the projection, while the double loop takes at most s(P )×|D(w)|×c(P ) time. Therefore, letting d = max({|D(w)| | w ∈ V }), the running time of Algorithm 1 is bounded by O ( |V | × (s(P )× d× c(P ) + b(P )) ) .\nSince constructing the projection of a classic CSP instance can be done in polynomial time, and likewise checking that an assignment is a solution, the whole algorithm runs in polynomial time if s(P ) is a polynomial in the size of P . For fractional edge covers, Grohe and Marx show the following.\nLemma 2 ([27]) A classic CSP instance P has at most |P |ρ ∗(hyp(P )) solutions.\nThe reason for Lemma 2 is that fractional edge covers require the hypergraph to be quite dense, and also that the hyperedges grow with the number of vertices in the hypergraph. This result has since been shown to be optimal — a classic CSP instance has polynomially many solutions in its size if and only if it has bounded fractional edge cover number [5].\nSince fractional edge cover number is a monotone width function, it follows that for any instance P = 〈V,C〉 and X ⊆ V , ρ∗(hyp(pjX(P ))) ≤ ρ∗(hyp(P )). This claim follows from the fact that pjX(P ) projects every constraint down to X, and hence every hyperedge of hyp(P ) down to X. Therefore, for classic CSP instances of bounded fractional edge cover number s(P ) is indeed polynomial in |P |. Grohe and Marx use this property to solve instances with bounded fractional hypertree width (and hence, bounded fractional edge cover number for every node in the corresponding tree decomposition) in polynomial time.\n3.2 CSP Instances with Few Solutions in Key Places\nAs we have seen above, having few solutions for every projection of a CSP instance is a property that can be used to obtain tractable classes of classic CSP instances. More importantly, we have shown that this property allows us to find all solutions to a CSP instance P , even with global constraints, if we can build arbitrary projections of P in polynomial time. In other words, with these two conditions we should be able to reduce instances with global constraints to classic instances in polynomial time. This, in turn, should allows us to apply the structural decomposition techniques discussed in Section 2.2 to such instances.\nHowever, on reflection there is no reason why we should need few solutions for every projection. Instead, consider the following reduction.\nDefinition 20 (Partial assignment checking) A global constraint catalogue Γ allows partial assignment checking if there exists a polynomial p(n) such that for any constraint e[δ] ∈ Γ we can decide in time O(p(|δ|)) whether a given assignment θ to a set of variables W ⊆ V(δ) is contained in an assignment that satisfies e[δ], i.e. whether there exists µ ∈ e[δ] such that θ = µ|W .\nAs an example, a catalogue that contains arbitrary EGC constraints (cf. Example 1) does not satisfy Definition 20, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [34]. On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 20 [35].\nIf a catalogue Γ satisfies Definition 20, we can for any constraint e[δ] ∈ Γ build arbitrary projections of it, that is, construct the global constraint pjX(e[δ]) for any X ⊆ V(δ), in polynomial time. In the case of Algorithm 1, where we build projections of projections, we can do so by keeping a copy of the original constraint, and projecting that each time.\nDefinition 21 (Intersection variables) Let 〈V,C〉 be a CSP instance. The set of intersection variables of any constraint e[δ] ∈ P is iv(δ) = ⋃ {V(δ) ∩ V(δ′) | e′[δ′] ∈ C − {e[δ]}}.\nIntersection variables are, in a sense, the only “interesting” variables of a constraint, as they are the ones interacting with the rest of the problem.\nDefinition 22 (Table constraint induced by a global constraint) Let P = 〈V,C〉 be a CSP instance. For every e[δ] ∈ C, let µ∗ be the assignment to V(δ)− iv(δ) that assigns a special value ∗ to every variable. The table constraint induced by e[δ] is ic(e[δ]) = e′[δ′], where V(δ′) = V(δ), and δ′ contains for every assignment θ ∈ sol(pjiv(δ)(P )) the assignment θ ⊕ µ∗.\nIf every constraint in a CSP instance P = 〈V,C〉 allows partial assignment checking, then building ic(e[δ]) for any e[δ] ∈ C can be done in polynomial time when |sol(pjX(P ))| is itself polynomial in the size of P for every subset X of iv(δ). To do so, we can invoke Algorithm 1 on the instance pjiv(δ)(P ). The definition below expresses this idea.\nDefinition 23 (Sparse intersections) A class of CSP instances P has sparse intersections if there exists a constant c such that for every constraint e[δ] in any instance P ∈ P, we have that for every X ⊆ iv(δ), |sol(pjX(P ))| < |P |c.\nIf a class of instances P has sparse intersections, and the instances are all over a constraint catalogue that allows partial assignment checking, then we can for every constraint e[δ] of any instance from P construct ic(e[δ]) in polynomial time. While this definition considers the instance as a whole, one special case of it is the case where every constraint has few solutions in the size of its description, that is, there is a constant c and the constraints are drawn from a catalogue Γ such that for every e[δ] ∈ Γ , we have that |{µ | µ ∈ e[δ]}| < |δ|c.\nNote that the problem of checking whether a class of CSP instances satisfies Definition 23 for a given c is, in general, hard. To see this, consider the special case of checking whether a global constraint e[δ] has any satisfying assignments at all. Letting δ be a SAT instance, that is, a propositional formula, and e an algorithm that checks whether an assignment to V(δ) satisfies the formula makes this an NP-hard problem to solve.\nMore generally, consider an arbitrary problem in NP. By definition, there is a polynomial-time algorithm that can check if a proposed solution to such a problem is correct. By treating the algorithm as the constraint type e, and the problem instances as descriptions δ, with a variable in V(δ) for each bit of the solution, it becomes clear that every problem in NP corresponds to a class of global constraints. The fact that global constraints have this much expressive power will be explored further in Section 4.\nDespite such bad news, however, it is not always difficult to recognise constraints with polynomially many satisfying assignments. A trivial example would be table constraints. For a less trivial example, consider the constraint Cβ from Example 3, where the number of satisfying assignments is bounded by a polynomial with exponent β (cf. the discussion after Corollary 1 for a detailed analysis).\nFor a more general example, consider a family of constraints that satisfy Definition 20. To check whether the number of solutions to a constraint from such a family is bounded by |δ|c for a fixed c in polynomial time, we can use Algorithm 1, stopping it if the number of partial assignments that extend to solutions exceeds the bound. Since we can check whether a partial assignment extends to a solution in polynomial time by Definition 20, we are also guaranteed an answer in polynomial time.\nArmed with these definitions, we can now state the following result.\nTheorem 5 Let P be a class of CSP instances over a catalogue that allows partial assignment checking. If P has sparse intersections, then we can in polynomial time\nreduce any instance P ∈ P to a classic CSP instance PCL with hyp(P ) = hyp(PCL), such that PCL has a solution if and only if P does.\nProof Let P = 〈V,C〉 be an instance from such a class P. For each e[δ] ∈ C, PCL will contain the table constraint ic(e[δ]) from Definition 22. Since P is over a catalogue that allows partial assignment checking, and P has sparse intersections, computing ic(e[δ]) can be done in polynomial time by invoking Algorithm 1 on pjiv(δ)(P ).\nBy construction, hyp(P ) = hyp(PCL). All that is left to show is that PCL has a solution if and only if P does. Let θ be a solution to P = 〈V,C〉. For every e[δ] ∈ C, we have that θ|iv(δ) ∈ pjiv(δ)(P ) by Definitions 19 and 21, and the assignment µ that assigns the value θ(v) to each v ∈\n⋃ e[δ]∈C iv(δ), and ∗ to every other variable is therefore\na solution to PCL. In the other direction, if θ is a solution to PCL, then θ satisfies ic(e[δ]) for every e[δ] ∈ C. By Definition 22, this means that θ|iv(δ) ∈ sol(pjiv(δ)(P )), and by Definition 19, there exists an assignment µe[δ] with µe[δ]|iv(δ) = θ|iv(δ) that satisfies e[δ]. By Definition 21, the variables not in iv(δ) do not occur in any other constraint in P , so we can combine all the assignments µe[δ] to form a solution µ to P such that for e[δ] ∈ C and v ∈ V(δ) we have µ(v) = µe[δ](v). ut\nFrom Theorem 5, we get tractable and fixed-parameter tractable classes of CSP instances with global constraints, in particular by applying Theorem 3.\nCorollary 1 Let H be a class of hypergraphs, and Γ a catalogue that allows partial assignment checking. If CSP(H, Γ ) has sparse intersections, then CSP(H, Γ ) is tractable or in FPT if CSP(H,Ext) is.\nProof Let H and Γ be given. By Theorem 5, we can reduce any P ∈ CSP(H, Γ ) to an instance PCL ∈ CSP(H,Ext) in polynomial time. Since PCL has a solution if and only if P does, tractability or fixed-parameter tractability of CSP(H,Ext) implies the same for CSP(H, Γ ). ut\nTo illustrate the above result, consider again the connected graph partition problem (Problem 1). This problem is NP-complete [18, p. 209], even for fixed α ≥ 3. However, note that when β is fixed, we can solve the problem in polynomial time, by successively guessing sets E′, with |E′| ≤ β, of broken edges, and checking whether the connected components of the graph 〈V,E −E′〉 all have α or fewer vertices. The number of such\nsets E′ is bounded by β∑ i=1 ( |E| i ) ≤ (|E| + 1)β , which is polynomial if β is fixed. As we show below, this argument can be seen as a special case of Theorem 5. To simplify the analysis, we assume without loss of generality that α < |V |, which means that any solution has at least one broken edge.\nWe claim that if β is fixed, then the constraint Cβ = eβ [δβ ] allows partial assignment checking, and has only a polynomial number of satisfying assignments. The latter implies that for any instance P of the CGP, |sol(pjiv(δβ)(P ))| is polynomial in the size of P for every subset of iv(δβ). Furthermore, we will show that for the constraint Cα = eα[δα], we also have that |sol(pjiv(δα)(P ))| is polynomial in the size of P . That Cα allows partial assignment checking can be seen by noting that each variable in V(δα) has a domain value for every vertex in the underlying graph. Therefore, given\na partial assignment to V(δα), we can check that no value is assigned more than α times. If yes, this assignment can be extended to a full one by assigning each remaining variable a domain value not yet assigned to any variable.\nFirst, we show that the number of satisfying assignments to Cβ is limited. Since Cβ limits the number of ones in any solution to β, the number of satisfying assignments to this constraint is the number of ways to choose up to β variables to be assigned\none. This is bounded by β∑ i=1 ( |E| i ) ≤ (|E|+ 1)β , and so we can generate them all in polynomial time. This argument also implies that we can perform partial assignment checking, simply by looking at the generated assignments.\nNow, let θ be such a solution. How many solutions to P contain θ? Every constraint on {u, v, e} with θ(e) = 1 allows at most |V |2 assignments, and there are at most β such constraints. So far we therefore have at most (|E|+ 1)β × |V |2β assignments.\nOn the other hand, a ternary constraint with θ(e) = 0 requires θ(u) = θ(v). Consider the graph G0 containing for every constraint on {u, v, e} with θ(e) = 0 the vertices u and v as well as the edge {u, v}. Since the original graph was connected, every connected component of G0 contains at least one vertex which is in the scope of some constraint with θ(e) = 1. Therefore, since equality is transitive, each connected component of G0 allows at most one assignment for each of the (|E| + 1)β × |V |2β assignments to the other variables of P . We therefore get a total bound of (|E|+1)β× |V |2β on the total number of solutions to P , and hence to pjiv(δα)(P ).\nThe hypergraph of any CSP instance P encoding the CGP has two hyperedges covering the whole problem, so the hypertree width of this hypergraph is two. Therefore, Corollary 1 and Theorem 1 apply and yield tractability for fixed β.\n3.3 Back Doors\nIf a class of CSP instances includes constraints from a catalogue that is not known to allow partial assignment checking, we may still obtain tractability in some cases by applying the notion of a back door set. A (strong) back door set [19,41] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve. Below, we are going to adapt this notion to individual constraints.\nDefinition 24 (Back door) Let Γ be a global constraint catalogue. A back door for a constraint e[δ] ∈ Γ is any set of variablesW ⊆ V(δ) (called a back door set) such that we can decide in polynomial time whether a given assignment θ to a set of variables V(θ) ⊇ W is contained in an assignment that satisfies e[δ], i.e. whether there exists µ ∈ e[δ] such that µ|V(θ) = θ.\nTrivially, for every constraint e[δ] the set of variables V(δ) is a back door set, since by Definition 4 we can always check in polynomial time if an assignment to V(δ) satisfies the constraint e[δ].\nThe key point about back doors is that given a catalogue Γ , adding to each e[δ] ∈ Γ with back door set W an arbitrary set of assignments to W produces a catalogue Γ ′ that allows partial assignment checking. Adding a set of assignments Θ means to add Θ to the description, and modify the algorithm e to only accept an assignment if it contains a member of Θ in addition to previous requirements. Furthermore, given a CSP instance P containing e[δ], as long as Θ ⊇ πW (sol(P )), adding Θ to e[δ] produces\nan instance that has exactly the same solutions. This point leads to the following definition.\nDefinition 25 (Sparse back door cover) Let ΓPAC be a catalogue that allows partial assignment checking and ΓBD a catalogue. For every instance P = 〈V,C〉 over ΓPAC ∪ ΓBD, let P ∩ ΓPAC be the instance with constraint set C′ = C ∩ ΓPAC and set of variables ⋃ {V ∩ V(δ) | e[δ] ∈ C′}.\nA class of CSP instances P over ΓPAC ∪ ΓBD has sparse back door cover if there exists a constant c such that for every instance P = 〈V,C〉 ∈ P and constraint e[δ] ∈ C, if e[δ] 6∈ ΓPAC , then there exists a back door setW for e[δ], findable in time polynomial in |P |, such that |sol(pjX(P ∩ ΓPAC))| ≤ |P |c for every X ⊆W .\nSparse back door cover means that for each constraint that is not from a catalogue that allows partial assignment checking, we can in polynomial time get a set of assignments Θ for its back door set using Algorithm 1, and so turn this constraint into one that does allow partial assignment checking. This operation preserves the solutions of the instance that contains this constraint.\nTheorem 6 If a class of CSP instance P has sparse back door cover, then we can in polynomial time reduce any instance P ∈ P to an instance P ′ such that hyp(P ) = hyp(P ′) and sol(P ) = sol(P ′). Furthermore, the class of instances {P ′ | P ∈ P} is over a catalogue that allows partial assignment checking.\nProof Let P = 〈V,C〉 ∈ P. We construct P ′ by adding to every e[δ] ∈ C such that e[δ] 6∈ ΓPAC , with back door setW , the set of assignments sol(pjW (P ∩ΓPAC)), which we can obtain using Algorithm 1. By Definition 25, we have for every X ⊆ W that |sol(pjW (P ∩ ΓPAC))| ≤ |P |c, so Algorithm 1 takes polynomial time since ΓPAC does allow partial assignment checking.\nIt is clear that hyp(P ′) = hyp(P ), and since sol(pjW (P ∩ ΓPAC)) ⊇ πW (sol(P )), the set of solutions stays the same, i.e. sol(P ′) = sol(P ). Finally, since we have replaced each constraint e[δ] in P that was not in ΓPAC by a constraint that does allow partial assignment checking, it follows that P ′ is over a catalogue that allows partial assignment checking. ut\nOne consequence of Theorem 6 is that we can sometimes apply Theorem 5 to a CSP instance that contains a constraint for which checking if a partial assignment can be extended to a satisfying one is hard. We can do so when the variables of that constraint are covered by the variables of other constraints that do allow partial assignment checking — but only if the instance given by those constraints has few solutions.\nAs a concrete example of this, consider again the encoding of the CGP that we gave in Example 3. The variables of constraint Cα are entirely covered by the instance P ′ obtained by removing Cα. As the entire set of variables of a constraint is a back door set for it, and the instance P ′ has few solutions (cf. the discussion after Theorem 5), this class of instances has sparse back door cover. As such, the constraint Cα could, in fact, be arbitrary without affecting the tractability of this problem. In particular, the requirement that Cα allows partial assignment checking can be dropped."
    }, {
      "heading" : "4 Subproblem Decompositions",
      "text" : "To generalize Theorem 5, consider the fact that our definition of a global constraint allows us to view a CSP instance 〈V,C〉 as a single constraint e[δ], by letting δ contain the set of constraint C, and setting V(δ) = V . The algorithm e then checks if an assignment satisfies all constraints. Of course, such a constraint encodes an NP-complete problem, but this is no different from e.g. the EGC constraint [34] (cf. Example 1). With this in mind, in this section we are going to investigate what happens if a CSP instance is split up into a set of smaller instances.\nSplitting up a (classic) CSP instance into smaller instances has previously been considered by Cohen and Green [10]. They use a very general framework of guarded decompositions [12] to define what they call “typed guarded decompositions”. This notion allows them to obtain a tractability result for a CSP instance that can be split into smaller instances drawn from known tractable classes.\nIn this section, we are going to adapt the notions defined in Section 3.2 to work with CSP instances rather than single constraints. Then, in Section 4.1, we will show how the result of Cohen and Green can be derived as a special case of Corollary 2.\nDefinition 26 (CSP subproblem) Given two CSP instances P = 〈V,C〉 and P ′ = 〈V ′, C′〉, we say that P ′ is a subproblem of P if C′ ⊆ C.\nIn other words, a subproblem of a CSP instance is given by a subset of the constraints in that instance. In [10], Cohen and Green call a subproblem a component of P .\nDefinition 27 (CSP union) Let Q1 = 〈V1, C1〉 and Q2 = 〈V2, C2〉 be two CSP instances. The union of Q1 and Q2 is the instance Q1 tQ2 = 〈V1 ∪ V2, C1 ∪ C2〉.\nDefinition 28 (Subproblem decomposition) Let P be a CSP instance. A set S of subproblems of P is a subproblem decomposition of P if ⊔ S = P .\nA subproblem decomposition of a CSP instance is proper if no element of the decomposition is a subproblem of any other.\nA subproblem decomposition of an instance P , then, is a set of subproblems that together contain all the constraints and variables of P . Note that a constraint may occur in more than one subproblem in a decomposition.\nBelow, we shall assume that all subproblem decompositions are proper. Since subproblems are given by subsets of constraints, the solutions to a CSP instance can be turned into solutions for any subproblem by projecting out the variables not part of the subproblem. Therefore, solving a subproblem P that contains another subproblem P ′ also solves P ′, making P ′ redundant.\nExample 5 Let P = 〈V,C〉 be a CSP instance. A very simple subproblem decomposition of P would be {〈V(δ), e[δ]〉 | e[δ] ∈ C}, that is, every constraint of P is a separate subproblem. This subproblem decomposition is clearly proper.\nExample 6 Consider a family of CSP instances on the set of boolean variables {xi, yi, zi | 1 ≤ i ≤ n ∈ {4, 6, 8, . . .}}, with the following constraints: An EGC constraint A on {x1, . . . , xn} with K(1) = 4 and K(0) = {0, . . . , n}. A second EGC constraint B, on {y1, . . . , yn, z1, . . . , zn} with K(1) = K(0) = {n}, and binary constraints on each pair {xi, yi} enforcing equality. A possible subproblem decomposition for an instance from\nthis family would be {P,Q}, where P contains A as well as the binary constraints, and Q contains the constraint B. This family is depicted in Figure 2, with P containing the constraints marked by solid lines, and Q the constraint marked by a dashed line.\nViewing subproblems as constraints and a subproblem decomposition S as a CSP instance 〈V( ⊔ S), S〉, we have sol(〈V( ⊔ S), S〉) = sol( ⊔ S), since every constraint is in some subproblem. As such, we will treat S as a CSP instance when it is convenient to simplify notation.\nUsing Definition 28, we can treat any set of CSP instances S as a subproblem decomposition of the instance ⊔ S. With that in mind, whenever we say that S is a subproblem decomposition without specifying what it is a decomposition of, we mean that S is a decomposition of the CSP instance ⊔ S.\nDefinition 29 (CSP instances given by subproblem decompositions) Let F be a family of subproblem decompositions. We define CSP(F) to be the class of CSP instances { ⊔ S | S ∈ F}.\nDefinition 30 (Hypergraph of a subproblem decomposition) Let S be a subproblem decomposition. The hypergraph of S, denoted hyp(S), has vertex set V( ⊔ S) and set of hyperedges {V(P ) | P ∈ S}. For a family F of subproblem decompositions, let hyp(F) = {hyp(S) | S ∈ F}.\nSince a CSP instance can be seen as a global constraint, Definition 20 (partial assignment checking) and Definition 23 (sparse intersections) carry over unchanged. To apply them to a family of subproblem decompositions F , we need only consider the catalogue ⋃ F in both cases.\nOne way of interpreting Definition 20 for a catalogue of CSP instances is that every instance has been drawn from a tractable class — not necessarily the same one, as long as these classes all allow us to check in polynomial time whether a partial assignment extends to a solution. Most known tractable classes of CSP instances have this property; in particular, all the classes discussed in Section 2.2 have it. To see this, note that a partial assignment can be seen as a set of constraints on one variable each, and adding such hyperedges to a hypergraph does not change its tree, hypertree, or submodular width. On the other hand, tractable classes defined by restricting the allowed assignments of a constraint, rather than the hypergraph, are usually preserved by adding a constraint with only one assignment [11].\nTo illustrate how these definitions apply to subproblem decompositions, consider the following example.\nExample 7 Recall the family of subproblem decompositions in Example 6. For a decomposition S = {P,Q} from this family, the set of intersection vertices for both subproblems is {y1, . . . , yn}. Furthermore, the EGC constraint A requires that there are exactly 4 variables assigned 1 among {x1, . . . , xn}, so there are (n4) satisfying assignments for this constraint. The equality constraints ensure that this is the number of solutions to the whole subproblem P , so for every X ⊆ {y1, . . . , yn} we have that |sol(pjX(S))| ≤ ( n 4). Therefore, this family of subproblem decompositions has sparse intersections.\nWe can now derive a straightforward generalization of Theorem 5.\nTheorem 7 Let F be a family of subproblem decompositions that allows partial assignment checking. If F has sparse intersections, then we can in polynomial time reduce any subproblem decomposition S ∈ F to a classic CSP instance P with hyp(P ) = hyp(S), such that P has a solution if and only if S does.\nProof As subproblems can be seen as global constraints, the proof follows directly from Theorem 5. ut\nCorollary 2 Let F be a family of subproblem decompositions that allows partial assignment checking and has sparse intersections. If CSP(hyp(F),Ext) is tractable or in FPT, then so is CSP(F).\nProof Let F be given. By Theorem 7, we can reduce any subproblem decomposition S ∈ F to an instance P ∈ CSP(hyp(F),Ext) in polynomial time. Since P has a solution if and only if S does, tractability of CSP(hyp(F),Ext) implies the same for CSP(F). ut\nTo illustrate this result, recall Example 6. From Example 7, we know that this family of subproblem decompositions has sparse intersections. Furthermore, both subproblem allow partial assignment checking, as the EGC constraints both have interval cardinality sets [35], and the equality constraints of subproblem P can always be satisfied. Therefore, Corollary 2 applies to this problem.\n4.1 Applying Corollary 2\nWe are now ready to discuss the result of Cohen and Green mentioned at the beginning of Section 4, and to show how it can be derived as a special case of our result. First, we need to define guarded decompositions.\nDefinition 31 (Guarded decomposition) A guarded block of a hypergraph G is a pair 〈λ, χ〉 where the guard λ is a subset of the hyperedges of G, and the block, χ, is a subset of ⋃ λ.\nFor every classic CSP instance P and every guarded block 〈λ, χ〉 of hyp(P ), we define the constraint generated by P on 〈λ, χ〉 to be the projection onto χ of the join of all the constraints of P whose scopes are in λ.\nA set of of guarded blocks Θ of a hypergraph G is a guarded decomposition of G if for every P ∈ CSP({G},Ext), the CSP instance over the same variables as P with constraints generated by the blocks in Θ has the same solutions as P .\nA guarded decomposition is acyclic if the hypergraph having the union of the blocks χ as vertices, and each χ as a hyperedge, is acyclic.\nCohen and Green then introduce a mapping µ from the constraints of a CSP instance P to nonempty sets of elements of a guarded decomposition of hyp(P ). They demand that\n1. For each guarded block 〈λ, χ〉 and hyperedge in λ, µ assigns at least one constraint with that scope to this guarded block, 2. that the set of guarded blocks µ assigns to a constraint c contains the scope of c in all the guards, and finally 3. that at least one of the guarded blocks assigned to c contains the variables of the scope of c in the block.\nNote that, taken together, the conditions above mean that the mapping µ turns each guarded block of the decomposition into a subproblem, and the whole decomposition into a subproblem decomposition, since each guarded block is assigned a set of constraints, and each constraint is assigned to a guarded block.\nFurthermore, they introduce two more notions. A type is a polynomial-time algorithm for solving a set of CSP instances. A typed guarded decomposition is one where each guarded block β is assigned a type, and the CSP instance given by the set of constraints assigned to β is a member of the assigned type. This is almost Definition 20, however, there is no provision for solving a problem with some variables assigned.\nFinally, a guarded decomposition Θ is k-separated if for every guarded block 〈λ, χ〉 there exists a set of hyperedges , with | | ≤ k, such that for each guarded block 〈λ2, χ2〉 ∈ Θ − {λ, χ} we have that χ ∩ χ2 ⊆ ⋃ . Observe that when k is fixed, the intersection variables of each subproblem are covered by a fixed number of table constraints, and hence that the number of possible solutions is bounded by the size of the join of these constraints. It follows that the intersections are sparse as per Definition 23.\nThey then proceed to show that for fixed k, a CSP instance with a k-separated, acyclic typed guarded decomposition can be solved in polynomial time, under the condition that the types can handle problems with some variables assigned specific values.\nThe last condition is precisely what we need for partial assignment checking. Therefore, since the decomposition is required to be acyclic, their result satisfies the conditions of Corollary 2. Note, however, that since there are other ways to obtain sparse intersections, Corollary 2 is a more general result even for classic CSP instances."
    }, {
      "heading" : "5 Weighted CSP",
      "text" : "Having few solutions in key parts of a CSP instance has turned out to be a property we can exploit to obtain tractability. In this section, we are going to apply this property to an extension of the CSP framework called weighted CSP instances [21,22], where every constraint assigns a cost to every satisfying assignment, and we would like to find a solution with smallest cost. This type of CSP is itself a special case of the more general valued CSP framework [38,42], where every constraint is specified by a function that assigns a cost to every possible assignment for the variables of that constraint. The reason for considering weighted, rather than valued, CSP, is that weighted (table) constraints list every satisfying assignment along with the costs, while a valued constraint is given by a function from assignments to values. The representation of a valued constraint is thus much more compact, and the notion of a satisfying assignment is no longer defined.\nDefinition 32 (Weighted constraint) A weighted global constraint e[δ] is a global constraint that assigns to each θ ∈ e[δ] a value cost(e[δ], θ) from Q.\nThe size of a weighted global constraint e[δ] is given by the sum of |δ| and the size of the bit representation for each cost.\nIn other words, the number of bits needed to represent the costs of all the satisfying assignments is part of a weighted constraint’s size.\nDefinition 33 (WCSP instance) A WCSP instance is a pair P = 〈V,C〉, where V is a set of variables and C a set of weighted constraints. An assignment is a solution to P if it satisfies every constraint in C, and we denote the set of all solutions to P by sol(P ).\nFor every solution θ to P we define cost(P, θ) = ∑ e[δ]∈C cost(e[δ], θ|V(δ)). An assignment θ is an optimal solution to P if and only if it is a solution to P with the smallest cost, i.e. cost(P, θ) = min({cost(P, θ′) | θ′ ∈ sol(P )}).\nAs is commonly done with optimization problems in complexity theory, below we consider the decision problem associated with WCSP instances.\nDefinition 34 (WCSP decision problem) Given a WCSP instance P and k ∈ Q, theWCSP decision problem is to decide whether P has a solution θ with cost(P, θ) ≤ k.\nAs for CSP instances, a classic WCSP instance is one where all constraints are table global constraints. As an example of known tractability results for classic WCSP instances, consider the theorem below.\nTheorem 8 ([22]) Let H be a class of hypergraphs. If ghw(H) < ∞, then a class of classic WCSP instances whose hypergraphs are in H is tractable.\nSince we are free to ignore the costs a weighted constraint puts on assignments and treat it as an “ordinary” constraint, definitions of subproblems and subproblem decompositions carry over unchanged. Note that since the WCSP decision problem is clearly in NP, we can view a WCSP instance as a weighted global constraint. Therefore, Definition 20 will now be subtly different.\nDefinition 35 (Weighted part. assignment checking) A weighted constraint catalogue Γ allows partial assignment checking if for any weighted constraint e[δ] ∈ Γ we can decide in polynomial time, given an assignment θ to a set of variables W ⊆ V(δ) and k ∈ Q, whether θ is contained in an assignment that satisfies e[δ] and has cost at most k, i.e. whether there exists µ ∈ e[δ] such that θ = µ|W and cost(e[δ], µ) ≤ k.\nIn other words, given a partial assignment we need to be able to solve the WCSP decision problem for our constraint in polynomial time. Note also that doing so allows us to find the minimum cost among the assignments that contain our partial assignment by binary search. This will be needed in order to construct projections of a weighted global constraint. To define the projection of a weighted constraint, we need to alter Definition 19 to take costs into account.\nDefinition 36 (Weighted constraint projection) Let e[δ] be a weighted constraint. The projection of e[δ] onto a set of variables X ⊆ V(δ) is the constraint pjX(e[δ]) such that µ ∈ pjX(e[δ]) if and only if there exists θ ∈ e[δ] with θ|X = µ. The cost of an assignment θ ∈ pjX(e[δ]) is cost(pjX(e[δ]), θ) = min({cost(e[δ], µ) | µ ∈ e[δ] and µ|X = θ}).\nFor a WCSP instance P = 〈V,C〉 and X ⊆ V we define pjX(P ) = 〈X,C′〉, where C′ is the least set containing for every e[δ] ∈ C such that X ∩ V(δ) 6= ∅ the constraint pjX∩V(δ)(e[δ]).\nDefinition 37 (Weighted table constraint induced by a subproblem) Let S be a subproblem decomposition. For every T ∈ S, let µ∗ be the assignment to V(T )−iv(T ) that assigns a special value ∗ to every variable. The weighted table constraint induced by T is ic(T ) = e[δ], where V(δ) = V(T ), and δ contains for every assignment θ ∈ sol(pjiv(T )(S)) the assignment θ ⊕ µ∗ with cost(ic(T ), θ ⊕ µ∗) = cost(pjiv(T )(T ), θ).\nSince the variables of a subproblem T ∈ S not in iv(T ) occur only in T itself, if we have a solution to pjiv(T )(S), it doesn’t matter what solution to T we extend it to. We should therefore pick the one that has the smallest cost, and that cost is precisely cost(pjiv(T )(T ), θ) by Definition 36. The same as for CSP instances, if every subproblem in a weighted decomposition S allows weighted partial assignment checking, building ic(T ) for any T ∈ S can be done in polynomial time when |sol(pjiv(T )(S))| is polynomial in the size of ⊔ S for every subset of iv(T ), again by using Algorithm 1. Since the definition of sparse intersections (Definition 23) carries over unchanged, we are ready to prove the following analogue of Theorem 5 for weighted subproblem decompositions.\nTheorem 9 Let F be a family of weighted subproblem decompositions that allows partial assignment checking. If F has sparse intersections, then we can in polynomial time reduce any weighted subproblem decomposition S ∈ F to a classic weighted CSP instance P with hyp(P ) = hyp(S), such that P has a solution with cost at most k ∈ Q if and only if S does.\nProof Let S be a subproblem decomposition from F . For each T ∈ S, P will contain the table constraint ic(T ) from Definition 22. Since F allows partial assignment checking and has sparse intersections, computing ic(T ) can be done in polynomial time by invoking Algorithm 1 on pjiv(T )(S).\nIt is clear that hyp(P ) = hyp(S). All that is left to show is that P has a solution with cost at most k ∈ N if and only if S does. Let θ be a solution to S. For every T ∈ S, θ|iv(T ) ∈ pjiv(T )(S) by Definitions 21 and 36, so the assignment µ that assigns\nthe value θ(v) to each v ∈ ⋃ T∈S iv(T ), and ∗ to every other variable is a solution to P . Furthermore, for every T ∈ S we have by Definition 37 that cost(ic(T ), µ|V(T )) = cost(pjiv(T )(T ), µ|iv(T )), so by Definition 36 cost(ic(T ), µ|V(T )) ≤ cost(T, θ|V(T )) and therefore cost(P, µ) ≤ cost(S, θ).\nIn the other direction, if θ is a solution to P , then θ satisfies ic(T ) for every T ∈ S. By Definition 37, this means that θ|iv(T ) ∈ sol(pjiv(T )(S)), and by Definition 36, there exists an assignment µT with µT |iv(T ) = θ|iv(T ) that satisfies T , such that cost(ic(T ), θ|V(T )) = cost(T, µT ). By Definition 21, the variables not in iv(T ) do not occur in any other subproblem from S, so we can combine all the assignments µT to form a solution µ to S such that for T ∈ S and v ∈ V(T ) we have µ(v) = µT (v), with cost(P, θ) = cost(S, µ). ut\nAs before, for a family of weighted subproblem decompositions F we defineWCSP(F) = { ⊔ S | S ∈ F}, and for a class of hypergraphs H we let WCSP(H,Ext) be the class of classic WCSP instances whose hypergraphs are in H. With that in mind, we can use Theorem 9 to obtain new tractable and fixed-parameter tractable classes of weighted CSP instances with global constraints.\nCorollary 3 Let F be a family of weighted subproblem decompositions that allows partial assignment checking and has sparse intersections. If WCSP(hyp(F),Ext) is tractable or in FPT, then so is WCSP(F).\nProof Let F be given. By Theorem 9, we can reduce any weighted subproblem decomposition S ∈ F to an instance P ∈ WCSP(hyp(F),Ext) in polynomial time. Since P has a solution with cost k if and only if S does, tractability of WCSP(hyp(F),Ext) implies the same for WCSP(F). ut"
    }, {
      "heading" : "6 Summary",
      "text" : "We have studied the tractability of CSPs with global constraints under various structural restrictions such as tree and hypertree width. By exploiting the number of solutions to CSP instances in key places, we have identified new tractable classes of such problems, both in the ordinary and weighted case.\nFurthermore, we have shown how this technique can be used to combine CSP instances drawn from known tractable classes, extending a previous result by Cohen and Green [10]. We have also shown how the existence of back doors in CSP instances can be used to augment our results.\nMore work remains to be done on this topic. In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32]. Also of interest is the complexity of checking whether a constraint has few solutions, which ties into finding classes of CSP instances that satisfy Definition 23.\nAcknowledgements This work has been supported by the Research Council of Norway through the project DOIL (RCN project #213115). The author thanks the anonymous reviewers for their detailed feedback."
    } ],
    "references" : [ {
      "title" : "Width functions for hypertree decompositions",
      "author" : [ "I. Adler" ],
      "venue" : "Doctoral dissertation, AlbertLudwigs-Universität Freiburg",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Hypertree width and related hypergraph invariants",
      "author" : [ "I. Adler", "G. Gottlob", "M. Grohe" ],
      "venue" : "European Journal of Combinatorics 28(8), 2167–2181",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Optimization methods for the partner units problem",
      "author" : [ "M. Aschinger", "C. Drescher", "G. Friedrich", "G. Gottlob", "P. Jeavons", "A. Ryabokon", "E. Thorstensen" ],
      "venue" : "Proceedings of the 8th International Conference on Integration of Artificial Intelligence and Operations Research Techniques in Constraint Programming for Combinatorial Optimization Problems (CPAIOR’11), Lecture Notes in Computer Science, vol. 6697, pp. 4–19. Springer",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Structural decomposition methods and what they are good for",
      "author" : [ "M. Aschinger", "C. Drescher", "G. Gottlob", "P. Jeavons", "E. Thorstensen" ],
      "venue" : "T. Schwentick, C. Dürr (eds.) Proceedings of the 28th International Symposium on Theoretical Aspects of Computer Science (STACS’11), Leibniz International Proceedings in Informatics, vol. 9, pp. 12– 28",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Size bounds and query plans for relational joins",
      "author" : [ "A. Atserias", "M. Grohe", "D. Marx" ],
      "venue" : "SIAM J. Comput. 42(4), 1737–1767",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The complexity of reasoning with global constraints",
      "author" : [ "C. Bessiere", "E. Hebrard", "B. Hnich", "T. Walsh" ],
      "venue" : "Constraints 12(2), 239–259",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Decomposition of the NValue constraint",
      "author" : [ "C. Bessiere", "G. Katsirelos", "N. Narodytska", "C.G. Quimper", "T. Walsh" ],
      "venue" : "Proceedings of the 16th International Conference on Principles and Practice of Constraint Programming (CP’10), Lecture Notes in Computer Science, vol. 6308. Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Classifying the complexity of constraints using finite algebras",
      "author" : [ "A. Bulatov", "P. Jeavons", "A. Krokhin" ],
      "venue" : "SIAM Journal on Computing 34(3), 720–742",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Constraint satisfaction with succinctly specified relations",
      "author" : [ "H. Chen", "M. Grohe" ],
      "venue" : "Journal of Computer and System Sciences 76(8), 847–860",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Typed guarded decompositions for constraint satisfaction",
      "author" : [ "D. Cohen", "M. Green" ],
      "venue" : "F. Benhamou (ed.) Proceedings of the 12th International Conference on the Principles and Practice of Constraint Programming (CP’06), Lecture Notes in Computer Science, vol. 4204, pp. 122–136. Springer",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "The complexity of constraint languages",
      "author" : [ "D. Cohen", "P. Jeavons" ],
      "venue" : "F. Rossi, P. van Beek, T. Walsh (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, pp. 245 – 280. Elsevier",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A unified theory of structural tractability for constraint satisfaction problems",
      "author" : [ "D. Cohen", "P. Jeavons", "M. Gyssens" ],
      "venue" : "Journal of Computer and System Sciences 74(5), 721–743",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Constraint representations and structural tractability",
      "author" : [ "D.A. Cohen", "M.J. Green", "C. Houghton" ],
      "venue" : "Proceedings of the 15th International Conference on Principles and Practice of Constraint Programming (CP’09), Lecture Notes in Computer Science, vol. 5732, pp. 289–303. Springer",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Tractable combinations of global constraints",
      "author" : [ "D.A. Cohen", "P.G. Jeavons", "E. Thorstensen", "S. Živný" ],
      "venue" : "C. Schulte (ed.) Proceedings of the 19th International Conference on Principles and Practice of Constraint Programming (CP’13), Lecture Notes in Computer Science, vol. 8124, pp. 230–246. Springer",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Constraint satisfaction, bounded treewidth, and finite-variable logics",
      "author" : [ "V. Dalmau", "P.G. Kolaitis", "M.Y. Vardi" ],
      "venue" : "Proceedings of the 8th International Conference on Principles and Practice of Constraint Programming (CP’02), Lecture Notes in Computer Science, vol. 2470, pp. 223–254. Springer",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Parameterized Complexity",
      "author" : [ "R.G. Downey", "M.R. Fellows" ],
      "venue" : "Monographs in Computer Science. Springer",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Parameterized Complexity Theory",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "Texts in Theoretical Computer Science. Springer",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : "W. H. Freeman",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Backdoors to satisfaction",
      "author" : [ "S. Gaspers", "S. Szeider" ],
      "venue" : "H.L. Bodlaender, R. Downey, F.V. Fomin, D. Marx (eds.) The Multivariate Algorithmic Revolution and Beyond, Lecture Notes in Computer Science, vol. 7370, pp. 287–317. Springer",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "MINION: A fast, scalable constraint solver",
      "author" : [ "I.P. Gent", "C. Jefferson", "I. Miguel" ],
      "venue" : "Proceedings of the 17th European Conference on Artificial Intelligence (ECAI’06), pp. 98–102. IOS Press",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Exploiting Tree Decomposition and Soft Local Consistency in Weighted CSP",
      "author" : [ "S. de Givry", "T. Schiex", "G. Verfaillie" ],
      "venue" : "Proceedings of the 21st National Conference on Artificial Intelligence (AAAI’06), pp. 22–27",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Tractable optimization problems through hypergraph-based structural restrictions",
      "author" : [ "G. Gottlob", "G. Greco", "F. Scarcello" ],
      "venue" : "S. Albers, A. Marchetti-Spaccamela, Y. Matias, S. Nikoletseas, W. Thomas (eds.) Proceedings of the 36th International Colloquium on Automata‚ Languages and Programming (ICALP’09), Lecture Notes in Computer Science, vol. 5556, pp. 16–30. Springer",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A comparison of structural CSP decomposition methods",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Artificial Intelligence 124(2), 243–282",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Hypertree decompositions and tractable queries",
      "author" : [ "G. Gottlob", "N. Leone", "F. Scarcello" ],
      "venue" : "Journal of Computer and System Sciences 64(3), 579–627",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Structural tractability of propagated constraints",
      "author" : [ "M.J. Green", "C. Jefferson" ],
      "venue" : "Proceedings of the 14th International Conference on Principles and Practice of Constraint Programming (CP’08), Lecture Notes in Computer Science, vol. 5202, pp. 372–386. Springer",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "The complexity of homomorphism and constraint satisfaction problems seen from the other side",
      "author" : [ "M. Grohe" ],
      "venue" : "Journal of the ACM 54(1), 1–24",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Constraint solving via fractional edge covers",
      "author" : [ "M. Grohe", "D. Marx" ],
      "venue" : "Proceedings of the 17th ACM-SIAM symposium on discrete algorithms (SODA’06), pp. 289–298. ACM",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Bin repacking scheduling in virtualized datacenters",
      "author" : [ "F. Hermenier", "S. Demassey", "X. Lorca" ],
      "venue" : "J. Lee (ed.) Proceedings of the 17th International Conference on Principles and Practice ofConstraint Programming (CP’11), Lecture Notes in Computer Science, vol. 6876, pp. 27–41. Springer",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Global constraints",
      "author" : [ "W.J. van Hoeve", "I. Katriel" ],
      "venue" : "F. Rossi, P. van Beek, T. Walsh (eds.) Handbook of Constraint Programming, Foundations of Artificial Intelligence, vol. 2, pp. 169–208. Elsevier",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Simultaneous matchings: Hardness and approximation",
      "author" : [ "M. Kutz", "K. Elbassioni", "I. Katriel", "M. Mahajan" ],
      "venue" : "Journal of Computer and System Sciences 74(5), 884–897",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Approximating fractional hypertree width",
      "author" : [ "D. Marx" ],
      "venue" : "ACM Transactions on Algorithms 6(2), 29:1–29:17",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Can you beat treewidth",
      "author" : [ "D. Marx" ],
      "venue" : "Theory of Computing",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2010
    }, {
      "title" : "Tractable hypergraph properties for constraint satisfaction and conjunctive queries",
      "author" : [ "D. Marx" ],
      "venue" : "J. ACM 60(6), 42",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Improved algorithms for the global cardinality constraint",
      "author" : [ "C.G. Quimper", "A. López-Ortiz", "P. van Beek", "A. Golynski" ],
      "venue" : "Proceedings of the 10th International Conference on Principles and Practice of Constraint Programming (CP’04), Lecture Notes in Computer Science, vol. 3258, pp. 542–556. Springer",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Generalized Arc Consistency for Global Cardinality Constraint",
      "author" : [ "J.C. Régin" ],
      "venue" : "Proceedings of the 13th National Conference on Artificial Intelligence (AAAI’96), pp. 209–215. AAAI Press",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "The Handbook of Constraint Programming",
      "author" : [ "F. Rossi", "P. van Beek", "Walsh", "T. (eds." ],
      "venue" : "Elsevier",
      "citeRegEx" : "36",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Tractable cases of the extended global cardinality constraint",
      "author" : [ "M. Samer", "S. Szeider" ],
      "venue" : "Constraints 16(1), 1–24",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Valued Constraint Satisfaction Problems: Hard and Easy Problems",
      "author" : [ "T. Schiex", "H. Fargier", "G. Verfaillie" ],
      "venue" : "C. Mellish (ed.) Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI’95), pp. 631–639",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Practical applications of constraint programming",
      "author" : [ "M. Wallace" ],
      "venue" : "Constraints 1, 139–168",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "ECLiPSe: A platform for constraint logic programming",
      "author" : [ "M. Wallace", "S. Novello", "J. Schimpf" ],
      "venue" : "ICL Systems Journal 12(1), 137–158",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Backdoors to typical case complexity",
      "author" : [ "R. Williams", "C.P. Gomes", "B. Selman" ],
      "venue" : "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI’03), pp. 1173–1178",
      "citeRegEx" : "41",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "The complexity and expressive power of valued constraints",
      "author" : [ "S. Živný" ],
      "venue" : "Doctoral dissertation, University of Oxford",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 28,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].",
      "startOffset" : 116,
      "endOffset" : 123
    }, {
      "referenceID" : 38,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].",
      "startOffset" : 116,
      "endOffset" : 123
    }, {
      "referenceID" : 2,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].",
      "startOffset" : 154,
      "endOffset" : 160
    }, {
      "referenceID" : 27,
      "context" : "Constraint programming (CP) is widely used to solve a variety of practical problems such as planning and scheduling [29,39], and industrial configuration [3,28].",
      "startOffset" : 154,
      "endOffset" : 160
    }, {
      "referenceID" : 19,
      "context" : "as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].",
      "startOffset" : 126,
      "endOffset" : 136
    }, {
      "referenceID" : 35,
      "context" : "as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].",
      "startOffset" : 126,
      "endOffset" : 136
    }, {
      "referenceID" : 39,
      "context" : "as global constraints, and a lot of the success of CP in practice has been attributed to solvers providing global constraints [20,36,40].",
      "startOffset" : 126,
      "endOffset" : 136
    }, {
      "referenceID" : 3,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].",
      "startOffset" : 287,
      "endOffset" : 304
    }, {
      "referenceID" : 7,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].",
      "startOffset" : 287,
      "endOffset" : 304
    }, {
      "referenceID" : 11,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].",
      "startOffset" : 287,
      "endOffset" : 304
    }, {
      "referenceID" : 22,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].",
      "startOffset" : 287,
      "endOffset" : 304
    }, {
      "referenceID" : 25,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].",
      "startOffset" : 287,
      "endOffset" : 304
    }, {
      "referenceID" : 32,
      "context" : "The theoretical properties of constraint problems, in particular the computational complexity of different types of problem, have been extensively studied and quite a lot is known about what restrictions on the general constraint satisfaction problem are sufficient to make it tractable [4,8,12,23,26,33].",
      "startOffset" : 287,
      "endOffset" : 304
    }, {
      "referenceID" : 23,
      "context" : "In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33].",
      "startOffset" : 188,
      "endOffset" : 198
    }, {
      "referenceID" : 26,
      "context" : "In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33].",
      "startOffset" : 188,
      "endOffset" : 198
    }, {
      "referenceID" : 32,
      "context" : "In particular, many structural restrictions, that is, restrictions on how the constraints in a problem interact, have been identified and shown to yield tractable classes of CSP instances [24,27,33].",
      "startOffset" : 188,
      "endOffset" : 198
    }, {
      "referenceID" : 29,
      "context" : "This is the case even when the global constraints are fairly simple, such as overlapping difference constraints with acyclic hypergraphs [30].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 5,
      "context" : "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [6,37].",
      "startOffset" : 121,
      "endOffset" : 127
    }, {
      "referenceID" : 36,
      "context" : "This is generally done by pruning from the domains of variables those values that cannot lead to a satisfying assignment [6,37].",
      "startOffset" : 121,
      "endOffset" : 127
    }, {
      "referenceID" : 6,
      "context" : "Another strand of research has explored conditions that allow global constraints to be replaced by collections of explicitly represented constraints [7].",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 8,
      "context" : "As discussed in [9], when the constraints in a family of problems have unbounded arity, the way that the constraints are represented can significantly affect the complexity.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 24,
      "context" : "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 12,
      "context" : "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation.",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 8,
      "context" : "Previous work in this area has assumed that the global constraints have specific representations, such as propagators [25], negative constraints [13], or GDNF/decision diagrams [9], and exploited properties particular to that representation.",
      "startOffset" : 177,
      "endOffset" : 180
    }, {
      "referenceID" : 13,
      "context" : "In contrast, we will use a definition of global constraints, used also in [14], that allows us to discuss different representations in a uniform manner.",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 9,
      "context" : "The results that we obtain on this topic extend previous research by Cohen and Green [10].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 20,
      "context" : "Finally, we show how our results can be extended to weighted CSP [21,22], that is, CSP where constraints assign costs to satisfying assignments, and the goal is to find an optimal solution.",
      "startOffset" : 65,
      "endOffset" : 72
    }, {
      "referenceID" : 21,
      "context" : "Finally, we show how our results can be extended to weighted CSP [21,22], that is, CSP where constraints assign costs to satisfying assignments, and the goal is to find an optimal solution.",
      "startOffset" : 65,
      "endOffset" : 72
    }, {
      "referenceID" : 28,
      "context" : "For example, in [29] a global constraint is defined as “a constraint that captures a relation between a non-fixed number of variables”.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 5,
      "context" : "Below, we offer a precise definition similar to the one in [6], where the authors define global constraints for a domain D over a list of variables σ as being given intensionally by a function D|σ| → {0, 1} computable in polynomial time.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 36,
      "context" : "Example 1 (EGC) A very general global constraint type is the extended global cardinality constraint type [37].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 0,
      "context" : "To present the various structural restrictions, we will use the framework of width functions, introduced by Adler [1].",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 26,
      "context" : "Next, we define a relaxation of hypertree width known as fractional hypertree width, introduced by Grohe and Marx [27].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 0,
      "context" : "A fractional edge cover for X is a function γ : H → [0, 1] such that ∑",
      "startOffset" : 52,
      "endOffset" : 58
    }, {
      "referenceID" : 26,
      "context" : "It is known that this minimum is always rational [27].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 1,
      "context" : "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 26
    }, {
      "referenceID" : 14,
      "context" : "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 26
    }, {
      "referenceID" : 23,
      "context" : "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 26
    }, {
      "referenceID" : 26,
      "context" : "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 26
    }, {
      "referenceID" : 30,
      "context" : "Theorem 1 ([2,15,24,27,31]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 26
    }, {
      "referenceID" : 32,
      "context" : "To go beyond fractional hypertree width, Marx [33] recently introduced the concept of submodular width.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 15,
      "context" : "However, this class is what is called fixed-parameter tractable [16,17].",
      "startOffset" : 64,
      "endOffset" : 71
    }, {
      "referenceID" : 16,
      "context" : "However, this class is what is called fixed-parameter tractable [16,17].",
      "startOffset" : 64,
      "endOffset" : 71
    }, {
      "referenceID" : 32,
      "context" : "Theorem 2 ([33]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 26,
      "context" : "The three structural restrictions that we have just presented form a hierarchy [27, 33]: For every hypergraph G, subw(G) ≤ fhw(G) ≤ ghw(G) ≤ tw(G).",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 32,
      "context" : "The three structural restrictions that we have just presented form a hierarchy [27, 33]: For every hypergraph G, subw(G) ≤ fhw(G) ≤ ghw(G) ≤ tw(G).",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 17,
      "context" : "Example 4 The NP-complete problem of 3-colourability [18] is to decide, given a graph 〈V,E〉, whether the vertices V can be coloured with three colours such that no two adjacent vertices have the same colour.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 26,
      "context" : "To obtain tractability for classic CSP instances of bounded fractional hypertree width, Grohe and Marx [27] use a bound on the number of solutions to a classic CSP instance, and show that this bound is preserved when we consider parts of a CSP instance.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 26,
      "context" : "Lemma 2 ([27]) A classic CSP instance P has at most |P | ∗(hyp(P )) solutions.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 4,
      "context" : "This result has since been shown to be optimal — a classic CSP instance has polynomially many solutions in its size if and only if it has bounded fractional edge cover number [5].",
      "startOffset" : 175,
      "endOffset" : 178
    }, {
      "referenceID" : 33,
      "context" : "Example 1) does not satisfy Definition 20, since checking whether an arbitrary EGC constraint has a satisfying assignment is NP-hard [34].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 34,
      "context" : "On the other hand, a catalogue that contains only EGC constraints whose cardinality sets are intervals does satisfy Definition 20 [35].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 18,
      "context" : "A (strong) back door set [19,41] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.",
      "startOffset" : 25,
      "endOffset" : 32
    }, {
      "referenceID" : 40,
      "context" : "A (strong) back door set [19,41] is a set of variables in a CSP instance that, when assigned, make the instance easy to solve.",
      "startOffset" : 25,
      "endOffset" : 32
    }, {
      "referenceID" : 33,
      "context" : "the EGC constraint [34] (cf.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 9,
      "context" : "Splitting up a (classic) CSP instance into smaller instances has previously been considered by Cohen and Green [10].",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 11,
      "context" : "They use a very general framework of guarded decompositions [12] to define what they call “typed guarded decompositions”.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 9,
      "context" : "In [10], Cohen and Green call a subproblem a component of P .",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 10,
      "context" : "On the other hand, tractable classes defined by restricting the allowed assignments of a constraint, rather than the hypergraph, are usually preserved by adding a constraint with only one assignment [11].",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 34,
      "context" : "Furthermore, both subproblem allow partial assignment checking, as the EGC constraints both have interval cardinality sets [35], and the equality constraints of subproblem P can always be satisfied.",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 20,
      "context" : "In this section, we are going to apply this property to an extension of the CSP framework called weighted CSP instances [21,22], where every constraint assigns a cost to every satisfying assignment, and we would like to find a solution with smallest cost.",
      "startOffset" : 120,
      "endOffset" : 127
    }, {
      "referenceID" : 21,
      "context" : "In this section, we are going to apply this property to an extension of the CSP framework called weighted CSP instances [21,22], where every constraint assigns a cost to every satisfying assignment, and we would like to find a solution with smallest cost.",
      "startOffset" : 120,
      "endOffset" : 127
    }, {
      "referenceID" : 37,
      "context" : "This type of CSP is itself a special case of the more general valued CSP framework [38,42], where every constraint is specified by a function that assigns a cost to every possible assignment for the variables of that constraint.",
      "startOffset" : 83,
      "endOffset" : 90
    }, {
      "referenceID" : 41,
      "context" : "This type of CSP is itself a special case of the more general valued CSP framework [38,42], where every constraint is specified by a function that assigns a cost to every possible assignment for the variables of that constraint.",
      "startOffset" : 83,
      "endOffset" : 90
    }, {
      "referenceID" : 21,
      "context" : "Theorem 8 ([22]) Let H be a class of hypergraphs.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 9,
      "context" : "Furthermore, we have shown how this technique can be used to combine CSP instances drawn from known tractable classes, extending a previous result by Cohen and Green [10].",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 8,
      "context" : "In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32].",
      "startOffset" : 211,
      "endOffset" : 220
    }, {
      "referenceID" : 25,
      "context" : "In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32].",
      "startOffset" : 211,
      "endOffset" : 220
    }, {
      "referenceID" : 31,
      "context" : "In particular, investigating whether a refinement of the conditions we have identified can be used to show dichotomy theorems, similar to those known for certain kinds of constraints and structural restrictions [9,26,32].",
      "startOffset" : 211,
      "endOffset" : 220
    } ],
    "year" : 2015,
    "abstractText" : "A wide range of problems can be modelled as constraint satisfaction problems (CSPs), that is, a set of constraints that must be satisfied simultaneously. Constraints can either be represented extensionally, by explicitly listing allowed combinations of values, or implicitly, by special-purpose algorithms provided by a solver. Such implicitly represented constraints, known as global constraints, are widely used; indeed, they are one of the key reasons for the success of constraint programming in solving real-world problems. In recent years, a variety of restrictions on the structure of CSP instances have been shown to yield tractable classes of CSPs. However, most such restrictions fail to guarantee tractability for CSPs with global constraints. We therefore study the applicability of structural restrictions to instances with such constraints. We show that when the number of solutions to a CSP instance is bounded in key parts of the problem, structural restrictions can be used to derive new tractable classes. Furthermore, we show that this result extends to combinations of instances drawn from known tractable classes, as well as to CSP instances where constraints assign costs to satisfying assignments.",
    "creator" : "LaTeX with hyperref package"
  }
}