{
  "name" : "1401.3484.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Modularity Aspects of Disjunctive Stable Models",
    "authors" : [ "Tomi Janhunen", "Emilia Oikarinen", "Hans Tompits", "Stefan Woltran" ],
    "emails" : [ "Tomi.Janhunen@tkk.fi", "Emilia.Oikarinen@tkk.fi", "tompits@kr.tuwien.ac.at", "woltran@dbai.tuwien.ac.at" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Practically all programming languages used in software development allow the programmer to split a program into several modules which interact through well-defined input/output interfaces. Given this, the entire program can be viewed as a composition of its component modules which are typically linked together in the respective run-time environment. The expected benefits of modular program development are manifold. First, it imposes a good programming style to be followed by the programmer. A complex software system is much easier to develop as a set of interacting components rather than a monolithic program. Second, a modular architecture allows for additional flexibility as regards delegating programming tasks amongst a team of programmers. In this setting, the goal of each programmer is to implement desired input/output behavior(s) in terms of concrete module(s) which together implement the software system being developed. Third, modular program\nc©2009 AI Access Foundation. All rights reserved.\ndesign can also be exploited in order to boost the execution of programs. Program optimization is also facilitated by structural information encompassed by module interfaces.\nAnswer-set programming (ASP) (Marek & Truszczyński, 1999; Niemelä, 1999; Gelfond & Leone, 2002) is a paradigm for declarative problem solving in which solutions of problems are described in terms of rules subject to a nonmonotonic semantics based on stable models (Gelfond & Lifschitz, 1988). In typical problem representations, a tight correspondence between solutions and stable models is sought for, and default negation is fully exploited in order to obtain concise encodings of relations involved in such problem descriptions. Furthermore, recursive definitions enable, e.g., the representation of closures of relations in a very natural way. Due to efficient implementations and emerging applications, the paradigm has received increasing attention during the past two decades.1 In the meantime, a number of extensions—such as disjunctions, weight constraints, and aggregates—have been proposed to the basic syntax of normal logic programs. In this paper, we concentrate on the class of disjunctive logic programs (DLPs) which is appropriate for solving search problems residing up to the second level of the polynomial-time hierarchy. The semantical account of DLPs is based on the respective generalization of stable-model semantics (Gelfond & Lifschitz, 1991).\nIn this paper, our goal is to investigate modularity in the context of DLPs and stablemodel semantics. Since stable models are defined only over complete programs, they do not lend themselves to modular programming prima facie. Perhaps for this reason, the concept of a module has not yet raised too much attention in the realm of answer-set programming. Except for a few dedicated papers (Gaifman & Shapiro, 1989; Eiter, Gottlob, & Veith, 1997b; Baral, Dzifcak, & Takahashi, 2006), modules mostly appeared as a by-product in studies of formal properties like stratification, splitting, or, more lately, in work on equivalence relations between programs (Lifschitz & Turner, 1994; Eiter, Gottlob, & Mannila, 1997a; Eiter, Ianni, Lukasiewicz, Schindlauer, & Tompits, 2008). In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs. The main result is a module theorem which links stable models associated with individual modules to those of their composition. Such a result is significant as it indicates that stable models are compositional in very much the same sense as classical models are in propositional logic. The only major restriction implied by the module theorem is that the definition of any set of positively interdependent atoms must be given within the same module.\nBesides the general benefits of modular program development discussed above, we are also looking for potential computational advantages of modularizing reasoning tasks in ASP. In this context, the search for stable models is probably the most central reasoning task. Results like the module theorem discussed above provide the basis for modularizing the search task. Extra care, however, is required because the computation of stable models for modules in separation is not necessarily efficient. More sophisticated methods, such as identifying cones of influence in Boolean circuits (Junttila & Niemelä, 2000), can be devised to identify modules which are relevant for the search of stable models—the rest is only used to expand a qualified stable model to one for the entire program. This strategy alleviates the treatment of extremely large program instances and it is also amenable to query evaluation.\n1. The 20th anniversary of stable-model semantics was celebrated at ICLP’08 which was held in Udine, Italy, in December 2008.\nUnfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemelä, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b).\nThere are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving. The idea is to gradually extend a program instance in terms of additional modules, e.g., when solving AI planning problems. Moreover, theoretical results like the splitting-set theorem (Lifschitz & Turner, 1994) and the module theorem can be directly exploited in correctness proofs. For instance, it is proved by Oikarinen and Janhunen (2008b) that the models of a prioritized circumscription can be captured with disjunctive stable models using a particular translation. A similar proof strategy is adopted in Theorem 8.5 of this paper.\nWe anticipate that compositional semantics can also prove useful if one tries to boost the search for stable models via parallelization, e.g., by computing stable models for modules in parallel. However, in order to avoid excessive communication costs, extra caution is needed when stable models computed in separation are linked together and potentially rejected. One possibility is to identify mutually independent modules as the basis for distribution. Besides this aspect, modularization may also lead to novel methods for the (non-parallelized) computation of stable models, other than the traditional ones.\nStructure and Preview of Results In this paper, we concentrate on the formal underpinnings of modular programming in the context of disjunctive logic programs under stable-model semantics. We proceed as follows. Our first goal is to generalize the theory developed for normal programs and smodels programs (Oikarinen & Janhunen, 2008a) to the case of disjunctive programs. To this end, we first introduce the notion of a DLPfunction in Section 2. The term goes back to Gelfond and Gabaldon (1999) who introduced LP-functions as (partial) definitions of new relations in terms of old, known ones. To enable such a functional view of disjunctive programs, they are endowed with a well-defined input/output interface. The idea is to partition the signature of a program encapsulated in this way into input atoms, output atoms, and hidden (or local) atoms. These distinctions provide the basis for the systematic composition of larger disjunctive logic programs out of program modules. However, arbitrary combinations of program modules are not meaningful and, first of all, we adopt syntactic restrictions introduced by Gaifman and Shapiro (1989) from the context of negation/disjunction-free logic programs. The interplay of default negation and disjunctions brings along new factors which lead to a relaxation of the restrictions in the sense that program modules are allowed to share rules. Then, having the basic syntactic issues of DLP-functions laid out, we concentrate on their semantics in Section 3. In this respect, we follow a strict model-theoretic approach and, in particular,\naddress the role of input atoms when it comes to viewing DLP-functions as mathematical functions. We proceed step by step and assign three different classes of models to each DLP-function, viz. classical models, minimal models, and stable models. The last provides an appropriate generalization of disjunctive stable models (Gelfond & Lifschitz, 1991) in the presence of input atoms.\nOur second objective is to establish the adequacy of the concept of a DLP-function in view of a compositional semantics. This will be witnessed by the main result of the paper, viz. the module theorem which shows how stable models of a DLP-function, Π, can be alternatively obtained as unions of compatible stable models for the modules constituting Π. The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs—neither involving default negation nor disjunctions. As observed by them, too, syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models.2 In the current paper, we strive for analogous results but in the case of programs permitting both default negation and disjunctions. It turns out that strongly connected components of positive dependency graphs provide a key criterion when it comes to confining program composition. The compositionality properties of disjunctive programs under stable-model semantics have also arisen in the context of the so-called splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). In fact, the module theorem established herein is a proper generalization of its predecessor (Oikarinen & Janhunen, 2008a). We illustrate the potential of our modular architecture by the evaluation of quantified Boolean formulas (QBFs), which serve as canonical representatives of the classes of the polynomial-time hierarchy (PH). Due to basic complexity results established by Eiter and Gottlob (1995), it is natural from our perspective to concentrate on the second level of the PH in the case of disjunctive programs.\nThe third aim of this paper is to have a look at some particular applications of the module theorem in disjunctive logic programming. In Section 6, we take an opposite view to the modular construction of DLP-functions and consider possibilities for their decomposition even in the absence of any other structural information. It turns out that strongly connected components can also be exploited in this respect but, in addition, the occurrences of hidden atoms must be taken into account when splitting a DLP-function into its components. As demonstrated in Section 7, our results open new prospects as regards unwinding disjunctions using the principle of shifting (Gelfond, Przymusinska, Lifschitz, & Truszczyński, 1991; Dix, Gottlob, & Marek, 1996; Eiter, Fink, Tompits, & Woltran, 2004). A proper generalization of this principle that partially covers also programs involving head-cycles is formulated and proved correct. Moreover, due to the modular nature of DLP-functions, it makes perfect sense to compare them as modules. The notion of modular equivalence is introduced for this purpose in Section 8. Interestingly, modular equivalence supports substitutions of equivalent programs and it also lends itself for translation-based verification as put forth by Oikarinen\n2. The main concern of Gaifman and Shapiro (1989) is modularity with respect to the logical consequences of a definite program and hence the intersection of its Herbrand models.\nand Janhunen (2004, 2009) in the related cases of ordinary equivalence and smodels programs. Section 9 contrasts our approach with related work. Finally, Section 10 provides a brief summary of results and concludes this paper."
    }, {
      "heading" : "2. The Class of DLP-Functions",
      "text" : "The topic of this section is the syntax of DLP-functions as well as syntactic restrictions imposed on composition of DLP-functions. A disjunctive rule is an expression of the form\na1 ∨ · · · ∨ an ← b1, . . . , bm,∼c1, . . . ,∼ck, (1)\nwhere n,m, k ≥ 0, and a1, . . . , an, b1, . . . , bm, and c1, . . . , ck are propositional atoms. Since the order of atoms is considered insignificant, we write A ← B,∼C as a shorthand for rules of form (1), where A = {a1, . . . , an}, B = {b1, . . . , bm}, and C = {c1, . . . , ck} are the respective sets of atoms. The basic intuition behind a rule A ← B,∼C is that if each atom in the positive body B can be inferred and none of the atoms in the negative body C, then some atom in the head A can be inferred. When both B and C are empty, we have a disjunctive fact, written A ←. If A is empty, then we have a constraint, written ⊥ ← B,∼C.\nA disjunctive logic program (DLP) is conventionally formed as a finite set of disjunctive rules. Additionally, we want a distinguished input and output interface for each DLP. To this end, we extend a definition originally proposed by Gaifman and Shapiro (1989) to the case of disjunctive programs.3 It is natural that such an interface imposes certain restrictions on the rules allowed in a module. Given a set R of disjunctive rules, we write At(R) for the signature of R, i.e., the set of (ground) atoms effectively appearing in the rules of R.\nDefinition 2.1 A DLP-function, Π, is a quadruple 〈R, I,O,H〉, where I, O, and H are pairwise distinct sets of input atoms, output atoms, and hidden atoms, respectively, and R is a DLP such that for each rule A ← B,∼C ∈ R,\n1. A ∪B ∪ C ⊆ I ∪O ∪H, and\n2. if A 6= ∅, then A ∩ (O ∪H) 6= ∅.\nA DLP-function Π = 〈R, I,O,H〉 is occasionally identified with R and, by a slight abuse of notation, we write A ← B,∼C ∈ Π to denote A ← B,∼C ∈ R. By the first condition of Definition 2.1, the rules in a DLP-function Π must obey the interface specification of Π, i.e., At(R) ⊆ I ∪ O ∪H. As regards the sets of atoms I, O, and H involved in the module interface, the atoms in I ∪ O are considered to be visible and hence accessible to other DLP-functions conjoined with Π; either to produce input for Π or to utilize the output of Π. On the other hand, the hidden atoms in H are used to formalize some auxiliary concepts of Π which may not make sense in the context of other DLP-functions but may save space substantially as demonstrated, e.g., by Janhunen and Oikarinen (2007, Example 4.5). The second condition of Definition 2.1 is concerned with the set of atoms O ∪H defined by the rules of R. The principle is that each non-empty disjunctive head must involve at least one atom from O ∪ H. This is just to ensure that a DLP-function Π must not interfere with\n3. Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).\nthe definitions of its input atoms I in terms of rules A ← B,∼C satisfying A ⊆ I. But otherwise, the rules of Π may be conditioned by input atoms.4 Given a set S of atoms, we distinguish the set of rules that define the atoms of S in R, i.e., the set of defining rules\nDefR(S) = {A ← B,∼C ∈ R | A ∩ S 6= ∅}. (2)\nOur next objective is to specify the conditions on which the composition of DLP-functions may take place. Roughly speaking, the idea is that larger DLP-functions can be formed in a modular fashion using smaller DLP-functions as components. As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs. Thus, program union as operator for composition without further restrictions is not satisfactory with respect to compositionality.\nWe start by adapting the construction of Gaifman and Shapiro (1989) to the case of disjunctive programs.\nDefinition 2.2 Two DLP-functions Π1 = 〈R1, I1, O1, H1〉 and Π2 = 〈R2, I2, O2, H2〉 respect the input/output interfaces of each other if and only if\n1. (I1 ∪O1 ∪H1) ∩H2 = ∅,\n2. (I2 ∪O2 ∪H2) ∩H1 = ∅,\n3. O1 ∩O2 = ∅,\n4. DefR1(O1) = DefR1∪R2(O1), and\n5. DefR2(O2) = DefR1∪R2(O2).\nThe first three of the conditions above are due to Gaifman and Shapiro (1989) and they imply that the sets O1, H1, O2, and H1 are mutually pairwise distinct. Violations with respect to the first two conditions can be circumvented by a renaming strategy. For instance, if an atom a ∈ H1 appears in I2 ∪O2 ∪H2, hence violating the second condition, it is possible to replace all occurrences of a in Π1 by a new atom a\n′ 6∈ I2 ∪ O2 ∪ H2 not appearing in Π2. This removes the conflict with respect to a and so forth. 5\nOn the other hand, the last two conditions of Definition 2.2 concern the distribution of rules involved in the definitions (2) of sets of atoms O1 and O2, i.e., the sets of rules DefR1(O1) and DefR2(O2), in R1 and R2, respectively. As regards disjunctive rules, the principle is that these sets of defining rules must remain intact when the union R1 ∪ R2 is formed which means that each module is supposed to have copies of all rules that form the definition of its output atoms. In spite of this, two modules Π1 and Π2 subject to the conditions of Definition 2.2 may effectively share disjunctive rules A ← B,∼C with a non-empty head A such that A ∩O1 6= ∅ and A ∩O2 6= ∅, as to be demonstrated next.\n4. In particular, input atoms in the head A of a rule act very much like atoms in the negative body ∼C. 5. An opposite view to program composition is considered in Section 6, where possibilities for decompos-\ning a disjunctive program into smaller DLP-functions are studied. As a counterpart to renaming, a revealing operator introduced in Definition 7.3 can be used for circumventing the first two conditions in Definition 2.2.\nExample 2.3 Consider the following two DLP-functions:6\n{b}\na ∨ b ← c; d ← a,∼d\n{a, c}\nand\n{a}\na ∨ b ← c; e ← a,∼e\n{b, c}\nMore formally, we have Π1 = 〈R1, {a, c}, {b}, {d}〉 and Π2 = 〈R2, {b, c}, {a}, {e}〉 such that R1 ∩ R2 = {a ∨ b ← c}. We show that Π1 and Π2 respect the input/output interfaces of each other: First, both hidden atoms d and e occur in exactly one of the two programs and thus the first two conditions in Definition 2.2 are satisfied. Second, we have disjoint output atoms, viz. atom b in Π1 and atom a in Π2. Finally, we have DefR1({b}) = DefR1∪R2({b}) = DefR2({a}) = DefR1∪R2({a}) = {a ∨ b ← c}, which shows that also the final two conditions in Definition 2.2 are satisfied, and as far as syntax is concerned, it makes sense to compose a larger DLP-function which is obtained as a kind of a union of Π1 and Π2; see (4) below.\nIn contrast to disjunctive programs, shared rules do not arise in the context of normal logic programs since only one head atom is allowed in each rule. The same can be stated about smodels programs (Simons, Niemelä, & Soininen, 2002) although such programs may contain, among other rule types, choice rules of the form\n{a1, . . . , an} ← B,∼C (3)\nwith heads of cardinality greater than one. As observed by Oikarinen and Janhunen (2008a), the heads of choice rules possessing multiple atoms can be freely split without affecting their semantics. When splitting such rules into n different rules {ai} ← B,∼C where 1 ≤ i ≤ n, the only concern is the creation of n copies of the rule body B,∼C which could reserve a quadratic space in the worst case. A new atom can be introduced to circumvent this. But the nature of proper disjunctive rules (1), the subject of study in this paper, is somewhat different. Unlike choice rules, disjunctive rules may interact through rule heads. In Example 2.3, the definition of a depends on b and vice versa. However, given a choice rule {a, b} ← c for instance, the choices regarding a and b are independent of each other: if c is true, both atoms can have any truth value. This is quite different from the interpretation of a∨b ← c which makes either a or b true given that c is true. To grasp the interaction of a and b it is natural to have b as an input to the definition of a and, conversely, a as input to that of b. As to be demonstrated in Section 7, shared rules can be rewritten so that input atoms are removed from the rule head but as a drawback of the rewriting technique, the compactness of the representation is partly lost. Therefore, we appreciate the extra flexibility provided by shared rules and interpret them to reflect the true nature of disjunctive rules.\nIn general, DLP-functions are composed according to the following principle:\n6. Here and henceforth we make use of a tabular format to represent DLP-functions: the output signature is given on the top, the input signature at the bottom, and the rules are listed in between. Thus, the declaration of the hidden signature remains implicit.\nDefinition 2.4 (Composition) Let Π1 = 〈R1, I1, O1, H1〉 and Π2 = 〈R2, I2, O2, H2〉 be two DLP-functions that respect the input/output interfaces of each other. Then, the composition of Π1 and Π2 is defined and determined by\nΠ1 ⊕Π2 = 〈R1 ∪R2, (I1 \\O2) ∪ (I2 \\O1), O1 ∪O2, H1 ∪H2〉. (4)\nThe treatment of atom types under Definitions 2.2 and 2.4 is summarized in Figure 1. The two symmetric figures on the left-hand side illustrate the signatures of DLP-functions Π1 = 〈R1, I1, O1, H1〉 and Π2 = 〈R2, I2, O2, H2〉 subject to composition. Input signatures and output signatures are emphasized by light gray and dark gray shadings, respectively. The superposition of the two figures yields the diagram given on the right which represents the resulting nine categories of atoms. Only three of them may involve shared atoms that originate from bothΠ1 andΠ2. The interface conditions introduced above should be intuitive to readers acquainted with the principles of object-oriented programming:\n1. Although Π1 and Π2 must not share hidden atoms, they may share input atoms, i.e., I1∩I2 6= ∅ is allowed. Output atoms are treated differently as O1∩O2 = ∅ is assumed.\n2. An input atom of Π1 becomes an output atom in Π1 ⊕ Π2 if it appears as an output atom in Π2, i.e., Π2 provides the input for Π1 in this setting. The input atoms of Π2 are treated in a symmetric fashion.\n3. The hidden atoms of Π1 and Π2 retain their status in Π1 ⊕Π2.\nExample 2.5 Recall Example 2.3 in which we showed that DLP-functions Π1 and Π2 respect the input/output interfaces of each other. Thus, the composition of Π1 and Π2 is defined, and Π1⊕Π2 is 〈R1 ∪R2, I, O,H〉 where the set I of input atoms is ({a, c}\\{a})∪({b, c}\\{b}) = {c}, the set O of output atoms is {a} ∪ {b} = {a, b}, and the set H of hidden atoms is {d} ∪ {e} = {d, e}, i.e., using our tabular format to represent modules, we have\n{b}\na ∨ b ← c; d ← a,∼d\n{a, c}\n⊕\n{a}\na ∨ b ← c; e ← a,∼e\n{b, c}\n=\n{a, b}\na ∨ b ← c; d ← a,∼d; e ← a,∼e\n{c}\nThe definitions of a and b in Π1 ⊕ Π2 share the rule a ∨ b ← c. Thanks to the flexibility of Definition 2.4, we are also able to split Π1 ⊕Π2 into its components whenever appropriate.\nFollowing previous approaches (Gelfond & Gabaldon, 1999; Oikarinen & Janhunen, 2008a), we define the signature At(Π) of a DLP-function Π = 〈R, I,O,H〉 as I ∪ O ∪H.7 For notational convenience, we distinguish the visible and hidden parts of At(Π) by setting Atv(Π) = I ∪ O and Ath(Π) = H = At(Π) \\ Atv(Π), respectively. Moreover, Ati(Π) and Ato(Π) are used to refer to the sets of input and output atoms of Π, respectively. These notations provide us a way to access the module interface when it is left implicit, e.g., to neglect the internal structure of modules. Lastly, for any set S ⊆ At(Π) of atoms, we denote the projections of S on Ati(Π), Ato(Π), Atv(Π), and Ath(Π) by Si, So, Sv, and Sh, respectively.\nIn formal terms, a DLP-function Π = 〈R, I,O,H〉 is designed to provide a mapping from subsets of I to a set of subsets of O ∪ H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored. In the sequel, the (syntactic) class of DLP-functions is denoted by D. It is assumed, for the sake of simplicity, that D spans over a fixed (at most denumerable) signature At(D)8 so that At(Π) ⊆ At(D) holds for each DLP-function Π ∈ D. Given DLP-functions Π1, Π2, and Π3 that pairwise respect the input/output interfaces of each other, it holds that\n• Π1 ⊕Π2 ∈ D (closure),\n• Π1 ⊕∅ = ∅⊕Π1 = Π1, for the empty DLP-function ∅ = 〈∅, ∅, ∅, ∅〉 (identity),\n• Π1 ⊕Π2 = Π2 ⊕Π1 (commutativity), and\n• Π1 ⊕ (Π2 ⊕Π3) = (Π1 ⊕Π2)⊕Π3 (associativity).\nThe theory of modules put forth by Oikarinen and Janhunen (2008a) is based on a more restrictive operator for program composition, viz. the join ⊔. The idea behind this operator is to forbid positive dependencies between programs which is to be explicated next.\nTechnically speaking, we define the positive dependency graph DG+(Π) of a DLP-function Π = 〈R, I,O,H〉 using only positive dependencies—following the definition by Ben-Eliyahu and Dechter (1994). However, we exclude input atoms from the graph as their definitions are external to Π anyway. Thus, we let DG+(Π) = 〈O ∪H,≤1〉 where b ≤1 a holds for a pair of atoms a, b ∈ O ∪H if and only if there is a rule A ← B,∼C ∈ R such that a ∈ A and b ∈ B. The reflexive and transitive closure of ≤1 gives rise to the dependency relation ≤ over Ato(Π)∪Ath(Π). A strongly connected component (SCC) S of the graph DG\n+(Π) is a maximal set S ⊆ Ato(Π)∪Ath(Π) such that b ≤ a for every pair a, b ∈ S of atoms. Given that Π1 ⊕ Π2 is defined, we say that Π1 and Π2 are mutually dependent iff DG\n+(Π1 ⊕ Π2) has an SCC S such that S ∩ Ato(Π1) 6= ∅ and S ∩ Ato(Π2) 6= ∅ (Oikarinen & Janhunen, 2008a), i.e., the component S is shared by the DLP-functions Π1 and Π2 in this way. If Π1 and Π2 are not mutually dependent, we also call them mutually independent.\nDefinition 2.6 (Joins) Given two DLP-functions Π1 and Π2, if the composition Π1 ⊕ Π2 is defined and Π1 and Π2 are mutually independent, then the join, Π1 ⊔ Π2, of Π1 and Π2 is defined and it coincides with Π1 ⊕Π2.\n7. Consequently, the length of Π in symbols, denoted by ‖Π‖, gives an upper bound for |At(Π)| which is important when one considers the computational cost of translating programs (Janhunen, 2006). 8. In practice, this set could be the set of all identifiers (names for propositions or similar objects).\nIn case that Π1 ⊔ Π2 is defined, and thus Π1 and Π2 are mutually independent, exactly one of the following conditions holds for each SCC S of DG+(Π1 ⊕Π2):\nS ⊆ Ato(Π1) ∪Ath(Π1); or (5)\nS ⊆ Ato(Π2) ∪Ath(Π2). (6)\nExample 2.7 Recall the programs Π1 and Π2 from Example 2.5 for which we obtain the positive dependency graph DG+(Π1⊕Π2) = 〈{a, b, d, e}, {〈a, d〉, 〈a, e〉}〉. Hence, the SCCs of the graph are simply singletons {a}, {b}, {d}, and {e}. Together with the observation that Ato(Π1) and Ato(Π2) are disjoint, we derive that Π1 and Π2 are not mutually dependent. Thus, the join Π1 ⊔Π2 = Π1⊕Π2 is defined since the composition Π1⊕Π2 is defined on the basis of the analysis performed in Example 2.5.\nExample 2.8 As an example of two DLP-functions which have their composition defined yet which are ineligible for a join, consider the following situation:\n{b}\na ∨ b ← c; b ← a,∼c\n{a, c}\n⊕\n{a}\na ∨ b ← c; a ← b,∼c\n{b, c}\n=\n{a, b}\na ∨ b ← c; a ← b,∼c; b ← a,∼c\n{c}\nHere, the result of composition involves an SCC S = {a, b} in the respective positive dependency graph, which has a non-empty intersection with the output signatures of the programs subject to composition. Hence, the respective join of the modules in question is not defined."
    }, {
      "heading" : "3. Model Theory and Stable-Model Semantics",
      "text" : "Having the syntax of DLP-functions defined, we now turn to their semantics. We proceed in three steps and introduce, correspondingly, three kinds of models, viz. classical models, minimal models, and, finally, stable models for each DLP-function. The last provide the intended semantics for a DLP-function whereas the first two serve as auxiliary concepts.\nAs usual, an interpretation for a DLP-function Π is defined as an arbitrary subset of At(Π). Given a particular interpretation M ⊆ At(Π), an atom a ∈ At(Π) is true under M , denoted M |= a, iff a ∈ M , otherwise a is false under M , denoted M 6|= a. For a negative literal ∼a, we define M |= ∼a iff M 6|= a. A set L of literals is satisfied by M , denoted by M |= L, iff M |= l, for every literal l ∈ L. We also define the disjunctive interpretation ∨\nL of a set L of literals: M |= ∨\nL iff M |= l for some literal l ∈ L. To begin with, we cover DLP-functions with a pure classical semantics, which treats disjunctive rules as classical implications. It should be emphasized that classical models of a DLP-function Π are specific interpretations as defined above and hence subsets of At(Π).\nDefinition 3.1 An interpretation M ⊆ At(Π) is a (classical) model of a DLP-function Π = 〈R, I,O,H〉, denoted M |= Π, iff M |= R, i.e., for every rule A ← B,∼C ∈ R,\nM |= B ∪ ∼C implies M |= ∨ A.\nThe set of all classical models of Π is denoted by CM(Π).\nClassical models provide an appropriate level of abstraction to address the role of input atoms in DLP-functions. Given a DLP-function Π and an interpretation M ⊆ At(Π), the projection Mi can be viewed as the actual input for Π which may (or may not) produce the respective output Mo, depending on the semantics assigned to Π. The treatment of input atoms in the sequel will be based on partial evaluation: the idea is to pre-interpret input atoms appearing in Π with respect to Mi.\nDefinition 3.2 For a DLP-function Π = 〈R, I,O,H〉 and an actual input Mi ⊆ I for Π, the instantiation of Π with respect to Mi, denoted by Π/Mi, is the quadruple 〈R\n′, ∅, O,H〉 where R′ contains a reduced rule\n(A \\ I) ← (B \\ I),∼(C \\ I) (7)\nfor each rule A ← B,∼C ∈ R such that Mi |= ∼Ai ∪Bi ∪ ∼Ci.\nExample 3.3 Consider the following DLP-function Π:\n{a, b}\na ∨ b ← ∼c; a ← c,∼b; b ← c,∼a\n{c}\nFor the actual input {c} ⊆ Ati(Π), the reduct Π/{c} is the DLP-function\n〈{a ← ∼b; b ← ∼a}, ∅, {a, b}, ∅〉.\nOn the other hand, with the actual input ∅ ⊆ Ati(Π), we obtain the reduct\nΠ/∅ = 〈{a ∨ b}, ∅, {a, b}, ∅〉.\nThe rules of form (7) are free of input atoms which indicates that the reduct Π/Mi is a DLP-function without input. Atoms in Ato(Π) ∪Ath(Π) are not affected in Π/Mi.\nProposition 3.4 Let Π be a DLP-function and M ⊆ At(Π) an interpretation that defines an actual input Mi ⊆ Ati(Π) for Π. For all interpretations N ⊆ At(Π) such that Ni = Mi,\nN |= Π ⇐⇒ No ∪Nh |= Π/Mi.\nProof. Consider any N ⊆ At(Π) such that Ni = Mi. (=⇒) Suppose that N |= Π. Assume that No ∪ Nh does not satisfy (7) for some rule A ← B,∼C in Π. It follows that Mi |= ∼Ai ∪Bi ∪∼Ci, and therefore Ni |= ∼Ai ∪Bi ∪∼Ci. Thus, N 6|= A ← B,∼C, a contradiction. It follows that No ∪Nh |= Π/Mi.\n(⇐=) Let No ∪ Nh |= Π/Mi hold. Assuming N 6|= A ← B,∼C for a rule of Π implies N |= B ∪ ∼C and N 6|= ∨\nA. It follows that Ni |= ∼Ai ∪ Bi ∪ ∼Ci and the corresponding rule (7) is included in Π/Mi as Ni = Mi. But this rule is not satisfied by No ∪ Nh since\nN 6|= A ← B,∼C implies No ∪ Nh |= (B \\ I) ∪ ∼(C \\ I) and No ∪ Nh 6|= ∨\n(A \\ I), a contradiction. Hence, we have that N |= Π.\nThus, the input reduction, as given in Definition 3.2, is fully compatible with classical semantics and we can characterize the semantic operator CM also in terms of the equation\nCM(Π) = ⋃\nMi⊆Ati(Π)\n{Mi ∪N | N ∈ CM(Π/Mi)}. (8)\nRecall that the models of any DLP-function Π are subsets of At(Π). Hence, we have here that each N ∈ CM(Π/Mi) is a subset of At(Π/Mi) and thusMi∩N = ∅ for eachMi ⊆ Ati(Π) since no atom from Ati(Π) occurs in Π/Mi by definition.\nHandling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them. The rough idea is to keep the interpretation of input atoms fixed while minimizing (i.e., falsifying) others as far as possible.\nDefinition 3.5 Let Π = 〈R, I,O,H〉 be a DLP-function. A model M ⊆ At(Π) of Π is I-minimal iff there is no model N of Π such that Ni = Mi and N ⊂ M .\nIn the sequel, the set of I-minimal models of Π = 〈R, I,O,H〉 is denoted by MM(Π) and we treat input atoms by stipulating I-minimality of models. Using this idea, Proposition 3.4 lifts for minimal models given the fact that Ati(Π/Mi) = ∅.\nProposition 3.6 Let Π be a DLP-function and M ⊆ At(Π) an interpretation that defines an actual input Mi ⊆ Ati(Π) for Π. For all interpretations N ⊆ At(Π) such that Ni = Mi,\nN ∈ MM(Π) ⇐⇒ No ∪Nh ∈ MM(Π/Mi).\nProof. Consider any N ⊆ At(Π) such that Ni = Mi. (=⇒) Let N ∈ MM(Π). It follows by Proposition 3.4 that No ∪ Nh |= Π/Mi. Assume that No ∪ Nh /∈ MM(Π/Mi). Recall that Ati(Π/Mi) = ∅. Thus, there is an interpretation S ⊂ No ∪ Nh such that S |= Π/Mi. It follows by Proposition 3.4 that N\n′ |= Π for an interpretation N ′ = Mi∪S. But then N ′ i = Ni and N\n′ ⊂ N jointly contradict N ∈ MM(Π). (⇐=) Suppose that No ∪Nh ∈ MM(Π/Mi). So, No ∪Nh |= Π/Mi, and N |= Π follows by Proposition 3.4. Let us then assume that N 6∈ MM(Π), i.e., there is a model N ′ |= Π with N ′i = Ni and N ′ ⊂ N . Thus, we have (N ′o ∪N ′ h) ⊂ (No ∪Nh), and since N ′ i = Ni = Mi it follows that N ′o ∪N ′ h |= Π/Mi by Proposition 3.4. Then, however, N ′ o ∪N ′ h |= Π/Mi is in contradiction with No ∪Nh ∈ MM(Π/Mi). The set MM(Π) of Ati(Π)-minimal models is sufficient to determine the semantics of a positive DLP-function Π, i.e., whose rules are of the form A ← B. Recall that for such rules A \\ Ati(Π) 6= ∅ holds whenever A 6= ∅. In order to cover arbitrary DLP-functions, we interpret negative body literals in the way proposed by Gelfond and Lifschitz (1991).\nDefinition 3.7 Given a DLP-function Π = 〈R, I,O,H〉 and an interpretation M ⊆ At(Π), the reduct of Π with respect to M is the positive DLP-function ΠM = 〈RM , I, O,H〉 where\nRM = {A ← B | A ← B,∼C ∈ R and M |= ∼C}. (9)\nDefinition 3.8 An interpretation M ⊆ At(Π) is a stable model of a DLP-function Π with an input signature Ati(Π) iff M ∈ MM(Π M ), i.e., M is an Ati(Π)-minimal model of Π M .\nHidden atoms play no special role in Definition 3.8. In contrast to this, they will affect possibilities for program decomposition, as to be presented in Section 6, and their status will be finally explicated when the notion of modular equivalence is introduced in Section 8. Definition 3.8 covers also the case of an ordinary disjunctive logic program, which is simply a DLP-function Π = 〈R, ∅, O, ∅〉: a model M ⊆ At(Π) = O of Π is stable iff M is a minimal model of RM . The definition of stable models gives rise to a semantic operator SM : D → 22 At(D) for DLP-functions:\nSM(Π) = {M ⊆ At(Π) | M ∈ MM(ΠM )}. (10)\nProposition 3.6 provides us a way to dismiss Ati(Π)-minimality in the definition of stable models if desirable. Given a stable model M of Π, the projection N = Mo∪Mh is a minimal model of (Π/Mi) N and hence a stable model of Π/Mi. In other words, we have\n(Π/Mi) M = (Π/Mi) Mo∪Mh = ΠM/Mi.\nThus, we can derive the following result:\nCorollary 3.9 For any DLP-function Π, we have\nSM(Π) = {M ⊆ At(Π) | Mo ∪Mh ∈ SM(Π/Mi)}.\nExample 3.10 Recall the DLP-function Π from Example 3.3, having no hidden atoms, given as follows:\n{a, b}\na ∨ b ← ∼c; a ← c,∼b; b ← c,∼a\n{c}\nΠ has four stable models in total: M1 = {a}, M2 = {b}, M3 = {a, c}, and M4 = {b, c}, which are the {c}-minimal models of the respective reducts of Π:\nΠM1 = 〈{a ∨ b ←; a ← c}, {c}, {a, b}, ∅〉, ΠM2 = 〈{a ∨ b ←; b ← c}, {c}, {a, b}, ∅〉, ΠM3 = 〈{a ← c}, {c}, {a, b}, ∅〉, and ΠM4 = 〈{b ← c}, {c}, {a, b}, ∅〉.\nNow, it is easy to verify that each Mj is a {c}-minimal model of the reduct Π Mj .\nFor illustrating Corollary 3.9, recall the reducts\nΠ/{c} = 〈{a ← ∼b; b ← ∼a}, ∅, {a, b}, ∅〉 and Π/∅ = 〈{a ∨ b}, ∅, {a, b}, ∅〉.\nThen, we have that SM(Π/{c}) = {{a}, {b}} and SM(Π/∅) = {{a}, {b}}.\nAn immediate observation is that we loose the general antichain property of stable models when input signatures are introduced. For instance, we haveM1 ⊂ M3 andM2 ⊂ M4 in Example 3.10. However, since the interpretation of input atoms is fixed by the semantics, we perceive antichains locally, i.e., the set {N ∈ SM(Π) | Ni = Mi} of stable models forms an antichain, for each input Mi ⊆ Ati(Π). In Example 3.10, the sets of stable models associated with actual inputs ∅ and {c} are {M1,M2} and {M3,M4}, respectively."
    }, {
      "heading" : "4. Characterizations using Classical Logic",
      "text" : "It is well known how the set of stable models of an ordinary disjunctive logic program, i.e., a DLP-function Π of the form 〈R, ∅, O, ∅〉, can be characterized via classical propositional logic, using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003). In this section, we generalize these concepts to arbitrary DLP-functions. To this end, the main concern is the role of input atoms and how to incorporate them into these concepts. Furthermore, we extend the tightness property of programs (Erdem & Lifschitz, 2003) to DLP-functions by introducing the notion of I-tightness in Section 4.2."
    }, {
      "heading" : "4.1 Program Completion and Loop Formulas",
      "text" : "Given a DLP-function Π, a loop of Π is any non-empty subset of a strongly connected component of the positive dependency graph DG+(Π). Recall that DG+(Π) has only the atoms of Ato(Π)∪Ath(Π) as its nodes. In particular, each singleton {a} with a ∈ Ato(Π)∪ Ath(Π) is thus a loop.\nExample 4.1 Consider DLP-functions Π1 and Π2 defined as follows:\nΠ1:\n{b, c}\na ∨ c ← b; b ← a\n{a}\nΠ2:\n{a, b}\na ∨ c ← b; b ← a\n{c}\nHere, Π1 has only singleton loops {b} and {c}. In particular, {a, b} is not a loop as it contains the input atom a. On the other hand, for Π2 we have loops {a}, {b}, and {a, b}.\nIn what follows, we use, for a set S of propositional formulas (or atoms), ¬S to denote a conjunction ∧\ns∈S ¬s and ∨ S as a shorthand for ∨\ns∈S s. Moreover, if appearing within a formula, a set S is implicitly understood as a conjunction of its elements. For a DLP-function Π and an atom a ∈ Ato(Π) ∪Ath(Π), we define the set of supporting formulas\nSuppF(a,Π) = {B ∧ ¬C ∧ ¬(A \\ {a}) | A ← B,∼C ∈ Π and a ∈ A}\nand for a loop L ⊆ Ato(Π) ∪Ath(Π) of Π, the set of externally supporting formulas\nESuppF(L,Π) = {B ∧ ¬C ∧ ¬(A \\ L) | A ← B,∼C ∈ Π, A ∩ L 6= ∅, and B ∩ L = ∅}.\nClark’s completion procedure and (conjunctive) loop formulas can be generalized for DLPfunctions in the following way:\nDefinition 4.2 For a DLP-function Π, the completion of Π is the set of formulas\nComp(Π) = {B ∧ ¬C → ∨\nA | A ← B,∼C ∈ Π} ∪ {a → ∨\nSuppF(a,Π) | a ∈ Ato(Π) ∪Ath(Π)}\nand the set of loop formulas for Π is\nLF(Π) = {L → ∨ ESuppF(L,Π) | L ⊆ Ato(Π) ∪Ath(Π) is a loop of Π}. 9\nObserve that in the case of Ati(Π) = ∅, i.e., Ato(Π) ∪ Ath(Π) = At(Π), the completion Comp(Π) reduces to the definition provided by Lee and Lifschitz (2003) and the same holds for the set LF(Π) of loop formulas. Generally speaking, the propositional theories Comp(Π) and LF(Π) characterize the set SM(Π) of stable models in the following sense:\nTheorem 4.3 For a DLP-function Π and an interpretation M ⊆ At(Π),"
    }, {
      "heading" : "M ∈ SM(Π) if and only if M |= Comp(Π) and M |= LF(Π).",
      "text" : "Proof. We first relate the sets SuppF(a,Π) and ESuppF(L,Π), as introduced above for a DLP-function Π, with the respective sets of complementary rules\nSuppCR(a,Π) = {A \\ {a} ← B,∼C | A ← B,∼C ∈ Π and a ∈ A} and ESuppCR(L,Π) = {A \\ L ← B,∼C | A ← B,∼C ∈ Π, A ∩ L 6= ∅, and B ∩ L = ∅}.\nFirst, it is straightforward that, for each interpretation M ⊆ At(Π), we have M |= Comp(Π) iff jointly M |= Π and for each a ∈ M ∩ (Ato(Π) ∪ Ath(Π)), M 6|= SuppCR(a,Π). Quite similarly, it holds that M |= LF(Π) iff, for each loop L ⊆ M ∩ (Ato(Π) ∪ Ath(Π)) of Π, M 6|= ESuppCR(L,Π). On the other hand, by viewing SuppCR(a,Π) and ESuppCR(L,Π) as DLP-functions having the same signatures as Π, we can apply Proposition 3.4 in order to evaluate input atoms. Thus, we obtain the following relationships for each DLP-function Π, interpretation M ⊆ At(Π), atom a ∈ Ato(Π) ∪ Ath(Π), and loop L ⊆ Ato(Π) ∪ Ath(Π) of Π:\n1. M |= Π iff Mo ∪Mh |= Π/Mi,\n2. M |= SuppCR(a,Π) iff Mo ∪Mh |= SuppCR(a,Π/Mi), and\n3. M |= ESuppCR(L,Π) iff Mo ∪Mh |= ESuppCR(L,Π/Mi).\nFinally, recall that for each interpretation M ⊆ At(Π), we have Ato(Π) = Ato(Π/Mi) and Ath(Π) = Ath(Π/Mi). Inspecting the definition of Comp(Π) and LF(Π) again, we can conclude for each interpretation M ⊆ At(Π) that M |= Comp(Π) ∪ LF(Π) iff Mo ∪Mh |= Comp(Π/Mi)∪LF(Π/Mi). In turn, we know that Mo ∪Mh |= Comp(Π/Mi)∪LF(Π/Mi) iff Mo ∪Mh is a stable model of the program Π/Mi by the results of Lee and Lifschitz (2003); recall that Π/Mi is an ordinary disjunctive program without any input atoms. Finally, we have SM(Π) = {M ⊆ At(Π) | Mo ∪Mh ∈ SM(Π/Mi)} by Corollary 3.9. This equality shows the claim.\nExample 4.4 Let us demonstrate the functioning of program completion and loop formulas on the DLP-functions from Example 4.1, i.e., on Π1 = 〈R, {a}, {b, c}, ∅〉 and Π2 = 〈R, {c}, {a, b}, ∅〉, where R = {a ∨ c ← b; b ← a}. The completions are\n9. Although it may seem that the case of a singleton loop L = {a} is somewhat redundant, this is not so, since some tautological rules such as a ∨ b ← a make a difference.\nComp(Π1) = {b → a ∨ c, a → b} ∪ {b → a, c → b ∧ ¬a} and Comp(Π2) = {b → a ∨ c, a → b} ∪ {b → a, a → b ∧ ¬c}.\nFurthermore, the sets of loop formulas are\nLF(Π1) = {b → ∨ ESuppF({b},Π1), c → ∨\nESuppF({c},Π1)} = {b → a, c → b ∧ ¬a} and\nLF(Π2) = {b → ∨ ESuppF({b},Π2), a → ∨\nESuppF({a},Π2), a ∧ b → ∨\nESuppF({a, b},Π2)} = {b → a, a → b ∧ ¬c, a ∧ b → ⊥}.\nIn the last formula, the occurrence of ⊥ is in view of ESuppF({a, b},Π2) = ∅, which yields an empty disjunction ∨\nESuppF({a, b},Π2) = ⊥ as usual. Computing the classical models of Comp(Π1) ∪ LF(Π1) = Comp(Π1) yields two such models, M1 = {a, b} and M2 = ∅. One can check that these are indeed the stable models of Π1 by recalling that Ati(Π1) = {a}. Thus, M1 relates to an actual input M1∩Ati(Π1) = {a} whereas M2 is based on M2 ∩ Ati(Π1) = ∅. On the other hand, the classical models of Comp(Π2) ∪ LF(Π2) are M1 = {c} and M2 = ∅, which again relate to the two possible inputs over Ati(Π2) = {c}. Finally, we note that {a, b} is also a model of Comp(Π2) but ruled out by LF(Π2)."
    }, {
      "heading" : "4.2 Tight DLP-functions",
      "text" : "We now extend the well-known concept of tightness (Erdem & Lifschitz, 2003) to DLPfunctions. This is of interest since we can exploit the fact that the positive dependency graph DG+(Π) is reduced modulo input atoms. In other words, since the dependency graph DG+(Π) has only the atoms of Ato(Π) ∪ Ath(Π) as its nodes, tightness for DLP-functions can be defined with respect to the input signature.\nIn the beginning of Section 4, loops were defined as arbitrary non-empty subsets of strongly connected components in DG+(Π). Thus, if DG+(Π) is acyclic then Π has only singleton loops. However, the converse is not necessarily true, since, for a program Π having only singleton loops, DG+(Π) may have edges 〈a, a〉, i.e., cycles of length one.\nDefinition 4.5 A DLP-function Π is Ati(Π)-tight (or tight, for short), if the positive dependency graph DG+(Π) is acyclic.\nExample 4.6 Recall DLP-functions Π1 = 〈R, {a}, {b, c}, ∅〉 and Π2 = 〈R, {c}, {a, b}, ∅〉 based on R = {a ∨ c ← b; b ← a} from Example 4.1. Here, Π1 is {a}-tight since the potential non-singleton loop {a, b} contains the input atom a. On the other hand, Π2 is not {c}-tight. It is worth mentioning that the “ordinary” variant of Π1, viz. DLP-function 〈R, ∅, {a, b, c}, ∅〉, is not ∅-tight—in particular, since R is not tight in the usual sense.\nWe note that the last observation, viz. that a DLP-function 〈R, I,O,H〉 may be I-tight although R is not a tight program, relies on the use of disjunctions in the program. In fact, for DLP-functions 〈R, I,O,H〉, where R is a set of normal rules of the form a ← B,∼C, we have that a DLP-function Π = 〈R, I,O,H〉 is I-tight iff R is tight. To verify this, note that the second item of Definition 2.1 implies that the head atom of a normal rule a ← B,∼C must not appear in I, and thus no loop of Π may involve atoms from I.\nWe now show that the notion of tightness introduced in Definition 4.5 enables us to characterize the stable models of a DLP-function by the classical models of its completion. Since each “ordinary” program can be represented as a DLP-function, we thus properly generalize the well-known completion semantics (Clark, 1978). The following lemma is already sufficient for this result in view of Definition 4.2 and Theorem 4.3.\nLemma 4.7 For any tight DLP-function Π, LF(Π) ⊆ Comp(Π).\nProof. Recall that for each a ∈ Ato(Π) ∪ Ath(Π), a → ∨\nSuppF(a,Π) is contained in Comp(Π). Moreover, since Π is tight, Π has only singleton loops, and thus LF(Π) contains only formulas a → ∨\nESuppF({a},Π), again for each a ∈ Ato(Π) ∪ Ath(Π). It remains to show that, for each atom a, SuppF(a,Π) is equivalent to ESuppF({a},Π) whenever the positive dependency graph DG+(Π) is acyclic. We repeat the definition of SuppF(a,Π) and give the definition for ESuppF(L,Π), simplified for the case L = {a}:\nSuppF(a,Π) = {B ∧ ¬C ∧ ¬(A \\ {a}) | A ← B,∼C ∈ Π and a ∈ A}; ESuppF({a},Π) = {B ∧ ¬C ∧ ¬(A \\ {a}) | A ← B,∼C ∈ Π, a ∈ A, and B ∩ {a} = ∅}.\nNow it is easy to see that for an acyclic dependency graphDG+(Π), a ∈ A impliesB∩{a} = ∅ for every rule A ← B,∼C ∈ Π. Thus, we conclude that SuppF(a,Π) = ESuppF({a},Π) holds for each a ∈ Ato(Π) ∪Ath(Π). Hence, the claim follows.\nExample 4.8 Recalling the DLP-function Π1 = 〈R, {a}, {b, c}, ∅〉 from Example 4.4 with R = {a ∨ c ← b; b ← a}, we obtain\nComp(Π1) = {b → a ∨ c, a → b} ∪ {b → a, c → b ∧ ¬a} and LF(Π1) = {b → ∨ ESuppF({b},Π1), c → ∨\nESuppF({c},Π1)} = {b → a, c → b ∧ ¬a}.\nNow, Π1 is tight and we observe that LF(Π1) ⊆ Comp(Π1) as expected.\nThe observations presented so far lead us to the following result:\nTheorem 4.9 For a tight DLP-function Π and an interpretation M ⊆ At(Π),"
    }, {
      "heading" : "M ∈ SM(Π) if and only if M |= Comp(Π).",
      "text" : "In particular, this result is compatible with an existing characterization of stable models in the case of Ati(Π) = ∅, i.e., if Ato(Π) ∪ Ath(Π) = At(Π). Then, the notion of Ati(Π)tightness coincides with ordinary tightness, and the definition of the completion Comp(Π) reduces to the one provided by Lee and Lifschitz (2003)."
    }, {
      "heading" : "5. Compositional Semantics",
      "text" : "In what follows, our objective is to establish the main result of this paper, i.e., to show that stable-model semantics, as given by Definition 3.8, is fully compositional when larger DLP-functions Π are formed as joins Π1 ⊔ . . . ⊔ Πn of DLP-functions. More precisely, the interconnection of SM(Π) and SM(Π1), . . . ,SM(Πn) is explicated in Section 5.1. In analogy\nto Section 3, we follow a quite rigorous approach and consider such a relationship for classical models first, then for minimal models, and eventually cover the case of stable models which comprises our module theorem. Then, in Section 5.2, we use quantified Boolean formulas from the second level of polynomial hierarchy and their modular representation in terms of DLP-functions to illustrate the module theorem. Finally, we devote Section 5.3 to a comparison with the splitting set theorem proven by Lifschitz and Turner (1994)."
    }, {
      "heading" : "5.1 Module Theorem",
      "text" : "To begin with, we formalize the criteria for combining interpretations as well as models.\nDefinition 5.1 Given two DLP-functions Π1 and Π2, interpretations M1 ⊆ At(Π1) and M2 ⊆ At(Π2) are mutually compatible (with respect to Π1 and Π2), or just compatible, if\nM1 ∩Atv(Π2) = M2 ∩Atv(Π1). (11)\nAccording to (11), any two compatible interpretations M1 and M2 for Π1 and Π2, respectively, agree about the truth values of their joint visible atoms in Atv(Π1)∩Atv(Π2). A quick inspection of Figure 1 reveals the three cases that may arise when the join Π = Π1⊔Π2 is defined and joint output atoms for Π1 and Π2 are thereafter disallowed: There may exist\n1. joint input atoms in Ati(Π) = Ati(Π1) ∩Ati(Π2), or\n2. atoms in Ato(Π1) ∩Ati(Π2) that are output atoms in Π1 and input atoms in Π2, or\n3. by symmetry, atoms in Ati(Π1) ∩Ato(Π2).\nRecall that according to Definition 2.6, atoms in the last two categories end up in Ato(Π) when Π = Π1 ⊔ Π2 is formed. Atoms in Atv(Π1) ∩ Atv(Π2) provide the basis to combine compatible interpretations for Π1 and Π2.\nDefinition 5.2 Let Π1 and Π2 be two DLP-functions such that Π = Π1 ⊔ Π2 is defined. Given any sets of interpretations A1 ⊆ 2 At(Π1) and A2 ⊆ 2 At(Π2), the natural join of A1 and A2 with respect to Atv(Π1) ∩Atv(Π2), denoted by A1 ⋊⋉ A2, is the set of interpretations\nA1 ⋊⋉ A2 = {M1 ∪M2 | M1 ∈ A1, M2 ∈ A2, and M1 and M2 are compatible}. (12)\nOur first modularity result is formulated for DLP-functions under classical semantics as defined in Section 3. The combination of classical models is understood as in (12).\nProposition 5.3 For all positive DLP-functions Π1 and Π2 such that Π1 ⊕Π2 is defined,\nCM(Π1 ⊕Π2) = CM(Π1) ⋊⋉ CM(Π2). (13)\nProof. Consider an interpretationM ⊆ At(Π1⊕Π2) and its projectionsM1 = M∩At(Π1) and M2 = M ∩ At(Π2) with respect to Π1 = 〈R1, I1, O1, H1〉 and Π2 = 〈R2, I2, O2, H2〉. It follows that M1 and M2 are compatible and M = M1 ∪M2 so that\nM ∈ CM(Π1 ⊕Π2) ⇐⇒ M |= R1 ∪R2 ⇐⇒ M1 |= R1 and M2 |= R2 ⇐⇒ M1 ∈ CM(Π1) and M2 ∈ CM(Π2) ⇐⇒ M ∈ CM(Π1) ⋊⋉ CM(Π2).\nGeneralizing Proposition 5.3 for stable models of DLP-functions is much more elaborate. We will cover the case of positive DLP-functions under minimal models first. The proof of Theorem 5.5 exploits program completion, loop formulas, as well as the characterization of stable and minimal models from Section 4 as follows:\nLemma 5.4 For all DLP-functions Π1 and Π2 such that Π1 ⊔ Π2 is defined, the following conditions hold:\nComp(Π1 ⊔Π2) = Comp(Π1) ∪ Comp(Π2); (14)\nLF(Π1 ⊔Π2) = LF(Π1) ∪ LF(Π2). (15)\nProof. We begin the proof by analyzing how formulas introduced by Clark’s completion and loop formulas are related with joins of DLP-functions. To this end, we will now establish that the sets of formulas associated with Π1 ⊔ Π2 are directly obtained as unions of sets of formulas associated with Π1 = 〈R1, I1, O1, H1〉 and Π2 = 〈R2, I2, O2, H2〉: First, an implication B∧¬C → ∨\nA belongs to Comp(Π1∪Π2) if and only if it belongs to Comp(Π1), Comp(Π2), or both in case of a shared rule. Second, let us consider any atom a ∈ O ∪H, where O = O1 ∪O2 and H = H1 ∪H2 are disjoint because Π1 ⊔Π2 is defined. For the same reason, either a ∈ O1∪H1 or a ∈ O2∪H2, i.e., the atom a is defined either by Π1 or Π2. Thus, we have either DefR1(a) = DefR1∪R2(a) or DefR2(a) = DefR1∪R2(a) by Definition 2.2, which implies that either SuppF(a,Π1⊔Π2) = SuppF(a,Π1) or SuppF(a,Π1⊔Π2) = SuppF(a,Π2). It follows that the implication a → ∨\nSuppF(a,Π1 ⊔ Π2) is a member of Comp(Π1 ⊔ Π2) if and only if either (i) a → ∨ SuppF(a,Π1) belongs to Comp(Π1) or (ii) a → ∨\nSuppF(a,Π2) belongs to Comp(Π2). Thus, we may conclude (14) for the completions involved.\nThird, recall that each loop L ⊆ At(Π1 ⊔Π2) of Π1 ⊔Π2 is contained in some SCC S of Π1 ⊔Π2. It follows by (5), (6), and Definition 2.2 that either\n1. L ⊆ O1 ∪H1 is a loop of Π1 and DefR1(L) = DefR1∪R2(L), or\n2. L ⊆ O2 ∪H2 is a loop of Π2 and DefR2(L) = DefR1∪R2(L).\nIn the cases above, we have either ESuppF(L,Π1⊔Π2) = ESuppF(L,Π1) or ESuppF(L,Π1⊔ Π2) = ESuppF(L,Π2). Thus, the respective loop formula L → ∨\nESuppF(L,Π1 ⊔ Π2) belongs to LF(Π1 ⊔Π2) if and only if it is contained in LF(Π1) ∪ LF(Π2).\nTheorem 5.5 For all positive DLP-functions Π1 and Π2 such that Π1 ⊔Π2 is defined,\nMM(Π1 ⊔Π2) = MM(Π1) ⋊⋉ MM(Π2). (16)\nProof. Consider any M ⊆ At(Π1⊔Π2) and the respective projections M1 = M ∩At(Π1) and M2 = M ∩At(Π2) which are compatible and, moreover, M = M1 ∪M2. We obtain the following chain of equivalences:\nM ∈ MM(Π1 ⊔Π2) ⇐⇒ M |= Comp(Π1 ⊔Π2) and M |= LF(Π1 ⊔Π2) [Theorem 4.3]\n⇐⇒\n{\nM1 |= Comp(Π1) and M1 |= LF(Π1) M2 |= Comp(Π2) and M2 |= LF(Π2)\n[(14) and (15)]\n⇐⇒ M1 ∈ MM(Π1) and M2 ∈ MM(Π2) [Theorem 4.3] ⇐⇒ M ∈ MM(Π1) ⋊⋉ MM(Π2). [Definition 5.2]\nExample 5.6 Let us demonstrate the result of Theorem 5.5 in a practical setting using DLPfunctions Π1 and Π2 as visualized below and their composition Π = 〈R, ∅, {a, b, c, d, e}, ∅〉.\nΠ1 :\n{a, b, c} a ∨ b ←; a ← b; b ← a; a ← c;\nc ∨ d ∨ e ← a, b\n{d, e}\nΠ2 :\n{d, e} d ← c; e ← d; d ← e;\nc ∨ d ∨ e ← a, b\n{a, b, c}\nThe join Π1 ⊔ Π2 is defined because the SCCs of the composition Π are S1 = {a, b, c} and S2 = {d, e}. The Ati(Π1)-minimal models of Π1 are {a, b, c}, {a, b, d}, {a, b, e}, and {a, b, d, e}. Likewise, calculating MM(Π2), we get\nMM(Π2) = {∅, {a}, {b}, {c, d, e}, {a, b, d, e}, {a, c, d, e}, {b, c, d, e}, {a, b, c, d, e}}.\nHence, the only minimal model of Π is M = {a, b, d, e} and the compatibility condition underlying (16) correctly excludes N = {a, b, c, d, e} 6∈ MM(Π). Note that there is no support to c being true in Π1 when d and e are true. Accordingly, c ∨ d ∨ e ← a, b is not active.\nWe are now prepared to present our central result:\nTheorem 5.7 (Module Theorem) For all DLP-functions Π1 and Π2 such that Π1 ⊔ Π2 is defined,\nSM(Π1 ⊔Π2) = SM(Π1) ⋊⋉ SM(Π2). (17)\nProof. Again, we take an interpretation M ⊆ At(Π1⊔Π2) and the respective compatible projections M1 = M ∩At(Π1) and M2 = M ∩At(Π2) into consideration. The proof of (17) can be based on (16) once a number of preliminary facts has been established:\n1. The composition ΠM11 ⊕Π M2 2 is defined.\nSince Π1 ⊔Π2 is defined, we know that Π1⊕Π2 is defined. This indicates that Π1 and Π2 respect the input/output interfaces of each other. The construction of Π M1 1 and ΠM22 does not affect this property which implies that Π M1 1 ⊕Π M2 2 is defined.\n2. The join ΠM11 ⊔Π M2 2 is defined.\nBy the preceding item, the positive dependency graph DG+(ΠM11 ⊕ Π M2 2 ) is defined. Let us assume that ΠM11 and Π M2 2 are mutually dependent, i.e., there is an SCC S of the graph above such that S ∩ Ato(Π M1 1 ) 6= ∅ and S ∩ Ato(Π M2 2 ) 6= ∅. Since the dependency graph has potentially fewer dependencies than the respective graph\nDG+(Π1⊕Π2) for Π1 and Π2, it follows that S is contained in some SCC S ′ of the latter. Since Ato(Π M1 1 ) = Ato(Π1) and Ato(Π M2 2 ) = Ato(Π2), we obtain S\n′∩Ato(Π1) 6= ∅ and S′ ∩Ato(Π2) 6= ∅. Thus, Π1 and Π2 are mutually dependent, a contradiction.\n3. The reduct (Π1 ⊔Π2) M coincides with ΠM11 ⊔Π M2 2 .\nA rule A ← B belongs to (Π1 ⊔Π2) M if and only if there is a rule A ← B,∼C in Π1, Π2, or both such that C ∩M = ∅. Equivalently, there is a rule A ← B,∼C in Π1 such that C ∩ M1 = ∅, or there is a rule A ← B,∼C in Π2 such that C ∩ M2 = ∅, i.e., A ← B ∈ ΠM11 or A ← B ∈ Π M2 2 .\nWe therefore get the following chain of equivalences:\nM ∈ SM(Π1 ⊔Π2) ⇐⇒ M ∈ MM((Π1 ⊔Π2) M ) [Definition 3.8]\n⇐⇒ M ∈ MM(ΠM11 ⊔Π M2 2 ) [Item 3 above] ⇐⇒ M ∈ MM(ΠM11 ) ⋊⋉ MM(Π M2 2 ) [Theorem 5.5] ⇐⇒ M1 ∈ MM(Π M1 1 ) and M2 ∈ MM(Π M2 2 ) [Definition 5.2] ⇐⇒ M1 ∈ SM(Π1) and M2 ∈ SM(Π2) [Definition 3.8] ⇐⇒ M ∈ SM(Π1) ⋊⋉ SM(Π2). [Definition 5.2]\nThe moral of Theorem 5.7 and Definition 2.6 is that stable semantics supports modularization as long as positively interdependent atoms are enforced in the same module.\nExample 5.8 Let Π1 and Π2 be DLP-functions as defined below and Π = Π1 ⊔ Π2 their join (which is clearly defined):\n{b}\na ∨ b ←; b ∨ c ←\n{a, c}\n⊔\n{c}\na ∨ c ←; b ∨ c ←\n{a, b}\n=\n{b, c}\na ∨ b ←; a ∨ c ←; b ∨ c ←\n{a}\nIt is straightforward to verify that SM(Π1) = {{b}, {a, b}, {a, c}, {b, c}} and SM(Π2) = {{c}, {a, b}, {a, c}, {b, c}}. Since Atv(Π1) ∩Atv(Π2) = {a, b, c}, we obtain\nSM(Π1) ⋊⋉ SM(Π2) = SM(Π1) ∩ SM(Π2) = {{a, b}, {a, c}, {b, c}}.\nA simple cross-check confirms that SM(Π) is indeed given by this set.\nExample 5.9 Consider the DLP-functions Π1 and Π2 from Example 2.8. Then, SM(Π1) = {∅, {a, b}, {b, c}} and SM(Π2) = {∅, {a, b}, {a, c}}. As shown in Example 2.8, the join of Π1 and Π2 is undefined. Thus, Theorem 5.7 is not applicable. Concerning the composition Π1 ⊕Π2, we note that SM(Π1 ⊕Π2) = {∅, {a, c}, {b, c}} 6= {∅, {a, b}} = SM(Π1) ⋊⋉ SM(Π2).\nTheorem 5.7 can be easily extended for DLP-functions consisting of more than two modules. In view of this, we say that a finite sequence M1, . . . ,Mn of stable models for modules Π1, . . . ,Πn, respectively, is compatible, iff Mi and Mj are pairwise compatible, for all 1 ≤ i, j ≤ n. This property guarantees that each Mi can be recovered from the union M =\n⋃n i=1Mi by taking the respective projection M ∩At(Πi) = Mi.\nCorollary 5.10 Let Π1, . . . ,Πn be a sequence of DLP-functions such that the join Π1⊔· · ·⊔ Πn is defined. Then,\nSM(Π1 ⊔ · · · ⊔Πn) = SM(Π1) ⋊⋉ · · · ⋊⋉ SM(Πn). (18)\nExample 5.11 The following example simply extends Example 5.8:\n{b}\na ∨ b ←; b ∨ c ←\n{a, c}\n⊔\n{c}\na ∨ c ←; b ∨ c ←\n{a, b}\n⊔\n{a}\na ∨ b ←; a ∨ c ←\n{b, c}\n=\n{a, b, c} a ∨ b ←; a ∨ c ←; b ∨ c ←\n∅\nNow we have SM(Π1) = {{b}, {a, b}, {a, c}, {b, c}}, SM(Π2) = {{c}, {a, b}, {a, c}, {b, c}}, and SM(Π3) = {{a}, {a, b}, {a, c}, {b, c}}. Thus, we learn from Corollary 5.10 that\nSM(Π1 ⊔Π2 ⊔Π3) = SM(Π1) ⋊⋉ SM(Π2) ⋊⋉ SM(Π3) = {{a, b}, {a, c}, {b, c}}."
    }, {
      "heading" : "5.2 Modular Representation of Quantified Boolean Formulas",
      "text" : "Our next objective is to illustrate the theory developed so far in terms of a more extensive example. To this end, we consider the pair of DLP-functions Πsatn and Π unsat n as depicted in Figure 2. Their purpose is the evaluation of quantified Boolean formulas (QBFs) of the form\n∃X∀Y n ∨\ni=1\n(¬Ai ∧Bi ∧ ¬Ci ∧Di), (19)\nwhere each Aj , Bj , Cj , and Dj is a set of Boolean variables, and the parameter n gives the number of disjuncts in the matrix which is a Boolean formula φ in disjunctive normal form (DNF).10 Without loss of generality, we may assume that X =\n⋃n i=1(Ai ∪ Bi), Y =\n⋃n i=1(Ci ∪Di), and X ∩ Y = ∅ hold for the sets X and Y of Boolean variables in (19). It is important to point out that in general the evaluation of QBFs of the form (19) constitutes a Σp2-complete decision problem which perfectly matches the complexity of checking the existence of stable models for a disjunctive program. Given this completeness property, it follows that in principle any decision problem in Σp2 can be turned into a QBF of the form (19), albeit more direct representations can be obtained for particular problem domains. In this respect, let us address three specific domains prior to detailing the generic approach.\n1. The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques. The simplified encoding provided by Koch, Leone, and Pfeifer (2003) is based on two kinds of disjunctive rules:\nstrat(x1) ∨ strat(x2) ∨ strat(x3) ∨ strat(x4) ← prod(y, x1, x2, x3, x4), (20)\nstrat(x) ← ctrl(x, x1, x2, x3, x4), strat(x1), strat(x2), strat(x3), strat(x4), (21)\n10. Also, recall the shorthands ¬S = V\ns∈S ¬s and S =\nV\ns∈S s introduced right after Example 4.1.\nFunction Πsatn : X\nFor 1 ≤ i ≤ n and x ∈ Ai: ← x, act(i); For 1 ≤ i ≤ n and x ∈ Bi: x ← act(i);\nFor 1 ≤ i ≤ n: Ai ← Bi,∼act(i)\n{act(1), . . . , act(n)}\nFunction Πunsatn : ∅\nFor 1 ≤ i ≤ n: Ci ∪ {u} ← Di, act(i); For y ∈ Y : y ← u;\nu ← ∼u\n{act(1), . . . , act(n)}\ncertificates. The required DLPs can be worked out via reductions into propositional (un)satisfiability. In particular, the test for unsatisfiability can be realized in analogy to Πunsatn analyzed below.\nIn the general case, we use Boolean variables and propositional atoms interchangeably in order to describe how the validity problem of (19) is captured by DLP-functions from Figure 2. The design of Πsatn and Π unsat n is based on the explanatory approach from Janhunen et al. (2006), where (19) is equivalently viewed as a formula ∃X¬∃Y ¬φ having the matrix ¬φ in conjunctive normal form (CNF). A clause11 Ai ∨ ¬Bi ∨ Ci ∨ ¬Di in ¬φ is active whenever Ai ∨ ¬Bi is false and the truth of the clause becomes dependent on Ci ∨ ¬Di; or to put it dually, ¬Ai ∧Bi is true and the truth of ¬Ai ∧Bi ∧¬Ci ∧Di depends on ¬Ci ∧Di. The validity of the formula ∃X¬∃Y ¬φ is captured as follows: Given an input interpretation Mi ⊆ {act(1), . . . , act(n)}, the upper DLP-function Π sat n from Figure 2 tries to explain the activation statuses of the clauses in ¬φ by checking that the respective theory {¬Ai ∧Bi | act(i) ∈ Mi}∪{Ai ∨ ¬Bi | act(i) 6∈ Mi} is satisfiable. The lower DLP-function, Π unsat n , plays the role of a coNP-oracle: it captures a test for the theory {Ci ∨ ¬Di | act(i) ∈ Mi} being unsatisfiable. The correctness of the representation provided by these DLP-functions will be addressed soon, but it is enough to understand their syntax and intuitive meaning for the moment. A concrete QBF instance is evaluated as follows.\nExample 5.12 Consider DLP-functions Πsatn and Π unsat n from Figure 2 in the case of QBF\n∃x1∃x2∀y1∀y2[(x1∧y1∧y2)∨(¬x2∧y1∧¬y2)∨(x1∧¬y1∧y2)∨(x1∧¬x2∧¬y1∧¬y2)]. (22)\nThus, the parameter for this instance is n = 4, and the input signature is {act(1), . . . , act(4)} for both Πsat4 and Π unsat 4 , as illustrated in Figure 3. The output signature of the former DLPfunction is {x1, x2} and all other atoms, i.e., y1, y2, and u, remain hidden in the latter. The joint input signature is used to specify the active part of the matrix in (22). The DLPfunction Πsat4 provides an explanation, i.e., an assignment to variables x1 and x2 as its output, whereas Πunsat4 is only responsible for the respective unsatisfiability check. As regards the validity of the QBF given in (22), the input interpretation {act(1), act(2), act(3), act(4)} yields a positive answer. The respective explanation, i.e., the output interpretation found by Πsat4 , is {x1}. It is easy to check that when x1 is true and x2 is false then the remainder of the matrix is true whatever values are assigned to y1 and y2. Hence, the QBF (22) is valid.\n11. For the purposes of this section, we interpret disjunctions A ∨ ¬B of sets A and ¬B = {¬b | b ∈ B} of positive and negative literals, respectively, as disjunctions of their elements.\nAs regards the general DLP-functions Πsatn and Π unsat n in Figure 2, they have identical input signatures, only Πsatn has output atoms, and the hidden atoms of Π unsat n are fully respected. Hence, the composition Πsatn ⊕Π unsat n is defined. Moreover, the atoms appearing in rules that involve positive dependencies belong to disjoint sets X and Y ∪ {u}. It is therefore clear that DG+(Πsatn ⊕ Π unsat n ) cannot have an SCC S such that S ∩ X 6= ∅ and S ∩ (Y ∪ {u}) 6= ∅. This implies that Πsatn ⊔Π unsat n is defined regardless of the QBF (19) in question. Let us exploit this fact in the context of specific DLP-functions of Example 5.12.\nExample 5.13 There are four stable models for the DLP-function Πsat4 :\n{act(1), act(2), act(3), act(4), x1}, {act(1), act(3), x1, x2}, {act(2)}, and {x2},\nlisted in decreasing level of activation. On the other hand, the DLP-function Πunsat4 has a unique stable model {act(1), act(2), act(3), act(4), y1, y2, u}, i.e., the interpretation {y1, y2, u} is the unique stable model of Πunsat4 /{act(1), act(2), act(3), act(4)} where the set of rules is given by\n{ u ← y1, y2; u ∨ y2 ← y1; u ∨ y1 ← y2; u ∨ y1 ∨ y2; y1 ← u; y2 ← u; u ← ∼u },\nand Πunsat4 /Mi has no stable models for any other input interpretation Mi. Moreover, we may apply the module theorem to calculate SM(Πsat4 ⊔Π unsat 4 ) by combining compatible pairs of models. There is only one such pair:\n{act(1), act(2), act(3), act(4), x1} ∈ SM(Π sat 4 ) and\n{act(1), act(2), act(3), act(4), y1, y2, u} ∈ SM(Π unsat 4 ).\nThus, {act(1), act(2), act(3), act(4), x1, y1, y2, u} is the unique stable model of the join Π sat 4 ⊔ Πunsat4 . Since SM(Π sat 4 ⊔Π unsat 4 ) is non-empty, we conclude that (22) is indeed valid.\nIt is natural to ask what can be stated about the stable models of the general DLPfunctions Πunsatn and Π sat n associated with the QBF ∃X∀Y φ given in (19). If M is a stable model of Πsatn , then the respective projectionMX = X∩M determines M , i.e., it holds for all 1 ≤ i ≤ n in the matrix φ that act(i) ∈ M if and only ifMX |= ¬Ai∧Bi. Moreover, the model MX is minimal in the sense that there is no strictly smaller interpretation N ⊂ MX with this property. This is an additional feature brought along the minimality of stable models. As a consequence, the DLP-function Πsatn does not capture all possible truth assignments to variables in X but no relevant truth assignments are lost. On the other hand, any stable model M of Πunsatn indicates that the respective theory\n{Ci ∨ ¬Di | 1 ≤ i ≤ n, act(i) ∈ M}\nis inconsistent, or alternatively, the formula ∨\n1≤i≤n,act(i)∈M ¬Ci ∧Di is valid. Concerning the correctness of the representation given in Figure 2, due to an existing proof by Janhunen et al. (2006), we only present the main steps—fully exploiting the benefits from our modular approach.\nTheorem 5.14 A QBF ∃X∀Y φ of the form (19) is valid iff SM(Πsatn ⊔Π unsat n ) is non-empty.\nProof sketch. Consider any QBF ∃X∀Y φ of the form (19). The following are equivalent:\n1. The formula ∃X∀Y φ is valid.\n2. There is a minimal interpretation N ⊆ X such that, for the set I = {1 ≤ i ≤ n | N 6|= Ai ∨ ¬Bi} of indices determined by N with N |= {¬Ai ∧Bi | i ∈ I}∪{Ai ∨ ¬Bi | i 6∈ I}, the theory {Ci ∨ ¬Di | i ∈ I} is unsatisfiable.\n3. The DLP-functions Πsatn and Π unsat n have compatible stable models M1 = N ∪{act(i) |\ni ∈ I} and M2 = {act(i) | i ∈ I} ∪ Y ∪ {u}, respectively.\n4. The DLP-function Πsatn ⊔Π unsat n has a stable model\nM = M1 ∪M2 = N ∪ {act(i) | i ∈ I} ∪ Y ∪ {u}.\nIn the second item, the minimality ofN means that there is noN ′ ⊂ N such that {1 ≤ i ≤ n | N ′ 6|= Ai ∨ ¬Bi} = I. This can be assumed without loss of generality.\nTheorem 5.14 and the module theorem suggest an approximation strategy for verifying the validity of QBFs of the form (19). If either SM(Πsatn ) or SM(Π unsat n ) is empty, we know directly that the formula is not valid. Otherwise, we check whether SM(Πsatn ⊔Π unsat n ) = ∅."
    }, {
      "heading" : "5.3 Splitting Sets",
      "text" : "For the sake of comparison, we formulate the splitting-set theorem (Lifschitz & Turner, 1994) for a DLP-function Π = 〈R, ∅, O, ∅〉, which essentially forms an “ordinary” disjunctive program. Splitting sets are sets of atoms that are closed in the following sense:\nDefinition 5.15 Given a DLP-function Π = 〈R, ∅, O, ∅〉, a set U ⊆ O of atoms is a splitting set for Π if and only if, for every rule A ← B,∼C ∈ R,"
    }, {
      "heading" : "A ∩ U 6= ∅ implies A ∪B ∪ C ⊆ U .",
      "text" : "By Definitions 2.1 and 5.15, the sets ∅ and O are always splitting sets for Π. However, one is mostly interested in other non-trivial splitting sets ∅ ⊂ U ⊂ O for Π, but such sets need not exist. Nevertheless, any splitting set U divides the respective set of rules R in two parts. The bottom, bU (R), of R with respect to U contains all rules A ← B,∼C ∈ R such that A ∪ B ∪ C ⊆ U , whereas the top, tU (R), of R is R \\ bU (R). The splitting of R into bU (R) and tU (R) becomes a proper one, i.e., bU (R) 6= ∅ and tU (R) 6= ∅, if\n1. U is non-trivial and\n2. every atom a ∈ O has at least one defining rule A ← B,∼C ∈ R such that a ∈ A.\nAccording to Lifschitz and Turner (1994), a solution to R with respect to U ⊆ O is a pair 〈X,Y 〉 where X ⊆ U , Y ⊆ O\\U , X ∈ SM(bU (R)), and Y ∈ SM(tU (R)/X). Here, tU (R)/X denotes the partial evaluation of tU (R) in the sense of Definition 3.2 using X ⊆ U as an input interpretation. Using a similar idea, let us introduce DLP-functions corresponding to bU (R) and tU (R). Given a splitting set U for Π, the join Π = ΠB ⊔ΠT , where\nΠB = 〈bU (R), ∅, U, ∅〉 and ΠT = 〈tU (R), U,O \\ U, ∅〉\nis defined. Then, the following result is implied by Theorem 5.7.\nCorollary 5.16 (Splitting-Set Theorem from Lifschitz & Turner, 1994) For every DLP-function Π = 〈R, ∅, O, ∅〉 corresponding to a set R of disjunctive rules, every splitting set U ⊆ O for Π, and every interpretation M ⊆ At(Π) = O, the following conditions are equivalent:\n1. M is a stable model of Π.\n2. M ∩ U ∈ SM(ΠB) and M ∈ SM(ΠT ).\n3. 〈M ∩ U,M \\ U〉 is a solution to R with respect to U .\nIn fact, Theorem 5.7 is strictly stronger than the splitting-set theorem. As previously demonstrated by Oikarinen and Janhunen (2008a), splitting sets are applicable to DLPfunctions like Π = 〈{a ← ∼b; b ← ∼a}, ∅, {a, b}, ∅〉 only in the trivial way, i.e., only U1 = ∅ are U2 = {a, b} are splitting sets for Π. In contrast, Theorem 5.7 applies to the preceding DLP-function in more versatile ways, i.e., Π1⊔Π2 is defined for Π1 = 〈{a ← ∼b}, {b}, {a}, ∅〉 and Π2 = 〈{b ← ∼a}, {a}, {b}, ∅〉. As a consequence of Π1 ⊔Π2 being defined, it is possible to determine the sets of stable models SM(Π1) = {{a}, {b}} = SM(Π2) in separation, if appropriate, and then conclude that SM(Π) = SM(Π1) ⋊⋉ SM(Π2) = {{a}, {b}} holds as well. Yet another generality aspect of splitting concerns the role of input atoms—they are assumed nonexistent above. Theorem 5.7, however, enables us to treat them as well."
    }, {
      "heading" : "6. Decomposing DLP-Functions",
      "text" : "The objectives of this section are contrary to the construction of a DLP-function as a join of modules. The idea is to exploit the strongly connected components of DG+(Π), for a DLPfunction Π, in order to decompose Π into smaller components, e.g., when there is no a priori information about the internal structure of Π. For simplicity, we will first consider DLPfunctions Π having no hidden atoms, i.e., where Ath(Π) = ∅. The effects of hidden atoms on the decomposition of DLP-functions will be addressed thereafter. As defined in conjunction with Definition 2.6, the SCCs in DG+(Π) are induced by the positive dependency relation ≤ which is reflexive and transitive, i.e., a preorder by definition. In the sequel, the set of SCCs in DG+(Π) is denoted by SCC+(Π). The positive dependency relation ≤ lifts for the elements of SCC+(Π) as follows: S1 ≤ S2 if and only if there are atoms a1 ∈ S1 and a2 ∈ S2 such that a1 ≤ a2. To this end, it does not matter which pair of atoms is inspected.\nLemma 6.1 For any DLP-function Π and any components S1, S2 ∈ SCC +(Π), S1 ≤ S2 if and only if a1 ≤ a2 for every a1 ∈ S1 and a2 ∈ S2.\nProof. (=⇒) If S1 ≤ S2, there are b1 ∈ S1 and b2 ∈ S2 such that b1 ≤ b2. Consider any a1 ∈ S1 and a2 ∈ S2. It follows that a1 ≤ b1 and b2 ≤ a2 by the definition of SCCs. Thus, a1 ≤ a2 as ≤ is transitive.\n(⇐=) This holds trivially as SCCs are non-empty.\nProposition 6.2 The relation ≤ over SCC+(Π) is reflexive, transitive, and antisymmetric.\nProof. The relation ≤ over SCC+(Π) is reflexive and transitive by definition. For antisymmetry, consider any S1, S2 ∈ SCC\n+(Π) such that S1 ≤ S2 and S2 ≤ S1. It follows by Lemma 6.1 that, for every a1 ∈ S1 and a2 ∈ S2, a1 ≤ a2 and a2 ≤ a1. Thus, S1 = S2 by the maximality of components in SCC+(Π).\nConsequently, we may conclude that 〈SCC+(Π),≤〉 is a partially ordered set. Since Π is finite by definition, 〈SCC+(Π),≤〉 has maxima and minima but these elements need not be unique. In particular, for each S ∈ SCC+(Π) there is a minimum element S1 ∈ SCC\n+(Π) such that S1 ≤ S and S2 ≤ S1 implies S2 = S1, for any S2 ∈ SCC\n+(Π). Thus, we may apply the principle of well-founded induction using the minima of 〈SCC+(Π),≤〉 as basis.\nGiven the structure 〈SCC+(Π),≤〉, the DLP-function Π = 〈R, I,O, ∅〉 can be decomposed in the following way: The set of rules associated with S ∈ SCC+(Π) is DefR(S) from (2), i.e., the set of defining rules for S in R. In general, the head of an arbitrary rule A ← B,∼C ∈ R may coincide in the sense of (2) with several SCCs, which implies that the rule is included in DefR(S) for several S ∈ SCC\n+(Π). However, such a distribution of rules is in perfect harmony with the last two conditions of Definition 2.2. We must also bear in mind integrity constraints ⊥ ← B,∼C which are not included in DefR(S) for any S ∈ SCC+(Π). To access the integrity constraints of any set R of rules, we define\nIC(R) = {A ← B,∼C ∈ R | A = ∅}. (23)\nWe are now ready to present a decomposition of Π based on SCC+(Π).\nDefinition 6.3 Given a DLP-function Π = 〈R, I,O, ∅〉, the decomposition induced by SCC+(Π) includes a DLP-function\nΠ0 = 〈IC(R),At(IC(R)) ∪ (I \\At(R)), ∅, ∅〉 (24)\nand, for each S ∈ SCC+(Π), a DLP-function\nΠS = 〈DefR(S),At(DefR(S)) \\ S, S, ∅〉. (25)\nThe purpose of the extra module Π0 is to keep track of integrity constraints as well as input atoms that are not mentioned by the rules of R. The other modules involved in the decomposition Π are induced by SCCs. Each ΠS refers to other modules using At(DefR(S)) \\ S as its input signature and provides the defining rules (if any) for every atom in S. Recall that an output atom having no defining rules will be falsified by default.\nProposition 6.4 For a DLP-function Π = 〈R, I,O, ∅〉 and its decomposition based on SCC+(Π), the join\nΠ0 ⊔ ( ⊔ S∈SCC+(Π)ΠS) (26)\nis defined and equal to Π.\nProof. Let us consider Π0 and ΠS for any S ∈ SCC +(Π). The composition Π0 ⊕ ΠS is defined because these modules involve no hidden atoms, Ato(Π0) = ∅, and we have DefR1(∅) = ∅ = DefR1∪R2(∅) and DefR2(S) = DefR(S) = DefR1∪R2(S) for the sets of rules R1 = IC(R) and R2 = DefR(S). The join Π0 ⊔ ΠS is defined as the respective composition is and the integrity constraints in Π0 do not create any dependencies in DG +(Π0 ⊕ΠS).\nLet us perform a similar analysis for ΠS1 and ΠS2 based on two different components S1, S2 ∈ SCC\n+(Π). It is clear that ΠS1 ⊕ ΠS2 is defined since these modules involve no hidden atoms, S1 ∩ S2 = ∅, and we have that DefR1(S1) = DefR(S1) = DefR1∪R2(S1) and DefR2(S2) = DefR(S2) = DefR1∪R2(S2), for R1 = DefR(S1) and R2 = DefR(S2).\nSince all pairwise joins are defined, also the overall join (26) is defined. By Definition 2.4 and the definition of SCC+(Π), the outcome is equal to Π because\n1. IC(R) ∪ ⋃\nS∈SCC+(Π)DefR(S) = R,\n2. ⋃\nS∈SCC+(Π) S = O, and\n3. (At(IC(R)) \\O) ∪ ((I \\At(R)) \\O) ∪ ⋃\nS∈SCC+(Π)(At(DefR(S)) \\O) = I.\nCorollary 6.5 For a DLP-function Π with Ath(Π) = ∅ and its decomposition based on SCC+(Π),\nSM(Π) = SM(Π0) ⋊⋉ (⋊⋉S∈SCC+(Π)SM(ΠS)).\nExample 6.6 Consider the following DLP-function Π:\n{a, b, c, d}\na ∨ b ∨ c ∨ d ←; ← a, c; ← b, c; ← a, d; ← b, d; a ← b; c ← d; b ← a; d ← c.\n∅\nSo, Ati(Π) = ∅, Ato(Π) = {a, b, c, d}, and Ath(Π) = ∅. There are two SCCs in DG +(Π), viz. S1 = {a, b} and S2 = {c, d}. The resulting decomposition of Π consists of\nΠ0 = 〈{← a, c; ← a, d; ← b, c; ← b, d}, {a, b, c, d}, ∅, ∅〉, ΠS1 = 〈{a ∨ b ∨ c ∨ d ←; a ← b; b ← a}, {c, d}, {a, b}, ∅〉, and ΠS2 = 〈{a ∨ b ∨ c ∨ d ←; c ← d; d ← c}, {a, b}, {c, d}, ∅〉.\nThe respective sets of stable models are\nSM(Π0) = {{a, b}, {c, d}, {a}, {b}, {c}, {d}, ∅}, SM(ΠS1) = {{a, b}, {c}, {d}, {c, d}}, SM(ΠS1) = {{c, d}, {a}, {b}, {a, b}}, and SM(Π) = {{a, b}, {c, d}}.\nNext, we address the case of DLP-functions involving hidden atoms, i.e., for which Ath(Π) 6= ∅ holds. Then, the components in DG\n+(Π) are subsets of Ato(Π) ∪ Ath(Π) and we have to revise (25) accordingly. For a DLP-function Π = 〈R, I,O,H〉 and S ∈ SCC+(Π),\nΠS = 〈DefR(S),At(DefR(S)) \\ S, S ∩O,S ∩H〉. (27)\nUnfortunately, a decomposition based on modules of the form (27) is likely to be too finegrained. For certain components S1, S2 ∈ SCC +(Π) such that S1 6= S2, the respective\nmodules ΠS1 and ΠS2 conforming to (27) might not respect hidden atoms of each other. A similar setting may arise with Π0 and an individual module ΠS based on some S ∈ SCC\n+(Π) if the integrity constraints of Π refer to hidden atoms of ΠS . The problem would disappear if all hidden atoms of Π were revealed but this is hardly appropriate—there are good reasons to hide certain atoms from a knowledge representation perspective.\nA way to approach this problem is to distinguish components S1 ∈ SCC +(Π) and"
    }, {
      "heading" : "S2 ∈ SCC",
      "text" : "+(Π) for which the respective modules ΠS1 and ΠS2 would not respect the hidden atoms of each other, i.e., a hidden atom defined by one would be referred by the other—either positively or negatively. Similar conflicts could also arise due to integrity constraints packed into the module Π0 distinguished in Definition 6.3. At first sight, we should amalgamate Π0 with any other module whose hidden atoms occur in the integrity constraints of Π0. But, in order to avoid fusions of this kind as far as possible, it is worth redistributing integrity constraints referring to hidden atoms. This is clearly possible for integrity constraints referring to hidden atoms involved in a single component only. To formalize the ideas presented so far, we distinguish a precise relation among the components of SCC+(Π) as follows.\nDefinition 6.7 Given a DLP-function Π, components S1, S2 ∈ SCC +(Π) do not respect the hidden atoms of each other, denoted by S1 !h S2, if and only if S1 6= S2 and there is\n1. a hidden atom h ∈ Ath(ΠS1) such that h ∈ Ati(ΠS2), or\n2. a hidden atom h ∈ Ath(ΠS2) such that h ∈ Ati(ΠS1), or\n3. there are hidden atoms h1 ∈ Ath(ΠS1) and h2 ∈ Ath(ΠS2) which both have an occurrence in some integrity constraint ← B,∼C of Π.\nIt is clear that !h is irreflexive and symmetric for the components of SCC +(Π) for any DLP-function Π. Moreover, the transitive closure of !h, denoted by ! + h , gives rise to a repartitioning of SCC+(Π). Each maximal block S1, . . . , Sn of components such that Si ! + h Sj holds for every i 6= j induces a module ΠS as determined by (27) for the union S = S1 ∪ . . . ∪ Sn. The key observation is that modules associated with different blocks of components respect hidden atoms of each other which makes Theorem 5.7 applicable at that level of abstraction. To summarize the treatment of DLP-functions involving hidden atoms in their rules, we revise Definition 6.3 accordingly.\nDefinition 6.8 Given a DLP-function Π = 〈R, I,O,H〉, the decomposition induced by SCC+(Π) and !+h includes a DLP-function\nΠ0 = 〈IC0(R),At(IC0(R)) ∪ (I \\At(R)), ∅, ∅〉 (28)\nwhere IC0(R) = {← B,∼C ∈ R | (B ∪ C) ∩H = ∅} and, for each maximal block S1, . . . , Sn of components of SCC+(Π) such that Si ! + h Sj for every i 6= j, a DLP-function\nΠS = 〈DefR(S) ∪ ICS(R),At(DefR(S) ∪ ICS(R)) \\ S, S ∩O,S ∩H〉 (29)\nwhere S = S1 ∪ . . . ∪ Sn and ICS(R) = {← B,∼C ∈ R | (B ∪ C) ∩ (S ∩H) 6= ∅}.\nAs regards Example 6.6, Definitions 6.3 and 6.8 yield identical decompositions for the DLP-function in question. The effects of hiding are demonstrated by the following example:\nExample 6.9 Consider a DLP-function Π = 〈R, ∅, O,H〉, for\nR = {← a,∼c; a ∨ b ←; b ∨ c ∨ d ←; c ← d; d ← c,∼b}\nand O∪H = {a, b, c, d}, where the exact partitioning of atoms in O and H varies from case to case as analyzed below. The SCCs in SCC+(Π) are S1 = {a}, S2 = {b}, and S3 = {c, d}.\n1. If we take all atoms visible in Π, i.e., if H = ∅, the decomposition of Π yields three modules, ΠS1 = 〈{a ∨ b ←}, {b}, {a}, ∅〉, ΠS2 = 〈{a ∨ b ←; b ∨ c ∨ d ←}, {a, c, d}, {b}, ∅〉, and ΠS3 = 〈{b ∨ c ∨ d ←; c ← d; d ← c,∼b}, {b}, {c, d}, ∅〉, in addition to the module Π0 = 〈{← a,∼c}, {a, c}, ∅, ∅〉 encompassing integrity constraints.\n2. If we hide H = {a} in Π, we obtain S1 !h S2 by the disjunctive rule a∨ b ←. Therefore, components S1 and S2 must be placed in the same block which is also maximal— giving rise to a module ΠS = 〈{← a,∼c; a ∨ b ←; b ∨ c ∨ d ←}, {c, d}, {b}, {a}〉 where S = S1 ∪ S2 = {a, b}. The other modules are Π0 = ∅ and ΠS3 listed above.\n3. Finally, if we set H = {a, c} for Π, we obtain S2 !h S3 by b∨c∨d ← and S1 !h S3 by ← a,∼c in addition to S1 !h S2 as stated above. Since Π0 = ∅, the decomposition of Π effectively collapses to a single module ΠS′ = Π where S ′ = S1 ∪ S2 ∪ S3.\nWe note about the non-trivial modules mentioned above that\nSM(ΠS1) = {{a}, {b}}, SM(ΠS2) = {{b}, {a, b}, {b, c}, {a, c}, {b, d}, {a, d}, {b, c, d}, {a, c, d}}, SM(ΠS3) = {{b}, {c, d}}, SM(Π0) = {∅, {c}, {a, c}}, and SM(ΠS) = {{b}, {a, c}, {b, c}, {b, d}, {a, c, d}, {b, c, d}}.\nBut, regardless of the decomposition obtained, it holds for the respective joins that\nSM(Π) = SM(ΠS1) ⋊⋉ SM(ΠS2) ⋊⋉ SM(ΠS3) ⋊⋉ SM(Π0) = SM(ΠS) ⋊⋉ SM(ΠS3) ⋊⋉ SM(∅) = SM(ΠS′) ⋊⋉ SM(∅) = {{a, c, d}, {b}}.\nIn the calculations involving ⋊⋉ it is important to notice that the allowed combinations of stable models are determined in terms of joint visible atoms of the modules involved. For instance, we have Atv(ΠS1) ∩ Atv(ΠS3) = {a, b} ∩ {b, c, d} = {b} so that SM(ΠS1) ⋊⋉ SM(ΠS3) is {{a} ∪ {c, d}, {b} ∪ {b}} = {{a, c, d}, {b}} by Definition 5.2. Thus, interestingly, the role of the remaining two modules ΠS2 and Π0 is merely to approve upon these two models. Recalling the discussion from the introduction, this suggests a strategy which gives precedence to\n1. an evaluation of modules having only few stable models, and\n2. a combination of stable models for modules that have only few visible atoms in common."
    }, {
      "heading" : "7. Shifting Disjunctions",
      "text" : "In this section, we continue the pursuit of applications for the module theorem established in Section 5. We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper. Roughly speaking, the idea behind shifting is to translate a disjunctive rule A ← B,∼C into several normal (non-disjunctive) rules by shifting head atoms h ∈ A to negative literals ∼h in the body. For instance, a simple disjunctive rule a ∨ b ∨ c ← is captured by normal rules\na ← ∼b,∼c, b ← ∼a,∼c, and c ← ∼a,∼b.\nAs shown by Eiter et al. (2004), such a local shifting transformation preserves ordinary equivalence, i.e., stable models.12 The application of this technique is, however, pre-empted in the presence of head-cycles (Ben-Eliyahu & Dechter, 1994). Such a cycle is provided by an SCC S that intersects with the head A of some disjunctive rule A ← B,∼C of Π such that |S∩A| > 1. For instance, local shifting is no longer applicable to the rule a∨ b∨ c ← in the presence of a ← b and b ← a which create a strongly connected component S = {a, b}. As a consequence, the respective DLP-functions\nΠ1 = 〈{a ∨ b ∨ c ←; a ← b; b ← a}, ∅, {a, b, c}, ∅〉, (30)\nΠ2 = 〈{a ← ∼b,∼c; b ← ∼a,∼c; c ← ∼a,∼b; a ← b; b ← a}, ∅, {a, b, c}, ∅〉 (31)\nhave different stable models: SM(Π1) = {{a, b}, {c}} and SM(Π2) = {{c}}. Such a discrepancy of stable models can be settled by applying the decomposition technique from Section 6. In fact, it leads to a proper generalization of the local shifting transformation which is formalized below for DLP-functions and their strongly connected components.\nDefinition 7.1 Let Π = 〈R, I,O,H〉 be a DLP-function and SCC+(Π) the respective set of SCCs. The general shifting of Π is the DLP-function GSH(Π) = 〈IC(R) ∪R′, I, O,H〉, where R′ is the set of rules\n{(A ∩ S) ← B,∼C,∼(A \\ S) | A ← B,∼C ∈ R, S ∈ SCC+(Π) and A ∩ S 6= ∅}. (32)\nHence, the idea is to project the head A of the rule with respect to each component S, and atoms in the difference A \\ S are shifted to the negative body. This can be viewed as the contribution of a disjunctive rule A ← B,∼C for a particular component S.\nExample 7.2 For Π1 from (30), we have SCC +(Π1) = {{a, b}, {c}}, so that\nGSH(Π1) = 〈{a ∨ b ← ∼c; c ← ∼a,∼b; a ← b; b ← a}, ∅, {a, b, c}, ∅〉.\nMost importantly, we have SM(GSH(Π1)) = {{a, b}, {c}} = SM(Π1), in contrast to the set SM(Π2) = {{c}} of stable models for Π2 from (31).\n12. In addition to ordinary equivalence, also uniform equivalence (Eiter & Fink, 2003) is preserved by local shifting but not strong equivalence (Lifschitz, Pearce, & Valverde, 2001).\nWe now prove the correctness of the general shifting principle from Definition 7.1. The aim is to exploit the decomposition of Π from Definition 6.3 together with the modular reconstruction of Π from Proposition 6.4 and the compositionality of stable semantics from Corollary 6.5. To extend the coverage of Corollary 6.5, we introduce explicit operators for revealing and hiding atoms of DLP-functions as follows:\nDefinition 7.3 Let Π = 〈R, I,O,H〉 be a DLP-function. Then,\n1. Reveal(Π, A) = 〈R, I,O ∪A,H \\A〉, for a set A ⊆ H of hidden atoms, and\n2. Hide(Π, A) = 〈R, I,O \\A,H ∪A〉, for a set A ⊆ O of output atoms.\nSince the definition of stable models does not make a difference between output atoms and hidden atoms, the following properties are easy to verify. The role of hidden atoms becomes important in Section 8 when DLP-functions are compared with each other.\nProposition 7.4 Let Π be any DLP-function.\n1. For any A ⊆ Ath(Π), SM(Π) = SM(Reveal(Π, A)).\n2. For any A ⊆ Ato(Π), SM(Π) = SM(Hide(Π, A)).\nLemma 7.5 Let Π be a DLP-function with Ath(Π) = ∅, S a component in SCC +(Π), and ΠS the respective module in the decomposition of Π according to Definition 6.3. Then,\nSM(ΠS) = SM(GSH(ΠS)). (33)\nProof. Recall that ΠS = 〈DefR(S), I, S, ∅〉, where the input signature I = At(DefR(S))\\ S. Notice that S is the only component in SCC+(ΠS) and hence GSH(ΠS) has a set of rules\nR′ = {(A ∩ S) ← B,∼C,∼(A \\ S) | A ← B,∼C ∈ DefR(S)}.\nConsider any interpretation M ⊆ I ∪S, where I and S are the input and output signatures of ΠS , respectively. Thus, Mi = M ∩ I and Mo = M ∩ S. Then, the following equivalences hold:\nA ← B ∈ (DefR(S)/Mi) Mo\n⇐⇒ ∃A ← B,∼C ∈ DefR(S)/Mi such that Mo |= ∼C ⇐⇒ ∃A′ ← B′,∼C ′ ∈ DefR(S) such that A = A ′ o, B = B ′ o, C = C ′ o,\nMi |= ∼A ′ i ∪B ′ i ∪ ∼C ′ i , and Mo |= ∼C ′ o\n⇐⇒ ∃A ← B′,∼C ′,∼A′i ∈ R ′ such that A = A′o, B = B ′ o, C = C ′ o,\nMi |= ∼A ′ i ∪B ′ i ∪ ∼C ′ i , and Mo |= ∼C ′ o\n⇐⇒ ∃A ← B,∼C ∈ R′/Mi such that Mo |= ∼C ⇐⇒ A ← B ∈ (R′/Mi) Mo .\nThus, we conclude that (DefR(S)/Mi) Mo coincides with (R′/Mi) Mo , and, consequently, Mo ∈ MM((DefR(S)/Mi) Mo) if and only if Mo ∈ MM((R ′/Mi)\nMo). Therefore, SM(ΠS/Mi) = SM(GSH(ΠS)/Mi). Since M and, in particular, Mi were arbitrarily chosen in the beginning, we obtain the equality of stable models stated in (33) directly by Corollary 3.9.\nTheorem 7.6 For any DLP-function Π = 〈R, I,O,H〉, SM(Π) = SM(GSH(Π)).\nProof. Since Π may have hidden atoms, Corollary 6.5 is not applicable to its decomposition based on SCC+(Π). Thus, we have to start with Π′ = Reveal(Π, H) = 〈R, I,O ∪H, ∅〉 rather than Π itself. Since SCCs are independent of hiding, we have SCC+(Π′) = SCC+(Π) and GSH(Π′) = Reveal(GSH(Π), H). Since Ath(Π\n′) = ∅ by construction, we know by Proposition 6.4 that Π′0 ⊔ ( ⊔ S∈SCC+(Π)Π ′ S) = Π ′. Applying GSH(·) to this equation yields\nGSH(Π′) = Π′0 ⊔ ( ⊔ S∈SCC+(Π)GSH(Π ′ S)). (34)\nAs regards the respective sets of stable models, we obtain\nSM(Π′) = SM(Π′0) ⋊⋉ (⋊⋉S∈SCC+(Π′)SM(Π ′ S)) [Corollary 6.5]\n= SM(Π′0) ⋊⋉ (⋊⋉S∈SCC+(Π′)SM(GSH(Π ′ S))) [Lemma 7.5] = SM(GSH(Π′)). [Corollary 6.5 and (34)]\nIt follows by Proposition 7.4 that SM(Hide(Π′, H)) = SM(Π′) = SM(GSH(Π′)) = SM(Hide(GSH(Π′), H)). Since Hide(Π′, H) = Π and Hide(GSH(Π′), H) = GSH(Π), we have established that SM(Π) = SM(GSH(Π)) as desired.\nAccording to Definition 6.3, decompositions of DLP-functions create multiple copies of disjunctive rules whose heads intersect with several SCCs. The introduction of such copies can be circumvented by applying the general shifting technique from Definition 7.1.\nExample 7.7 For the DLP-function Π from Example 6.6, we obtain R1 = {a∨b ← ∼c,∼d; a ← b; b ← a} and R2 = {c ∨ d ← ∼a,∼b; c ← d; d ← c} as the sets of rules associated with Π1 = 〈R1, {c, d}, {a, b}, ∅〉 and Π2 = 〈R2, {a, b}, {c, d}, ∅〉, for which Π1 ⊔ Π2 = 〈R1 ∪R2, ∅, {a, b, c, d}, ∅〉 is defined.\nThese observations enable us to view disjunctive rules which are shared by the modules associated with SCCs as syntactic sugar. However, a clever implementation can save space using shared rules. In the worst case, unwinding a rule a1∨ · · ·∨an ← B,∼C that coincides with the respective SCCs S1, . . . , Sn such that a1 ∈ S1, . . . , an ∈ Sn may create n copies of the body B ∪∼C. Such a quadratic blow-up can be partly alleviated by introducing a new atom b as a name for the body. Thus the result of shifting a1 ∈ S1, . . . , an ∈ Sn becomes\na1 ← b,∼a2, . . . ,∼an; ... ai ← b,∼a1, . . . ,∼ai−1,∼ai+1, . . . ,∼an; ... an ← b,∼a1, . . . ,∼an−1\ntogether with the defining rule b ← B,∼C for b. There is an implementation of the general shifting principle called dencode.13 If requested to do so, it calculates beforehand whether it pays off to introduce a new atom for the body for each disjunctive rule or not.\n13. Available at http://www.tcs.hut.fi/Software/asptools/ for experimenting."
    }, {
      "heading" : "8. Equivalence of DLP-Functions",
      "text" : "The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of logic program modules—giving rise to the notion of modular equivalence for logic programs. In this section, we generalize the concept of modular equivalence for DLP-functions and introduce a translation-based method for checking modular equivalence of DLP-functions following analogous approaches of Oikarinen and Janhunen (2004, 2009)."
    }, {
      "heading" : "8.1 Modular Equivalence",
      "text" : "Module interfaces must be taken properly into account when DLP-functions are compared. For this reason, we consider two DLP-functions Π1 and Π2 to be compatible if and only if Ati(Π1) = Ati(Π2) and Ato(Π1) = Ato(Π2).\nDefinition 8.1 DLP-functions Π1 and Π2 are modularly equivalent, denoted by Π1 ≡m Π2, if and only if\n1. Π1 and Π2 are compatible and\n2. there is a bijection f : SM(Π1) → SM(Π2) such that for all interpretations M ∈ SM(Π1), M ∩Atv(Π1) = f(M) ∩Atv(Π2).\nThe proof that ≡m is congruent for ⊔ lifts from the case of normal programs (Oikarinen & Janhunen, 2008a) to the disjunctive case using Theorem 5.7.\nProposition 8.2 Let Π1, Π2, and Π be DLP-functions. If Π1 ≡m Π2 and both Π1 ⊔Π and Π2 ⊔Π are defined, then Π1 ⊔Π ≡m Π2 ⊔Π.\nProof. Let Π1 = 〈R1, I1, O1, H1〉 and Π2 = 〈R2, I2, O2, H2〉 be DLP-functions such that Π1 ≡m Π2, and Π = 〈R, I,O,H〉 a DLP-function acting as an arbitrary context for Π1 and Π2 such that Π1 ⊔Π and Π2 ⊔Π are defined. Consider any M ∈ SM(Π1 ⊔Π). Theorem 5.7 implies that M1 = M ∩At(Π1) ∈ SM(Π1) and N = M ∩At(Π) ∈ SM(Π). Since Π1 ≡m Π2, we have I1 = I2, O1 = O2, and there is a bijection f : SM(Π1) → SM(Π2) such that\nM1 ∩ (I1 ∪O1) = f(M1) ∩ (I2 ∪O2) (35)\nholds for M1. Define M2 = f(M1). Since M1 and N are compatible by definition and (35) holds, the models M2 and N are compatible as I1 = I2 and O1 = O2. Thus, M2 ∪ N ∈ SM(Π2⊔Π) by Theorem 5.7 and we have effectively described how M is mapped to a model in SM(Π2 ⊔Π) by a function g : SM(Π1 ⊔Π) → SM(Π2 ⊔Π) defined by\ng(M) = f(M ∩At(Π1)) ∪ (M ∩At(Π)).\nClearly, g maps the set of visible atoms in M to itself, that is,\nM ∩ (I1 ∪ I ∪O1 ∪O) = g(M) ∩ (I2 ∪ I ∪O2 ∪O).\nThe justifications for g being a bijection are as follows:\n• g is an injection: M 6= N implies g(M) 6= g(N) for all M,N ∈ SM(Π1 ⊔ Π), since f(M ∩At(Π1)) 6= f(N ∩At(Π1)) or M ∩At(Π) 6= N ∩At(Π).\n• g is a surjection: for any N ∈ SM(Π2 ⊔ Π), M = f −1(N ∩ At(Π2)) ∪ (N ∩ At(Π)) ∈\nSM(Π1 ⊔Π) and g(M) = N , since f is a surjection.\nThe inverse function g−1 : SM(Π2 ⊔ Π) → SM(Π1 ⊔ Π) of g can be defined by setting g−1(N) = f−1(N ∩At(Π2)) ∪ (N ∩At(Π)). Thus, Π1 ⊔Π ≡m Π2 ⊔Π.\nNote that Π ≡m GSH(Π) follows directly from Theorem 7.6. Applying Proposition 8.2 in the context of Theorem 7.6 indicates that shifting can be localized to a particular component Π1 in a larger DLP-function Π1 ⊔Π since Π1 ⊔Π ≡m GSH(Π1) ⊔Π."
    }, {
      "heading" : "8.2 Verifying Modular Equivalence",
      "text" : "Oikarinen and Janhunen (2004) proposed a translation-based method for the verification of weak equivalence of disjunctive logic programs. Two logic programs are weakly equivalent iff they have exactly the same set of stable models. Thus, weak equivalence can be seen as a special case of modular equivalence for DLP-functions Π1 and Π2 where Ati(Π1) ∪ Ath(Π1) = Ati(Π2) ∪ Ath(Π2) = ∅. This motivates us to adjust the translationbased technique for the verification of modular equivalence. As observed in previous work (Janhunen & Oikarinen, 2007; Oikarinen & Janhunen, 2008a), the verification of visible/modular equivalence involves a counting problem in general. A reduction of computational time complexity can be achieved for programs that have enough visible atoms, referred to as the EVA property for short, (Janhunen & Oikarinen, 2007). For any DLPfunction Π = 〈R, I,O,H〉, we define the hidden part of Π as the restricted DLP-function Πh = 〈DefR(H), I ∪O,H, ∅〉 which enables the evaluation of hidden atoms in H given arbitrary truth values for all other atoms in I ∪ O. Recalling Definition 3.2, we use an instantiation of Πh with respect to an interpretation Mv ⊆ Ati(Πh), i.e., Πh/Mv, to define the EVA property for the DLP-function Π.\nDefinition 8.3 A DLP-function Π = 〈R, I,O,H〉 has enough visible atoms iff Πh/Mv has a unique stable model for each Mv ⊆ Atv(Π) = Ati(Πh).\nThe idea behind the translation-based method of Oikarinen and Janhunen (2004) is that ordinary disjunctive programs R1 and R2 are weakly equivalent iff their translations TR(R1, R2) and TR(R2, R1) have no stable models. In the following, we propose a modified version of the translation function adjusted to verification of modular equivalence. In order to be able to verify modular equivalence, we need to take the semantics of the atoms in the input signature into account as well as the role of hidden atoms when modular equivalence of programs is under consideration. In the case of DLP-functions, we transform any pair Π1 and Π2 of compatible DLP-functions into a DLP-function EQT(Π1,Π2) that has a stable model iff there is some stable model M ∈ SM(Π1) for which there is no stable model N ∈ SM(Π2) with M ∩Atv(Π1) = N ∩Atv(Π2). We form the translation as a composition of DLP-functions in order to fully exploit the compositionality of the stable model semantics when justifying the correctness of the method.\nIn what follows, we use new atoms a•, a◦, and a∗ not appearing in At(Π1) ∪ At(Π2) for any atom a, and we use the shorthand A• = {a• | a ∈ A} for any set A of atoms, and\nanalogously defined shorthands A◦ and A∗. Moreover, diff, unsat, unsat•, and ok are new atoms not appearing in At(Π1) ∪ At(Π2). The translation EQT(Π1,Π2), which is to be summarized by Definition 8.4 below, consists of the following three parts:\n(i) The DLP-function Π1 naturally captures a stable model M ∈ SM(Π1).\n(ii) The DLP-function hidden(Π2) = 〈Rh, I ∪O,H ∗, ∅〉 provides a representation for the\nhidden part of Π2 = 〈R, I,O,H〉 evaluated with respect to the visible part of M . The input signature of hidden(Π2) consists of the visible atoms in Atv(Π2) = Atv(Π1) = I∪ O. The set Rh contains a rule A ∗ h ← Bv∪B ∗ h,∼(Av∪Cv∪C ∗ h) for each A ← B,∼C ∈ R such that Ah 6= ∅, i.e., A ← B,∼C ∈ DefR(H). The hidden parts of rules are renamed systematically using atoms from Ath(Π2)\n∗. This is to capture the unique stable model N for (Π2)h/Mv expressed in Ath(Π2)\n∗ rather than Ath(Π2). Note that the existence and uniqueness of such an N is guaranteed by the EVA property.\n(iii) Finally, the DLP-function\nTR(Π2) = 〈RTR, I ∪O ∪H ∗, O• ∪H• ∪ {unsat, unsat•, diff, ok}, O◦ ∪H◦〉\nprovides a minimality check. The set RTR contains\n1. a rule unsat ← Bv ∪B ∗ h,∼(Av ∪A ∗ h ∪ Cv ∪ C ∗ h) for each rule A ← B,∼C ∈ R, 2. rules a• ← a,∼a◦,∼unsat and a◦ ← a,∼a•,∼unsat for each a ∈ O, and rules a• ← a∗,∼a◦,∼unsat and a◦ ← a∗,∼a•,∼unsat for each a ∈ H,\n3. a rule unsat• ← Bi ∪ B • o ∪ B • h,∼(Ai ∪ A • o ∪ A • h ∪ Cv ∪ C ∗ h),∼unsat for each rule\nA ← B,∼C ∈ R,\n4. a rule diff ← a,∼a•,∼unsat for each a ∈ O, and a rule diff ← a∗,∼a•,∼unsat for each a ∈ H, and\n5. the following rules:\nok ← unsat, ok ← diff,∼unsat,∼unsat•, and ⊥ ← ∼ok.\nThe intuition behind the translation TR(Π2) is as follows. The rules in the first item check whether an interpretation L ⊆ At(Π2) corresponding to the actual input K = (L ∩ (I ∪O)) ∪ {a∗ | a ∈ L ∩H} ⊆ Atv(Π2) ∪ Ath(Π2)\n∗ for TR(Π2) satisfies the rules in Π2. If the rules of Π2 are satisfied, then the rules in items 2–4 are activated by the literals ∼unsat in their bodies. The rules in the second item are used to generate a subset L′ of L such that L′ ∩ Ati(Π2) = L ∩ Ati(Π2). This is achieved by introducing a new atom a• for each a ∈ Ato(Π2) ∪ Ath(Π2). The rules in the third item check whether the representation of L′ in Ati(Π2) ∪ Ato(Π2) • ∪ Ath(Π2) •, i.e., K ′ = (L′ ∩ I) ∪ {a• | a ∈ L′ ∩ (O ∪H)}, satisfies the rules in ΠL2 . The rules in the fourth item check whether L′ is a proper subset of L. Finally, the rules in the fifth item summarize the reasons why L cannot be a stable model of Π2, i.e., either the rules in Π2 are not satisfied in L, or L is not a minimal model of Π L 2 . As the net effect of this construction, TR(Π2)/K has a stable model iff L is not a stable model of Π2.\nDefinition 8.4 Let Π1 and Π2 = 〈R, I,O,H〉 be compatible DLP-functions having enough visible atoms. Then, the translation EQT(Π1,Π2) is given by Π1 ⊔ hidden(Π2) ⊔ TR(Π2).\nThe translation TR(Π2) for the minimality check essentially contains the same rules as TR(R1, R2) \\ R1, where TR(R1, R2) is the translation defined by Oikarinen and Janhunen (2004) for sets R1 and R2 of disjunctive rules. There are two further aspects, however. First, occurrences of hidden atoms from H are additionally represented using their counterparts from H∗. Second, we only need renamed versions of atoms in O ∪H because the interpretation of atoms in the input signature I is kept fixed. Finally, we note that for DLP-functions Π1 and Π2 which correspond to ordinary disjunctive logic programs, i.e., for Π1 = 〈R1, ∅, O, ∅〉 and Π2 = 〈R2, ∅, O, ∅〉, the translation EQT(Π1,Π2) coincides with TR(R1, R2).\nTheorem 8.5 Let Π1 and Π2 be compatible DLP-functions having enough visible atoms. Then, Π1 ≡m Π2 iff both SM(EQT(Π1,Π2)) = ∅ and SM(EQT(Π2,Π1)) = ∅.\nProof sketch. Let Π1 and Π2 = 〈R, I,O,H〉 be compatible DLP-functions having enough visible atoms. By Theorem 5.7, given compatible interpretations M1 ⊆ At(Π1), M2 ⊆ At(hidden(Π2)), and M3 ⊆ At(TR(Π2)), M = M1∪M2∪M3 is a stable model of the translation EQT(Π1,Π2) iff M1 ∈ SM(Π1), M2 ∈ SM(hidden(Π2)), and M3 ∈ SM(TR(Π2)). Given any interpretation M1 ⊆ At(Π1), there is a unique stable model M2 ∈ SM(hidden(Π2)) compatible with M1, since Π2 has the EVA property. Hence, hidden(Π2) does not constrain stable models in the composition EQT(Π1,Π2). Whenever M3 is compatible with both M1 and M2, it holds that M3∩(I∪O∪H ∗) = (M1∪M2)∩(I∪O∪H ∗) and M3 ∈ SM(TR(Π2)) iff the interpretation M3∩(I∪O)∪{a ∈ H | a ∗ ∈ M3} is not a stable model of Π2 as established by Oikarinen and Janhunen (2004, Theorem 1). When verifying modular equivalence of DLP-functions of the forms Π1 ⊔Π and Π2 ⊔Π, it is possible to further streamline the translations involved in the verification task.\nTheorem 8.6 Let Π1 and Π2 be compatible DLP-functions having enough visible atoms, and Π a DLP-function such that Π1 ⊔Π and Π2 ⊔Π are defined. Then, Π1 ⊔Π ≡m Π2 ⊔Π iff both SM(EQT(Π1,Π2) ⊔Π) = ∅ and SM(EQT(Π2,Π1) ⊔Π) = ∅.\nThe context Π can be an arbitrary DLP-function, i.e., it is not necessary for Π to have the EVA property, as long as Π1 ⊔ Π and Π2 ⊔ Π are defined. To prove Theorem 8.6, notice that due to the structure of the translation, EQT(Π1,Π2)⊔Π is defined whenever Π1 ⊔Π is defined, and then Theorems 5.7 and 8.5 can be applied."
    }, {
      "heading" : "9. Related Work",
      "text" : "Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over relational databases. In their approach, query programs are formalized as triples 〈π,R,S〉 where π is a set of disjunctive rules and R and S are the signatures for the input and output relations, respectively, whereas auxiliary (hidden) predicates are left implicit. Hence, in the propositional case, the only notable difference with respect to Definition 2.1 is that input atoms are not allowed to occur in the heads of disjunctive rules. As regards semantics, the\nprogram π is reduced with respect to a complete input database D specified in terms of R, yielding the instantiation π[D], and, among others, stable-model semantics is applied to π[D] in analogy to Definition 3.2. However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by ⊔.\nModularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category—the join ⊔ being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(·, ·):\ntclo(x, y) ← rel(x, y); tclo(x, y) ← tclo(x, z), rel(z, y).\nHere, tclo(·, ·) acts as the output predicate of the module tclo[rel] whereas rel(·, ·) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(·, ·) above. Consider, for instance, the rule\nloop(x) ← tclo[edge](x, y), tclo[edge](y, x)\nwhich captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(·, ·). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures\nIn = {edge(x, y) | 1 ≤ x, y ≤ n} and On = {tclo(x, y) | 1 ≤ x, y ≤ n}\nin the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion. The outcome determines the meaning of the modular description via an embedding into ASP (Lifschitz & Turner, 1999).\nFaber, Greco, and Leone (2007) apply the magic-set method in the evaluation of datalog programs with negation. Their notion of a module is based on the concept of an independent\nset. For a non-disjunctive logic program Π = 〈R, ∅, O, ∅〉, such a set S ⊆ O satisfies, for any a ∈ S, the following two conditions:\n1. if there is a rule h ← B,∼C ∈ R such that h = a, then B ∪ C ⊆ S, and\n2. if a ∈ B ∪ C for some dangerous rule h ← B,∼C ∈ R, then {h} ∪B ∪ C ⊆ S.\nWe skip the exact definition of dangerous rules which, roughly speaking, may interfere with the existence of stable models. It is clear that independent sets are splitting sets in the sense of Definition 5.15, but not vice versa in general. Hence, the module theorem provided by Faber et al. (2007) can be viewed as a special case of the splitting-set theorem and, therefore, observations presented in Section 5.3 apply to independent sets as well."
    }, {
      "heading" : "10. Conclusion and Discussion",
      "text" : "In this paper, we introduced a formal framework for modular programming in the context of disjunctive logic programs under stable-model semantics. The framework is based on the notion of a DLP-function which puts into effect appropriate input/output interfacing for disjunctive logic programs. Analogous module concepts have already been studied in the cases of normal logic programs and smodels programs (Oikarinen & Janhunen, 2008a) and even propositional theories (Janhunen, 2008a), but the special characteristics of disjunctive rules are properly taken into account in the syntactic and semantic definitions of DLPfunctions presented herein. In this respect, we would like to draw the reader’s attention to Definition 2.1 (item 2), Definition 2.2 (items 4–5), as well as Definition 3.2.\nUndoubtedly, the main result of this paper is the module theorem, i.e., Theorem 5.7, which is proved for DLP-functions in general—thus covering the class of disjunctive programs. The module theorem is important as it provides a compositional semantics for disjunctive programs and it generalizes existing approaches such as those based on splitting sets (Lifschitz & Turner, 1994) and magic sets (Faber et al., 2007). Although our approach is based on a number of design decisions, e.g., as regards the definition of module composition, it nevertheless brings out the limits of modular programming in the context of a nonmonotonic declarative language. The module theorem can be exploited in a number of ways in ASP based on disjunctive logic programs. As demonstrated in Section 6, it provides the basis for decomposing disjunctive programs into their components and hence the localization of reasoning tasks. Moreover, as established in Section 7, the technique of shifting disjunctive rules can be generalized for disjunctive programs involving head-cycles. Actually, the generalized form enables us to remove shared disjunctive rules altogether but this might not be desirable due to higher space requirements. Finally, the theory of modular equivalence is fully applicable to DLP-functions as demonstrated in Section 8.\nIn addition to the results discussed above, we anticipate further applications of the module theorem in the future. We strongly believe that research in this direction not only yields results of theoretical interest but also leads to the development of practicably useful software engineering methods for ASP. In fact, first tools for decomposing and linking programs have already been implemented in the context of the smodels system.14 The results of Section 6 enable the development of analogous tools to be used with disjunctive solvers such as\n14. See modlist and lpcat in the ASP tools collection at http://www.tcs.hut.fi/Software/asptools/.\nclaspD, cmodels, dlv, and GnT. There is also an implementation of the general shifting principle, called dencode, in the ASP tool collection. The results of Section 8 pave the way for extending a translation-based verification tool, dlpeq (Janhunen & Oikarinen, 2004), for the verification of modular equivalence. Such an extension is already available in the respective tool, lpeq, for smodels programs (Oikarinen & Janhunen, 2009).15\nAcknowledgments This work was partially supported by the Academy of Finland under projects #211025 (“Advanced Constraint Programming Techniques for Large Structured Problems”) and #122399 (“Methods for Constructing and Solving Large Constraint Models”), and by the Austrian Science Foundation (FWF) under projects P18019 (“Formal Methods for Comparing and Optimizing Nonmonotonic Logic Programs”) and P21698 (“Methods and Methodologies for Developing Answer-Set Programs”). The authors would like to thank the anonymous referees for their constructive comments as well as Martin Gebser and Torsten Schaub for their suggestion to exploit program completion and loop formulas in the proof of the module theorem. A preliminary version of this paper appeared in the proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07), Vol. 4483 of LNCS, pp. 175–187, Tempe, AZ, USA, Springer."
    } ],
    "references" : [ {
      "title" : "Macros, macro calls and use of ensembles in modular answer set programming",
      "author" : [ "C. Baral", "J. Dzifcak", "H. Takahashi" ],
      "venue" : "Proceedings of the 22nd International Conference on Logic Programming (ICLP’06 ),",
      "citeRegEx" : "Baral et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Baral et al\\.",
      "year" : 2006
    }, {
      "title" : "Propositional semantics for disjunctive logic programs",
      "author" : [ "R. Ben-Eliyahu", "R. Dechter" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Ben.Eliyahu and Dechter,? \\Q1994\\E",
      "shortCiteRegEx" : "Ben.Eliyahu and Dechter",
      "year" : 1994
    }, {
      "title" : "Modularity in logic programming",
      "author" : [ "M. Bugliesi", "E. Lamma", "P. Mello" ],
      "venue" : "Journal of Logic Programming,",
      "citeRegEx" : "Bugliesi et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Bugliesi et al\\.",
      "year" : 1994
    }, {
      "title" : "Negation as failure",
      "author" : [ "K.L. Clark" ],
      "venue" : "Logic and Data Bases,",
      "citeRegEx" : "Clark,? \\Q1978\\E",
      "shortCiteRegEx" : "Clark",
      "year" : 1978
    }, {
      "title" : "Reducing disjunctive to non-disjunctive semantics by shift-operations",
      "author" : [ "J. Dix", "G. Gottlob", "V.W. Marek" ],
      "venue" : "Fundamenta Informaticae,",
      "citeRegEx" : "Dix et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Dix et al\\.",
      "year" : 1996
    }, {
      "title" : "Conflict-driven disjunctive answer set solving",
      "author" : [ "C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. König", "M. Ostrowski", "T. Schaub" ],
      "venue" : "Proceedings of the 11th International Conference on Principles and Knowledge Representation and Reasoning,",
      "citeRegEx" : "Drescher et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Drescher et al\\.",
      "year" : 2008
    }, {
      "title" : "Uniform equivalence of logic programs under the stable model semantics",
      "author" : [ "T. Eiter", "M. Fink" ],
      "venue" : "Proceedings of the 19th International Conference on Logic Programming (ICLP’03),",
      "citeRegEx" : "Eiter and Fink,? \\Q2003\\E",
      "shortCiteRegEx" : "Eiter and Fink",
      "year" : 2003
    }, {
      "title" : "Simplifying logic programs under uniform and strong equivalence",
      "author" : [ "T. Eiter", "M. Fink", "H. Tompits", "T. Woltran" ],
      "venue" : "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04 ),",
      "citeRegEx" : "Eiter et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2004
    }, {
      "title" : "On the computational cost of disjunctive logic programming: Propositional case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Eiter and Gottlob,? \\Q1995\\E",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1995
    }, {
      "title" : "Modular logic programming and generalized quantifiers",
      "author" : [ "T. Eiter", "G. Gottlob", "H. Veith" ],
      "venue" : "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’97 ),",
      "citeRegEx" : "Eiter et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Combining answer set programming with description logics for the Semantic Web",
      "author" : [ "T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Eiter et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2008
    }, {
      "title" : "Tight logic programs",
      "author" : [ "E. Erdem", "V. Lifschitz" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "Erdem and Lifschitz,? \\Q2003\\E",
      "shortCiteRegEx" : "Erdem and Lifschitz",
      "year" : 2003
    }, {
      "title" : "Magic sets and their application to data integration",
      "author" : [ "W. Faber", "G. Greco", "N. Leone" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Faber et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Faber et al\\.",
      "year" : 2007
    }, {
      "title" : "Fully abstract compositional semantics for logic programs",
      "author" : [ "H. Gaifman", "E. Shapiro" ],
      "venue" : "In Proceedings of the 16th Annual ACM Symposium on Principles of Programming Languages,",
      "citeRegEx" : "Gaifman and Shapiro,? \\Q1989\\E",
      "shortCiteRegEx" : "Gaifman and Shapiro",
      "year" : 1989
    }, {
      "title" : "Engineering an incremental ASP solver",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "S. Thiele" ],
      "venue" : "Proceedings of the 24th International Conference on Logic Programming (ICLP’08),",
      "citeRegEx" : "Gebser et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2008
    }, {
      "title" : "Detecting inconsistencies in large biological networks with answer set programming",
      "author" : [ "M. Gebser", "T. Schaub", "S. Thiele", "B. Usadel", "P. Veber" ],
      "venue" : "Proceedings of the 24th International Conference on Logic Programming (ICLP’08),",
      "citeRegEx" : "Gebser et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2008
    }, {
      "title" : "Building a knowledge base: An example",
      "author" : [ "M. Gelfond", "A. Gabaldon" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Gelfond and Gabaldon,? \\Q1999\\E",
      "shortCiteRegEx" : "Gelfond and Gabaldon",
      "year" : 1999
    }, {
      "title" : "Logic programming and knowledge representation – the A-Prolog perspective",
      "author" : [ "M. Gelfond", "N. Leone" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Gelfond and Leone,? \\Q2002\\E",
      "shortCiteRegEx" : "Gelfond and Leone",
      "year" : 2002
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of the 5th International Conference on Logic Programming",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1988\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing,",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Disjunctive defaults",
      "author" : [ "M. Gelfond", "H. Przymusinska", "V. Lifschitz", "M. Truszczyński" ],
      "venue" : "Proceedings of the 2nd International Conference on Principles and Knowledge Representation and Reasoning,",
      "citeRegEx" : "Gelfond et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelfond et al\\.",
      "year" : 1991
    }, {
      "title" : "Answer set programming based on propositional satisfiability",
      "author" : [ "E. Giunchiglia", "Y. Lierler", "M. Maratea" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Giunchiglia et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2006
    }, {
      "title" : "Some (in)translatability results for normal logic programs and propositional theories",
      "author" : [ "T. Janhunen" ],
      "venue" : "Journal of Applied Non-Classical Logics,",
      "citeRegEx" : "Janhunen,? \\Q2006\\E",
      "shortCiteRegEx" : "Janhunen",
      "year" : 2006
    }, {
      "title" : "Modular equivalence in general",
      "author" : [ "T. Janhunen" ],
      "venue" : "Proceedings of the 18th European Conference on Artificial Intelligence",
      "citeRegEx" : "Janhunen,? \\Q2008\\E",
      "shortCiteRegEx" : "Janhunen",
      "year" : 2008
    }, {
      "title" : "Removing redundancy from answer set programs",
      "author" : [ "T. Janhunen" ],
      "venue" : "Proceedings of the 24th International Conference on Logic Programming (ICLP’08),",
      "citeRegEx" : "Janhunen,? \\Q2008\\E",
      "shortCiteRegEx" : "Janhunen",
      "year" : 2008
    }, {
      "title" : "Unfolding partiality and disjunctions in stable model semantics",
      "author" : [ "T. Janhunen", "I. Niemelä", "D. Seipel", "P. Simons", "You", "J.-H" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "Janhunen et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Janhunen et al\\.",
      "year" : 2006
    }, {
      "title" : "lpeq and dlpeq – translators for automated equivalence testing of logic programs",
      "author" : [ "T. Janhunen", "E. Oikarinen" ],
      "venue" : "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04 ),",
      "citeRegEx" : "Janhunen and Oikarinen,? \\Q2004\\E",
      "shortCiteRegEx" : "Janhunen and Oikarinen",
      "year" : 2004
    }, {
      "title" : "Automated verification of weak equivalence within the smodels system",
      "author" : [ "T. Janhunen", "T. Oikarinen" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "Janhunen and Oikarinen,? \\Q2007\\E",
      "shortCiteRegEx" : "Janhunen and Oikarinen",
      "year" : 2007
    }, {
      "title" : "Towards an efficient tableau method for boolean circuit satisfiability checking",
      "author" : [ "T. Junttila", "I. Niemelä" ],
      "venue" : "Proceedings of the First International Conference on Computational Logic (CL 2000),",
      "citeRegEx" : "Junttila and Niemelä,? \\Q2000\\E",
      "shortCiteRegEx" : "Junttila and Niemelä",
      "year" : 2000
    }, {
      "title" : "Enhancing disjunctive logic programming systems by SAT checkers",
      "author" : [ "C. Koch", "N. Leone", "G. Pfeifer" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Koch et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Koch et al\\.",
      "year" : 2003
    }, {
      "title" : "Loop formulas for disjunctive logic programs",
      "author" : [ "J. Lee", "V. Lifschitz" ],
      "venue" : "Proceedings of the 19th International Conference on Logic Programming (ICLP’03 ), Vol. 2916 of LNCS,",
      "citeRegEx" : "Lee and Lifschitz,? \\Q2003\\E",
      "shortCiteRegEx" : "Lee and Lifschitz",
      "year" : 2003
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "Leone et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Computing circumscription",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Proceedings of the 9th International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "Lifschitz,? \\Q1985\\E",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 1985
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "V. Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2001
    }, {
      "title" : "A modular action description language",
      "author" : [ "V. Lifschitz", "W. Ren" ],
      "venue" : "In Proceedings of the 21st National Conference on Artificial Intelligence",
      "citeRegEx" : "Lifschitz and Ren,? \\Q2006\\E",
      "shortCiteRegEx" : "Lifschitz and Ren",
      "year" : 2006
    }, {
      "title" : "Splitting a logic program",
      "author" : [ "V. Lifschitz", "H. Turner" ],
      "venue" : "Proceedings of the 11th International Conference on Logic Programming",
      "citeRegEx" : "Lifschitz and Turner,? \\Q1994\\E",
      "shortCiteRegEx" : "Lifschitz and Turner",
      "year" : 1994
    }, {
      "title" : "Representing transition systems by logic programs",
      "author" : [ "V. Lifschitz", "H. Turner" ],
      "venue" : "Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning,",
      "citeRegEx" : "Lifschitz and Turner,? \\Q1999\\E",
      "shortCiteRegEx" : "Lifschitz and Turner",
      "year" : 1999
    }, {
      "title" : "ASSAT: computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Lin and Zhao,? \\Q2004\\E",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2004
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V.W. Marek", "M. Truszczyński" ],
      "venue" : null,
      "citeRegEx" : "Marek and Truszczyński,? \\Q1999\\E",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 1999
    }, {
      "title" : "Applications of circumscription to formalizing commonsense knowledge",
      "author" : [ "J. McCarthy" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "McCarthy,? \\Q1986\\E",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1986
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Niemelä,? \\Q1999\\E",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1999
    }, {
      "title" : "Verifying the equivalence of logic programs in the disjunctive case",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "Proceedings of the 7th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04 ),",
      "citeRegEx" : "Oikarinen and Janhunen,? \\Q2004\\E",
      "shortCiteRegEx" : "Oikarinen and Janhunen",
      "year" : 2004
    }, {
      "title" : "Achieving compositionality of the stable model semantics for smodels programs",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "Oikarinen and Janhunen,? \\Q2008\\E",
      "shortCiteRegEx" : "Oikarinen and Janhunen",
      "year" : 2008
    }, {
      "title" : "Implementing prioritized circumscription by computing disjunctive stable models",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "Artificial Intelligence: Methodology, Systems, and Applications, 13th International Conference (AIMSA’08),",
      "citeRegEx" : "Oikarinen and Janhunen,? \\Q2008\\E",
      "shortCiteRegEx" : "Oikarinen and Janhunen",
      "year" : 2008
    }, {
      "title" : "A translation-based approach to the verification of modular equivalence",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "Oikarinen and Janhunen,? \\Q2009\\E",
      "shortCiteRegEx" : "Oikarinen and Janhunen",
      "year" : 2009
    }, {
      "title" : "A theory of diagnosis from first principles",
      "author" : [ "R. Reiter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Reiter,? \\Q1987\\E",
      "shortCiteRegEx" : "Reiter",
      "year" : 1987
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Simons et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Simons et al\\.",
      "year" : 2002
    } ],
    "referenceMentions" : [ {
      "referenceID" : 40,
      "context" : "Answer-set programming (ASP) (Marek & Truszczyński, 1999; Niemelä, 1999; Gelfond & Leone, 2002) is a paradigm for declarative problem solving in which solutions of problems are described in terms of rules subject to a nonmonotonic semantics based on stable models (Gelfond & Lifschitz, 1988).",
      "startOffset" : 29,
      "endOffset" : 95
    }, {
      "referenceID" : 21,
      "context" : "In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs.",
      "startOffset" : 38,
      "endOffset" : 55
    }, {
      "referenceID" : 13,
      "context" : "In a recent approach of Oikarinen and Janhunen (2008a), the modular architecture put forth by Gaifman and Shapiro (1989) is accommodated for the classes of normal and smodels programs.",
      "startOffset" : 94,
      "endOffset" : 121
    }, {
      "referenceID" : 5,
      "context" : "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al.",
      "startOffset" : 75,
      "endOffset" : 98
    }, {
      "referenceID" : 31,
      "context" : ", 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemelä, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally.",
      "startOffset" : 62,
      "endOffset" : 82
    }, {
      "referenceID" : 5,
      "context" : "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemelä, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced.",
      "startOffset" : 76,
      "endOffset" : 657
    }, {
      "referenceID" : 5,
      "context" : "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemelä, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b). There are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving.",
      "startOffset" : 76,
      "endOffset" : 1043
    }, {
      "referenceID" : 5,
      "context" : "Unfortunately, contemporary disjunctive answer-set solvers, such as claspd (Drescher et al., 2008), cmodels (Giunchiglia, Lierler, & Maratea, 2006), dlv (Leone et al., 2006), and gnt (Janhunen, Niemelä, Seipel, Simons, & You, 2006), exhibit little support for modular reasoning although related techniques like strongly connected components are exploited internally. There are also other reasoning tasks that can be boosted with a modular approach. For instance, the optimization of answer-set programs gives rise to the problem of verifying whether different versions of programs have the same answer sets. As demonstrated by Oikarinen and Janhunen (2009), such verification tasks may benefit from modularization, and, in particular, if approximation techniques based on modular equivalence are introduced. Following this idea, the first modular off-line optimizer of answer-set programs, called modopt, has recently been implemented (Janhunen, 2008b). There are also other interesting applications of modules in sight: Gebser et al. (2008a) propose an incremental technique for answer-set solving. The idea is to gradually extend a program instance in terms of additional modules, e.g., when solving AI planning problems. Moreover, theoretical results like the splitting-set theorem (Lifschitz & Turner, 1994) and the module theorem can be directly exploited in correctness proofs. For instance, it is proved by Oikarinen and Janhunen (2008b) that the models of a prioritized circumscription can be captured with disjunctive stable models using a particular translation.",
      "startOffset" : 76,
      "endOffset" : 1445
    }, {
      "referenceID" : 15,
      "context" : "The term goes back to Gelfond and Gabaldon (1999) who introduced LP-functions as (partial) definitions of new relations in terms of old, known ones.",
      "startOffset" : 22,
      "endOffset" : 50
    }, {
      "referenceID" : 13,
      "context" : "However, arbitrary combinations of program modules are not meaningful and, first of all, we adopt syntactic restrictions introduced by Gaifman and Shapiro (1989) from the context of negation/disjunction-free logic programs.",
      "startOffset" : 135,
      "endOffset" : 162
    }, {
      "referenceID" : 3,
      "context" : "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step.",
      "startOffset" : 63,
      "endOffset" : 76
    }, {
      "referenceID" : 3,
      "context" : "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs—neither involving default negation nor disjunctions.",
      "startOffset" : 64,
      "endOffset" : 472
    }, {
      "referenceID" : 3,
      "context" : "The proof of the theorem is based on the notions of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003) which are first lifted to the case of DLPfunctions in Section 4 as a preparatory step. The proof of the module theorem follows as the main topic of Section 5. The result is non-trivial because the underlying semantics based on stable models is inherently nonmonotonic. This feature was already recognized by Gaifman and Shapiro (1989) in a much simpler setting of definite programs—neither involving default negation nor disjunctions. As observed by them, too, syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models.2 In the current paper, we strive for analogous results but in the case of programs permitting both default negation and disjunctions. It turns out that strongly connected components of positive dependency graphs provide a key criterion when it comes to confining program composition. The compositionality properties of disjunctive programs under stable-model semantics have also arisen in the context of the so-called splitting-set theorem (Lifschitz & Turner, 1994; Eiter et al., 1997a, 2008). In fact, the module theorem established herein is a proper generalization of its predecessor (Oikarinen & Janhunen, 2008a). We illustrate the potential of our modular architecture by the evaluation of quantified Boolean formulas (QBFs), which serve as canonical representatives of the classes of the polynomial-time hierarchy (PH). Due to basic complexity results established by Eiter and Gottlob (1995), it is natural from our perspective to concentrate on the second level of the PH in the case of disjunctive programs.",
      "startOffset" : 64,
      "endOffset" : 1651
    }, {
      "referenceID" : 13,
      "context" : "The main concern of Gaifman and Shapiro (1989) is modularity with respect to the logical consequences of a definite program and hence the intersection of its Herbrand models.",
      "startOffset" : 20,
      "endOffset" : 47
    }, {
      "referenceID" : 13,
      "context" : "To this end, we extend a definition originally proposed by Gaifman and Shapiro (1989) to the case of disjunctive programs.",
      "startOffset" : 59,
      "endOffset" : 86
    }, {
      "referenceID" : 16,
      "context" : "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).",
      "startOffset" : 77,
      "endOffset" : 105
    }, {
      "referenceID" : 16,
      "context" : "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).",
      "startOffset" : 77,
      "endOffset" : 122
    }, {
      "referenceID" : 16,
      "context" : "Similar approaches within the area of ASP have previously been introduced by Gelfond and Gabaldon (1999), Janhunen (2006), and Oikarinen and Janhunen (2008a).",
      "startOffset" : 77,
      "endOffset" : 158
    }, {
      "referenceID" : 13,
      "context" : "As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs.",
      "startOffset" : 23,
      "endOffset" : 50
    }, {
      "referenceID" : 13,
      "context" : "As observed already by Gaifman and Shapiro (1989), syntactic restrictions on program composition are necessary in order to guarantee compositionality properties for the semantics based on Herbrand models, even for the simple case of definite programs. Thus, program union as operator for composition without further restrictions is not satisfactory with respect to compositionality. We start by adapting the construction of Gaifman and Shapiro (1989) to the case of disjunctive programs.",
      "startOffset" : 23,
      "endOffset" : 451
    }, {
      "referenceID" : 13,
      "context" : "The first three of the conditions above are due to Gaifman and Shapiro (1989) and they imply that the sets O1, H1, O2, and H1 are mutually pairwise distinct.",
      "startOffset" : 51,
      "endOffset" : 78
    }, {
      "referenceID" : 22,
      "context" : "As observed by Oikarinen and Janhunen (2008a), the heads of choice rules possessing multiple atoms can be freely split without affecting their semantics.",
      "startOffset" : 29,
      "endOffset" : 46
    }, {
      "referenceID" : 22,
      "context" : "Consequently, the length of Π in symbols, denoted by ‖Π‖, gives an upper bound for |At(Π)| which is important when one considers the computational cost of translating programs (Janhunen, 2006).",
      "startOffset" : 176,
      "endOffset" : 192
    }, {
      "referenceID" : 15,
      "context" : "In formal terms, a DLP-function Π = 〈R, I,O,H〉 is designed to provide a mapping from subsets of I to a set of subsets of O ∪ H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored.",
      "startOffset" : 168,
      "endOffset" : 196
    }, {
      "referenceID" : 15,
      "context" : "In formal terms, a DLP-function Π = 〈R, I,O,H〉 is designed to provide a mapping from subsets of I to a set of subsets of O ∪ H in analogy to LP-functions formalized by Gelfond and Gabaldon (1999). However, the exact definition of this mapping is deferred until Section 3 where the semantics of DLP-functions will be anchored. In the sequel, the (syntactic) class of DLP-functions is denoted by D. It is assumed, for the sake of simplicity, that D spans over a fixed (at most denumerable) signature At(D)8 so that At(Π) ⊆ At(D) holds for each DLP-function Π ∈ D. Given DLP-functions Π1, Π2, and Π3 that pairwise respect the input/output interfaces of each other, it holds that • Π1 ⊕Π2 ∈ D (closure), • Π1 ⊕∅ = ∅⊕Π1 = Π1, for the empty DLP-function ∅ = 〈∅, ∅, ∅, ∅〉 (identity), • Π1 ⊕Π2 = Π2 ⊕Π1 (commutativity), and • Π1 ⊕ (Π2 ⊕Π3) = (Π1 ⊕Π2)⊕Π3 (associativity). The theory of modules put forth by Oikarinen and Janhunen (2008a) is based on a more restrictive operator for program composition, viz.",
      "startOffset" : 168,
      "endOffset" : 929
    }, {
      "referenceID" : 1,
      "context" : "Technically speaking, we define the positive dependency graph DG(Π) of a DLP-function Π = 〈R, I,O,H〉 using only positive dependencies—following the definition by Ben-Eliyahu and Dechter (1994). However, we exclude input atoms from the graph as their definitions are external to Π anyway.",
      "startOffset" : 162,
      "endOffset" : 193
    }, {
      "referenceID" : 32,
      "context" : "Handling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them.",
      "startOffset" : 127,
      "endOffset" : 160
    }, {
      "referenceID" : 39,
      "context" : "Handling input atoms is slightly more complicated in the case of minimal models but the primitives of parallel circumscription (Lifschitz, 1985; McCarthy, 1986) provide us with a straightforward way to address them.",
      "startOffset" : 127,
      "endOffset" : 160
    }, {
      "referenceID" : 18,
      "context" : "In order to cover arbitrary DLP-functions, we interpret negative body literals in the way proposed by Gelfond and Lifschitz (1991).",
      "startOffset" : 102,
      "endOffset" : 131
    }, {
      "referenceID" : 3,
      "context" : ", a DLP-function Π of the form 〈R, ∅, O, ∅〉, can be characterized via classical propositional logic, using the concepts of completion (Clark, 1978) and loop formulas (Lin & Zhao, 2004; Lee & Lifschitz, 2003).",
      "startOffset" : 134,
      "endOffset" : 147
    }, {
      "referenceID" : 30,
      "context" : ", Ato(Π) ∪ Ath(Π) = At(Π), the completion Comp(Π) reduces to the definition provided by Lee and Lifschitz (2003) and the same holds for the set LF(Π) of loop formulas.",
      "startOffset" : 88,
      "endOffset" : 113
    }, {
      "referenceID" : 30,
      "context" : "In turn, we know that Mo ∪Mh |= Comp(Π/Mi)∪LF(Π/Mi) iff Mo ∪Mh is a stable model of the program Π/Mi by the results of Lee and Lifschitz (2003); recall that Π/Mi is an ordinary disjunctive program without any input atoms.",
      "startOffset" : 119,
      "endOffset" : 144
    }, {
      "referenceID" : 3,
      "context" : "Since each “ordinary” program can be represented as a DLP-function, we thus properly generalize the well-known completion semantics (Clark, 1978).",
      "startOffset" : 132,
      "endOffset" : 145
    }, {
      "referenceID" : 30,
      "context" : "Then, the notion of Ati(Π)tightness coincides with ordinary tightness, and the definition of the completion Comp(Π) reduces to the one provided by Lee and Lifschitz (2003).",
      "startOffset" : 147,
      "endOffset" : 172
    }, {
      "referenceID" : 32,
      "context" : "3 to a comparison with the splitting set theorem proven by Lifschitz and Turner (1994).",
      "startOffset" : 59,
      "endOffset" : 87
    }, {
      "referenceID" : 31,
      "context" : "The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques.",
      "startOffset" : 48,
      "endOffset" : 68
    }, {
      "referenceID" : 31,
      "context" : "The strategic companies domain is identified by Leone et al. (2006) as one of the first practical domains involving decision problems on the second level of the polynomialtime hierarchy and solved using ASP techniques. The simplified encoding provided by Koch, Leone, and Pfeifer (2003) is based on two kinds of disjunctive rules:",
      "startOffset" : 48,
      "endOffset" : 287
    }, {
      "referenceID" : 22,
      "context" : "Quite recently, Oikarinen and Janhunen (2008b) presented an efficient encoding of prioritized circumscription as a disjunctive program (and thus, as a special case, of parallel circumscription as well)—enabling a concise representation of minimal diagnoses in the sense of Reiter (1987).",
      "startOffset" : 30,
      "endOffset" : 47
    }, {
      "referenceID" : 22,
      "context" : "Quite recently, Oikarinen and Janhunen (2008b) presented an efficient encoding of prioritized circumscription as a disjunctive program (and thus, as a special case, of parallel circumscription as well)—enabling a concise representation of minimal diagnoses in the sense of Reiter (1987). The resulting disjunctive rules involve head-cycles (see Section 7 for details) which typically pre-empt a polynomial-time translation into a computationally easier normal logic program.",
      "startOffset" : 30,
      "endOffset" : 287
    }, {
      "referenceID" : 22,
      "context" : "The design of Πsat n and Π unsat n is based on the explanatory approach from Janhunen et al. (2006), where (19) is equivalently viewed as a formula ∃X¬∃Y ¬φ having the matrix ¬φ in conjunctive normal form (CNF).",
      "startOffset" : 77,
      "endOffset" : 100
    }, {
      "referenceID" : 22,
      "context" : "Concerning the correctness of the representation given in Figure 2, due to an existing proof by Janhunen et al. (2006), we only present the main steps—fully exploiting the benefits from our modular approach.",
      "startOffset" : 96,
      "endOffset" : 119
    }, {
      "referenceID" : 32,
      "context" : "According to Lifschitz and Turner (1994), a solution to R with respect to U ⊆ O is a pair 〈X,Y 〉 where X ⊆ U , Y ⊆ O\\U , X ∈ SM(bU (R)), and Y ∈ SM(tU (R)/X).",
      "startOffset" : 13,
      "endOffset" : 41
    }, {
      "referenceID" : 22,
      "context" : "As previously demonstrated by Oikarinen and Janhunen (2008a), splitting sets are applicable to DLPfunctions like Π = 〈{a ← ∼b; b ← ∼a}, ∅, {a, b}, ∅〉 only in the trivial way, i.",
      "startOffset" : 44,
      "endOffset" : 61
    }, {
      "referenceID" : 20,
      "context" : "We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper.",
      "startOffset" : 62,
      "endOffset" : 102
    }, {
      "referenceID" : 4,
      "context" : "We now generalize the principle of shifting disjunctive rules (Gelfond et al., 1991; Dix et al., 1996) by applying the results of this paper.",
      "startOffset" : 62,
      "endOffset" : 102
    }, {
      "referenceID" : 7,
      "context" : "As shown by Eiter et al. (2004), such a local shifting transformation preserves ordinary equivalence, i.",
      "startOffset" : 12,
      "endOffset" : 32
    }, {
      "referenceID" : 22,
      "context" : "Equivalence of DLP-Functions The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006).",
      "startOffset" : 217,
      "endOffset" : 233
    }, {
      "referenceID" : 22,
      "context" : "Equivalence of DLP-Functions The concept of visible equivalence was originally introduced in order to neglect hidden atoms when logic programs, or other theories of interest, are compared on the basis of their models (Janhunen, 2006). Oikarinen and Janhunen (2008a) extended this idea to the level of logic program modules—giving rise to the notion of modular equivalence for logic programs.",
      "startOffset" : 218,
      "endOffset" : 266
    }, {
      "referenceID" : 22,
      "context" : "2 Verifying Modular Equivalence Oikarinen and Janhunen (2004) proposed a translation-based method for the verification of weak equivalence of disjunctive logic programs.",
      "startOffset" : 46,
      "endOffset" : 62
    }, {
      "referenceID" : 22,
      "context" : "The idea behind the translation-based method of Oikarinen and Janhunen (2004) is that ordinary disjunctive programs R1 and R2 are weakly equivalent iff their translations TR(R1, R2) and TR(R2, R1) have no stable models.",
      "startOffset" : 62,
      "endOffset" : 78
    }, {
      "referenceID" : 22,
      "context" : "The translation TR(Π2) for the minimality check essentially contains the same rules as TR(R1, R2) \\ R1, where TR(R1, R2) is the translation defined by Oikarinen and Janhunen (2004) for sets R1 and R2 of disjunctive rules.",
      "startOffset" : 165,
      "endOffset" : 181
    }, {
      "referenceID" : 7,
      "context" : "Related Work Eiter et al. (1997a) consider the use of disjunctive datalog programs as query programs over relational databases.",
      "startOffset" : 13,
      "endOffset" : 34
    }, {
      "referenceID" : 7,
      "context" : "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated.",
      "startOffset" : 50,
      "endOffset" : 71
    }, {
      "referenceID" : 7,
      "context" : "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by ⊔. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey.",
      "startOffset" : 50,
      "endOffset" : 664
    }, {
      "referenceID" : 7,
      "context" : "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by ⊔. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category—the join ⊔ being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion.",
      "startOffset" : 50,
      "endOffset" : 1149
    }, {
      "referenceID" : 7,
      "context" : "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by ⊔. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category—the join ⊔ being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(·, ·): tclo(x, y) ← rel(x, y); tclo(x, y) ← tclo(x, z), rel(z, y). Here, tclo(·, ·) acts as the output predicate of the module tclo[rel] whereas rel(·, ·) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(·, ·) above. Consider, for instance, the rule loop(x) ← tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(·, ·). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 ≤ x, y ≤ n} and On = {tclo(x, y) | 1 ≤ x, y ≤ n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations.",
      "startOffset" : 50,
      "endOffset" : 2220
    }, {
      "referenceID" : 7,
      "context" : "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by ⊔. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category—the join ⊔ being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(·, ·): tclo(x, y) ← rel(x, y); tclo(x, y) ← tclo(x, z), rel(z, y). Here, tclo(·, ·) acts as the output predicate of the module tclo[rel] whereas rel(·, ·) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(·, ·) above. Consider, for instance, the rule loop(x) ← tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(·, ·). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 ≤ x, y ≤ n} and On = {tclo(x, y) | 1 ≤ x, y ≤ n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion.",
      "startOffset" : 50,
      "endOffset" : 2976
    }, {
      "referenceID" : 7,
      "context" : "However, in contrast to our modular architecture, Eiter et al. (1997a) take both positive and negative dependencies into account and no recursion between modules is tolerated. The resulting hierarchy of complete components admits a straightforward generalization of the splitting sequences (Lifschitz & Turner, 1994). The essential difference is that a partial order rather than a total order of modules is assumed. In this respect, it is worth pointing out that partial orders of DLP-functions are permitted by ⊔. Modularity has gained more attention in the context of conventional (monotonic) logic programming; see the work of Bugliesi, Lamma, and Mello (1994) for a survey. Two mainstream approaches are identified: The first is called programming-in-the-large in which algebraic operators are introduced for the construction of logic programs out of modules. The approach of our paper falls into this category—the join ⊔ being an example of such operators. The other, and quite different programming-in-the-small approach, is to extend the underlying logical language in terms of abstraction mechanisms. In the approach of Eiter et al. (1997b), for instance, logic program modules are viewed as generalized quantifiers which are allowed to nest but only in a hierarchical fashion. To give an idea of this approach, consider a module that formalizes the transitive closure of a relation denoted by a predicate rel(·, ·): tclo(x, y) ← rel(x, y); tclo(x, y) ← tclo(x, z), rel(z, y). Here, tclo(·, ·) acts as the output predicate of the module tclo[rel] whereas rel(·, ·) is its only input predicate. The module can be invoked to create the transitive closure of any binary relation substituted for rel(·, ·) above. Consider, for instance, the rule loop(x) ← tclo[edge](x, y), tclo[edge](y, x) which captures nodes involved in the loops of a directed graph whose edges are supposed to be represented with the predicate edge(·, ·). In our approach, the call tclo[edge] would result in one module as part of the respective ground program with input and output signatures In = {edge(x, y) | 1 ≤ x, y ≤ n} and On = {tclo(x, y) | 1 ≤ x, y ≤ n} in the case of n vertices. However, in the architecture of Eiter et al. (1997b), the module tclo[rel] can be invoked several times to form transitive closures of different relations. In our effectively propositional approach, each invocation of tclo[rel] would map to a new module. Although these modules could be obtained by straightforward renaming of predicates, this aspect illustrates the power of the programming-in-the-small approach. Here, tclo[rel] acts as a new parameterized connective which the programmer can concisely refer to as a new relation, viz. the transitive closure of rel in this case. But, in spite of succinctness at this point, such relations may have to be unwound in an actual implementation. This aspect is made explicit in the modular action description (MAD) language proposed by Lifschitz and Ren (2006): a modular action description is turned into a single-module description in a recursive fashion. The outcome determines the meaning of the modular description via an embedding into ASP (Lifschitz & Turner, 1999). Faber, Greco, and Leone (2007) apply the magic-set method in the evaluation of datalog programs with negation.",
      "startOffset" : 50,
      "endOffset" : 3220
    }, {
      "referenceID" : 12,
      "context" : "Hence, the module theorem provided by Faber et al. (2007) can be viewed as a special case of the splitting-set theorem and, therefore, observations presented in Section 5.",
      "startOffset" : 38,
      "endOffset" : 58
    }, {
      "referenceID" : 12,
      "context" : "The module theorem is important as it provides a compositional semantics for disjunctive programs and it generalizes existing approaches such as those based on splitting sets (Lifschitz & Turner, 1994) and magic sets (Faber et al., 2007).",
      "startOffset" : 217,
      "endOffset" : 237
    } ],
    "year" : 2009,
    "abstractText" : "Practically all programming languages allow the programmer to split a program into several modules which brings along several advantages in software development. In this paper, we are interested in the area of answer-set programming where fully declarative and nonmonotonic languages are applied. In this context, obtaining a modular structure for programs is by no means straightforward since the output of an entire program cannot in general be composed from the output of its components. To better understand the effects of disjunctive information on modularity we restrict the scope of analysis to the case of disjunctive logic programs (DLPs) subject to stable-model semantics. We define the notion of a DLP-function, where a well-defined input/output interface is provided, and establish a novel module theorem which indicates the compositionality of stable-model semantics for DLP-functions. The module theorem extends the well-known splitting-set theorem and enables the decomposition of DLP-functions given their strongly connected components based on positive dependencies induced by rules. In this setting, it is also possible to split shared disjunctive rules among components using a generalized shifting technique. The concept of modular equivalence is introduced for the mutual comparison of DLP-functions using a generalization of a translation-based verification method.",
    "creator" : "dvips(k) 5.96 Copyright 2005 Radical Eye Software"
  }
}