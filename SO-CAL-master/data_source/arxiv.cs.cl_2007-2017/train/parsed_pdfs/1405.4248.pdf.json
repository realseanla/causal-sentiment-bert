{
  "name" : "1405.4248.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "formelle de Montague", "Yannis Haralambous", "−−−→ LangLog" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "Les mathématiques de la langue : l’approche formelle de Montague∗\nYannis Haralambous"
    }, {
      "heading" : "19 mai 2014",
      "text" : "Résumé\nNous présentons une méthode de modélisation de la langue naturelle qui est fortement basée sur les mathématiques. Cette méthode, appelée «sémantique formelle», a été initiée par le linguiste américain Richard M. Montague dans les années 1970. Elle utilise des outils mathématiques tels que les langages et grammaires formels, la logique du 1er ordre, la théorie de types et le λ-calcul. Nous nous proposons de faire découvrir au lecteur tant la sémantique formelle de Montague que les outils mathématiques dont il s’est servi."
    }, {
      "heading" : "1 Introduction",
      "text" : "La modélisation mathématique de la langue que nous présentons ici, date des années 70 du siècle dernier. Les langages artificiels (comme le langage de la logique ou les divers langages de programmation) existaient déjà mais les linguistes pensaient que les langues naturelles étaient bien trop chaotiques pour que l’on puisse leur appliquer les mêmes méthodes que pour les langages artificiels. Arrive alors un certain Richard M. Montague qui prétend que c’est tout à fait possible, à condition d’utiliser des outils mathématiques évolués, et il le démontre à travers trois articles (dont le premier, de 1970, s’intitule, de manière assez provocante, L’anglais en tant que langage formel [13]). Malheureusement Montague est mort assez jeune 1 mais son travail a néanmoins révolutionné la linguistique et l’a rapproché des mathématiques et de l’informatique.\nDans cet article nous allons décrire les outils mathématiques dont s’est servi Montague pour modéliser la langue naturelle : les langages formels, les grammaires formelles, le λ-calcul typé, la logique du 1er ordre, la théorie des ensembles. Ce texte s’inspire fortement (tout en le simplifiant) de l’ouvrage [4]."
    }, {
      "heading" : "2 L’approche de Montague",
      "text" : "La langue sert avant tout de parler du monde. Nos points de départ seront donc le «monde» et la «langue». Le «monde», que nous noterons Monde peut être le monde réel, un monde imaginaire, ou simplement un ensemble d’objets ou d’idées abstraites (d’ailleurs, à la section 7.3 nous parlerons de l’ensemble des «mondes possibles»). La «langue (naturelle)», que nous noterons LangNat, sera un ensemble de phrases françaises, orthographiquement et syntaxiquement correctes, et qui se réfèrent aux objets de l’ensemble Monde.\nPour étudier la langue, Montague propose d’intercaler entre LangNat et Monde, un ensemble de formules écrites dans un langage artificiel intermédiaire, basé sur la logique de 1er ordre et le λ-calcul typé. Nous noterons par LangLog l’ensemble des traductions des phrases de LangNat dans ce langage.\n∗Une version plus évoluée de ce texte va paraître dans la revue Quadrature (http://www.quadrature.info) en 2015.\n1. Et de manière tragique, au point où sa mort a inspiré un roman policier, la Sémantique du meurtre d’Aifric Campbell [3].\nar X\niv :1\n40 5.\n42 48\nv1 [\ncs .C\nL ]\n1 6\nM ay\n2 01\n4\nOn a donc la situation suivante :\nLangNat Trad−−−→ LangLog Inter−−−→Monde,\noù Trad est la traduction des phrases françaises en langage intermédiaire, et Inter le lien entre LangLog et le Monde que l’on appelle interprétation 2.\nDans la suite nous utilisons des caractères bâton inclinés pour représenter les mots de LangNat, et des caractères gras pour représenter les entités de Monde. Ainsi, Gérard ∈ LangNat sera un nom (propre) masculin de six lettres, qui se prononce /Ze.KaK/. Par contre, gérard ∈ Monde sera un individu, en chair et en os, identifié par ce prénom. On va considérer que dans Monde il n’y a qu’un seul gérard.\nDans cet article nous allons décrire, dans l’ordre, LangNat (§ 3), LangLog (§ 4), Trad (§ 5) et Monde/Inter (§ 6)."
    }, {
      "heading" : "3 La structure de la langue",
      "text" : "Parmi les nombreuses manières d’étudier la langue naturelle, celles qui vont nous intéresser dans cet article sont la syntaxe et la sémantique. La syntaxe étudie grosso modo la composition des phrases, c’est-à-dire la manière dont les mots se combinent pour former des phrases, selon leurs catégories grammaticales (nom, adjectif, adverbe, verbe, etc.).\nLa sémantique est l’étude de la signification. Il s’avère que la syntaxe est un outil indispensable pour l’étude de la sémantique grâce au\nprincipe suivant :\nPrincipe de compositionnalité. La sémantique d’une phrase s’obtient à partir des sémantiques de ses parties et de la manière dont elles ont été composées (= la syntaxe de la phrase).\nEn effet, pour comprendre le sens de la phrase Gérard aime Alice il faut savoir ce que sont (ou peuvent être) Gérard, Alice et l’action d’aimer, et identifier par la syntaxe de la phrase le fait que c’est Gérard qui est en position de sujet et c’est donc lui qui aime Alice, et non pas l’inverse.\nPour commencer, voyons comment analyser syntaxiquement les phrases de LangNat. Les outils mathématiques qui vont nous servir sont les langages formels et les grammaires formelles."
    }, {
      "heading" : "3.1 Langages formels",
      "text" : "Définissons d’abord la notion de monoïde libre. Soit Σ un ensemble quelconque que nous allons appeler alphabet.\nDéfinition 1. On appelle monoïde libre (Σ∗, ·, ε) sur Σ, l’ensemble de tous les produits x1 · · ·xn (n ≥ 1) d’éléments de Σ, auquel on ajoute l’élément ε, appelé élément neutre. La loi · doit être associative.\nOn appelle concaténation la loi du monoïde, et on s’autorise de ne pas la noter. Les éléments du monoïde sont appelés «mots», et ε est le «mot vide».\nDéfinition 2. Un langage formel L sur un alphabet Σ est un sous-ensemble quelconque du monoïde libre Σ∗.\nCe qui fait la force des langages formels, c’est que — malgré son appellation —, un «alphabet» n’est pas forcément un ensemble de lettres. Les éléments d’un «alphabet» peuvent être des motsclé d’un langage de programmation (dans ce cas, un «mot» sera, par exemple, un programme dans ce langage), des symboles mathématiques (un «mot» sera alors une formule), des nucléotides (un\n2. Attention, ici le mot «interprétation» a un sens technique strict (cf. § 6), qu’il ne faut pas confondre avec celui du langage courant.\n«mot» sera alors un sous-brin d’ADN), etc. Dans notre cas, l’«alphabet» sera formé de mots de la langue française, et les éléments de LangNat seront des phrases de la langue française.\nSe pose alors la question : si un langage formel est un sous-ensemble quelconque du monoïde libre, alors comment le décrire ?\nToute la difficulté est là : comment choisir les mots qui forment un langage formel — ou, de manière équivalente, comment décider si un mot appartient ou non à un langage formel donné (éventuellement infini) ?\nUne méthode pour décrire des langages formels est celle des grammaires formelles."
    }, {
      "heading" : "3.2 Grammaires formelles",
      "text" : "Une grammaire formelle est un ensemble de règles de production. En partant d’un symbole appelé «axiome de départ», on applique ces règles à un ensemble de symboles auxiliaires appelés «non-terminaux» jusqu’à aboutir aux mots du langage que l’on souhaite définir (et qui donc s’appellent «terminaux», puisqu’on ne peut aller plus loin).\nDéfinition 3. Soit Σ un alphabet. Une grammaire formelle G est un quadruplet (S, V,Σ, P ) où S est un élément appelé axiome de départ, V l’ensemble des symboles non-terminaux, Σ l’ensemble des symboles terminaux, et P l’ensemble des productions.\nUne production p est un couple (X,u), où X ∈ V ∪ {S}, et u ∈ (Σ ∪ V )∗ (c’est-à-dire le monoïde libre sur les éléments de Σ et de V ).\nUne suite d’applications successives de productions est appelée une dérivation.\nOn note une telle production p : X → u. Une production envoie donc un élément non-terminal (d’où son nom de «non-terminal») ou l’axiome de départ, à un mot comportant des terminaux et des non-terminaux. On peut appliquer des productions aux mots : si p : X → u et si le mot w s’écrit w1Xw2 alors p produira le mot w1uw2. Mais attention : si w s’écrit w1Xw2Xw3 alors une application de p peut produire w1uw2Xw3 ou w1Xw2uw3 (mais pas les deux en même temps, pour que cela arrive il faudrait l’appliquer deux fois). Et si w ne contient pas X, alors p laisse w inchangé.\nOn se pose alors la question suivante : est-ce qu’un mot w peut être l’image d’une dérivation partant de S ? On dira alors que w est G-dérivable.\nDéfinition 4. Soit G = (S, V,Σ, P ) une grammaire formelle. Le langage formel engendré par G, noté LG, est l’ensemble des éléments de Σ∗ qui sont G-dérivables.\nNotons bien que les éléments de LG sont tous des mots sur des terminaux. En effet, l’axiome de départ et les non-terminaux sont indispensables pour obtenir le langage formel engendré mais n’y apparaissent pas eux-mêmes. Dans notre cas, les non-terminaux vont être des catégories et fonctions grammaticales. Prenons un exemple. On peut décrire syntaxiquement la phrase Gérard dort par la grammaire p1 : S→ GN GV p2 : GN→ N p3 : GV→ V p4 : N→ Gérard p5 : V→ dort où S est l’axiome de départ ; les symboles GN (groupe nominal), GV (groupe verbal), N (nom) et V (verbe) sont des non-terminaux ; et, enfin, Gérard et dort sont des terminaux."
    }, {
      "heading" : "3.3 Arbre syntaxique d’une phrase",
      "text" : "Comme on vient de le voir, pour décrire la structure syntaxique d’une phrase, il suffit de donner sa dérivation partant de S, c’est-à-dire l’ensemble de productions à travers lesquelles on obtient cette phrase.\nCette dérivation peut être admirablement bien illustrée par un arbre syntaxique : il s’agit d’un arbre (c’est-à-dire d’un graphe connexe sans cycle) orienté, dont la racine est l’axiome initial, les sommets intermédiaires sont les non-terminaux qui interviennent dans la production de la phrase, et les feuilles sont les mots de la phrase. Tout ensemble d’arêtes (orientées) sortant d’un sommet représente alors une production, et les enfants d’un sommet sont exactement les symboles de la partie droite de sa production.\nL’arbre syntaxique de la fig. 1 représente la dérivation partant de S qui produit la phrase Gérard aime Alice."
    }, {
      "heading" : "4 Le langage intermédiaire",
      "text" : "La prochaine étape consiste à décrire LangLog, c’est-à-dire les formules du langage intermédiaire. Ce langage est basé sur deux outils mathématiques : la logique du 1er ordre et le λ-calcul typé.\n4.1 Notions de logique du 1er ordre Nous ne développerons ici de la logique du 1er ordre que ce qui est nécessaire pour notre exposé. Pour définir les formules logiques nous allons nous servir des symboles suivants : 1. symboles de constante a, b, c, . . . ; 2. symboles de variable x, y, z, . . . ; 3. symboles de prédicat P,Q,R, . . . qui prennent un certain nombre d’arguments (on appelle\narité le nombre d’arguments d’un prédicat). Les arguments peuvent être des variables ou des constantes. On note, par exemple, P (a, b, x) le prédicat ternaire dont les arguments sont a, b, x ;\n4. symboles d’opérateur qui s’appliquent aux prédicats : l’opérateur unaire de négation ¬, et les opérateurs binaires de conjonction ∧, de disjonction ∨, d’implication →, de double implication ↔ ;\n5. symboles de quantificateur existentiel ∃ et universel ∀, qui s’appliquent aux variables ; 6. le symbole d’égalité = ; 7. des parenthèses.\nDéfinition 5. On définit une formule logique de manière récursive : 1. Un prédicat d’arité n appliqué à n constantes et/ou variables est une formule. 2. Si a et b sont des constantes ou des variables, a = b est une formule. 3. Si f est une formule, (f) et ¬f sont des formules. 4. Si f est une formule et x une variable, ∃x f et ∀x f sont des formules. 5. Si f et g sont des formules, f ∧ g, f ∨ g, f → g et f ↔ g sont des formules.\nLe lecteur aura sans doute remarqué que nous venons d’énumérer une multitude de symboles sans donner leur signification.\nIl y a une raison à cela : en fait, une formule logique n’est a priori rien d’autre qu’un assemblage de symboles abstraits (selon les règles syntaxiques données par la définition 5) et c’est grâce à ce degré élevé d’abstraction qu’elle peut être appliquée à une infinité de situations différentes.\nPour appliquer une formule à une situation et lui donner ainsi un «sens», on fait une interprétation, c’est-à-dire une correspondance entre LangLog etMonde. Mais qu’est-ce qu’une interprétation au juste ?\nDéfinition 6. Soit Z2 l’ensemble {vrai, faux}. Une interprétation d’une formule logique φ est une application Inter : LangLog → Monde telle que pour chaque constante c de φ, Inter(c) ∈ Monde, et pour chaque prédicat n-aire P de φ, Inter(P ) est une fonction Monden → Z2. D’autre part, pour toute variable x de φ, Inter(x) devient une variable à valeurs dans Monde.\nL’interprétation de l’opérateur unaire ¬ est une application Z2 → Z2 et celles des opérateurs binaires ∧, ∨, → et ↔ sont des applications Z2 × Z2 → Z2, dont les valeurs sont données par la table suivante (poétiquement appelée table de vérité) :\nφ ψ ¬φ φ ∧ ψ φ ∨ ψ φ→ ψ φ↔ ψ vrai vrai faux vrai vrai vrai vrai vrai faux faux faux vrai faux faux faux vrai vrai faux vrai vrai faux faux faux vrai faux faux vrai vrai\nDans une interprétation donnée, une formule qui ne contient aucune variable est nécessairement vraie ou fausse. Il en est de même lorsqu’elle contient uniquement des variables quantifiées, c’està-dire telles que pour chacune il y ait un quantificateur qui lui soit appliqué. Une variable non quantifiée est appelée libre. L’interprétation d’une formule contenant n variables libres est une fonction Monden → Z2 : sa valeur de vérité dépend des valeurs que prennent ses variables libres.\nAprès cette rapide introduction à (une partie de) la logique du 1er ordre, voyons comment traduire les phrases de LangNat en des formules logiques.\n5 Traduction LangNat→ LangLog Nous allons noter Trad l’application qui traduit les phrases de LangNat en des formules de LangLog. Une phrase du type Gérard dort décrit une situation où il y a un agent identifié par le nom Gérard qui effectue l’action de dormir. Dans la formule logique il est naturel de prendre une constante g pour représenter Gérard .\nÀ son tour, g doit être interprétée par l’entité du monde réel qui correspond à Gérard , notons cette entité gérard. On a donc Trad(Gérard) = g et Inter(g) = gérard.\nLe choix naturel pour traduire le verbe dort est un prédicat unaire dort. L’interprétation de dort va être une fonctionMonde→ Z2, et, en particulier, on aura Inter(dort(g)) = Inter(dort)(Inter(g)) = Inter(dort)(gérard) = vrai.\nMais comment déduire la formule dort(g) à partir de la grammaire formelle de la syntaxe de la phrase Gérard dort ? Cette grammaire nécessite les règles suivantes : p1 : S→ GN GV p2 : GN→ N p3 : GV→ V p4 : N→ Gérard p5 : V→ dort\nTous les symboles de cette grammaire sont traduits dans LangLog : en effet, GV et V sont traduits par le prédicat dort, GN et N par la constante g et, par le principe de compositionnalité, S devient alors dort(g). On définit :\nTrad(S) = dort(g) Trad(GN) = Trad(N) = g Trad(GV ) = Trad(V ) = dort.\nNotre traduction est complète puisque tous les sommets de l’arbre syntaxique de la phrase de LangNat ont été traduits dans LangLog.\nPrenons maintenant une phrase légèrement plus complexe : Gérard aime Alice (cf. fig. 1). On peut s’attendre à avoir Trad(S) = aime(g, a) où g et a sont des constantes logiques dont les interprétations sont le vilain gérard et la belle alice. De même, dans ce cas, Trad(aime) = aime.\nMais attention ! Avons-nous traduit tous les sommets de l’arbre de la fig. 1 en LangLog ? Hélas, non ! Car, quelle est alors la traduction de GV? On ne peut écrire aime(_, a), cela n’est pas une formule logique valide...\nMontague aurait pu s’arrêter là, en disant : «je sais traduire mes terminaux (Gérard , aime, Alice) et mon axiome de départ (S) en langage logique, peu me chaut le reste».\nQue nenni ! Son génie a consisté — entre autres — à dire que si l’on veut être honnête avec soimême, si l’on veut aller au fond des choses, alors le principe de compositionnalité doit s’appliquer partout, aussi bien dans LangNat, que dans LangLog, et la traduction d’une composition doit être la composition des traductions.\nAutrement dit : si S produit GN et GV, alors la traduction de S doit s’obtenir à partir des traductions de GN et de GV. Mais avec les outils mathématiques décrits jusqu’à maintenant, cela n’est pas possible. Il faut donc se servir d’outils plus performants. Montague en a choisi deux : la théorie des types et le λ-calcul.\nVoyons d’abord ce que sont les types et à quoi ils servent."
    }, {
      "heading" : "5.1 Théorie des types",
      "text" : "Avant de traduire en LangLog tous les sommets d’un arbre syntaxique, il faut déjà se demander de quelle manière ils se combinent entre eux. Un exemple : dans la phrase Gérard aime Alice, l’interprétation du prédicat binaire aime peut être considérée comme une application Monde2 → Z2 (elle envoie la paire d’entités (gérard,alice) vers la valeur vrai si gérard aime alice et vers faux sinon).\nAutre exemple : dans la phrase Gérard aime Alice et Paul déteste Virginie, la particule de coordination et va combiner deux phrases pour en produire une nouvelle, son interprétation sera donc une application Z2 × Z2 → Z2.\nLa situation se complique encore plus dans le cas des adverbes : dans Gérard aime beaucoup Alice, l’adverbe beaucoup agit sur le verbe, donc on peut considérer qu’il transforme une application Monde2 → Z2 en une autre application Monde2 → Z2.\nEt que dire alors des modificateurs d’adverbe comme vraiment beaucoup : en effet, vraiment agit sur beaucoup et est donc un transformateur de transformateur d’application Monde2 → Z2...\nComment gérer cette complexité qui semble croître inexorablement ? Voici la modélisation mathématique qui nous délivre du cauchemar décrit ci-dessus : Montague considère qu’il n’existe que deux types sémantiques primitifs : celui de «formule» (dont l’interprétation dans Monde sera vrai ou faux) et celui de «constante individuelle» (dont l’interprétation sera un élément de Monde). Il note t les formules et e les constantes. Ensuite il prend le monoïde libre {e, t}∗ dont il note la loi comme un produit scalaire 〈,〉. Attention : cette loi n’est pas associative, donc pas question de faire des «simplifications» : 〈e, 〈e, t〉〉 n’est pas la même chose que 〈〈e, e〉, t〉 !\nEnsuite, il appelle les éléments de ce monoïde, des types sémantiques complexes et fait correspondre chaque sommet de l’arbre syntaxique à un type sémantique complexe, de la manière suivante : l’élément de gauche de 〈,〉 est la «donnée d’entrée» du type, son élément de droite est sa «donnée de sortie».\nExemple : un prédicat unaire, comme dort, s’applique à une constante, son interprétation fournit une valeur de Z2. On dira donc qu’il est de type 〈e, t〉 (= «il prend un e et il nous rend un t»).\nMais attention : on ne prend qu’un seul élément d’entrée à la fois ! Un prédicat binaire ne sera donc pas de type 〈{e, e}, t〉 (cette syntaxe n’est pas valide) mais sera décrit de manière récursive comme 〈e, 〈e, t〉〉.\nSi on y réfléchit un peu, c’est parfaitement logique : un prédicat binaire auquel on fournit une valeur devient prédicat unaire, donc pour une entrée e, la sortie est 〈e, t〉. De même, le type d’un prédicat ternaire sera 〈e, 〈e, 〈e, t〉〉〉 et ainsi de suite...\nDe la même manière, la particule de conjonction et sera de type 〈t, 〈t, t〉〉, l’adverbe beaucoup de type 〈〈e, t〉, 〈e, t〉〉, et le modificateur d’adverbe vraiment, de type 〈〈〈e, t〉, 〈e, t〉〉, 〈〈e, t〉, 〈e, t〉〉〉. Arrivé à ce stade, le lecteur/la lectrice doit normalement se sentir ébloui(e) devant l’époustouflante beauté de ce modèle : en effet, quelque soit le type sémantique d’un mot, aussi complexe soit-il, on peut le décrire simplement par un élément du monoïde libre {e, t}∗... c’est simple et efficace.\nNous réécrivons sur la fig. 2 l’arbre syntaxique de la fig. 1 en remplaçant les symboles de la grammaire formelles par leurs types sémantiques. Le lecteur peut constater que (a) à chaque fois qu’un sommet n’a qu’un seul enfant, le type sémantique ne change pas, et (b) à chaque fois qu’un sommet a plusieurs enfants, leurs types sémantiques se composent : ainsi, 〈e, t〉 appliqué à e donne t, et 〈e, 〈e, t〉〉 appliqué à e donne 〈e, t〉. On note × cette composition : 〈e, t〉 × e = t. Pour qu’une composition T1 × T2 puisse avoir lieu, il faut que T1 soit un type complexe et que sa première composante soit égale à T2.\nLa cohérence sémantique d’une phrase provient du fait que les types sémantiques des sommets de son arbre syntaxique se composent correctement, pour arriver au type de S qui est, invariablement, t (comme on peut le constater sur le graphe de la fig. 2).\nTout cela est bien pensé, mais on constate que l’on ne sait toujours pas comment écrire les formules logiques correspondant aux sommets intermédiaires de l’arbre syntaxique. C’est là que le λ-calcul vient à la rescousse."
    }, {
      "heading" : "5.2 Le λ-calcul",
      "text" : "Sous ce nom exotique et mystérieux se cache tout simplement la notion de fonction : appliquer un «λ-opérateur» à une expression mathématique ou logique revient tout simplement à la transformer en fonction.\nAinsi, λx.f(x) est la même chose que x 7→ f(x), c’est-à-dire la fonction f . L’intérêt de la notation est qu’elle nous permet de définir toutes sortes de fonctions. Par exemple, λx.λy.(x+ y) est la fonction (de deux variables) qui à (x, y) associe x + y, alors que λx.(x + y) est la fonction (d’une variable) qui à x associe la somme x+ y (sans donner plus d’information sur y). De même, λP.P (x) est la fonction qui associe à un prédicat unaire sa valeur en x et λP.λx.P (x) est la fonction qui à P et à x associe P (x). Les amateurs de λ-calcul s’amusent même à noter λx.x la fonction identité et λx.c la fonction constante de valeur c.\nLorsqu’on a une fonction f , on peut l’appliquer à une valeur x, et on note le résultat f(x). De même, on peut appliquer une λ-expression à une valeur. Ainsi (λx. sin(x))(π2 ) est tout simplement sin(π2 ). On appelle cela, tout naturellement, une application.\nL’utilisation que Montague fait de la notation λ est très judicieuse. Elle obéit au principe suivant :\nPrincipe de «composition-application». Toute composition de types sémantiques correspond à une application de λ-expressions.\nCe principe va nous guider pour retrouver les λ-expressions correspondant aux sommets des arbres syntaxiques.\nPrenons comme exemple la phrase Gérard aime Alice et les arbres des fig. 1 et 2. On sait déjà que Trad(GN1) = g, Trad(GN2) = a et Trad(S) = aime(g, a). Appliquons le principe de composition-application pour trouver Trad(GV) et Trad(V).\nMais avant de le faire, un petit changement s’impose, afin de nous mettre en conformité avec la théorie des types : on n’écrira plus aime(g, a) pour Gérard aime Alice, comme on l’a fait jusqu’à maintenant, mais aime(a)(g). Cela ne change en rien l’amour indéfectible de Gérard pour Alice, c’est juste que maintenant «aime» n’est plus un «banal prédicat binaire», mais est fièrement devenu un type complexe 〈e, 〈e, t〉〉 !\nRaisonnons maintenant à reculons : on vient de décréter que Trad(S) = aime(a)(g) ; d’autre part, on sait que Trad(GN1) = g ; quel sera Trad(GV) ?\nLaissons-nous guider par les types : dans la fig. 2, le type de GV est 〈e, t〉. On peut en conclure que Trad(GV) nécessite un λ-opérateur, qui doit capter le e pour en faire un t. Et c’est ce λ-opérateur qui va recevoir le g quand on va appliquer Trad(GV) à g. Écrivons donc Trad(GV) = λy.aime(a)(y).\nVérifions : Trad(GV)(g) = (λy.aime(a)(y))(g) = aime(a)(g) = Trad(S), donc tout va bien. De la même manière, on définit Trad(V) = λx.λy.aime(x)(y), et on vérifie : Trad(V)(a) = (λx.λy.aime(x)(y))(a) = λy.aime(a)(y) = Trad(GV). cqfd. Le lecteur trouvera sur la fig. 3 la traduction dans LangLog de l’arbre syntaxique de la phrase Gérard aime Alice :\nOn constate que la taille et la complexité des formules logiques sont assez variées : alors que Trad(GN1) = g et Trad(GN2) = a sont très simples, Trad(V) est bien plus complexe. On peut dire qu’intuitivement cela montre le potentiel d’action caché dans le verbe : lorsque on monte vers la racine, le verbe agit sur les autres constituants, jusqu’à fournir la phrase complète."
    }, {
      "heading" : "5.3 Un exemple : la coordination",
      "text" : "Pour montrer la force de cette théorie et exercer un peu nos neurones, posons-nous un petit casse-tête : la coordination. Le problème commence quand l’insatiable Gérard se met à préférer Alexia alors qu’il aime Alice. Prenons la phrase Gérard aime Alice mais préfère Alexia, et son arbre syntaxique (fig. 4). Les indices des GV et cGV servent uniquement à les distinguer dans la suite. On a noté cGV3 la partie mais préfère Alexia, qui n’est pas un simple groupe verbal mais un «groupe verbal muni d’une conjonction» (d’où le «c» de cGV).\nQue dire de cette phrase ? Le mot mais correspond logiquement à une conjonction et donc la traduction de S sera aime(a)(g)∧préfère(a′)(g) où a = Trad(Alice) et a′ = Trad(Alexia). D’après la section précédente, Trad(GV2) et Trad(GV4) seront resp. λy.aime(a)(y) et λy.préfère(a′)(y).\nLa grande question est : que seront Trad(GV1), Trad(cGV3), et surtout Trad(CONJ) ?\nTraçons d’abord l’arbre des types (fig. 5). Pour GV1, GV2, GV4, rien de nouveau, ce sont des 〈e, t〉, comme tout GV qui se respecte. Quid de cGV3 ? Coincé entre GV1 et GV2, il ne peut être que 〈〈e, t〉, 〈e, t〉〉. Et donc, CONJ ne peut être que 〈〈e, t〉, 〈〈e, t〉, 〈e, t〉〉〉 (intuitivement : à partir d’un prédicat, et ensuite d’un deuxième prédicat, il fournit un nouveau prédicat).\nEt maintenant, pour trouver Trad(GV1), Trad(cGV3) et Trad(CONJ), allons de nouveau à reculons :\n1. Pour trouver Trad(GV1) il faut éliminer (le terme correct est «λ-abstraire») g de Trad(S) = aime(a)(g) ∧ préfère(a′)(g). On le fait en écrivant Trad(S) = λx.(aime(a)(x) ∧ préfère(a′)(x))(g) et donc Trad(GV1) = λx.(aime(a)(x) ∧ préfère(a′)(x)).\n2. Essayons de λ-abstraire Trad(GV2) de Trad(GV1) pour obtenir Trad(cGV3) : on a Trad(GV1) = λx.(aime(a)(x)∧préfère(a′)(x)) = λx.aime(a)(x)∧λx.préfère(a′)(x). Le terme λx.aime(a)(x) est un prédicat.\nOn peut le λ-abstraire en l’écrivant sous la forme λP.(P )(λx.aime(a)(x)), ce qui donne Trad(GV1) = λP.(P ∧λx.préfère(a′)(x))(λx.aime(a)(x)) et donc, par le principe de compositionapplication, Trad(cGV3) = λP.(P ∧ λx.préfère(a′)(x)).\n3. De la même manière, nous λ-abstrayons Trad(GV4) de Trad(cGV3) et ce qui reste sera Trad(CONJ). On trouve Trad(cGV3) = λQ.λP.(P ∧ Q)(λx.préfère(a′)(x)) et donc, enfin, Trad(CONJ) = λQ.λP.(P ∧Q).\nÀ y réfléchir, ce résultat n’a rien d’étonnant : après tout, un opérateur binaire comme ∧ n’associe-t-il pas deux prédicats P et Q au prédicat P ∧Q ?"
    }, {
      "heading" : "5.4 La quantification",
      "text" : "Prenons maintenant la phrase tout le monde aime Alice. La différence avec Gérard aime Alice est que si Gérard (grammaticalement, un nom) peut être traduit par une constante g et puis interprété par une entité gérard, on ne peut faire de même pour tout le monde (un pronom indéfini), que l’on sera logiquement obligé d’interpréter par la totalité des objets de Monde (puisque c’est «tout le monde» qui aime Alice).\nCela ne va pas changer outre mesure l’arbre syntaxique de la phrase (fig. 6), mais on voit la différence au niveau de l’arbre des types (fig. 7b). Là où Gérard était traduit par un type e, tout le monde est traduit par un 〈〈e, t〉, t〉, c’est-à-dire qu’il prend le groupe verbal λx.aime(a)(x) en entrée et retourne une valeur de vérité (la réponse à la question : «tout le monde aime-t-il Alice ?»).\nQuelle va être la traduction de S ? Il est naturel de se servir du quantificateur universel pour écrire Trad(S) = ∀x (aime(a)(x)).\nSachant que GV se traduit par λx.aime(a)(x), quelle va être la traduction de PRN? Voici comment s’y prendre : posons P = λx.aime(a)(x), P est donc un prédicat unaire. S devient alors ∀x (P (x)), que l’on peut λ-abstraire en (λQ.(∀x (Q(x)))(P ), et on reconnaît ici une fonction de prédicat appliquée au prédicat P . Mais ce prédicat n’est autre que la traduction de GV, et on a donc trouvé une fonction qui, appliquée à GV, nous donne S : d’après le principe de compositionnalité, cela n’est rien d’autre que la traduction de PRN.\nOn remplace donc P par sa valeur et on a Trad(tout le monde) = λP.(∀x (P (x))), qui est bien de type 〈〈e, t〉, t〉."
    }, {
      "heading" : "5.5 L’article défini",
      "text" : "Que de plus simple dans la langue française que l’article défini «le, la, les» ? Et pourtant, sa traduction en LangLog sera pour nous un petit challenge ! Prenons la phrase le philosophe aime Alice (fig. 8). Notons tout de suite que philosophe ne peut être traduit par une constante, comme, par exemple, Gérard , puisque «être philosophe» est une propriété, et les propriétés sont traduites par des prédicats unaires. Ainsi, on écrira philosophe(g) pour dire que g est philosophe. De même, ∃x philosophe(x) signifie qu’il existe un philosophe. Et donc, si la phrase de départ était un philosophe aime Alice (avec un article indéfini), sa traduction en LangLog serait ∃x (philosophe(x) ∧ aime(a)(x)).\nD’où l’arbre de types de la phrase le philosophe aime Alice (fig. 9), où l’on affecte à philosophe le type 〈e, t〉 (le même que celui du verbe aime) et donc GN1 devient 〈〈e, t〉, t〉. Il ne nous reste\nd’autre choix pour le que de lui affecter le type 〈〈e, t〉, 〈〈e, t〉, t〉〉, autrement dit : il prend un 〈e, t〉 (philosophe) et ensuite un autre 〈e, t〉 (aime) et retourne une valeur de vérité.\nMais comment traduire alors l’article défini le ? Formulons la question autrement : comment indiquer qu’il n’y a qu’un seul philosophe, et que quand on dit le philosophe on parle justement de lui ? Pour répondre à cette question, rappelons-nous que dans la définition de la formule logique de 1er ordre (déf. 5, p. 4) nous avons mentionné la relation binaire = («égalité»). Mais qu’est-ce donc l’«égalité» ?\nC’est une vaste question philosophique dont on ne parle guère en cours de mathématiques... et pourtant, en logique du 1er ordre, l’«égalité» a un sens bien particulier, que voici : écrire a = b signifie que l’on demande que dans toute interprétation, les constantes (ou variables) a et b soient interprétées par le même élément de Monde.\nEt c’est ainsi qu’on traduit l’unicité : il n’y a qu’un seul philosophe x si et seulement si pour tout individu y tel que y soit philosophe, on ait x = y.\nLa phrase le philosophe aime Alice se traduira donc par ∃x (∀y (philosophe(y) ↔ x = y) ∧ aime(a)(x)).\nEn appliquant les mêmes méthodes de λ-abstraction que dans la section précédente, on trouve que la traduction de l’article défini le ne peut être que\nTrad(le) = λQ.(λP.(∃x (∀y (Q(y)↔ (x = y)) ∧ P (x)))).\nLe lecteur peut imaginer le désarroi de l’étudiant en linguistique qui, ayant raté le premier cours, se retrouve devant une formalisation de la langue naturelle qui traduit un des mots les plus simples de sa langue par cette horrible formule... Est-ce bien raisonnable ? En fait, nous n’avons fait que rendre visible l’important potentiel sémantique de ce petit mot grammatical — à première vue, insignifiant — qu’est l’article défini.\n6 L’ensemble Monde et la fonction d’interprétation Inter Jusqu’ici nous avons surtout parlé de Trad : LangNat→ LangLog. Il ne reste plus qu’à décrire plus précisément Monde, ainsi que la fonction Inter : LangLog →Monde. Pour cela, nous allons nous servir d’un autre outil mathématique, bien plus connu cette fois-ci : la théorie des ensembles.\nAinsi, si a = Trad(Alice) et g = Trad(Gérard) deviennent dans Monde la belle alice et le vilain gérard, que dire alors des autres sommets des arbres syntaxiques que nous avons étudiés ?\nLà aussi Montague a eu les bonnes idées ! D’après la définition de l’interprétation d’une formule (déf. 6), un prédicat unaire est interprété par une fonction Monde→ Z2, où Z2 est l’ensemble {vrai, faux}. Notons par ZMonde2 les fonctions de Monde dans Z2. Alors Inter(λx.P (x)) ∈ ZMonde2 , c’est-à-dire que l’interprétation d’un prédicat unaire de LangLog est un élément de ZMonde2 .\nCette propriété se généralise aux prédicats n-aires quelconques. En effet, il suffit de constater qu’un prédicat binaire devient une fonction qui à chaque élément de Monde associe un prédicat unaire. Donc Inter(λx.λy.P (x)(y)) ∈ ZMondeMonde2 , et ainsi de suite...\nCela semble abstrait, mais en réalité on ne fait que manipuler de simples relations binaires. Prenons un exemple : supposons que Monde = {alice,gérard,billy} (notés dans LangLog par a, g, b) et que l’on ait Inter(aime(a)(g)) = vrai et Inter(aime(a)(b)) = vrai. Que va être Inter(λy.aime(a)(y)) ? Ce sera un élément de ZMonde2 : l’ensemble de relations binaires φa = {(alice, faux), (gérard,vrai), (billy,vrai)} (puisque gérard et billy aiment alice, mais alice ne s’aime pas elle-même). Nous avons appelé φa cet ensemble de relations binaires puisqu’il s’agit de savoir qui aime alice. De la même manière, il existe φg et φb qui concernent gérard et billy.\nQue sera alors Inter(λx.λy.aime(x)(y)) ? Ce sera un élément de ZMonde Monde\n2 : un ensemble de relations binaires entre des éléments de Monde et des fonctions Monde→ Z2. Dans notre cas, ce sera tout simplement Φ = {(alice, φa), (gérard, φg), (billy, φb)}.\nSupposons que nous souhaitions savoir si Inter(aime(g)(a)) est vrai. Écrivons\nInter(aime(g)(a))\n= Inter((λx.λy.aime(x)(y))(g)(a))\n= Inter(λx.λy.aime(x)(y))(Inter(g))(Inter(a))\n= Φ(Inter(g))(Inter(a))\n= φg(Inter(a)) = faux,\ndonc, hélas, alice n’aime (toujours) pas gérard. On voit donc de quelle manière il est possible d’interpréter n’importe quelle formule de LangLog."
    }, {
      "heading" : "7 Et le reste...",
      "text" : "Cet article est déjà assez long. Jusqu’ici, nous avons parcouru et partiellement illustré une partie de la théorie de Montague. Le restant de sa théorie est tout aussi utile et intéressant, mais n’implique pas de nouvel outil mathématique ; nous allons donc nous contenter d’en décrire rapidement les grandes lignes."
    }, {
      "heading" : "7.1 Inférence",
      "text" : "Ce qui fait la force de la logique mathématique est le fait qu’à partir d’un ensemble de formules (que l’on considère vraies pour une interprétation donnée), on a des mécanismes (appelés règles d’inférence) pour obtenir de nouvelles formules (également vraies dans la même interprétation). On admet donc certaines formules en tant qu’axiomes et on en déduit d’autres, appelées théorèmes. C’est ainsi que fonctionnent les mathématiques : que ce soit en géométrie, en algèbre ou en analyse, on admet certains axiomes et on construit des théories en démontrant des théorèmes.\nUn exemple de règle d’inférence très utile est le modus ponens : si on a φ → ψ et φ alors on peut en déduire ψ (exemple : si on admet que tous les hommes sont mortels et que Socrate est un homme, alors on peut en déduire que Socrate est mortel).\nMontague introduit le mécanisme des règles d’inférence dans LangLog."
    }, {
      "heading" : "7.2 La temporalité",
      "text" : "Pour analyser des phrases comme Gérard n’aime plus Alice, Montague introduit la temporalité dans LangLog. Le temps y est représenté de deux manières : par des instants et par des intervalles\ntemporels. Il propose des opérateurs entre les intervalles : deux intervalles [t1, t2] et [t3, t4] peuvent se chevaucher (quand, par exemple, t1 < t3 < t2 < t4), être totalement disjoints (t2 < t3) ou s’imbriquer l’un dans l’autre (t1 < t2 < t3 < t4).\nChaque formule de LangLog est indexée temporellement : sa valeur de vérité dépend (outre les variables libres qu’elle contient) de ses propriétés temporelles."
    }, {
      "heading" : "7.3 Les mondes possibles/accessibles",
      "text" : "Pour analyser des phrases comme Gérard aime peut-être Alice, mais certainement pas Alexia, Montague introduit les notions de modalité et de mondes accessibles. Il propose deux opérateurs modaux : φ qui signifie «φ est nécessairement vraie», et φ qui signifie «φ est peut-être vraie».\nPour formaliser ces notions, il parle de «mondes accessibles» : en effet, on a toujours dit que Monde pouvait être un monde hypothétique quelconque, alors pourquoi ne pas en imaginer plusieurs, voire tous les mondes possibles et imaginables ? Mais comme cela est un peu éloigné de la réalité des problèmes que l’on peut se poser, il est plus raisonnable de parler de mondes «accessibles» : ce sont ceux qui constituent des alternatives plausibles à un monde donné. SiMonde et Monde′ sont des mondes, on peut imaginer une relation binaire Accessible(Monde,Monde′) qui signifie que Monde′ est accessible à partir de Monde.\nAlors la formule φ est «nécessairement vraie» ( φ) si elle est vraie dans tous les mondes accessibles à partir du monde courant, et elle est «peut-être» vraie ( φ), si elle est vraie dans certains de ces mondes."
    }, {
      "heading" : "7.4 Intensionnalité",
      "text" : "Définir un ensemble extensionnellement consiste à énumérer ses éléments, le définir intensionnellement consiste à en donner les propriétés. Ainsi, {p | p ≤ 10, p premier} est une définition intensionnelle et {2, 3, 5, 7} la définition sensationnelle du même ensemble.\nMontague se sert de l’intensionnalité pour englober en un seul objet mathématique les valeurs d’une expression dans tous les mondes accessibles. Ainsi, si aime(a)(g) est vrai dans les mondes Monde1, Monde2 et Monde4, et aime(a′)(g) est vrai dans les mondes Monde1, Monde2 et Monde3, alors ces deux formules ont la même valeur de vérité dans certains mondes mais pas dans tous. On dira que leurs intensions sont différentes.\nL’intension d’une formule est donc une fonction qui envoie différents mondes vers les valeurs de vérité correspondantes des formules. En comparant les intensions de deux formules, on compare leur «comportement» dans tous les mondes accessibles, c’est bien plus puissant que de les comparer dans un seul monde. Cette notion est tellement importante pour Montague que sa théorie est souvent appelée sémantique intensionnelle."
    }, {
      "heading" : "8 Conclusion",
      "text" : "Nous avons exploré les outils mathématiques qui ont servi à Montague et à ceux qui l’ont suivi pour modéliser la langue naturelle en tant que langage formel. Ce parcours nous a permis d’évoquer et de décrire brièvement les langages et grammaires formels, une version légèrement restreinte de la logique de 1er ordre, la théorie de types, le λ-calcul. Dans chaque cas nous avons tenté de justifier l’utilité de l’outil pour l’analyse de la langue naturelle, et de l’illustrer par des exemples.\nNotre but a été de faire découvrir au lecteur comment les mathématiques permettent d’étudier les liens entre la langue naturelle et le monde — liens qui nous affectent tous profondément puisque, comme disait Wittgestein :\n«die Grenzen meiner Sprache bedeuten die Grenzen meiner Welt» (= les limites de ma langue sont les limites de mon propre monde) [14, § 5.6]\nConseils de lecture Les langages et grammaires formels sont décrits avec beaucoup de rigueur dans [6]. La logique du 1er ordre est admirablement bien présentée par J.-P. Delahaye dans [7]. En ce qui concerne la sémantique de Montague, une présentation très accessible est donnée dans [9]. L’ouvrage [5] est un peu plus technique mais tout aussi abordable. Enfin, [10], tiré du Séminaire de philosophie et mathématiques de l’ENS (dirigé, excusez du peu, par J. Dieudonné et R. Thom), en donne une synthèse très efficace. Dans son exposé filmé «La modélisation mathématique des langues naturelles» de l’Université de tous les savoirs, S. Kahane parle de la sémantique de Montague [12, 30′24′′–34′45′′] avant d’enchaîner sur une de ses propres contributions : les grammaires à bulles [11].\nEnfin, en ce qui concerne la vie (et la mort) de Richard M. Montague, voir l’essai That’s just Semantics ! [1], ainsi que les romans [2], [3] et [8].\nRéférences [1] Sacha Arnold. That’s just Semantics ! en ligne : http://shar.es/StiAm [2] David Berlinski. Less than meets the eye. St. Martin’s Press, 1994. [3] Aifric Campbell. The Semantics of Murder. Serpent’s Tail, 2009. [4] Ronnie Cann. Formal Semantics, an Introduction. Cambridge Univ. Press, 1993. [5] Michel Chambreuil and Jean-Claude Pariente. Langue naturelle et logique. Peter Lang, 1990. [6] Patrick Dehornoy. Mathématiques de l’informatique. Dunod, 2000. [7] Jean-Paul Delahaye. Outils logiques pour l’intelligence artificielle. Eyrolles, 1988. [8] Samuel Delany. The mad man. Masquerade Books, 1996. [9] Michel Galmiche. Sémantique linguistique et logique. puf, 1991. [10] Paul Gochet. La sémantique récursive de Davidson et de Montague. In Penser les mathé-\nmatiques (Séminaire de philosophie et mathématiques de l’École normale supérieure), pages 73–87. Éditions du Seuil, 1982.\n[11] Sylvain Kahane. Extractions dans une grammaire de dépendance à bulles. TAL, 41 :187–216, 2000.\n[12] Sylvain Kahane. La modélisation mathématique des langues naturelles (vidéo). http://www.canal-u.tv/video/universite_de_tous_les_savoirs/la_modelisation_ mathematique_des_langues_naturelles.1315 2002.\n[13] Richard M. Montague. English as a formal language. In B. Visentini et al., editors, Linguaggi nella Società et nella Tecnica, pages 188–211. Edizioni di Comunità, 1970.\n[14] Ludwig Wittgenstein. Tractatus logico-philosophicus. Tel. Gallimard, 2001."
    } ],
    "references" : [ {
      "title" : "Less than meets the eye",
      "author" : [ "David Berlinski" ],
      "venue" : "St. Martin’s Press,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1994
    }, {
      "title" : "The Semantics of Murder",
      "author" : [ "Aifric Campbell" ],
      "venue" : "Serpent’s Tail,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Formal Semantics, an Introduction",
      "author" : [ "Ronnie Cann" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1993
    }, {
      "title" : "Outils logiques pour l’intelligence artificielle",
      "author" : [ "Jean-Paul Delahaye" ],
      "venue" : "Eyrolles,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1988
    }, {
      "title" : "The mad man",
      "author" : [ "Samuel Delany" ],
      "venue" : "Masquerade Books,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1996
    }, {
      "title" : "Sémantique linguistique et logique",
      "author" : [ "Michel Galmiche" ],
      "venue" : "puf,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1991
    }, {
      "title" : "Extractions dans une grammaire de dépendance",
      "author" : [ "Sylvain Kahane" ],
      "venue" : "à bulles. TAL,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2000
    }, {
      "title" : "La modélisation mathématique des langues naturelles (vidéo)",
      "author" : [ "Sylvain Kahane" ],
      "venue" : "http://www.canal-u.tv/video/universite_de_tous_les_savoirs/la_modelisation_ mathematique_des_langues_naturelles.1315",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2002
    }, {
      "title" : "English as a formal language",
      "author" : [ "Richard M. Montague" ],
      "venue" : "Edizioni di Comunità,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1970
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "Montague qui prétend que c’est tout à fait possible, à condition d’utiliser des outils mathématiques évolués, et il le démontre à travers trois articles (dont le premier, de 1970, s’intitule, de manière assez provocante, L’anglais en tant que langage formel [13]).",
      "startOffset" : 258,
      "endOffset" : 262
    }, {
      "referenceID" : 2,
      "context" : "Ce texte s’inspire fortement (tout en le simplifiant) de l’ouvrage [4].",
      "startOffset" : 67,
      "endOffset" : 70
    }, {
      "referenceID" : 1,
      "context" : "Et de manière tragique, au point où sa mort a inspiré un roman policier, la Sémantique du meurtre d’Aifric Campbell [3].",
      "startOffset" : 116,
      "endOffset" : 119
    }, {
      "referenceID" : 3,
      "context" : "Delahaye dans [7].",
      "startOffset" : 14,
      "endOffset" : 17
    }, {
      "referenceID" : 5,
      "context" : "En ce qui concerne la sémantique de Montague, une présentation très accessible est donnée dans [9].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 6,
      "context" : "Kahane parle de la sémantique de Montague [12, 30′24′′–34′45′′] avant d’enchaîner sur une de ses propres contributions : les grammaires à bulles [11].",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 0,
      "context" : "Montague, voir l’essai That’s just Semantics ! [1], ainsi que les romans [2], [3] et [8].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 1,
      "context" : "Montague, voir l’essai That’s just Semantics ! [1], ainsi que les romans [2], [3] et [8].",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 4,
      "context" : "Montague, voir l’essai That’s just Semantics ! [1], ainsi que les romans [2], [3] et [8].",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 0,
      "context" : "es/StiAm [2] David Berlinski.",
      "startOffset" : 9,
      "endOffset" : 12
    }, {
      "referenceID" : 1,
      "context" : "[3] Aifric Campbell.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[4] Ronnie Cann.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[7] Jean-Paul Delahaye.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[8] Samuel Delany.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[9] Michel Galmiche.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[11] Sylvain Kahane.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[12] Sylvain Kahane.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "[13] Richard M.",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2014,
    "abstractText" : "Nous présentons une méthode de modélisation de la langue naturelle qui est fortement basée sur les mathématiques. Cette méthode, appelée «sémantique formelle», a été initiée par le linguiste américain Richard M. Montague dans les années 1970. Elle utilise des outils mathématiques tels que les langages et grammaires formels, la logique du 1er ordre, la théorie de types et le λ-calcul. Nous nous proposons de faire découvrir au lecteur tant la sémantique formelle de Montague que les outils mathématiques dont il s’est servi.",
    "creator" : "LaTeX with hyperref package"
  }
}