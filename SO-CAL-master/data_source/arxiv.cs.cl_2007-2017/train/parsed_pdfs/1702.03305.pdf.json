{
  "name" : "1702.03305.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ "f.fancellu@sms.ed.ac.uk,", "siva.reddy@ed.ac.uk,", "bonnie}@inf.ed.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 2.\n03 30\n5v 1\n[ cs\n.C L\n] 1\n0 Fe\nb 20 17 D raft\nwould benefit from the ability to represent negation and its scope on top of widelyused linguistic resources. In this paper, we investigate the possibility of obtaining a first-order logic representation with negation scope marked using Universal Dependencies. To do so, we enhance UDepLambda, a framework that converts dependency graphs to logical forms. The resulting UDepLambda¬ is able to handle phenomena related to scope by means of an higher-order type theory, relevant not only to negation but also to universal quantification and other complex semantic phenomena. The initial conversion we did for English is promising, in that one can represent the scope of negation also in the presence of more complex phenomena such as universal quantifiers."
    }, {
      "heading" : "1 Introduction",
      "text" : "Amongst the different challenges around the topic of negation, detecting and representing its scope is one that has been extensively researched in different sub-fields of NLP (e.g. Information Extraction (Velldal et al., 2012; Fancellu et al., 2016)). In particular, recent work have acknowledged the value of representing the scope of negation on top of existing linguistic resources (e.g. AMR – Bos (2016)). Manually annotating the scope of negation is however a time-consuming process, requiring annotators to have some expertise of formal semantics.\nOur solution to this problem is to automatically convert an available representation that captures negation into a framework that allows a rich variety of semantic phenomena to be represented, in-\nMalta borders no country\nROOT\nNUSBJ NEG\nDOBJ\n(a) UD Dependency Tree\nλe.∃x∃y.borders(e) ∧ country(x) ∧ no(x)∧\nMalta(y) ∧ arg1(e, y) ∧ arg2(e, x)\n(b) UDepLambda Logical Form\n∀x.country(x) → ¬∃e∃y.borders(e)∧\nMalta(y) ∧ arg1(e, y) ∧ arg2(e, x)\n(c) Desired Logical Form\nFigure 1: The dependency tree for ‘Malta borders no country’ and its logical forms\ncluding scope. That is, given an input sentence, we show how its universal dependency (UD) parse can be converted into a representation in first-order logic (FOL) with lambda terms that captures both predicate–argument relations and scope.\nOur approach is based on UDepLambda\n(Reddy et al., 2017; Reddy et al., 2016), a constraint framework that converts dependency graphs into logical forms, by reducing the lambda expressions assigned to the dependency edges using the lambda expressions of the connected head and child nodes. The edge labels in the input UD graph are only edited minimally so to yield a more fine-grained description on the phenomena they describe, while lexical information is used only for a very restricted class of lexical items, such as negation cues. A FOL representation of the entire input graph can be then obtained by traversing the edges in a given order and combining their semantics.\nHowever, in its original formulation, UDe-\nD raft\npLambda does not handle either universal quantifiers or other scope phenomena. For example, the sentence ‘Malta borders no country’ has the UD graph shown in Figure 1(a). When compared to the correct representation given in Figure 1(c), the UDepLambda output shown in Figure 1(b) shows the absence of universal quantification, which in turn leads negation scope to be misrepresented.\nFor this reason, we set the foundation of UDepLambda¬ (UDepLambda-not), an enhanced version of the original framework, whose type theory allows us to jointly handle negation and universal quantification. Moreover, unlike its predecessor, the logical forms are based on the one used in the ‘Groeningen Meaning Bank’ (GMB; (Basile et al., 2012)), so to allow future comparison to a manually annotated semantic bank.\nAlthough the present work shows the conversion process for English, given that the edge labels are universal, our framework could be used to explore the problem of representing the scope of negation in the other 40+ languages universal dependencies are available in. This could also address the problem that all existing resources to represent negation scope as a logical form are limited to English (e.g. GMB and ‘DeepBank’ (Flickinger et al., 2012)) or only to a few other languages (e.g. ‘The Spanish Resource Grammar’ (Marimon, 2010)).\nIn the reminder of this paper, after introducing the formalism we will be working in (§2), we will work the theory behind some of the conversion rules, from basic verbal negation to some of the more complex phenomena related to negation scope, such as the determiner ‘no’(§3.1), the interaction between the negation operator and the universal classifier (§3.2) and non-adverbial or lexicalized negation cues such as ‘nobody’, ‘nothing’ and ‘nowhere’ (§3.3). Limitations, where present, will be highlighted.\nContribution. The main contribution of the paper is UDepLambda¬, a UD-to-FOL conversion framework, whose type theory is able to handle scope related phenomena, which we show here in the case of negation.\nFuture work. UDepLambda¬ can serve as a basis for further extensions that could apply to other complex semantic phenomena and be learned automatically, given the link to a manually annotated semantic bank."
    }, {
      "heading" : "NUSBJ",
      "text" : "2 UDepLambda¬\nWe introduce here the foundations of UDepLambda¬, an enhancement to the UDepLambda framework to convert a UD graph into its correspondent logical form. As its predecessor, the conversion takes place in four different steps: enhancement, binarization, substitution and composition. Whereas binarization and composition are the same as UDepLambda, substitution differs in:\n• using a higher order type-theory to deal with universal quantification, which can interact\nwith other scope operator such as negation;\n• using FOL expressions based on those used in the Groeningen Meaning Bank (GMB), so\nas to link to a manually–annotated semantic bank which can be leveraged for future work.1\nThe details of the four steps are as follows:\nEnhancement. In this step, we first convert a dependency tree to a dependency graph using existing existing enhancements in UDepLambda. The enhanced dependency labels are represented in red color. In future, we will replace this step with existing enhancements (Schuster and Manning, 2016).\nBinarization. The dependency graph is mapped to a LISP-style s-expression, where the order of the edge traversal is specified. For instance, the expression (nsubj (aux (neg eat not) does) John) indicates that the semantic representation of the sentence in Figure (2) is derived by composing the semantics of the edge nsubj with the logic form of ‘John’ and of the phrase ’does\n1The current study ignores certain aspects of Discourse Representation Theory (Kamp et al., 2011) on which the GMB is based, which are secondary to the issues we are focussed on.\nD raft\nnot eat’. The semantics of the phrase ‘does not eat’ is in turn derived by composing the edge aux with the phrase ‘not eat’ and the auxiliary ‘does’. Finally ‘not’ and ‘eat’ are composed along the edge neg.\nThe order of traversal follows an obliqueness hierarchy which defines a strict ordering of the modifiers of a given head traversed during composition. This hierarchy is reminiscent of bottom-up traversal in a binarized constituency tree (where for instance the direct object is always visited before the subject). Furthermore, for a head to be further composed, all its modifiers needs to be composed first. In the sentence in Figure (2), this hierarchy is defined as neg > aux > nusbj, where the semantics of the subject can be applied only when the other modifiers to the verb-head have been already composed.\nSubstitution. The substitution step assigns a lambda expression to each edge and vertex (i.e. word) in the graph. The lambda expressions of the edges are manually crafted to match the semantics of the edge labels while no assumption is made on the semantics of the word-vertices which are always introduced as existentially bound variables. This allows usnot to rely for most part on any language-specific lexical information. These expressions follows recent work on semantic compositionality of complex phenomena in event semantics (Champollion, 2011). In doing this, we generalize our type theory as follows:\n• Each word-vertex is assigned a semantic type 〈〈v, t〉, t〉 or 〈〈v, t〉, t〉 (here shortened in 〈vt, t〉), where v stands for either a paired variable of type Event × Individual. This is in contrast with the type assigned to words\nin the original UDepLambda 〈v, t〉. The result of this type-raising operation is clear when we compare the following lambda expressions:\nUDepLambda: λx.man(xa) UDepLambda¬: λf.∃x.man(xa) ∧ f(x)\nwhere the ‘handle’ f allows for complex types to be added inside another lambda expression. Following the GMB, proper nouns are treated like indefinite nouns, being linked to a existentially-bound variable (e.g. John := λf.∃x.named(xa, John, PER) ∧ f(x)).\n• Each edge is assigned the semantic type 〈〈vt, t〉, 〈〈vt, t〉, 〈vt, t〉〉〉 where we combine a generalized quantifier over the parent word\n(P) with the one over the child word (Q) to return another generalized quantifier (f). For instance, when reducing the sub-expression (nsubj eat John), we first reduce the parent vertex ‘eat’ (P) and then the child vertex ‘John’(Q) using the semantics of the subject (‘Actor’ in the GMB).\nnsubj:= λP.λQ.λf.P (λx.f(x) ∧Q(λy. Actor(xe, ya)))\nWhen compared to the original UDepLambda expression (of type 〈〈v, t〉, 〈〈v, t〉, 〈v, t〉〉〉):\nλf.λg.λx.∃y.f(xe) ∧ g(ya) ∧ arg1(xe, ya)\nunlike its predecessor, UDepLambda¬ allows for nested dependencies between parent and child node which is necessary to model scope phenomena.\n• In cases such as the sub-expression (neg ‘John does eat’ not), the edge label neg and\nthe word ‘not’ carry the exact same semantics (i.e. the negation operator ¬). For these functional words we try to define semantics on the dependency edges only rather than on the word. As shown below, reducing Q does not impact the semantic composition of the edge neg:\nneg:= λP.λQ.λf.¬P (λx.f(x))\nnot:= λf.TRUE\nComposition. The lambda expressions are reduced by following the traversal order decided during the binarization step. Let’s exemplify the composition step by showing at the same time how simple verbal negation composes semantically, where the input s-expression is (neg (aux (nsubj eat John) does) not). The substitution step assigns vertices and edges the following semantics:\n‘eat’ := λf.∃x.eat(xe) ∧ f(x) ‘not’ := λf.TRUE ‘John’ := λf.∃x.named(xa, John, PER)∧ f(x) ‘does’ := λf.TRUE\nnsubj:= λP.λQ.λf.P (λx.f(x) ∧Q(λy.Actor(xe, ya))) aux := λP.λQ.λf.P (λx.f(x)) neg:= λP.λQ.λf.¬P (λx.f(x)) ex-closure:= λx.TRUE\nwhere the subscripts e and a stands for the event-type and the individual-type existential variable respectively. As for the edge neg, the child of a aux edge is ignored because not contributing to the overall semantics of the sentence.2 We start by reducing (neg eat not), where P is the parent vertex ‘eat’ and Q the child vertex ‘not’. This yields the expression:3\nλf.¬∃x.eat(xe) ∧ f(x)\nWe then use this logic form to first reduce the lambda expression on the edge aux, which outputs the same input representation, and then compose this with the semantics of the edge nsubj. The final representation of the sentence (after we apply existential closure) is as follows:\n¬∃x.∃y.eat(xe) ∧ named(ya, John, PER) ∧ Actor(xe, ya)\nGiven the resulting logical form we consider as part of negation scope all the material under the negation operator ¬."
    }, {
      "heading" : "3 Analysis of negative constructions",
      "text" : ""
    }, {
      "heading" : "3.1 The quantifier ‘no’",
      "text" : "Let’s consider the sentence ‘No man came’ along with its dependency trees and logical form, shown in Figure 3.\nAs shown in Figure 3(b), one shortcoming of the original UDepLambda is that it doesn’t cover universal quantification. However, even if we were to assign any of the following lambda expressions containing material implication to the neg edge connecting parent-λf (‘man’) and child-λg (‘no’):\n?λf.λg.λx.f(x) → ¬f(x) ?λf.λg.λx.f(x) → g(x)\nthe resulting expressions would have no means of later accommodating the event ‘came’ in the consequent of the material implication:\n*λx.man(x) → ¬man(x) *λx.man(x) → no(x)\n2The present work does not consider the semantics of time the word ‘does’ might contribute to.\n3Step-by-step derivations are shown in Appendix A.\nThe higher-order type theory of UDepLambda¬ solves this problem by ensuring that a) there is a universal quantified variable along with material implication and b) the entity bound to it (man(x)) is introduced only in the antecedent, whereas the negated event (along with other arguments) only in the consequent. The lambda expression assigned to the neg edge is the following\nλP.λQ.λf.∀x.(P (λy.EQ(x, y)) → ¬f(x))\nwhere f allows to leave a ‘handle’ for the event ‘came’ to be further composed in the subsequent only, whereas the two-place function EQ(x,y) as argument of P binds the word in the parent node with the universally quantified variable x. It is worth mentioning at this point that although the universal quantifier ‘no’ is parsed as depending from an edge neg, it possesses a semantics that distinguishes it from other negative adverbs such as ‘not’ or ‘never’, in the fact that they bind their head to a universally quantifiable\nD raft\nvariable. In these cases we also enhance the label on the dependency edge to reflect this more fine-grained distinction. In the presence of ‘no’ the neg edge becomes neg:univ if its child vertex is a universal quantifier. This edit operation relies on having a list of lexical items for both universal quantifiers and negation cues in a language, which is easily obtainable given that these items form a small, closed class.\nA further edit operation is needed to make sure that the quantifier always outscopes the negation operator; to do so, we modify the semantics of the edge that connects the head of the edge neg:univ (‘man’) with its parent (‘came’), nsubj, by inverting the order of the Q and P, so that the former outscopes the latter. We call this enhanced edge an ‘edge-name:inv.’ edge. Compared to nsubj, the semantics of nsubj:inv would be as follows:\nnsubj :=\nλP.λQ.λf.P (λx.f(x) ∧Q(λy.Actor(xe, ya))) nsubj-inv := λP.λQ.λf.Q(λy.P (λx.Actor(xe, ya) ∧ f(x)))\nUsing the edited input UD graph, the hierarchy we follow during composition is neg:univ > nsubj:inv to yield the s-expression (nsubj:inv (neg:univ no man) came). Given the following input semantics:\nman:= λf.∃x.man(xa) ∧ f(x) came:= λf.∃x.came(xe) ∧ f(x)\nneg:univ:=\nλP.λQ.λf.∀x.(P (λy.EQ(x, y)) → ¬f(x)) nsubj:inv :=\nλP.λQ.λf.Q(λy.P (λx.Actor(xe, ya) ∧ f(x)))\nwe first reduce the lambda expression on the edge neg:univ. to yield the expression λf.∀x.(man(xa) → ¬f(x)) and then combine it along the edge nsubj:inv to yield the following representation:\n∀y.(man(ya) → ¬∃x.came(xe)∧Actor(xe, ya))\n, where the scope of negation is correctly converted as inside the universal quantifier.\nInverting the order of the parent and child nodes in the semantics of the :inv. edge always allows to represent the universally quantified element as outscoping the event it depends on. At the same time, all other arguments and modifiers of the parent event will always compose inside the consequent. This applies to our initial example in Figure 1, where composing the s-expression (dobj:inv. borders ‘no country’) to yield the expression:\nλf.∀y.(country(ya) → ¬∃x.borders(xe) ∧ Theme(xe, ya) ∧ f(x))\n, makes sure that further material can only be added in place of f(e), which is inside the scope of ¬, in turn in the scope of ∀. So when composing the semantics of the subject ‘Malta’ (:= λf.∃x.named(xa,Malta,ORG)∧ f(x)), the universal will still have wide-scope, as shown below:\n∀y.(country(ya) → ¬∃x.∃z.named(za,Malta, PER) ∧\nborders(xez) ∧ Theme(xe, ya)∧Actor(xe, za))"
    }, {
      "heading" : "3.2 Negation and universal quantifier",
      "text" : "Alongside quantifiers inherently expressing negation, as the one shown in the previous section, another challenging scope representation arises during the interaction between a negation cue and a non-negative universal quantifier, such ‘every’. Let’s take as example the sentences ‘Not every man came’, shown in Figure 4 alongside its FOL representation.\nIf compared to the representation of the\nsentence ‘No man came’, where the universal quantifier outscopes the negation operator, the construction ‘not every’ yields the opposite interaction where the quantifier is in the scope of ¬ (correspondent to the meaning ‘there exists some man who came’).\nAs shown in the previous section and here in Figure 4(b), UDepLambda cannot deal with such constructions, yielding a meaning where there exists and event but there doesn’t exists the entity that performs it. On the other hand, UDepLambda¬ can easily derive the correct representation by applying the same edits to the UD graph shown in the previous section. First, we enhance the det edge to become a more finegrained det:univ in the presence of the child node ‘every’. Second, we change nsubj into nsubj-inv., since a universal quantifier is in its yield. The lambda expression assigned to the edge det:univ is as follows:\ndet:univ:=λP.λQ.λf.∀x.(P (λy.EQ(x, y)) → f(x))\nOnce again, we deploy the usual bottomup binarization hierarchy where all modifiers of a head need to be composed before the head itself can be used for further composition. In the case of ‘not every...’, we start from the modifiers ‘every’\nD raft\nand ‘not’ and compose the edges following the order det:univ 〉 neg so to make sure that negation operator ¬ outscopes the universal quantifier ∀. After the modifiers of the head ‘man’ are composed, we can then move on to compose the head itself with its governor node, the event ‘came’. The nsubj:inv. edge ensures that the subject scopes over the event and not the other way around. Following this, we are able to obtain the final representation:\n¬∀y.(man(ya) → ∃x.came(xe)∧Actor(xe, ya))"
    }, {
      "heading" : "3.3 Nobody/nothing/nowhere",
      "text" : "As shown in Table 1, ‘nobody’, ‘nothing’ and ‘nowhere’ belong to that class of negation cues whose parent edge do not mark them as inherently expressing negation. However using an handcrafted list of negation cues for English, we can detect and assign them the semantic representation λf.¬∃x.thing/person/location(xa)∧f(x), where the negation operator scopes over an existentially bound entity.\nBinarization and composition vary according to\nwhether these elements are arguments or adjuncts. If an argument, the scope of negation includes also the event, otherwise the latter is excluded. To this end, let’s compare the sentences ‘Nobody came’ and ‘John came with nothing’, along with their dependency graphs and logic forms (Figure 5).\nThe argument ‘nobody’ in ‘Nobody came’\nyields a scope reading where the negation operator scopes over the existential. To achieve such reading we once again convert the nsubj (or any argument edge for that matter) into a nsubj:inv. edge. This is reminiscent of how we handled universal quantification when we introduced the quantifier ‘no’, which is in fact integral part of such lexical elements (the semantics of ‘no-body came’ can be in fact read as ‘for all x such that x is a person that x did not come’). Also, the fact that the semantics of these elements is represented through an existential and not a universal bound variable is no problem since we are working under the equivalence ∀x.P (x) → ¬Q(x) ≡ ¬∃x.P (x) ∧Q(x). Given the s-expression (nsubj:inv. came nobody) the composition is then as follows:\n¬∃x.∃y.person(ya) ∧ f(x) ∧Actor(xe, ya) ∧ came(xe)\nOn the other hand, when the negated lexical element is embedded in an adjunct, as in ‘with nothing’, no enhancement of the original dependency edges takes place since we want to preserve negation scope inside the phrase (so to yield a reading where the event ‘John came’ did indeed take place). By substituting and combining the semantics of the s-expression (nmod:with came nothing), where the edge nmod:with is assigned the lambda expression λP.λQ.λf.P (λx.f(x) ∧\nD raft\nQ(λy.with(xe, ya))), we obtain the following logic form:\nλf.∃x.came(xe) ∧ f(x) ∧ ¬∃y.(thing(ya) ∧ with(xe, ya))\n, where we can the scope of negation is limited to the propositional phrase. Given that the f is outside the scope of negation, further compositions (in the case along the edge nsubj.) will also compose outside it, yielding the correct form in Figure (5).\nThe only limitation we have observed so far concerns ‘nowhere’ (:= λf.∃x.location(xa) ∧ f(x)) and the fact it is always associated with a dependency tag advmod. The tag advmod describes however the manner an action is carried out and has the logical form λP.λQ.λf.P (λx.f(x) ∧ Q(λy.Manner(xe, ya))). This is however different from how ‘nowhere’ is treated in the Groeningen Meaning Bank, where it is described as where and not how the event takes place. That is, our framework would assign a sentence like ‘They got nowhere near the money’ the logical form ∃x.got(xe) ∧ ¬∃y.(location(ya) ∧ Manner(xe, ya)), whereas the one contained in the GMB is: ∃x.got(xe) ∧ ¬∃ya.(location(ya) ∧ in(xe, ya))"
    }, {
      "heading" : "4 Conclusion and future work",
      "text" : "This paper addressed the problem of representing negation scope from universal dependencies by setting the foundations of UDepLambda¬, a conversion framework whose high-order type theory is able to deal with complex semantic phenomena related to scope. The conversion processes we presented show that it is possible to rely on dependency edges and additionally to minimal language-dependent lexical information to compose the semantics of negation scope. The fact that this formalism is able to correctly compose the scope for many complex phenomena related to negation scope is promising.\nWe are currently working on extending this\nwork in two directions: 1. Automatic framework evaluation: given the conversion rules presented in this paper, we are planning to automatically convert the UD graphs for the sentences in the GMB so to compare the graph we automatically generate with a goldstandard representation. This would also to identify and quantify the errors of our framework. 2. Automatic semantic parsing: given the connection between this framework and the GMB, we would like to explore the possibility of learning the conversion automatically, so not to rely on an hand-crafted hierarchy to decide the order of edge traversal."
    }, {
      "heading" : "A Step-by-step λ-reductions",
      "text" : "*Throughout the derivations, we are going to use the variable e in place of xe and z,y or x in place of xa. Due to space restrictions, we skip reduction for existential closure (→ex−clos)."
    }, {
      "heading" : "A.1 ‘John does not eat’",
      "text" : "λP.λQ.λf.P (λe.f(e) ∧Q(λx.Actor(e, x)))(λf.∃e.eat(e) ∧ f(e)) →α λP.λQ.λf.P (λe.f(e) ∧Q(λx.Actor(e, x)))(λg.∃e\n′ .eat(e′) ∧ g(e′)) →β λQ.λf.λg.[∃e\n′.eat(e′) ∧ g(e′)](λe.f(e) ∧Q(λx.Actor(e, x))) →β λQ.λf.∃e\n′.eat(e′) ∧ λe.[f(e) ∧Q(λx.Actor(e, x))](e′) →β λQ.λf.∃e\n′.eat(e′) ∧ f(e′) ∧Q(λx.Actor(e′, x)) →β λQ.λf.∃e\n′.eat(e′) ∧ f(e′) ∧Q[λx.Actor(e′, x)](λf.∃x.named(x, John, PER) ∧ f(x)) →α λQ.λf.∃e\n′.eat(e′) ∧ f(e′) ∧Q[λx.Actor(e′, x)](λg.∃z.named(z, John, PER) ∧ g(z)) →β λf.∃e\n′.eat(e′) ∧ f(e′) ∧ λg.[∃z.named(z, John, PER) ∧ g(z)](λx.Actor(e′, x)) →β λf.∃e\n′.eat(e′) ∧ f(e′) ∧ ∃z.named(z, John, PER) ∧ λx.[Actor(e′, x)](z) →β λf.∃e ′.eat(e′) ∧ f(e′) ∧ ∃z.named(z, John, PER) ∧Actor(e′, z)\nλP.λQ.λf.¬P (λe.f(e))(λf.∃e′.∃z.eat(e′) ∧ f(e′) ∧ named(z, John, PER) ∧Actor(e′, z)) →α λP.λQ.λf.¬P (λe.f(e))(λg.∃e\n′.∃z.eat(e′) ∧ g(e′) ∧ named(z, John, PER) ∧Actor(e′, z)) →β λQ.λf.¬λg.[∃e\n′.∃z.eat(e′) ∧ g(e′) ∧ named(z, John, PER) ∧Actor(e′, z)](λe.f(e)) →β λQ.λf.¬∃e\n′.∃z.eat(e′) ∧ λe.[f(e)](e′) ∧ named(z, John, PER) ∧Actor(e′, z) →β λQ.λf.¬∃e\n′.∃z.eat(e′) ∧ f(e′) ∧ named(z, John, PER) ∧Actor(e′, z) →β λf.¬∃e\n′.∃z.eat(e′) ∧ f(e′) ∧ named(z, John, PER) ∧Actor(e′, z) →β λf.[¬∃e\n′.∃z.eat(e′) ∧ named(z, John, PER) ∧Actor(e′, z) ∧ f(e′)](λx.TRUE) →β ¬∃e\n′.∃z.eat(e′) ∧ named(z, John, PER) ∧Actor(e′, z) ∧ λx.[TRUE](e′) →β ¬∃e ′.∃z.eat(e′) ∧ named(z,John,PER) ∧Actor(e′, z)"
    }, {
      "heading" : "A.2 ‘No man came’",
      "text" : "λP.λQ.λf.∀x.(P (λy.EQ(x, y)) → ¬f(x))(λf.∃x.man(x) ∧ f(x)) →α λP.λQ.λf.∀x.(P (λy.EQ(x, y)) → ¬f(x))(λf\n′.∃z.man(z) ∧ f ′(z)) →β λQ.λf.∀x.(λf\n′.[∃z.man(z) ∧ f ′(z)](λy.EQ(x, y)) → ¬f(x)) →β λQ.λf.∀x.(∃z.man(z) ∧ λy.[EQ(x, y)](z) → ¬f(x)) →β λQ.λf.∀x.(∃z.man(z) ∧ EQ(x, z) → ¬f(x)) →EQ λQ.λf.∀x.(man(x) → ¬f(x)) →β λf.∀x.(man(x) → ¬f(x))\nλP.λQ.λf.Q(λx.P (λe.Actor(e, x) ∧ f(e)))(λf.∃e.came(e) ∧ f(e)) →α λP.λQ.λf.Q(λx.P (λe.Actor(e, x) ∧ f(e)))(λg.∃e\n′.came(e′) ∧ g(e′)) →β λQ.λf.Q(λx.λg.[∃e\n′.came(e′) ∧ g(e′))](λe.Actor(e, x) ∧ f(e))) →β λQ.λf.Q(λx.∃e\n′.came(e′) ∧ λe.[Actor(e, x) ∧ f(e)](e′)) →β λQ.λf.Q(λx.∃e\n′.came(e′) ∧Actor(e′, x) ∧ f(e′)) →α λQ.λf.Q(λx.∃e\n′.came(e′) ∧Actor(e′, x) ∧ f(e′))(λf ′.∀x′.(man(x′) → ¬f ′(x′)) →β λf.λf\n′.[∀x′.(man(x′) → ¬f ′(x′))](λx.∃e′.came(e′) ∧Actor(e′, x) ∧ f(e′)) →β λf.∀x\n′.(man(x′) → ¬λx.[∃e′.came(e′) ∧Actor(e′, x) ∧ f(e′)](x′)) →β λf.∀x\n′.(man(x′) → ¬∃e′.came(e′) ∧Actor(e′, x′) ∧ f(e′)) →ex−clos. ∀x ′.(man(x′) → ¬∃e′.came(e′) ∧Actor(e′,x′))"
    }, {
      "heading" : "A.3 ‘Not every man came’",
      "text" : "→∀ λf.∀x.(man(x) → f(x)) →¬ λf.¬∀z.(man(z) → f(z))\nλP.λQ.λf.Q(λx.P (λe.Actor(e, x) ∧ f(e)))(λf.∃e.came(e) ∧ f(e))\nD raft\n→α λP.λQ.λf.Q(λx.P (λe.Actor(e, x) ∧ f(e)))(λg.∃e ′.came(e′) ∧ g(e′)) →β λQ.λf.Q(λx.λg.[∃e ′.came(e′) ∧ g(e′))](λe.Actor(e, x) ∧ f(e))) →β λQ.λf.Q(λx.∃e ′.came(e′) ∧ λe.[Actor(e, x) ∧ f(e)](e′)) →β λQ.λf.Q(λx.∃e ′.came(e′) ∧Actor(e′, x) ∧ f(e′))\nλQ.λf.Q(λx.∃e′.came(e′) ∧Actor(e′, x) ∧ f(e′))(λf.¬∀z.(man(z) → f(z)) →α λQ.λf.Q(λx.∃e\n′.came(e′) ∧Actor(e′, x) ∧ f(e′))(λf ′.¬∀z.(man(z) → f ′(z)) →β λf.λf\n′.[¬∀z.(man(z) → f ′(z))](λx.∃e′.came(e′) ∧Actor(e′, x) ∧ f(e′)) →β λf.¬∀z.(man(z) → λx.[∃e\n′.came(e′) ∧Actor(e′, x) ∧ f(e′)](z)) →β λf.¬∀z.(man(z) → ∃e\n′.came(e′) ∧Actor(e′, z) ∧ f(e′)) →ex−clos. ¬∀z.(man(z) → ∃e ′.came(e′) ∧Actor(e′, z))"
    }, {
      "heading" : "A.4 ‘Nobody came’",
      "text" : "λP.λQ.λf.Q(λx.P (λe.f(e) ∧Actor(e, x)))(λf.∃e.f(e) ∧ came(e)) →α λP.λQ.λf.Q(λx.P (λe.f(e) ∧Actor(e, x)))(λg.∃e\n′ .g(e′) ∧ came(e′)) →β λQ.λf.Q(λx.λg.[∃e\n′.g(e′) ∧ came(e′)](λe.f(e) ∧Actor(e, x))) →β λQ.λf.Q(λx.∃e\n′.λe.[f(e) ∧Actor(e, x)](e′) ∧ came(e′)) →β λQ.λf.Q(λx.∃e ′.f(e′) ∧Actor(e′, x) ∧ came(e′))\nλQ.λf.Q(λx.∃e′.f(e′) ∧Actor(e′, x) ∧ came(e′))(λf.¬∃x.person(x) ∧ f(x)) →α λQ.λf.Q(λx.∃e\n′.f(e′) ∧Actor(e′, x) ∧ came(e′))(λg.¬∃z.person(z) ∧ g(z)) →β λf.λg.[¬∃z.person(z) ∧ g(z)](λx.∃e\n′.f(e′) ∧Actor(e′, x) ∧ came(e′)) →β λf.¬∃z.person(z) ∧ λx.[∃e\n′.f(e′) ∧Actor(e′, x) ∧ came(e′)](z) →β λf.¬∃z.∃e\n′.person(z) ∧ f(e′) ∧Actor(e′, z) ∧ came(e′) →ex−clos. ¬∃z.∃e ′.person(z) ∧Actor(e′, z) ∧ came(e′)"
    }, {
      "heading" : "A.5 ‘John came with nothing’",
      "text" : "λP.λQ.λf.P (λe.f(e) ∧Q(λx.with(e, x)))(λf.∃e.came(e) ∧ f(e)) →α λP.λQ.λf.P (λe.f(e) ∧Q(λx.with(e, x)))(λg.∃e\n′ .came(e′) ∧ g(e′)) →β λQ.λf.λg.[∃e\n′.came(e′) ∧ g(e′)](λe.f(e) ∧Q(λx.with(e, x))) →β λQ.λf.∃e\n′.came(e′) ∧ f(e′) ∧ λe.[Q(λx.with(e, x))](e′) →β λQ.λf.∃e\n′.came(e′) ∧ f(e′) ∧Q(λx.with(e′, x)) →β λQ.λf.∃e\n′.came(e′) ∧ f(e′) ∧Q[λx.with(e′, x)](λf.¬∃x.thing(x) ∧ f(x)) →α λQ.λf.∃e\n′.came(e′) ∧ f(e′) ∧Q[λx.with(e′, x)](λg.¬∃z.thing(z) ∧ g(z)) →β λf.∃e\n′.came(e′) ∧ f(e′) ∧ λg.[¬∃z.thing(z) ∧ g(z)](λx.with(e′ , x)) →β λf.∃e\n′.came(e′) ∧ f(e′) ∧ ¬∃z.thing(z) ∧ λx.[with(e′, x)](z) →β λf.∃e ′.came(e′) ∧ f(e′) ∧ ¬∃z.thing(z) ∧ with(e′, z)\nλP.λQ.λf.P (λe.f(e) ∧Q(λx.Actor(e, x)))(λf.∃e′.came(e′) ∧ f(e′) ∧ ¬∃z.thing(z) ∧ with(e′, z)) →α λP.λQ.λf.P (λe.f(e)∧Q(λx.Actor(e, x)))(λg.∃e\n′.came(e′)∧g(e′)∧¬∃z.thing(z)∧with(e′, z)) →β λQ.λf.λg.[∃e\n′.came(e′) ∧ g(e′) ∧ ¬∃z.thing(z) ∧ with(e′, z)](λe.f(e) ∧Q(λx.Actor(e, x))) →β λQ.λf.∃e\n′.came(e′) ∧ λe.[f(e) ∧Q(λx.Actor(e, x))](e′) ∧ ¬∃z.thing(z) ∧ with(e′, z) →β λQ.[λf.∃e\n′.came(e′) ∧ f(e′) ∧Q(λx.Actor(e′, x)) ∧ ¬∃z.thing(z) ∧ with(e′, z)] (λg.∃y.named(y, John, PER) ∧ g(y)) →β λf.∃e\n′.came(e′) ∧ f(e′) ∧ λg.[∃y.named(y, John, PER) ∧ g(y)](λx.Actor(e′, x)) ∧ ¬∃z.thing(z) ∧with(e′, z)] →β λf.∃e\n′.came(e′) ∧ f(e′) ∧ ∃y.named(y, John, PER) ∧ λx.[Actor(e′, x)](y) ∧ ¬∃z.thing(z) ∧ with(e′, z) →β λf.∃e\n′.came(e′)∧∃y.named(y, John, PER)∧f(e′)∧Actor(e′, y)∧¬∃z.thing(z)∧with(e′ , z) →ex−clos. ∃e ′.∃y.came(e′) ∧ named(y,John,PER) ∧Actor(e′,y) ∧ ¬∃z.thing(z) ∧with(e′, z)"
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Many language technology applications would benefit from the ability to represent negation and its scope on top of widelyused linguistic resources. In this paper, we investigate the possibility of obtaining a first-order logic representation with negation scope marked using Universal Dependencies. To do so, we enhance UDepLambda, a framework that converts dependency graphs to logical forms. The resulting UDepLambda¬ is able to handle phenomena related to scope by means of an higher-order type theory, relevant not only to negation but also to universal quantification and other complex semantic phenomena. The initial conversion we did for English is promising, in that one can represent the scope of negation also in the presence of more complex phenomena such as universal quantifiers.",
    "creator" : "dvips(k) 5.996 Copyright 2016 Radical Eye Software"
  }
}