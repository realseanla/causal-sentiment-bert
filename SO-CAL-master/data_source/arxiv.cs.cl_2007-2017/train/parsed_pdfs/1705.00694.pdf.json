{
  "name" : "1705.00694.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Polynomial-Time Algorithm for the Lambek Calculus with Brackets of Bounded Order",
    "authors" : [ "Max Kanovich", "Stepan Kuznetsov", "Glyn Morrill", "Andre Scedrov" ],
    "emails" : [ "m.kanovich@qmul.ac.uk", "sk@mi.ras.ru", "morrill@cs.upc.edu", "scedrov@math.upenn.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Digital Object Identifier 10.4230/LIPIcs...\n1 Introduction\nThe calculus L of Lambek [20] is a logic of strings. It is retrospectively recognisable as the multiplicative fragment of non-commutative intuitionistic linear logic without empty antecedents; the calculus L∗ is like L except that it admits empty antecedents. The Lambek calculus is the foundation of categorial grammar, a linguistic paradigm of grammar as logic and parsing as deduction; see for instance Buszkowski [4], Carpenter [5], Jäger [14], Morrill [24], Moot and Retoré [22]. For example, the sentence “John knows Mary likes Bill” can be analysed as grammatical because N, (N \\S) / S,N, (N \\S) /N,N → S is a theorem of Lambek calculus. Here N stands for noun phrase, S stands for sentence, and syntactic categories for other words are built from these two primitive ones using division operations. For example, (N \\S) /N takes noun phrases on both sides and yields a sentence, thus being the category of transitive verb.\nCategorial grammar, that started from works of Ajdukiewicz [2] and Bar-Hillel [3], aspires to practice linguistics to the standards of mathematical logic; for example, Lambek [20] proves cut-elimination, that yields the subformula property, decidability, the finite reading property, and the focalisation property. In a remarkable series of works Mati Pentus has proved the main metatheoretical results for Lambek calculus: equivalence to context-free grammars [27], completeness w.r.t. language models [28][29], NP-completeness [30]; a polynomial-time algorithm for checking provability of formulae of bounded order in L∗ [31]. The Lambek\nlicensed under Creative Commons License CC-BY Leibniz International Proceedings in Informatics Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany\nar X\niv :1\n70 5.\n00 69\n4v 1\n[ cs\n.L O\n] 1\nM ay\ncalculus with only one division operation (and without product) is decidable in polynomial time (Savateev [32]).\nThe Lambek calculus with brackets Lb (Morrill 1992 [23]; Moortgat 1995 [21]) is a logic of bracketed strings which is a conservative extension of Lambek calculus with bracket modalities the rules for which are conditioned on metasyntactic brackets. In this paper we consider a variant of Lb that allows empty antecedents, denoted by Lb∗.\nThe syntax of Lb∗ is more involved than the syntax of the original Lambek calculus. In L, the antecedent (left-hand side) of a sequent is just a linearly ordered sequence of formulae. In Lb∗, it is a structure called configuration, or meta-formula. Meta-formulae are built from formulae, or types, as they are called in categorial grammar, using two metasyntactic constructors: comma and brackets. The succedent (right-hand side) of a sequent is one type. Types, in their turn, are built from variables, or primitive types, p1, p2, . . . , using three binary connectives of Lambek, \\, /, and ·, and two unary ones, 〈〉 and []−1, that operate brackets. Axioms of Lb∗ are pi → pi, and the rules are as follows:\nΠ→ A ∆(B)→ C ∆(Π, A \\B)→ C (\\ →) A,Π→ B Π→ A \\B (→ \\) Γ(A,B)→ C Γ(A ·B)→ C (· →)\nΠ→ A ∆(B)→ C ∆(B /A,Π)→ C (/→) Π, A→ B Π→ B /A (→ /) Γ→ A ∆→ B Γ,∆→ A ·B (→ ·)\n∆([A])→ C ∆(〈〉A)→ C (〈〉 →) Π→ A [Π]→ 〈〉A (→ 〈〉) ∆(A)→ C ∆([[]−1A])→ C ([]−1 →) [Π]→ A Π→ []−1A (→ []−1)\nCut-elimination is proved in Moortgat [21]. The Lambek calculus with brackets permits the characterisation of syntactic domains in addition to word order. By way of linguistic example, consider how a relative pronoun type assignment (CN \\CN ) /(S /N) (here CN is one primitive type, corresponding to common noun: e.g., “book”, as opposed to noun phrase “the book”) allows unbounded relativisation by associative assembly of the body of relative clauses:\n(a) man who Mary likes (b) man who John knows Mary likes (c) man who Mary knows John knows Mary likes . . .\nThus, (b) is generated because the following is a theorem in the pure Lambek calculus:\nCN , (CN \\CN ) /(S /N), N, (N \\S) / S,N, (N \\S) /N → CN\nConsider, however, the following example: *book which John laughed without reading, where * indicates that this example is not grammatical. In the original Lambek calculus this ungrammatical example is generated, but in Lambek calculus with brackets its ungrammaticality can be characterised by assigning the adverbial preposition a type []−1((N \\S) \\(N \\S)) /(N \\S) blocking this phrase because the following is not a theorem in Lambek calculus with brackets:\nCN , (CN \\CN ) /(S /N), N,N \\S, [[]−1((N \\S) \\(N \\S)) /(N \\S), (N \\S) /N ]→ CN\nwhere the []−1 engenders brackets which block the associative assembly of the body of the relative clause. Another example of islands is provided by the “and” (“or”) construction: *girl whom John loves Mary and Pete loves. Also, non-associative Lambek calculus can be embedded into the Lambek calculus with brackets (Kurtonina [16]).\nJäger [13] claims to prove the context free equivalence of Lb grammar on the basis of a translation from Lb to L due to Michael Moortgat’s student Koen Versmissen [33]. However, contrary to Versmissen the translation is not an embedding translation (Fadda and Morrill [8],\np. 124). We present the counter-example in the end of Section 3. Consequently the result of Jäger is in doubt: the context free equivalence theorem might be correct, but the proof of Jäger, resting on the Versmissen translation, is not correct.\nPentus [31] presents an algorithm for provability in L∗ based on tabularisation (memoisation) of proof nets. This algorithm runs in polynomial time, if the order of the sequent is bounded. An algorithm of the same kind was also developed by Fowler [9][10]. For the unbounded case, derivability problem for L∗ is in the NP class and is NP-complete [30]. In this paper we provide a Pentus-style algorithm for Lb∗ provability using (1) the proof nets for Lambek calculus with brackets of Fadda and Morrill [8] which are based on a correction of the Versmissen translation, and (2) an automata-theoretic argument. Again, for the unbounded case, Lb∗ is NP-hard (since it contains L∗ as a conservative fragment), and also belongs to the NP class, since the size of a cut-free derivation in Lb∗ is linearly bounded by the size of the goal sequent.\nThe rest of this paper is organised as follows. In Section 2 we define complexity parameters and formulate the main result. Section 3 contains the formulation and proof of a graphtheoretic provability criterion for Lb∗, known as proof nets. In Section 4 we introduce some more convenient complexity parameters and show their polynomial equivalence to the old ones. Section 5 is the central one, containing the description of our algorithm. In order to make this paper self-contained, in Section 6 we give a detailed explanation of Pentus’ construction [31], since it is crucial for our algorithm to work. Finally, in Section 7 we discuss directions of future research in this field.\n2 The Main Result\nFor a sequent Γ→ C we consider the following three complexity parameters. The first one is the size of the sequent, ||Γ → C||, counted as the total number of variables and logical symbols in it, including brackets.\nI Definition 1. The size of a formula, meta-formula, or sequent in Lb∗ is defined recursively as follows: ||pi|| = 0; ||A ·B|| = ||A \\B|| = ||B /A|| = ||A||+ ||B||+ 1; ||〈〉A|| = ||[]−1A|| = ||A||+ 1; ||Λ|| = 0; ||Γ,∆|| = ||Γ||+ ||∆||; ||[Γ]|| = ||Γ||+ 2; ||Γ→ C|| = ||Γ||+ ||C||.\nThe second parameter is the order.\nI Definition 2. For any formula A let prod(A) be 1 if A is of the form A1 ·A2 or 〈〉A1, and 0 if not. The order of a formula, meta-formula, or sequent in Lb∗ is defined recursively as follows: ord(pi) = 0; ord(A · B) = max{ord(A), ord(B)}; ord(A \\B) = ord(B /A) = max{ord(A) + 1, ord(B)+prod(B)}; ord(〈〉A) = ord(A); ord([]−1A) = max{ord(A)+prod(A), 1}; ord(Λ) = 0; ord(Γ,∆) = max{ord(Γ), ord(∆)}; ord([Γ]) = ord(Γ); ord(Γ → C) = max{ord(Γ) + 1, ord(C) + prod(C)}.\nFor sequents without · and []−1, this definition is quite intuitive: the order is the nesting depth of implications (\\, /, and finally →) and 〈〉 modalities. With ·, we also count alternations between divisions and multiplications: for example, in p1 \\(p2·(p3 \\(p4·. . . pk) . . .)) implications are not nested, but the order grows linearly. On the other hand, the order is always bounded by a simpler complexity parameter, the maximal height of the syntactic tree. Also, linguistic applications make use of syntactic types of small, constantly bounded order.\nThe third parameter is the bracket nesting depth.\nI Definition 3. The bracket nesting depth of a formula, meta-formula, or a sequent in Lb∗ is defined recursively as follows: b(pi) = 0; b(A/B) = b(B \\A) = b(A ·B) = max{b(A), b(B)};\nb(〈〉A) = b([]−1A) = b(A) + 1; b(Λ) = 0; b(Γ,∆) = max{b(Γ),b(∆)}; b([Γ]) = b(Γ) + 1; b(Γ→ C) = max{b(Γ),b(C)}.\nBy poly(x1, x2, . . .) we denote a value that is bounded by a polynomial of x1, x2, . . .\nI Theorem 4. There exists an algorithm that decides whether a sequent Γ→ C is derivable in Lb∗ in poly(N, 2R, NB) time, where N = ||Γ→ C||, R = ord(Γ→ C), B = b(Γ→ C).\nIf the depth parameters, R and B, are fixed, the working time of the algorithm is polynomial w.r.t. N . However, the dependence on the depth parameters is exponential.\n3 Proof Nets\nIn this section we formulate and prove a graph-theoretic criterion for derivability in Lb∗. A sequent is derivable if and only if there exists a proof net, that is, a graph satisfying certain correctness conditions.\nFor each variable pi we introduce two literals, pi and p̄i, and also four literals, [, ], [̄, and ]̄ for brackets. Next we define two translations (positive, A+, and negative, A−) of Lb∗-formulae into expressions built from literals using two connectives, O and ⊗. I Definition 5. p+i = pi, (A ·B)+ = A+ ⊗B+, (A \\B)+ = A−OB+, (B /A)+ = B+ OA−, (〈〉A)+ = ] ⊗ A+ ⊗ [, ([]−1A)+ = ]̄ OA+ O [̄; p−i = p̄i, (A · B)− = B−OA−, (A \\B)− = B− ⊗A+, (B /A)− = A+ ⊗B−, (〈〉A)− = [̄ OA−O ]̄, ([]−1A)− = [⊗A− ⊗ ].\nFor meta-formulae, we need only the negative translation. In this translation we use an extra connective, , which serves as a metasyntactic version of O (just as the comma is a metasyntactic product in the sequent calculus for Lb∗)."
    }, {
      "heading" : "I Definition 6. (Γ,∆)− = ∆− Γ−; [Γ]− = [̄ Γ− ]̄.",
      "text" : "Finally, a sequent Γ→ C is translated as Γ− C+ (or as C+ if Γ is empty). Essentially, this in an extension of Pentus’ translation of L∗ into cyclic multiplicative linear logic (CMLL) [29][31]. In this paper, for the sake of simpicity, we don’t introduce an intermediate calculus that extends CMLL with brackets, and formulate the proof net criterion directly for Lb∗.\nDenote the set of all literal and connective occurrences in this translation by ΩΓ→C . These occurrences are linearly ordered; connectives and literals alternate. The total number of occurrences is 2n. Denote the literal occurrences (in their order) by `1, . . . , `n and the connective occurrences by c1, . . . , cn.\nI Definition 7. The dominance relation on the occurrences of O and ⊗, denoted by ≺, is defined as follows: for a subexpression of the form AOB or A⊗B if the occurrence of the central connective is ci, then for any cj inside A or B we declare cj ≺ ci.\nWe assume that O’s that come from translations of bracket modalities associate to the left and ⊗’s associate to the right (this choice is arbitrary). Thus, in a pair of such O’s the right one dominates the left one in the syntactic tree, and the left one dominates the principal connective of A; symmetrically for ⊗.\nThe other two relations are the sisterhood relation on bracket literals and connectives, Sb and Sc respectively. Both relations are symmetric.\nI Definition 8. The bracket sisterhood relation, Sb, connects pairs of occurrences of [ and ] or [̄ and ]̄ that come from the same 〈〉A, []−1A, or [Γ]. The connective sisterhood relation, Sc, connects pairs of occurrences of ⊗, O, or that come from the same 〈〉A, []−1A, or [Γ]. Occurrences connected by one of the sisterhood relations will be called sister occurrences.\nI Definition 9. A proof structure E is a symmetric relation on the set of literal occurrences ({`1, . . . , `n}) such that each occurrence is connected by E to exactly one occurrence, and each occurrence of a literal q, where q is a variable, [, or ], is connected to an occurrence of q̄.\nI Definition 10. A proof structure E is planar, if its edges can be drawn in a semiplane without intersection while the literal occurrences are located on the border of this semiplane in their order (`1, . . . , `n).\nEdges of a planar proof structure divide the upper semiplane into regions. The number of regions is n2 + 1 (the outermost, infinite region also counts).\nI Definition 11. A planar proof structure E is a proof net, if it satisfies two conditions. 1. On the border of each region there should be exactly one occurrence of O or . 2. Define an oriented graph A that connects each occurrence of ⊗ to the unique occurrence\nof O or located in the same region. The graph A ∪≺ should be acyclic.\nBy definition, edges of E and A in a proof net do not intersect, in other words, the graph E ∪ A is also planar. We can also consider proof structures and proof nets on expressions that are not translations of Lb∗ sequents. For example, proof nets allow cyclic permutations: a proof net for γ1 γ2 can be transformed into a proof net for γ2 γ1 (the ≺ relation in γ1 and γ2 is preserved).\nI Lemma 12. For an expression of the form A−1 . . . A−m (which is not a translation of an Lb∗ sequent, since there is no B+ in the end) there couldn’t exist a proof net.\nProof. Following Pentus [29], for any string γ of literals, O’s, ⊗’s, and ’s we define \\(γ) as the number of negative literals (i.e., of the form q̄, where q is a variable or a bracket) minus the number of O’s and ’s. Then we establish the following: (1) \\(A+) = 0 and \\(A−) = 1 for any formula A; (2) if there exists a proof net for γ, then \\(γ) = −1. The first statement is proved by joint induction on A. The second one follows from the fact that the number of regions is greater than the number of E links exactly by one; links are in one-to-one correspondence with negative literal occurrences and each region holds a unique occurrence of O or . Since \\( A−1 . . . A−m) = m−m = 0 6= −1, there is no proof net. J\nI Definition 13. A proof structure E respects sisterhood, if the following condition holds: if 〈`i, `i′〉 ∈ E , 〈`i, `j〉 ∈ Sb, and 〈`i′ , `j′〉 ∈ Sb, then 〈`j , `j′〉 ∈ E (i.e., sister brackets are connected to sister brackets).\nI Theorem 14. The sequent Γ→ C is derivable in Lb∗ if and only if there exists a proof net E over ΩΓ→C that respects sisterhood.\nProof. The direction from Lb∗-derivation to proof net is routine: we construct the proof net by induction, maintaining the correctness criterion. For the other direction, we proceed by induction on the number of O and ⊗ occurrences.\nIf there are no occurrences of O or ⊗, then the total number of occurrences is, on one hand, equal to n; on the other hand, it is equal to the number of regions, n2 + 1. Therefore,\nn = 2, and the only possible proof net is p̄ p , that corresponds to the p→ p axiom. Otherwise consider the set of all occurrences of O and ⊗ with the relation A ∪≺. Since this relation is acyclic (and the set is not empty), there exists a maximal element, ci. Case 1.1: ci is a O occurrence that came from (A ·B)− = B−OA−. Replacing this O by corresponds to applying (· →).\nCase 1.2: ci is a O occurrence that came from (A \\B)+ = A−OB+. Replacing this O by changes Γ− A−OB+ to Γ− A− B+, which corresponds to applying (→ \\). (In the negative translation, formulae in the left-hand side appear in the inverse order.)\nCase 1.3: ci is a O occurrence that came from (B /A)+ = B+ OA−. Again, replace O with and cyclically transform the net, yielding A− Γ− B+. Then apply (→ /).\nCase 2.1: ci is a ⊗ occurrence that came from (A ·B)+ = A+ ⊗B+. Then A(ci) is a occurrence, and the A link splits the proof net for Γ→ A ·B into two separate proof nets for Γ1 → A and Γ2 → B (Γ1 and/or Γ2 could be empty, then two or three ’s shrink into one):\nΓ−2 Γ − 1 A+ ⊗ B+\nNote that here the fragments before the occurrence A(ci) and between A(ci) and A are negative translations of whole metaformulae (Γ1 and Γ2), not just substrings with possibly disbalanced brackets. Indeed, suppose that a pair of sister brackets, [̄ and ]̄, is split between these two fragments. Then, since E links cannot intersect A, the corresponding pair of [ and ], connected to the original pair by E , will also be split and therefore belong to translations of different formulae. However, they also form a sister pair (our proof net respects sisterhood), and therefore should belong to one formula (by definition of the translation). Contradiction.\nSince for the sequents Γ1 → A and Γ2 → B the induction parameter is smaller, they are derivable, and therefore Γ1,Γ2 → A ·B is derivable by application of the (→ ·) rule.\nCase 2.2: ci is a ⊗ occurrence from (A \\B)− = B−⊗A+. Again, the proof net gets split:\n. . . B− ⊗ A+ Π− . . . C+︸ ︷︷ ︸ ∆−\n(As in the previous case, no pair of sister brackets could be split by A here, and Π− is a translation of a whole metaformula.) The outer fragment provides a proof net for ∆〈B〉 → C; applying a cyclic permutation to the inner fragment yields a proof net for Π→ A. The goal sequent, ∆〈Π, A \\B〉 → C, is obtained by applying the (/→) rule.\nThe other situation,\n. . . Π− B− ⊗ A+ . . . C+︸ ︷︷ ︸ ∆−\nis impossible by Lemma 12, applied to the inner net. Case 2.3: ci is a ⊗ occurrence that came from (B /A)− = A+ ⊗B−. Symmetric. Case 3.1: ci is a O occurrence that came from ([]−1A)+ = ]̄ OA+ O [̄. Then we replace two O’s by ’s and cyclically relocate the rightmost [̄ with its E link, obtaining [̄ Γ− ]̄ A+ from Γ− ]̄ OA+ O [̄. This corresponds to an application of (→ []−1).\nCase 3.2: ci is a O occurrence that came from (〈〉A)− = [̄ OA−O ]̄. By replacing O’s with ’s, we change 〈〉A into [A]. This corresponds to an application of (〈〉 →).\nCase 4.1: ci is a ⊗ occurrence that came from (〈〉A)+ = ]⊗A+ ⊗ [. Consider the E links that go from these ] and [. Since (〈〉A)+ is the rightmost formula, they both either go to the left or into A+. The second situation is impossible, because then A(ci) should also be a O occurrence in A+, that violates the maximality of ci (and also the acyclicity condition).\nIn the first situation, the picture is as follows:\nγ1 [̄ Γ− ]̄ γ2 ] ⊗ A+ ⊗ [\n(Due to maximality of ci, A(ci) and its sister are ’s, not O’s.) Clearly, γ1 and γ2 are empty: otherwise we have two ’s in one region. Then we can remove brackets and transform this proof net into a proof net for Γ− A+, i.e., Γ→ A. Applying (→ 〈〉) yields [Γ]→ 〈〉A.\nCase 4.2: ci is a ⊗ occurrence that came from ([]−1A)− = [⊗A− ⊗ ]. As in the previous case, consider the E links going from these bracket occurrences. The good situation is when they go to different sides:\n. . . [̄ γ1 [ ⊗ A− ⊗ ] γ2 ]̄ . . . C+︸ ︷︷ ︸ ∆−\n(The connectives surrounding [⊗A− ⊗ ] are ’s due to the maximality of ci.) Again, γ1 and γ2 should be empty (the connective after [̄ or before ]̄ here cannot be a ⊗, and we get more than one O or in a region), and removing the bracket corresponds to applying ([]−1 →): replace [[]−1A] with A in the context ∆.\nPotentially, the E links from the brackets could also go to one side, but then they end at a pair of sister brackets ]̄ and [̄ (in this order), which can occur only in ]̄ OBO [̄. Then one of these O’s is A(ci), which contradicts the maximality of ci. J\nThe idea of proof nets as a representation of derivation in a parallel way comes from the original Girard’s paper on linear logic [12]. For the non-commutative case, including the Lambek calculus, proof nets were studied by many researchers including Abrusci [1], de Groote [7], Nagayama and Okada [25], Penn [26], Pentus [29], Yetter [34], and others. In our definition of proof nets form Lb∗ we follow Fadda and Morrill [8], but with the correctness (acyclicity) conditions of Pentus [29][31] rather than Danos and Regnier [6].\nThe idea of handling brackets similarly to variables is due to Versmissen [33]. If we take a sequent that is derivable in Lb∗, replace brackets with fresh variables, say, r and s, and respectively substitute r · A · s for 〈〉A and r \\A/ s for []−1A, we obtain a sequent that is derivable in L∗ (this follows from our proof net criterion and can also be shown directly). Versmissen, however, claims that the converse is also true. This would make our Theorem 4 a trivial corollary of Pentus’ result [31], but Fadda and Morrill [8] present a counter-example for Versmissen’s claim. Namely, the sequent [[]−1p], [[]−1q] → 〈〉[]−1(p · q) is not derivable in Lb∗, but its translation, r, r \\ p / s, s, r, r \\ q / s, s→ r · (r \\(p · q) / s) · s, is derivable in L∗. This example shows the importance of the sisterhood condition in Theorem 14: the only possible proof net for this sequent, shown below, doesn’t respect sisterhood.\n[̄ [ ⊗ q̄ ⊗ ] ]̄ [̄ [ ⊗ p̄ ⊗ ] ]̄ ] ⊗ ]̄ O p ⊗ q O [̄ ⊗ [\n4 Complexity Parameters for Proof Nets\nIn this section we introduce new complexity parameters that operate with ΩΓ→C rather than with the original sequent Γ→ C, and therefore are more handy for complexity estimations. We show that a value is polynomial in terms of the old parameters if it is polynomial in terms of the new ones.\nThe first parameter, denoted by n, is the number of literals in ΩΓ→C . It is connected to the size of the original sequent by the following inequation: n ≤ 2||Γ→ C||. (We have to multiply by 2, since a modality, 〈〉 or []−1, being counted as one symbol in Γ→ C, introduces two literals.)\nThe second parameter, denoted by d = d(ΩΓ→C), is the connective alternation depth, and informally it is the maximal number of alternations between O and ⊗ on the ≺-path from any literal to the root of the parse tree. Formally it is defined by recursion.\nI Definition 15. For an expression γ constructed from literals using O, ⊗, and , let prod(γ) be 1 if γ is of the form γ1⊗γ2, and 0 otherwise. Define d(γ) by recursion: d(q) = d(q̄) = 0 for any literal q; d(γ1 O γ2) = d(γ1 γ2) = max{d(γ1)+prod(γ1), d(γ2)+prod(γ2)}; d(γ1⊗γ2) = max{d(γ1), d(γ2)}.\nThe d parameter is connected to the order of the original sequent:\nI Lemma 16. For any sequent Γ→ C, the following holds: d(ΩΓ→C) ≤ ord(Γ→ C).\nProof. We prove the following two inequations for any formula A by simultaneous induction on the construction of A: d(A+) ≤ ord(A) and d(A−) + prod(A−) ≤ ord(A). The induction is straightforward, the only interesting cases are the negative ones for A2 \\A1, A1 /A2, and ([]−1A1)−. In those three cases, we need to branch further into two subcases: whether A1 is a variable or a complex type. Finally, d(ΩΓ→C) = d( A−1 . . . A − k C+) = max{d(A − 1 ) + prod(A−1 ), . . . , d(A − k ) + prod(A − k ), d(C+) + prod(C+)} ≤ max{ord(Γ), ord(C) + prod(C)} ≤ max{ord(Γ) + 1, ord(C) + prod(C)} = ord(Γ→ C). J\nThe third parameter is b, the maximal nesting depth of pairs of sister brackets. Clearly, b = b(Γ→ C).\nIn the view of the inequations established in this section, if a value is poly(n, 2d, nb), it is also poly(||Γ → C||, 2ord(Γ→C), ||Γ → C||b(Γ→C)), and for our algorithm we’ll establish complexity bounds in terms of n, d, and b.\n5 The Algorithm\nOur goal is to obtain an efficient algorithm that seeks for proof nets that respect sisterhood. We are going to split this task: first find all possible proof nets satisfying Pentus’ correctness conditions, and then distill out those which respect sisterhood. One cannot, however, simply yield all the proof nets. The reason is that there exist derivable sequents, even without brackets and of order 2, that have exponentially many proof nets, for example, p / p, . . . , p / p, p, p \\ p, . . . , p \\ p→ p. Therefore, instead of generating all the proof nets for a given sequent, Pentus in an addition to his provability verification algorithm produces a context-free grammar that generates a set of words encodings of all these proof nets. We filter this set by intersecting it with the set of codes of all proof structures that respect sisterhood. For the latter, we build a finite automaton of polynomial size.\nNote that this context-free grammar construction is different from the translation of Lambek categorial grammars into context-free grammars (Pentus [27]). The grammar from\nPentus’ algorithm that we consider here generates all proof nets for a fixed sequent, while in [27] a context-free grammar is generated for all words that have corresponding derivable Lambek sequents. The latter (global) grammar is of exponential size (though for the case of only one division there also exists a polynomial construction [18]), while the former (local) one is polynomial. For the bracket extension, we present a construction of the local grammar. The context-freeness for the global case is claimed by Jäger [13], but his proof uses an incorrect lemma by Versmissen (see above).\nFollowing Pentus [31], for a given sequent Γ→ C we encode proof structures as words of length n over alphabet {e1, . . . , en}.\nI Definition 17. The code c(E) of proof structure E is constructed as follows: if `i and `j are connected by E , then the i-th letter of c(E) is ej and the j-th letter is ei.\nThe code of a proof structure is always an involutive permutation of e1, . . . , en. We are going to define two languages, P1 and P2, with the following properties:\n1. P1 = {c(E) | E is a proof net}; 2. c(E) ∈ P2 iff E respects sisterhood.\nNote that in the condition for P2 we say nothing about words that are not of the form c(E). Some of these words could also belong to P2. Nevertheless, w ∈ P1 ∩ P2 iff w = c(E) for some pairing E that is a proof net and respects sisterhood. Therefore, the sequent is derivable in Lb∗ iff P1 ∩ P2 6= ∅.\nNow the algorithm that checks derivability in Lb∗ works as follows: it constructs a contextfree grammar for P1 ∩ P2 and checks whether the language generated by this grammar is non-empty. Notice that the existence of such a grammar is trivial, since the language is finite. However, it could be of exponential size, and we’re going to construct a grammar of size poly(n, 2d, nb), and do it in polynomial time.\nFor P1, we use the construction from [31]. As the complexity measure (size) of a context-free grammar, |G1|, we use the summary length of its rules.\nI Theorem 18 (M. Pentus 2010). There exists a context-free grammar G1 of size poly(n, 2d) that generates P1. Moreover, this grammar can be obtained from the original sequent by an algorithm with working time also bounded by poly(n, 2d).\nThis theorem is stated as a remark in [31]. We give a full proof of it in Section 6. Next, we construct a finite automaton for a language that satisfies the condition for P2.\nI Lemma 19. There exists a deterministic finite automaton with poly(n, nb) states that generates a language P2 over alphabet {e1, . . . , en} such that c(E) ∈ P2 iff E respects sisterhood. Moreover, this finite automaton can be obtained from the original sequent by an algorithm with working time poly(n, nb).\nProof. First we describe this automaton informally. Its memory is organised as follows: it includes a pointer i to the current letter of the word (a number from 1 to n+ 1) and a stack that can be filled with letters of {e1, . . . , en}. In the beginning, i = 1 and the stack is empty. At each step (while i ≤ n), the automaton looks at `i. If it is not a bracket, the automaton increases the pointer and proceeds to the next letter in the word. If it is a bracket, let its sister bracket be `j . Denote the i-th (currently being read) letter of the word by ei′ . If `i′ is not a bracket, yield “no” (bracket is connected to non-bracket). Otherwise let `j′ be the sister of `i′ and consider two cases. 1. j > i. Then push ej′ on top of the stack, increase the pointer and continue.\n2. j < i. Then pop the letter from the top of the stack and compare it with ei′ . If they do not coincide, yield “no”. Otherwise increase the pointer and continue. If i = n+ 1 and the stack is empty, yield “yes”. Since sister brackets are well-nested, on the i-th step we pop from the stack the symbol that was pushed there on the j-th step (if `i and `j are sister brackets and j < i). Thus, the symbol popped from the stack contains exactly the information that, if the bracket `j is connected to `j′ , then the bracket `i should be connected to the sister bracket `i′ , and we verify the fact that E satisfies this condition by checking that the i-th letter is actually ei′ .\nNote that here we do not check the fact the word really encodes some proof structure E , since malformed codes will be ruled out by the intersection with P1.\nIf the bracket nesting depth is b, we’ll never have more than b symbols on the stack. For each symbol we have n possibilities (e1, . . . , en). Therefore, the total number of possible states of the stack is 1 + n+ n2 + . . .+ nb ≤ (b+ 1) · nb. The pointer has (n+ 1) possible values. Thus, the whole number of possible memory states is (n+ 1) · (b+ 1) · nb + 1 (the last “+1” is for the “failure” state, in which the automaton stops to yield “no”).\nFormally, our automaton is a tuple A2 = 〈Q,Σ, δ, q0, {qF }〉, where Σ = {e1, . . . , en} is the alphabet, Q = {1, . . . , n+ 1} × Σ≤b ∪ {⊥}, where Σ≤b is the set of all words over Σ of length not greater than b, is the set of possible states (⊥ is the “failure” state), q0 = 〈1, ε〉 is the initial state, qF = 〈n+ 1, ε〉 is the final (acception) state, and δ ⊂ Q× Σ×Q is a set of transitions defined as follows:\nδ = {〈i, ξ〉 ei′−−→ 〈i+ 1, ξ〉 | `i is not a bracket}\n∪ {〈i, ξ〉 ei′−−→ ⊥ | `i is a bracket and `i′ is not a bracket}\n∪ {〈i, ξ〉 ei′−−→ 〈i+ 1, ξej′〉 | `i is a bracket, its sister bracket is `j , j > i; `i′ is a bracket, its sister bracket is `j′}\n∪ {〈i, ξei′〉 ei′−−→ 〈i+ 1, ξ〉 | `i is a bracket, its sister bracket is `j , j < i}\n∪ {〈i, ξei′′〉 ei′−−→ ⊥ | `i is a bracket, its sister bracket is `j , j < i, and i′ 6= i′′}.\nA2 is a deterministic finite automaton with not more than (n+1) · (b+1) ·nb +1 = poly(n, nb) states, and it generates a language P2 such that c(E) ∈ P2 iff E respects sisterhood.\nIn the RAM model, each transition is computed in constant time, and the total number of transitions is not more than |Q|2 · n ≤ ((n + 1) · (b + 1) · nb + 1)2 · n, which is also poly(n, nb). J\nNow we combine Theorem 18 and Lemma 19 to obtain a context-free grammar G for P1 ∩ P2 of size poly(|G1|, |A2|, |Σ|), where |A2| is the number of states of A2. For this we use the following well-known result:\nI Theorem 20. If a context-free grammar G1 defines a language P1 over an alphabet Σ and a deterministic finite automaton A2 defines a language P2 over the same alphabet, then there exists a context-free grammar G that defines P1 ∩ P2, the size of this grammar is poly(|G1|, |A2|, |Σ|), and, finally, this grammar can be obtained from G1 and A2 by an algorithm with working time also poly(|G1|, |A2|, |Σ|).\nFor this theorem we use the construction from [11, Theorem 3.2.1] that works directly with the context-free formalism and this makes the complexity estimation straightforward. Since |G1| = poly(n, 2d), |A2| = poly(n, nb), and |Σ| = n, |G2| is poly(n, 2d, nb). Finally, checking derivability of the sequent is equivalent to checking the non-emptiness of the language P1∩P2, which is done using the following theorem [11, Lemma 1.4.3a and Theorem 4.1.2a]:\nI Theorem 21. There exists an algorithm that checks whether the language generated by a context-free grammar G is non-empty, with poly(|G|) working time.\nThe whole algorithm described in this section works in poly(n, 2d, nb) = poly(||Γ → C||, 2ord(Γ→C), ||Γ→ C||b(Γ→C)) time, as required in Theorem 4.\n6 Proof of Theorem 18 (Pentus’ Construction Revisited)\nIn our algorithm, described in Section 5, we use Pentus’ polynomial-size context-free grammar, that generates all proof nets, as a black box: we need only Theorem 18 itself, not the details of the construction in its proof. However, Pentus [31] doesn’t explicitly formulate this theorem, but rather gives it as side-effect of the construction for checking existence of a proof net (e.g., non-emptiness of the context-free language). The latter is, unfortunately, not sufficient for our needs. Moreover, we use slightly different complexity parameters. Therefore, and also in order to make our paper logically self-contained, in this section we redisplay Pentus’ construction in more detail, in other words, prove Theorem 18.\nPentus’ idea for seeking proof nets is based on dynamic programming. In ΩΓ→C , connective and literal occurrences alternate: c1, `1, c2, `2, . . . , cn, `n. Consider triples of the form (i, j, k), where 1 ≤ i ≤ j ≤ k ≤ n.\nI Definition 22. An (i, j, k)-segment Ẽ is a planar pairing of literals from {`i, . . . , `k−1} such that in every region created by Ẽ there exists a unique O or occurrence from {ci, . . . , ck} that belongs to this region, and, in particular, this occurrence for the outer (infinite) region is cj , called the open par. If k = j = i, then Ẽ is empty, and ci should be a O or occurrence.\nFor each Ẽ we construct the corresponding Ã that connects each ⊗ occurrence to the only O or in the same region; for the outer region, it uses the open par.\nI Definition 23. An (i, j, k)-segment Ẽ is correct, if the graph Ã ∪ ≺ is acyclic.\nFor each (i, j, k)-segment, in the non-terminals of the grammar we keep a small amount of information, which we call the “ghost” of the segment and that is sufficient to construct bigger segments (and, finally, the whole proof net) from smaller ones.\nI Definition 24. A ⊗ occurrence is called dominant, if it is not immediately dominated (in the ≺ preorder) by another ⊗ occurrence. For each ⊗ occurrence c there exists a unique dominant ⊗ occurrence τ(c) such that τ(c) c and on the ≺ path from c to τ(c) all occurrences are ⊗ occurrences.\nLet’s call two ⊗ occurrences equivalent, c ≈ c′, if τ(c) = τ(c′). Equivalent ⊗ occurrences form clusters; from each cluster we pick a unique representative, the ≺-maximal occurrence τ(c). By - we denote the transitive closure of ≺∪≈: c - c′ means that there is a path from c to c′ that goes along ≺ and also could go in the inverse direction, but only from ⊗ to ⊗ with no O or in between.\nI Lemma 25. For an (i, j, k)-segment Ẽ, the graph Ã ∪ ≺ is acyclic iff the graph Ã ∪- is acyclic. For a proof structure E, the graph Ã ∪ ≺ is acyclic iff any cycle in Ã ∪- is a trivial ≈-cycle in a cluster. [31, Lemma 6.2]\nProof. Pentus proves this lemma by a topological argument. If Ã ∪- has non-trivial cycles, take a simple cycle (i.e. a cycle where no vertex appears twice) that embraces the smallest area. If this cycle includes a link from c to d where c ≈ d and c d, then consider the Ã link\nthat goes from c. This link should go inside the cycle, and, continuing by this link, one could construct a new cycle with a smaller area embraced. Contradiction. The other direction is trivial, since every cycle in Ã ∪ ≺ is a non-trivial cycle in Ã ∪-. J\nIn view of this lemma we can now use - instead of ≺ in the correctness (acyclicity) criteria for proof nets and (i, j, k)-segments.\nI Definition 26. For a connective occurrence ci let Vi be the set of all dominant ⊗ occurrences on the ≺ path from ci to the root of the parse tree.\nSince each dominant ⊗ marks a point of alternation between ⊗ and O (or , on the top level), and the number of such alternations is bounded by d, we have |Vi| ≤ d for any i.\nI Definition 27. The ghost of an (i, j, k)-segment Ẽ , denoted by R, is the restriction of the transitive closure of Ã ∪- to the set Vi ∪ Vj ∪ Vk that is forced to be irreflexive (in other words, we remove trivial ≈-cycles). An (i, j, k)-ghost is an arbitrary transitive irreflexive relation on Vi ∪ Vj ∪ Vk.\nI Lemma 28. The number of different (i, j, k)-ghosts is poly(2d).\nProof. Let |Vi| = d1, |Vj | = d2, |Vk| = d3 (these three numbers are not greater than d). Each ghost includes three chains, Qi, Qj , and Qk, and it remains to count the number of possible connections between them. Due to transitivity, if a vertex in Vi is connected to a vertex in Vj , then it is also connected to all greater vertices. Now we represent elements of Vj as d2 white balls, and put d1 black balls between them. The i-th black ball is located in such a place that the i-th vertex of Vi is connected to all vertices of Vj that are greater than the position of the i-th ball, and only to them. Due to transitivity, the order of black balls is the same as Qi. The number of possible distributions of white and black balls is(\nd1+d2 d1\n) < 2d1+d2 ≤ 22d. Doing the same for all 6 pairs of 3 chains, we get the estimation\n(22d)6 = (2d)12 = poly(2d) for the number of (i, j, k)-ghosts. J\nNow we define the context-free grammar G1. Non-terminal symbols of this grammar include the starting symbol S and symbols Fi,j,k,R for any triple (i, j, k) (1 ≤ i ≤ j ≤ k ≤ n) and any (i, j, k)-ghost R. The meaning of these non-terminals is in the following statement, which will be proved by induction after we present the rules of G1: a word w is derivable from Fi,j,k,R iff w = c(Ẽ) for a correct (i, j, k)-segment Ẽ with ghost R; a word w is derivable from S iff w = c(E) for some proof net E . (Codes of (i, j, k)-segments are defined in the same way as codes of proof structures, as involutive permutations of ei, . . . , ek−1.)\nFor the induction base case, i = j = k, we take only those values of i such that ci is a O or occurrence, and denote by Qi the ≺ relation restricted to Vi (this is the trivial ghost of an empty (i, i, i)-segment); Qi is always acyclic, and an isolated O or occurrence ci is always a correct (i, i, i)-segment (with an empty Ẽ), and ci is its open par. Now for each O or occurrence ci we add the following rule to the grammar (this is a ε-rule, the right-hand side is empty):\nFi,i,i,Qi ⇒ .\nNext, consider the non-trivial situation, where i < k. The difference k− i should be even, otherwise there couldn’t exist a literal pairing Ẽ . Moreover, if both ci and ck are O or occurrences, a correct (i, j, k)-segment also couldn’t exist, since in the outer region we have at least two O or occurrences, namely, ci and ck. Therefore, we include rules for Fi,j,k,R only if k− i is even and at least one of ci and ck should be ⊗. Let it be ci (Pentus’ situation of the first kind). The ck case (Pentus’ situation of the second kind) is handled symmetrically.\nWe take the leftmost literal occurrence, `i, and find all possible occurrences among `i+1, . . . , `k−1 that could be connected to `i (i.e., if `i is an occurrence of q, we seek for q̄, and vice versa). For each such occurrence, `h−1, we consider two triples, (i + 1, j′, h − 1) and (h, j, k), and all possible (i+ 1, j′, h− 1)- and (h, j, k)-ghosts, R1 and R2, respectively. For each such pair, R1 and R2, we consider the transitive closure of the following relation: R1 ∪R2 ∪Qi ∪ {〈τ(ci), d〉 | d ∈ Vj}. If it is irreflexive (acyclic), its restriction to Vi ∪ Vj ∪ Vk, denoted by R, will become a ghost of an (i, j, k)-segment. For this, we add the following rule to the grammar:\nFi,j,k,R ⇒ eh−1 Fi+1,j′,h−1,R1 ei Fh,j,k,R2 .\nI Lemma 29. In this grammar, a word w can be derived from Fi,j,k,R iff w = c(Ẽ) for some (i, j, k)-segment E with ghost R.\nProof. Proceed by induction on k − i. The base case (i = j = k) was considered above. For the “only if” part, let w be derived by a rule for the first kind (the second kind is symmetric). Then w = eh−1w1eiw2, and by induction hypothesis w1 and w2 encode (i + 1, j′, h − 1)- and (h, j, k)-segments with ghosts R1 and R2 respectively. The word w encodes an (i, j, k)-segment, and it remains to show that this segment is correct and its ghost is R. For this new segment, Ã = Ã1 ∪ Ã2 ∪ 〈ci, cj〉. Suppose there is a non-trivial cycle in Ã ∪ -. Since all cycles in Ã1 ∪ - and Ã2 ∪ - are trivial, this cycle should either include links from both Ã1 and Ã2 or use the new 〈ci, cj〉 connection (or both). The cycle, however, cannot cross Ẽ links, therefore the only way of “legally crossing the border” between segments is by going through ⊗ occurrences that dominate ci, ci+1, ch−1, ch, or ck. We can assume that these “border crossing points” are dominant ⊗ occurrences (otherwise we can add a ≈-detour to the cycle). Then the cycle is actually a concatenation of parts of the following three kinds: (1) connecting vertices of Vi+1 ∪ Vh−1; (2) connecting vertices of Vh ∪ Vk; (3) connecting τ(ci), via cj , to a vertex d of Vj . In this case, our cycle induces a cycle in R1 ∪R2 ∪Qi ∪ {〈τ(ci), d〉 | d ∈ Vj}, which is impossible by definition.\nIt remains to show that R is the ghost of the newly constructed segment. Indeed, R is a binary relation on Vi ∪ Vj ∪ Vk and is included into the transitive closure of Ã ∪-, therefore R is a subrelation of the ghost. On the other hand, if there is a pair 〈c, d〉 in the ghost, then there is a path from c to d and, as shown above, it can be split into parts of kinds (1), (2), and (3). Thus, 〈c, d〉 ∈ R, and therefore R coincides with the ghost.\nFor the “if” part, if ci in an (i, j, k)-segment is a ⊗ occurrence, consider the Ẽ link from the literal occurrence `i. It splits the segment into two ones. For each of them, by induction hypothesis, we generate their codes from Fi+1,j′,h−1,R1 and Fh,j,k,R2 respectively, and then apply the rule to generate the code of the original segment. Situations of the second kind, where ck is a ⊗ occurrence, are handled symmetrically. J\nFinally, we add rules for the starting symbol. These rules are analogous to the rules for situations of the second kind. Take `n and find all possible occurrences among `1, . . . , `n−1 that could be connected to it. For each such occurrence `h and any pair of (0, 0, h)- and (h+ 1, j′, n)-ghosts, R1 and R2, respectively (in the first segment j = 0, since in the whole proof net the open par should be the leftmost occurrence of ), consider the transitive closure of R1 ∪R2. If it is irreflexive, then we add the following rule to the grammar:\nS ⇒ F0,0,h,R1 en Fh+1,j′,n,R2 eh.\nI Lemma 30. A word w can be derived from S iff w = c(Ẽ) for some proof net E.\nProof. Analogous to the previous lemma. J\nThis lemma shows that we’ve constructed a grammar that generates P1. Now to finish the proof of Theorem 18 it remains to establish complexity bounds. The number of non-terminal symbols is bounded by n3 ·K + 1, where K is the maximal number of (i, j, k)-ghosts. Since each rule has length at most 5 (1 non-terminal on the left and 4 symbols on the right), |G1| is bounded by 5(n3 ·K + 1), and, since K is poly(2d) (Lemma 28), |G1| is poly(2d, n). Clearly, the procedure that generates G1 from the original sequent is also polynomial in running time: acyclicity checks for each rule are performed in poly(n) time, and the number of rules is poly(2d, n).\n7 Conclusions and Future Work\nIn this paper, we’ve presented an algorithm for provability in the Lambek calculus with brackets. Our algorithm runs in polynomial time w.r.t. the size of the input sequent, if its order and bracket nesting depth are bounded.\nWe summarize some questions raised for future research. First, Pentus [31] also presents a parsing procedure for Lambek categorial grammars. Our intention is to develop an efficient parsing procedure for grammars with brackets. Second, the problem whether Lb∗grammars define exactly context-free languages is still open (the counter-example by Fadda and Morrill [8] jeopardises Jäger’s claim). Third, in our calculus we allow empty antecedents. We are going to modify our algorithm for the bracketed extension of the original Lambek calculus, using a modified notion of proof nets (see for example [19][17]). A more general question is to extend the algorithm to other enrichments of the Lambek calculus (see, for example, [24]), keeping polynomiality, if possible. Notice that some of these enrichments are generally undecidable [15], so it is interesting to find feasible bounded fragments.\nAcknowledgements. The authors are grateful to Mati Pentus for in-depth comments on his algorithm [31].\nReferences 1 V. M. Abrusci. Non-commutative proof nets. In J.-Y. Girard, Y. Lafont, and L. Regnier,\neditors, Advances in Linear Logic. Cambridge University Press, 1995. 2 K. Ajdukiewicz. Die syntaktische Konnexität. Studia Philosophica, 1:1–27, 1935. 3 Y. Bar-Hillel. A quasi-arithmetical notation for syntactic description. Language, 29:47–58,\n1953. 4 W. Buszkowski. Type logics in grammar. In Trends in Logic: 50 Years of Studia Logica,\npages 337–382. Springer, 2003. 5 B. Carpenter. Type-Logical Semantics. MIT Press, Cambridge, MA, 1997. 6 V. Danos and L. Regnier. The structure of multiplicatives. Arch. Math. Log., 28:181–203,\n1989. 7 Ph. de Groote. A dynamic programming approach to categorial deduction. In Harald\nGanzinger, editor, Proc. CADE 1999, volume 1632 of Lect. Notes Comput. Sci., pages 1–15, Trento, 1999. Springer. 8 M. Fadda and G. Morrill. The Lambek calculus with brackets. In Language and Grammar: Studies in Mathematical Linguistics and Natural Language, pages 113–128. CSLI, Jan 2005. 9 T. Fowler. Efficient parsing with the product-free Lambek calculus. In Proc. COLING 2008, 2008. 10 T. Fowler. A polynomial time algorithm for parsing with the bounded order Lambek calculus. In Proc. MoL 2009, 2009. 11 S. Ginsburg. The mathematical theory of context-free languages. McGraw-Hill, 1966.\n12 J.-Y. Girard. Linear logic. Theor. Comput. Sci., 50:1–102, 1987. 13 G. Jäger. On the generative capacity of multi-modal categorial grammars. Research on Language and Computation, 1(1–2):105–125, 2003. 14 G. Jäger. Anaphora and Type Logical Grammar, volume 24 of Trends in Logic – Studia Logica Library. Springer, Dordrecht, 2005. 15 M. Kanovich, S. Kuznetsov, and A. Scedrov. Undecidability of the Lambek calculus with a relevant modality. ArXiv e-prints, 2016. arXiv:1601.06303. 16 N. Kurtonina. Frames and labels. A modal analysis of categorial inference. PhD thesis, Universiteit Utrecht, ILLC, Amsterdam, 1995. 17 S. Kuznetsov. Lambek grammars with one division and one primitive type. Log. J. IGPL, 20(1):207–221, 2012. 18 S. L. Kuznetsov. On translating Lambek grammars with one division into context-free grammars. Proc. Steklov Inst. Math., 294:129–138, 2016. 19 F. Lamarche and C. Retoré. Proof nets for the Lambek calculus—an overview. In V. M.\nAbrusci and C. Casadio, editors, Proofs and Linguistic Categories, Proc. 1996 Roma Workshop, pages 241–262. CLUEB, 1996.\n20 J. Lambek. The mathematics of sentence structure. Amer. Math. Mon., 65:154–170, 1958. 21 M. Moortgat. Multimodal linguistic inference. J. Log. Lang. Inform., 5(3, 4):349–385, 1996. 22 R. Moot and C. Retoré. The Logic of Categorial Grammars: A Deductive Account of Natural Language Syntax and Semantics. Springer, Heidelberg, 2012. 23 G. Morrill. Categorial formalisation of relativisation: pied piping, islands, and extraction sites. Technical Report LSI-92-23-R, Universitat Politècnica de Catalunya, 1992. 24 G. V. Morrill. Categorial Grammar: Logical Syntax, Semantics, and Processing. Oxford University Press, 2011. 25 M. Nagayama and M. Okada. A graph-theoretic characterization theorem for multiplicative fragment of non-commutative linear logic. Theor. Comput. Sci., 294:551–573, 2003. 26 G. Penn. A graph-theoretic approach to sequent derivability in the Lambek calculus. Electr. Notes Theor. Comput. Sci., 53, 2002. 27 M. Pentus. Lambek grammars are context-free. In Proc. LICS 1993, pages 430–433, Montreal, 1993. 28 M. Pentus. Models for the Lambek calculus. Ann. Pure Appl. Log., 75(1–2):179–213, 1995. 29 M. Pentus. Free monoid completeness of the Lambek calculus allowing empty premises, volume 12 of Lecture Notes in Logic, pages 171–209. Springer-Verlag, Berlin, 1998. 30 M. Pentus. Lambek calculus is NP-complete. Theor. Comput. Sci., 357(1):186–201, 2006. 31 M. Pentus. A polynomial-time algorithm for Lambek grammars of bounded order. Linguistic Analysis, 36(1–4):441–471, 2010. 32 Yu. Savateev. Unidirectional Lambek grammars in polynomial time. Theory Comput. Syst., 46(4):662–672, 2010. 33 K. Versmissen. Grammatical composition: modes, models, modalities. PhD thesis, OTS Utrecht, 1996. 34 D. N. Yetter. Quantales and (noncommutative) linear logic. J. Symb. Log., 55(1):41–64,\n1990."
    } ],
    "references" : [ {
      "title" : "Non-commutative proof nets",
      "author" : [ "V.M. Abrusci" ],
      "venue" : "Advances in Linear Logic",
      "citeRegEx" : "Abrusci.,? \\Q1995\\E",
      "shortCiteRegEx" : "Abrusci.",
      "year" : 1995
    }, {
      "title" : "Die syntaktische Konnexität",
      "author" : [ "K. Ajdukiewicz" ],
      "venue" : "Studia Philosophica,",
      "citeRegEx" : "Ajdukiewicz.,? \\Q1935\\E",
      "shortCiteRegEx" : "Ajdukiewicz.",
      "year" : 1935
    }, {
      "title" : "A quasi-arithmetical notation for syntactic description",
      "author" : [ "Y. Bar-Hillel" ],
      "venue" : "Language, 29:47–58,",
      "citeRegEx" : "Bar.Hillel.,? \\Q1953\\E",
      "shortCiteRegEx" : "Bar.Hillel.",
      "year" : 1953
    }, {
      "title" : "Type logics in grammar. In Trends in Logic: 50 Years of Studia Logica, pages 337–382",
      "author" : [ "W. Buszkowski" ],
      "venue" : null,
      "citeRegEx" : "Buszkowski.,? \\Q2003\\E",
      "shortCiteRegEx" : "Buszkowski.",
      "year" : 2003
    }, {
      "title" : "Type-Logical Semantics",
      "author" : [ "B. Carpenter" ],
      "venue" : null,
      "citeRegEx" : "Carpenter.,? \\Q1997\\E",
      "shortCiteRegEx" : "Carpenter.",
      "year" : 1997
    }, {
      "title" : "The structure of multiplicatives",
      "author" : [ "V. Danos", "L. Regnier" ],
      "venue" : "Arch. Math. Log.,",
      "citeRegEx" : "Danos and Regnier.,? \\Q1989\\E",
      "shortCiteRegEx" : "Danos and Regnier.",
      "year" : 1989
    }, {
      "title" : "A dynamic programming approach to categorial deduction",
      "author" : [ "Ph. de Groote" ],
      "venue" : "Proc. CADE 1999,",
      "citeRegEx" : "Groote.,? \\Q1999\\E",
      "shortCiteRegEx" : "Groote.",
      "year" : 1999
    }, {
      "title" : "The Lambek calculus with brackets. In Language and Grammar: Studies in Mathematical Linguistics and Natural Language, pages 113–128",
      "author" : [ "M. Fadda", "G. Morrill" ],
      "venue" : null,
      "citeRegEx" : "Fadda and Morrill.,? \\Q2005\\E",
      "shortCiteRegEx" : "Fadda and Morrill.",
      "year" : 2005
    }, {
      "title" : "Efficient parsing with the product-free Lambek calculus",
      "author" : [ "T. Fowler" ],
      "venue" : "In Proc. COLING 2008,",
      "citeRegEx" : "Fowler.,? \\Q2008\\E",
      "shortCiteRegEx" : "Fowler.",
      "year" : 2008
    }, {
      "title" : "The mathematical theory of context-free languages",
      "author" : [ "S. Ginsburg" ],
      "venue" : null,
      "citeRegEx" : "Ginsburg.,? \\Q1966\\E",
      "shortCiteRegEx" : "Ginsburg.",
      "year" : 1966
    }, {
      "title" : "On the generative capacity of multi-modal categorial grammars",
      "author" : [ "J.-Y. Girard" ],
      "venue" : "Linear logic. Theor. Comput. Sci.,",
      "citeRegEx" : "Girard.,? \\Q1987\\E",
      "shortCiteRegEx" : "Girard.",
      "year" : 1987
    }, {
      "title" : "Anaphora and Type Logical Grammar, volume 24 of Trends in Logic",
      "author" : [ "G. Jäger" ],
      "venue" : "Language and Computation,",
      "citeRegEx" : "Jäger.,? \\Q2003\\E",
      "shortCiteRegEx" : "Jäger.",
      "year" : 2003
    }, {
      "title" : "Undecidability of the Lambek calculus with",
      "author" : [ "M. Kanovich", "S. Kuznetsov", "A. Scedrov" ],
      "venue" : "Logica Library. Springer, Dordrecht,",
      "citeRegEx" : "Kanovich et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Kanovich et al\\.",
      "year" : 2005
    }, {
      "title" : "Frames and labels. A modal analysis of categorial inference",
      "author" : [ "N. Kurtonina" ],
      "venue" : "a relevant modality. ArXiv e-prints,",
      "citeRegEx" : "Kurtonina.,? \\Q2016\\E",
      "shortCiteRegEx" : "Kurtonina.",
      "year" : 2016
    }, {
      "title" : "Lambek grammars with one division and one primitive type",
      "author" : [ "S. Kuznetsov" ],
      "venue" : "Log. J. IGPL,",
      "citeRegEx" : "Kuznetsov.,? \\Q1995\\E",
      "shortCiteRegEx" : "Kuznetsov.",
      "year" : 1995
    }, {
      "title" : "On translating Lambek grammars with one division into context-free",
      "author" : [ "S.L. Kuznetsov" ],
      "venue" : null,
      "citeRegEx" : "Kuznetsov.,? \\Q2012\\E",
      "shortCiteRegEx" : "Kuznetsov.",
      "year" : 2012
    }, {
      "title" : "Proof nets for the Lambek calculus—an overview",
      "author" : [ "M. V" ],
      "venue" : "grammars. Proc. Steklov Inst. Math.,",
      "citeRegEx" : "V.,? \\Q2016\\E",
      "shortCiteRegEx" : "V.",
      "year" : 2016
    }, {
      "title" : "Multimodal linguistic inference",
      "author" : [ "M. Moortgat" ],
      "venue" : "CLUEB,",
      "citeRegEx" : "Moortgat.,? \\Q1996\\E",
      "shortCiteRegEx" : "Moortgat.",
      "year" : 1996
    }, {
      "title" : "Natural Language Syntax and Semantics",
      "author" : [ "G. Morrill" ],
      "venue" : null,
      "citeRegEx" : "Morrill.,? \\Q2012\\E",
      "shortCiteRegEx" : "Morrill.",
      "year" : 2012
    }, {
      "title" : "A graph-theoretic characterization theorem for multiplicative",
      "author" : [ "M. Nagayama", "M. Okada" ],
      "venue" : null,
      "citeRegEx" : "Nagayama and Okada.,? \\Q2011\\E",
      "shortCiteRegEx" : "Nagayama and Okada.",
      "year" : 2011
    }, {
      "title" : "A graph-theoretic approach to sequent derivability in the Lambek calculus",
      "author" : [ "G. Penn" ],
      "venue" : "non-commutative linear logic. Theor. Comput. Sci.,",
      "citeRegEx" : "Penn.,? \\Q2003\\E",
      "shortCiteRegEx" : "Penn.",
      "year" : 2003
    }, {
      "title" : "Lambek grammars are context-free",
      "author" : [ "M. Pentus" ],
      "venue" : "Notes Theor. Comput. Sci.,",
      "citeRegEx" : "Pentus.,? \\Q2002\\E",
      "shortCiteRegEx" : "Pentus.",
      "year" : 2002
    }, {
      "title" : "Models for the Lambek calculus",
      "author" : [ "M. Pentus" ],
      "venue" : "Montreal,",
      "citeRegEx" : "Pentus.,? \\Q1993\\E",
      "shortCiteRegEx" : "Pentus.",
      "year" : 1993
    }, {
      "title" : "Logic, pages 171–209",
      "author" : [ "M. Pentus" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "Pentus.,? \\Q1998\\E",
      "shortCiteRegEx" : "Pentus.",
      "year" : 1998
    }, {
      "title" : "Grammatical composition: modes, models, modalities",
      "author" : [ "K. Versmissen" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "Versmissen.,? \\Q2010\\E",
      "shortCiteRegEx" : "Versmissen.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "Pentus (2010) gave a polynomial-time algorithm for determining provability of bounded depth formulas in L∗, the Lambek calculus with empty antecedents allowed.",
      "startOffset" : 0,
      "endOffset" : 14
    } ],
    "year" : 2017,
    "abstractText" : "Lambek calculus is a logical foundation of categorial grammar, a linguistic paradigm of grammar as logic and parsing as deduction. Pentus (2010) gave a polynomial-time algorithm for determining provability of bounded depth formulas in L∗, the Lambek calculus with empty antecedents allowed. Pentus’ algorithm is based on tabularisation of proof nets. Lambek calculus with brackets is a conservative extension of Lambek calculus with bracket modalities, suitable for the modeling of syntactical domains. In this paper we give an algorithm for provability in Lb∗, the Lambek calculus with brackets allowing empty antecedents. Our algorithm runs in polynomial time when both the formula depth and the bracket nesting depth are bounded. It combines a Pentus-style tabularisation of proof nets with an automata-theoretic treatment of bracketing. Digital Object Identifier 10.4230/LIPIcs...",
    "creator" : "LaTeX with hyperref package"
  }
}