{
  "name" : "1205.1975.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Expressivity of Time-Varying Graphs and the Power of Waiting in Dynamic Networks",
    "authors" : [ "A. Casteigts", "P. Flocchini", "E. Godard", "N. Santoro", "M. Yamashita" ],
    "emails" : [ "casteig@eecs.uottawa.ca", "flocchin@eecs.uottawa.ca", "egodard@cmi.univ-mrs.fr", "santoro@scs.carleton.ca", "mak@csce.kyushu-u.ac.jp" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n20 5.\n19 75\nv1 [\ncs .D\nC ]\nWe prove that the set of languages Lnowait when no waiting is allowed contains all computable languages. On the other end, using algebraic properties of quasi-orders, we prove that Lwait is just the family of regular languages. In other words, we prove that, when waiting is no longer forbidden, the power of the accepting automaton (difficulty of the environment) drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State machine. This (perhaps surprisingly large) gap is a measure of the computational power of waiting.\nWe also study bounded waiting; that is when waiting is allowed at a node only for at most d time units. We prove the negative result that Lwait[d] = Lnowait; that is, the expressivity decreases only if the waiting is finite but unpredictable (i.e., under the control of the protocol designer and not of the environment)."
    }, {
      "heading" : "1 Introduction",
      "text" : ""
    }, {
      "heading" : "1.1 Highly Dynamic Networks",
      "text" : "Computing in static networks (complex or otherwise) is a subject which has been intensively studied from many point of views (serial/distributed, centralized/decentralized, offline/online, etc.), and it is one of the central themes of distributed computing. Computing in dynamic networks, that is where the structure of the network changes in time, is relatively less understood. Extensive research has been devoted to systems where the network dynamics are due to faults (e.g., node or edge deletions or additions). Indeed fault-tolerance is probably the most profound concern in distributed computing. Faults however are limited in scope, bounded\nin number, and are considered anomalies with respect to the correct behaviour of the system. The study of computing in systems where the network faults are actually extensive and possibly unbounded is at the core of the field of self-stabilization; the goal of the research is to devise protocols that, operating in such extreme faulty conditions, are nevertheless able to provide correct solutions if the system instability subsides (for long enough time). Also in this case, faults in the network structure are considered anomalies with respect to the correct behaviour of the system.\nWhat about systems where the instability never ends? where the network is never connected? where changes are unbounded and occur continuously? where they are not anomalies but integral part of the nature of the system?\nSuch highly dynamic systems do exist, are actually quite widespread, and becoming more ubiquitous. The most obvious class is that of wireless ad hoc mobile networks: the topology of the communication network, formed by having an edge between two entities when they are in communication range, changes continuously in time as the movement of the entities destroys old connections and creates new ones. These changes can be dramatic; connectivity does not necessarily hold, at least with the usual meaning of contemporaneous end-to-end multi-hop paths between any pair of nodes, and the network may actually be disconnected at every time instant. These infrastructure-less highly dynamic networks, variously called delay-tolerant, disruptive-tolerant, challenged, opportunistic, have been long and extensively investigated by the engineering community and, more recently, by distributed computing researchers, especially with regards to the problems of broadcast and routing (e.g. [22, 27, 33]).\nIn these networks, the protocol designer has no a priori knowledge nor control over the trajectories of the entities. However, similar highly dynamic conditions occur also when the mobility of the entities follows a predictable pattern, e.g. periodic or cyclic routes, like in the case of public transports with fixed timetables, low earth orbiting (LEO) satellite systems, security guards’ tours, etc. (e.g., see [28, 32]). Interestingly, similar complex dynamics occur also in environments where there is no mobility at all, e.g., in social networks (e.g. [12, 24]).\nNote that when dealing with these dynamic networks, most of the basic network and graph concepts - such as path, distance, diameter, connected components, etc - have no meaning without a temporal context; indeed, all the usual connectivity concepts have to be extended to a temporal version to take into account the realities of the environments being modeled."
    }, {
      "heading" : "1.2 Journey and Wait",
      "text" : "From a formal point of view, the highly dynamic features of these networks and their temporal nature are captured by the model of time-varying graphs (or evolving graphs), where edges between nodes exist only at some times, a priori unknown to the algorithm designer (e.g., see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).\nA crucial aspect of dynamic networks, and obviously of time-varying graphs, is that a path from a node to another might still exist over time, even though at no time the path exists in its entirety. It is this fact that renders routing, broadcasting, and thus computing possible in spite of the otherwise unsurmountable difficulties imposed by the nature of those networks. Hence, the notion of “path over time”, formally called journey, is a fundamental concepts and plays a central role in the definition of almost all concepts related to connectivity in time-varying graphs.\nExamined extensively, under a variety of names (e.g., temporal path, schedule-conforming path, timerespecting path, trail), informally a journey is a walk <e1, e2, ..., ek> and a sequence of time instants <t1, t2, ..., tk> where edge ei exists at time ti and its latency ζi at that time is such that ti+1 ≥ ti + ζi.\nWhile the concept of journey captures the notion of “path over time” so crucial in dynamical systems, it does not yet capture additional limitations that some of these environments can impose on the use of the journeys during a computation. More specifically, there are systems that provide the entities with storecarry-forward-like mechanisms (e.g., local buffering); thus an entity wanting to communicate with a specific\nother entity at time t0, can wait until the opportunity of communication presents itself. There are however environments where such a provision is not available (e.g., there are no buffering facilities), and thus waiting is not allowed. In time-varying graphs, this distinction is the one between a direct journey where ∀i, ti+1 = ti + ζi, and an indirect journey where ∃i, ti+1 > ti + ζi.\nWith regards to problem solving, any restriction, imposed by the nature of the system on the protocol designer, has clearly an impact on the computability and complexity of problems. In dynamic networks, computing (already a difficult task) is intuitively more difficult in environments that do not allow waiting than in those where waiting is possible; that is, environments where the only feasible journeys are the direct ones are clearly more challenging (for the problem solver) than those where journeys can be indirect.\nIn the common view of the environment as the adversary that the problem solver has to face, an environment that forbids waiting is clearly a more difficult (i.e. stronger) adversary than the one that allows waiting. The natural and immediate question is “how much stronger is the adversary if waiting is not allowed?” which can be re-expressed as: “if waiting is allowed, how much easier is to solve problems?”, or simply “what is the computational power of waiting?”\nA first difficulty in addressing these important questions is that most of the terms are qualitative, and currently there are no measures that allow to quantify even the main concepts e.g. “complexity” of the environment, “strength” of the adversary, “difficulty” of solving problems, etc.\nIn this paper, motivated by these qualitative questions, we examine the complexity of the environment (modeled as a time-varying graph) in terms of its expressivity, and establish results showing the (surprisingly dramatic) difference that the possibility of waiting creates."
    }, {
      "heading" : "1.3 Contributions",
      "text" : "Given a dynamic network modeled as a time-varying graph G, a journey in G can be viewed as a word on the alphabet of the edge labels; in this light, the class of feasible journeys defines the language Lf (G) expressed by G, where f ∈ {wait, nowait} indicates whether or not indirect journeys are considered feasible by the environment.\nWe focus on the sets of languages Lnowait = {Lnowait(G) : G ∈ U} and Lwait = {Lwait(G) : G ∈ U}, where U is the set of all time-varying graphs; that is, we look at the languages expressed when waiting is, or is not allowed. For each of these two sets, the complexity of recognizing any language in the set (that is, the computational power needed by the accepting automaton) defines the level of difficulty of the environment.\nWe first study the expressivity of time-varying graphs when waiting is not allowed, that is the only feasible journeys are direct ones. We prove that the set Lnowait contains all computable languages. That is, we show that, for any computable language L, there exists a time-varying graph G such that L = Lnowait(G).\nWe next examine the expressivity of time-varying graphs if indirect journey are allowed. We prove that Lwait is precisely the set of regular languages. The proof is algebraic and based on order techniques, relying on a theorem by Harju and Ilie [19] that enables to characterize regularity from the closure of the sets from a well quasi-order. In other words, we prove that, when waiting is no longer forbidden, the power of the accepting automaton (i.e., the difficulty of the environment, the power of the adversary), drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State Machine. This (perhaps surprisingly large) gap is a measure of the computational power of waiting.\nTo better understand the power of waiting, we then turn our attention to bounded waiting; that is when indirect journeys are considered feasible if the pause between consecutive edges in the journeys have a bounded duration d > 0. In other words, at each step of the journey, waiting is allowed only for at most d time units. We examine the set Lwait[d] of the languages expressed by time-varying graphs when waiting is allowed up to d time units. We prove the negative result that for any fixed d ≥ 0, Lwait[d] = Lnowait, which implies that the complexity of the environment is not affected by allowing waiting for a limited amount of\ntime. As a result, the power of the adversary is decreased only if it has no control over the length of waiting, i.e., if the waiting is unpredictable."
    }, {
      "heading" : "1.4 Related Work",
      "text" : "The literature on dynamic networks and dynamic graphs could fill volumes. Here we briefly mention only some of the work most directly connected to the results of this paper. The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6]. The evolving graph views the dynamics of the system as a sequence of global snapshots (taken either in discrete steps or when events occur). The equivalent model of time-varying graph (TVG), formalized in [10] and used here, views the dynamics of the system from the local point of view of the entities: for any given entity, the local edges and neighborhood can be considered independently from the entire graph (e.g. how long it is available, with what properties, with what latency, etc.).\nBoth viewpoints have been extensively employed in the analysis of basic problems such as routing, broadcasting, gossiping and other forms of information spreading (e.g., [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.g., [4, 13]); and in the investigations of emerging properties in social networks (e.g., [23, 31]). A characterization of classes of TVGs with respect to properties typically assumed in the research can be found in [10]. The related investigations on dynamic networks include also the extensive work on population protocols (e.g., [2, 11]); interestingly, the setting over which population protocols are defined is a particular class of time-varying graphs (recurrent interactions over a connected underlying graph). The impact of bounded waiting in dynamic networks has been investigated for exploration [21]."
    }, {
      "heading" : "2 Definitions and Terminology",
      "text" : "Time-varying graphs: A time-varying graph1 G is a quintuple G = (V,E,T , ρ, ζ), where V is a finite set of entities or nodes; E ⊆ V × V × Σ is a finite set of relations between these entities (edges), possibly labeled by symbols in an alphabet Σ. The system is studied over a given time span T ⊆ T called lifetime, where T is the temporal domain (typically, N or R+ for discrete and continuous-time systems, respectively); ρ : E × T → {0, 1} is the presence function, which indicates whether a given edge is available at a given time; ζ : E × T → T, is the latency function, which indicates the time it takes to cross a given edge if starting at a given date (the latency of an edge could vary in time). Both presence and latency are arbitrary computable functions. The directed edge-labeled graph G = (V,E), called the footprint of G, may contain loops, and it may have more than one edge between the same nodes, but all with different labels.\nA path over time, or journey, is a sequence < (e1, t1), (e2, t2), ..., (ek , tk) > where < e1, e2, ..., ek > is a walk in the footprint G, ρ(ei, ti) = 1 (for 1 ≤ i < k), and ζ(ei, ti) is such that ti+1 ≥ ti + ζ(ei, ti) (for 1 ≤ i < k). If ∀i, ti+1 = ti + ζ(ei, ti) the journey is said to be direct, indirect otherwise. We denote by J ∗(G) the set of all journeys in G.\nThe time-varying-graph (TVG) formalism can arguably describe a multitude of different scenarios, from transportation networks to communication networks, complex systems, or social networks [10]. Figure 1 shows two simple examples of TVGs, depicting respectively a transportation network (Figure 1(a)) and a communication network (Figure 1(b)). In the transportation network, an edge from node u to node v represents the possibility for some agent to move from u to v; typical edges in this scenario are available on a punctual basis, i.e., the presence function ρ for these edges returns 1 only at particular date(s) when the\n1We use the notation for time-varying graphs introduced in [10]\ntrip can be started. The latency function ζ may also vary from one edge to another, as well as for different availability dates of a same given edge (e.g. variable traffic on the road, depending on the departure time). In the communication network, the labels are not indicated; shown instead are the intervals of time when the presence function ρ is 1. An example of direct journey in this graph is J1 = {(ab, 2), (bc, 2+ζ)}. Examples of indirect ones include J2 = {(ac, 2), (cd, 5)}, and J3 = {(ab, 2), (bc, 2 + ζ), (cd, 5)}.\nTVG-automata: Given a time-varying graph G = (V,E,T , ρ, ζ) whose edges are labeled over Σ, we define a TVG-automaton A(G) as the 5-tuple A(G) = (Σ, S, I, E , F ) where Σ is the input alphabet; S = V is the set of states; I ⊆ S is the set of initial states; F ⊆ S is the set of accepting states; E ⊆ S×T ×Σ×S× T is the set of transitions such that (s, t, a, s′, t′) ∈ E iff ∃e = (s, s′, a) ∈ E : ρ(e, t) = 1, ζ(e, t) = t′ − t. In the following we shall denote (s, t, a, s′, t′) ∈ E also by s, t a → s′, t′. A TVG-automaton A(G) is deterministic if for any time t ∈ T , any state s ∈ S, any symbol a ∈ Σ, there is at most one transition of the form (s, t a → s′, t′); it is non-deterministic otherwise.\nGiven a TVG-automaton A(G), a journey in A(G) is a finite sequence of transitions J = (s0, t0 a0→\ns1, t1), (s1, t ′ 1 a1→ s2, t2) . . . (sp−1, t ′ p−1 ap−1 → sp, tp) such that the sequence<(e0, t0), (e1, t′1), ..., (ep−1, t ′ p−1)> is a journey in G and tp = t′p−1 + ζ(ep−1, t ′ p−1), where ei = (si, si+1, ai) (for 0 ≤ i < p). Consistently with the above definitions, we say that J is direct if ∀i, t′i = ti (there is no pause between transitions), and indirect otherwise (i.e., ∃i : t′i > ti). We denote by λ(J ) the associated word a0, a1, ...ap−1 and by start(J ) and arrival(J ) the dates t0 and tp, respectively. To complete the definition, an empty journey J∅ consists of a single state, involves no transitions, its associated word is the empty word λ(J∅) = ε, and its arrival date is the starting date.\nA journey is said accepting iff it starts in an initial state s0 ∈ I and ends in a accepting state sp ∈ F . A TVG-automaton A(G) accepts a word w ∈ Σ∗ iff there exists an accepting journey J such that λ(J ) = w.\nLetLnowait(G) denote the set of words (i.e., the language) accepted by TVG-automaton A(G) using only direct journeys, and let Lwait(G) be the language recognized if journeys are allowed to be indirect. Given the set U of all possible TVGs, let us denote Lnowait = {Lnowait(G) : G ∈ U} and Lwait = {Lwait(G) : G ∈ U} the sets of all languages being possibly accepted by a TVG-automaton if journeys are constrained to be direct (i.e., no waiting is allowed) and if they are unconstrained (i.e., waiting is allowed), respectively.\nIn the following, when no ambiguity arises, we will use interchangeably the terms node and state, and the terms edge and transition; the term journey will be used both in reference to the sequence of edges in the TVG and to the corresponding sequence of transitions in the associated TVG-automaton.\nThe closest concept to TVG-automata are Timed automata proposed by [1] to model real-time systems. A timed automaton has real valued clocks and the transitions are guarded with simple comparisons on the clock values; with only one clock and no reset it is a TVG-automaton with 0 latency.\nExample of TVG-automaton: Figure 2 shows an example of a deterministic TVG-automaton that recognizes the context-free language anbn for n ≥ 1 (using only direct journeys). Consider the graph G1 = (V,E,T , ρ, ζ), composed of three nodes: V = {v0, v1, v2}, and five edges: E = {(v0, v0, a), (v0, v1, b),\n(v1, v1, b), (v1, v2, b), (v0, v2, b))}. The presence and latency functions are as shown in Table 1, where p and q are two distinct prime numbers greater than 1. Consider now the corresponding automaton A(G1) where v0 is the initial state and v2 is the accepting state. For clarity, let us assume that A(G1) starts at time 1 (the same behavior could be obtained by modifying slightly the formulas involving t in Table 1). It is clear that the an portion of the word anbn is read entirely at v0 within t = pn time. If n = 1, at this time the only available edge is e3 (labeled b) which allows to correctly accept ab. Otherwise (n > 1) at time t = pn, the only available edge is e1 which allows to start reading the bn portion of the word. By construction of ρ and ζ , edge e2 is always present except for the very last b, which has to be read at time t = pnqn−1. At that time, only e4 is present and the word is correctly recognized. It is easy to verify that only these words are recognized, and the automaton is deterministic. The reader may have noticed the basic principle employed here (and later in the paper) of using latencies as a means to encode words into time, and presences as a means to select through opening the appropriate edges at the appropriate time."
    }, {
      "heading" : "3 No waiting allowed",
      "text" : "This section focuses on the expressivity of time-varying graphs when only direct journeys are allowed. We prove that Lnowait includes all computable languages.\nLet L be an arbitrary computable language defined over a finite alphabet Σ. Let ε denote the empty word; note that L might or might not contain ε. The notation α.β indicates the concatenation of α ∈ Σ∗ with β ∈ Σ∗. Let q = |Σ| be the size of the alphabet, and w.l.o.g assume that Σ = {0, . . . , q− 1}. We define an injective encoding ϕ : Σ∗→N associating to each word w = a0.a1 . . . ak ∈ Σ∗ the sum qk+1 + ∑k j=0 ajq k−j . It is exactly the integer corresponding to 1.w interpreted in base q. By convention, ϕ(ε) = 0. Consider now the TVG G2 where V = {v0, v1, v2}, E = {{(v0, v1, i), i ∈ Σ} ∪ {{(v0, v2, i), i ∈ Σ},∪{(v1, v1, i), i ∈ Σ} ∪ {(v1, v2, i), i ∈ Σ} ∪ {(v2, v1, i), i ∈ Σ} ∪ {(v2, v2, i), i ∈ Σ}}. The presence\nand latency functions are defined relative to which node is the end-point of an edge. For all u ∈ {v0, v1, v2}, i ∈ Σ, and t ≥ 0, we define\n• ρ((u, v1, i), t) = 1 iff t ∈ ϕ(Σ∗) and ϕ−1(t).i ∈ L,\n• ζ((u, v1, i), t) = ϕ(ϕ −1(t).i) − t\n• ρ((u, v2, i), t) = 1 iff t ∈ ϕ(Σ∗) and ϕ−1(t).i /∈ L,\n• ζ((u, v2, i), t) = ϕ(ϕ −1(t).i) − t\nConsider the corresponding TVG-automaton A(G2) where v0 is the initial state, and v1 is the unique accepting state if the ε /∈ L (see Figure 3), while both v0 and v1 are accepting states if ε ∈ L.\nTheorem 3.1. Lnowait(G2) = L.\nProof. We want to show there is a unique accepting journey J with λ(J ) = w iff w ∈ L. We first show that for all words w ∈ Σ∗, there is exactly one direct journey J in A(G2) such that λ(J ) = w, and in this case arrival(J ) = ϕ(w). This is proven by induction on k ∈ N, the length of the words. It clearly holds for k = 0 since the only word of that length is ε and ϕ(ε) = 0. Let k ∈ N. Suppose now that for all w ∈ Σ∗, |w| = k we have exactly one associated direct journey, and arrival(J ) = ϕ(w). Consider w1 ∈ Σ∗ with |w1| = k + 1. Without loss of generality, let w1 = w.i where w ∈ Σ∗ and i ∈ Σ. By induction there is exactly one direct journey J with λ(J ) = w. Let u = arrival(J ) be the node of arrival and t the arrival time. By induction, t ∈ ϕ(Σ∗); furthermore since the presence function depends only on the node of arrival and not on the node of origin, there exists exactly one transition, labeled i from u. So there exists only one direct journey labeled by w1. By definition of the latency function, its arrival time is ϕ(ϕ−1(t).i) = ϕ(w.i) = ϕ(w1). This ends the induction. We now show that such a unique journey is accepting iff w ∈ L. In fact, by construction of the presence function, every journey that corresponds to w ∈ L,w 6= ε, ends in v1, which is an accepting state. The empty journey corresponding to ε ends in v0 which, by definition, is accepting iff ε ∈ L."
    }, {
      "heading" : "4 Waiting allowed",
      "text" : "We now turn the attention to the case of time-varying graphs where indirect journeys are possible, that is entities have the choice to wait for future opportunities of interaction rather than seizing only those that are directly available. In striking contrast with the non-waiting case, we show that the languages Lwait recognized by TVG-automata consists only of regular languages. Let R denote the set of regular languages. We show that\nTheorem 4.1. Lwait = R.\nProof. (of inclusion for regular languages) This first inclusion follows easily from observing that any finitestate machine (FSM) is a particular TVG-automaton whose edges are always present and have a nil latency. The fact that we allow waiting here does not modify the behavior of the automata as long as we consider deterministic FSMs only (which is sufficient), since at most one choice exists at each state for each symbol read. Thus, for any regular language L, there exists a corresponding TVG G such that Lwait(G) = L.\nThe reverse inclusion is more involved. Consider G = (V,E,T , ρ, ζ) with labels in Σ, we have to show that Lwait(G) ∈ R.\nThe proof is algebraic, and based on order techniques, relying on a theorem of Harju and Ilie (Theorem 4.16 in [19]) that enables to characterize regularity from the closure of the sets from a well quasi-order. We will use here an inclusion order on journeys (to be defined formally below). Informally, a journey J is included in another journey J ′ if its sequence of transition is included (in the same order) in the sequence of transitions of J ′. It should be noted that sets of indirect journeys from one node to another are obviously closed under this inclusion order (on the journey J it is possible to wait on a node as if the missing transitions from J ′ were taking place), which is not the case for direct journeys as it is not possible to wait. In order to apply the theorem, we have to show that this inclusion order is a well quasi-order, i.e. that it is not possible to find an infinite set of journeys such that none of them could be included in another from the same set.\nLet us first introduce some definitions and results about quasi-orders. We denote by ≤ a quasi-order over a given set Q. A set X ⊂ Q is an antichain if all elements of X are pairwise incomparable. The quasi-order ≤ is well founded if in Q, there is no infinite descending sequence x1 ≥ x2 ≥ x3 ≥ . . . (where ≥ is the inverse of ≤) such that for no i, xi ≤ xi+1. If ≤ is well founded and all antichains are finite then ≤ is a well quasi-order on Q. When Q = Σ∗ for alphabet Σ, a quasi-order is monotone if for all x, y, w1, w2 ∈ Σ∗, we have x ≤ y ⇒ w1xw2 ≤ w1yw2.\nA word x ∈ Σ∗ is a subword of y ∈ Σ∗ if x can be obtained by deleting some letters on y. This defines a relation that is obviously transitive and we denote ⊆ the subword order on Σ∗. We can extend the ⊆ order to labeled walks as follows: given two walks γ, γ′ on the footprint G of G, we note γ ⊆ γ′ if γ and γ′ begin on the same node and end on the same node, and γ is a subwalk of γ′.\nGiven a date t ∈ T and a word x in Σ∗, we denote by J ∗t, x the set {J ∈ J ∗(G) : start(J ) = t, λ(J ) = x}. J ∗0, x is simply denoted J ∗x. Given two nodes u and v, we allow the notation u x\nt v if\nthere exists a journey from u to v in J ∗t, x. Given a journey J , J is the corresponding labeled walk (in the footprint G). We will denote by Γ(x) the set {J : λ(J ) = x}.\nLet x and y be two words in Σ∗. We define the quasi-order ≺, as follows: x ≺ y if\n∀J ∈ J ∗y,∃γ ∈ Γ(x), γ ⊆ J .\nThe relation ≺ is obviously reflexive. We now establish the link between comparable words and their associated journeys and walks, and state some useful properties of relation ≺.\nLemma 4.2. Let x, y ∈ Σ∗ be such that x ≺ y. Then for any Jy ∈ J ∗y, there exists Jx ∈ J ∗x such that Jx ⊆ Jy, start(Jx) = start(Jy), arrival(Jx) = arrival(Jy).\nProof. By definition, there exists a labeled path γ ∈ Γ(x) such that γ ⊆ Jy. It is then possible to find a journey Jx ∈ J ∗x with Jx = γ and arrival(Jx) = arrival(Jy) by using for every edge of Jx the schedule of the same edge in Jy.\nProposition 4.3. The relation ≺ is transitive.\nProof. Suppose we have x ≺ y and y ≺ z. Consider J ∈ J ∗z. By Lemma 4.2, we get a journey Jy ∈ J ∗y, such that Jy ⊆ J . By definition, there exists γ ∈ Γ(x) such that γ ⊆ Jy. Therefore γ ⊆ J , and finally x ≺ z.\nThe main proposition to be proved now is the following\nProposition 4.4. (Σ∗,≺) is a well quasi-order.\nIndeed, consider the two following results.\nDefinition 4.5. Let L ⊂ Σ∗. For any quasi-order ≤, we denote DOWN≤(L) = {x | ∃y ∈ L, x ≤ y}.\nThis is a corollary of Lemma 4.2\nCorollary 4.6. Consider the language L of words induced by labels of journeys from u to v starting at time t. Then DOWN≺(L)L.\nThe following theorem is due to Harju and Ilie:\nTheorem 4.7 ([19]). For any monotone well quasi order ≤ of Σ∗, for any L ⊂ Σ∗, the language DOWN≤(L) is regular.\nFrom Proposition 4.4, Corollary 4.6, and Theorem 4.7, the claim of Theorem 4.1 will immediately follow. The remaining of this section is devoted to the proof that ≺ is a well quasi-order. We have first to prove the following.\nProposition 4.8. The quasi-order ≺ is monotone.\nProof. Let x, y be such that x ≺ y. Let z ∈ Σ∗. Let J ∈ J ∗yz. Then there exists Jy ∈ J ∗y and Jz ∈ J\n∗start(Jy), z such that the end node of Jy is the start node of Jz . By Lemma 4.2, there exists Jx that ends in the same node as Jy and with the same arrival time. We can consider J ′ the concatenation of Jx and Jz. By construction J ′ ∈ Γ(xz), and J ′ ⊆ J . Therefore xz ≺ yz. The property zx ≺ zy is proved similarly using the start property of Lemma 4.2.\nProposition 4.9. The quasi-order ≺ is well funded.\nProof. Consider a descending chain x1 ≻ x2 ≻ x3 ≻ . . . such that for no i xi ≺ xi+1. We show that this chain is finite. Suppose the contrary. By definition of ≺, we can find γ1, γ2, . . . such that for all i, γi ∈ J ∗xi, and such that γi+1 ⊆ γi. This chain of walks is necessarily stationary and there exits i0 such that γi0 = γi0+1. Therefore, xi0 = xi0+1, a contradiction.\nTo prove that ≺ is a well quasi-order, we now have to prove that all antichains are finite. Let (Q,≤) be a quasi-order. For all A,B ⊂ Q, we denote A≤PB if there exists an injective mapping ϕ : A −→ B, such that for all a ∈ A, a ≤ ϕ(a). The relation ≤P is transitive and defines a quasi-order on P(Q).\nAbout the finiteness of antichains, we recall the following result\nLemma 4.10 ([20]). Let (Q,≤) be a well quasi-order. Then (P(Q),≤P ) is a well quasi-order.\nand the fundamental result of Higman:\nTheorem 4.11 ([20]). Let Σ be a finite alphabet. Then (Σ∗,⊆) is a well quasi-order.\nThis implies that our set of journey-induced walks is also a well quasi-order for ⊆ as it can be seen as a special instance of Higman’s Theorem about the subword order.\nWe are now ready to prove that all antichains are finite.\nTheorem 4.12. Let L ⊂ Σ∗ be an antichain for ≺. Then L is finite.\nWe prove this theorem by using a technique similar to the variation by [29] of the proof of [20]. First, we need the following property:\nLemma 4.13. Let X be an antichain of Σ∗. If ≺ is a well quasi-order on DOWN≺(X)\\X then X is finite.\nProof. We denote Q = DOWN≺(X)\\X, and suppose Q is a well quasi-order for ≺. Therefore the product and the associated product order (Σ × Q,≺×) define also a well quasi-order. We consider A = {(a, x) | a ∈ Σx ∈ Qax ∈ X}. Because ≺ is monotone, for all (a, x), (a′, x′) ∈ A, (a, x) ≺× (b, y) ⇒ ax ≺ by. Indeed, in this case a = b and x ≺ y ⇒ ax ≺ ay. So A has to be an antichain of the well quasi-order Σ×Q. Therefore A is finite. By construction, this implies that X is also finite.\nProof. We can now end the proof of Theorem 4.12. Suppose we have an infinite antichain X0. By applying recursively the previous lemma, there exists for all i ∈ N, Xi+1 ⊂ DOWN≺(Xi)\\Xi that is also an infinite antichain of Σ∗. By definition of DOWN≺, for all x ∈ Xi+1, there exists y ∈ Xi such that x ≺ y, ie x ⊆ y. It is also possible to choose the elements x such that no pair is sharing a common y. So Xi+1 ⊆P Xi, and we have a infinite descending chain of (P(Σ∗),⊆P). This would contradict Lemma 4.10.\nFrom Propositions 4.3, 4.8, 4.9 and Theorem 4.12 it follows that (Σ∗,≺) is a well quasi-order, completing the proof of Proposition 4.4; thus, Lwait(G) is a regular language for any TVG G, concluding the proof of Theorem 4.1. That is Lwait = R.\nRemark 4.14. The reader should note that ≺ does not correspond to ⊆P if we were to identify a word x with the subset of corresponding walks. Indeed, if W denotes the set of walks, then for A,B ∈ P(W ), A ⊂ B ⇒ A ⊆P B, however if A = Γ(x), B = Γ(y), then A ⊂ B ⇒ y ≺ x. Therefore the above theorem cannot be derived by a simple application of the results of Higman."
    }, {
      "heading" : "5 Bounded waiting allowed",
      "text" : "To better understand the power of waiting, we now turn our attention to bounded waiting; that is when indirect journeys are considered feasible if the pause between consecutive edges has a bounded duration d > 0. We examine the set Lwait[d] of all languages expressed by time-varying graphs when waiting is allowed up to d time units, and prove the negative result that for any fixed d ≥ 0, Lwait[d] = Lnowait. That is, the complexity of the environment is not affected by allowing waiting for a limited amount of time.\nThe basic idea is to reuse the same technique as in Section 3, but with a dilatation of time, i.e., given the bound d, the edge schedule is time-expanded by a factor d (and thus no new choice of transition is created compared to the no-waiting case).\nTheorem 5.1. For any duration d, Lwait[d] = Lwait[0] (i.e., Lnowait)\nProof. Let L be an arbitrary computable language defined over a finite alphabet Σ. Let d ∈ N be the maximal waiting duration. We consider a TVG G2,d structurally equivalent to G2 (see Figure 3 in Section 3), i.e.,, G2,d = (V,E,T , ρ, ζ) such that V = {v0, v1, v2}, E = {{(v0, v1, i), i ∈ Σ} ∪ {{(v0, v2, i), i ∈ Σ},∪{(v1, v1, i), i ∈ Σ}∪ {(v1, v2, i), i ∈ Σ}∪ {(v2, v1, i), i ∈ Σ}∪ {(v2, v2, i), i ∈ Σ}}. The initial state is v0, and the accepting state is v1. If ε ∈ L then v0 is also accepting.\nBased on the mapping ϕ defined for G2 in Section 3, we define another mapping ϕd that associates to any word w the value (d + 1)ϕ(w). We also define ψd(t) to be equal to ϕ−1(⌊ t d+1⌋) when it is defined. For instance, ϕ5(0110) in base 2 gives (101 + 1) × 10110 (i.e., 132 in base 10). Reversely, we have ψ5(132) = ... = ψ5(137) = 0110, and ψ5(138) = ... = ψ5(143) = 0111.\nThe presence and latency functions are now defined along the lines as those of G2, the only difference being that we are using ϕd (resp. ψd) instead of ϕ (resp. ϕ−1). Thus, for all u ∈ {v0, v1, v2}, i ∈ Σ, and t ≥ 0, we define\n• ρ((u, v1, i), t) = 1 iff ⌊ td+1⌋ ∈ ϕd(Σ ∗) and ψd(t).i ∈ L,\n• ζ((u, v1, i), t) = ϕd(ψd(t).i) − t\n• ρ((u, v2, i), t) = 1 iff ⌊ td+1⌋ ∈ ϕd(Σ ∗) and ψd(t).i /∈ L,\n• ζ((u, v2, i), t) = ϕd(ψ −1 d (t).i) − t\nBy the same induction technique as in Section 3, we have that L ⊆ L(G2,d). Similarly, we have that any journey labeled by w ends at time exactly ϕd(w), even if some d−waiting occurred.\nFinally, we remark that for all words w,w′ ∈ Σ+ such that w 6= w′, we have |ϕd(w) − ϕd(w′)| > d. Indeed, if w 6= w′ then they differ by at least one letter. The minimal time difference is when this is the last letter and these last letters are i, i + 1 w.l.o.g. In this case, |ϕd(w) − ϕd(w′)| ≥ d + 1 by definition of ϕd. Therefore waiting for a duration of d does not enable more transitions in terms of labeling."
    } ],
    "references" : [ {
      "title" : "A theory of timed automata",
      "author" : [ "R. Alur", "D.L. Dill" ],
      "venue" : "Theoretical Comp. Sci.,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1994
    }, {
      "title" : "The computational power of population protocols",
      "author" : [ "D. Angluin", "J. Aspnes", "D. Eisenstat", "E. Ruppert" ],
      "venue" : "Distributed Computing,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2007
    }, {
      "title" : "How to explore a fast-changing world",
      "author" : [ "C. Avin", "M. Koucky", "Z. Lotker" ],
      "venue" : "In Proc. 35th International Colloquium on Automata, Languages and Programming (ICALP),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "Parsimonious flooding in dynamic graphs",
      "author" : [ "H. Baumann", "P. Crescenzi", "P. Fraigniaud" ],
      "venue" : "In Proceedings 28th ACM Symposium on Principles of Distributed Computing (PODC),",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2009
    }, {
      "title" : "Complexity of connected components in evolving graphs and the computation of multicast trees in dynamic networks",
      "author" : [ "S. Bhadra", "A. Ferreira" ],
      "venue" : "In Proc. 2nd Intl. Conference on Ad Hoc Networks and Wireless (ADHOC- NOW),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2003
    }, {
      "title" : "Computing shortest, fastest, and foremost journeys in dynamic networks",
      "author" : [ "B. Bui-Xuan", "A. Ferreira", "A. Jarry" ],
      "venue" : "Intl. J. of Foundations of Comp. Science,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2003
    }, {
      "title" : "Characterizing topological assumptions of distributed algorithms in dynamic networks",
      "author" : [ "A. Casteigts", "S. Chaumette", "A. Ferreira" ],
      "venue" : "In Proc. 16th Intl. Colloquium on Structural Information and Communication Complexity (SIROCCO),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2009
    }, {
      "title" : "Deterministic computations in time-varying graphs: Broadcasting under unstructured mobility",
      "author" : [ "A. Casteigts", "P. Flocchini", "B. Mans", "N. Santoro" ],
      "venue" : "In Proc. 5th IFIP Conference on Theoretical Computer Science (TCS),",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2010
    }, {
      "title" : "Measuring temporal lags in delay-tolerant networks",
      "author" : [ "A. Casteigts", "P. Flocchini", "B. Mans", "N. Santoro" ],
      "venue" : "In Proc. 25th IEEE Intl. Parallel and Distr. Processing Symp. (IPDPS),",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Time-varying graphs and dynamic networks",
      "author" : [ "A. Casteigts", "P. Flocchini", "W. Quattrociocchi", "N. Santoro" ],
      "venue" : "In Proc. 10th Int. Conf. on Ad Hoc Networks and Wireless (ADHOC-NOW),",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "Mediated population protocols",
      "author" : [ "I. Chatzigiannakis", "O. Michail", "P. Spirakis" ],
      "venue" : "Proc. 36th Int. Colloquium on Automata, Languages and Programming,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2009
    }, {
      "title" : "Rumor spreading in social networks",
      "author" : [ "F. Chierichetti", "S. Lattanzi", "A. Panconesi" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Flooding time in edge-markovian dynamic graphs",
      "author" : [ "A. Clementi", "C. Macci", "A. Monti", "F. Pasquale", "R. Silvestri" ],
      "venue" : "In Proc. 27th ACM Symp. on Principles of Distributed Computing (PODC),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Information spreading in stationary markovian evolving graphs",
      "author" : [ "A. Clementi", "A. Monti", "F. Pasquale", "R. Silvestri" ],
      "venue" : "In Proc. of the 23rd IEEE International Parallel and Distributed Processing Symposium (IPDPS),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "Prioritized gossip in vehicular networks",
      "author" : [ "A. Cornejo", "C. Newport" ],
      "venue" : "In Proc. of the 6th International Workshop on Foundations of Mobile Computing (DIALM-POMC),",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "Building a reference combinatorial model for MANETs",
      "author" : [ "A. Ferreira" ],
      "venue" : "IEEE Network,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2004
    }, {
      "title" : "Exploration of periodically varying graphs",
      "author" : [ "P. Flocchini", "B. Mans", "N. Santoro" ],
      "venue" : "In Proc. 20th Intl. Symposium on Algorithms and Computation (ISAAC),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2009
    }, {
      "title" : "What model and what conditions to implement unreliable failure detectors in dynamic networks",
      "author" : [ "F. Greve", "L. Arantes", "P. Sens" ],
      "venue" : "In Proceedings of the 3rd International Workshop on Theoretical Aspects of Dynamic Distributed Systems,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2011
    }, {
      "title" : "On quasi orders of words and the confluence property",
      "author" : [ "T. Harju", "L. Ilie" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1998
    }, {
      "title" : "Ordering by divisibility in abstract algebras",
      "author" : [ "G. Higman" ],
      "venue" : "Proceedings of the London Mathematical Society,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1952
    }, {
      "title" : "On the power of waiting when exploring public transportation systems",
      "author" : [ "D. Ilcinkas", "A. Wade" ],
      "venue" : "Principles of Distributed Systems (OPODIS),",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2011
    }, {
      "title" : "Practical routing in delay-tolerant networks",
      "author" : [ "E.P.C. Jones", "L. Li", "J.K. Schmidtke", "P.A.S. Ward" ],
      "venue" : "IEEE Transactions on Mobile Computing,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2007
    }, {
      "title" : "Protocols and impossibility results for gossip-based communication mechanisms",
      "author" : [ "D. Kempe", "J. Kleinberg" ],
      "venue" : "In Proc. 43rd Symposium on Foundations of Computer Science (FOCS),",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2002
    }, {
      "title" : "The structure of information pathways in a social communication network",
      "author" : [ "G. Kossinets", "J. Kleinberg", "D. Watts" ],
      "venue" : "In Proc. 14th Intl. Conf. on Knowledge Discovery and Data Mining (KDD),",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2008
    }, {
      "title" : "Distributed computation in dynamic networks",
      "author" : [ "F. Kuhn", "N. Lynch", "R. Oshman" ],
      "venue" : "In Proceedings of the 42nd ACM Symposium on Theory of computing (STOC),",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2010
    }, {
      "title" : "Coordinated consensus in dynamic networks",
      "author" : [ "F. Kuhn", "Y. Moses", "R. Oshman" ],
      "venue" : "In Proc. of the 30th ACM Symposium on Principles of Distributed Computing (PODC),",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2011
    }, {
      "title" : "Efficient adaptive routing in delay tolerant networks",
      "author" : [ "C. Liu", "J. Wu" ],
      "venue" : "In Proc. of IEEE International Conference on Communications (ICC’09),",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2009
    }, {
      "title" : "Scalable routing in cyclic mobile networks",
      "author" : [ "C. Liu", "J. Wu" ],
      "venue" : "IEEE Trans. Parallel Distrib. Syst.,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2009
    }, {
      "title" : "On well-quasi-ordering finite trees",
      "author" : [ "C. St. J.A. Nash-Williams" ],
      "venue" : "Mathematical Proceedings of the Cambridge Philosophical Society,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1963
    }, {
      "title" : "Information dissemination in highly dynamic graphs",
      "author" : [ "R. O’Dell", "R. Wattenhofer" ],
      "venue" : "In Proc. Joint Workshop on Foundations of Mobile Computing (FOMC),",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2005
    }, {
      "title" : "Small-world behavior in time-varying graphs",
      "author" : [ "J. Tang", "S. Scellato", "M. Musolesi", "C. Mascolo", "V. Latora" ],
      "venue" : "Phys. Rev. E,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "Study of a bus-based disruption-tolerant network: mobility modeling and impact on routing",
      "author" : [ "X. Zhang", "J. Kurose", "B.N. Levine", "D. Towsley", "H. Zhang" ],
      "venue" : "In Proc. 13th ACM Int. Conference on Mobile Computing and Networking,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2007
    }, {
      "title" : "Routing in intermittently connected mobile ad hoc networks and delay tolerant networks: Overview and challenges",
      "author" : [ "Z. Zhang" ],
      "venue" : "IEEE Communications Surveys & Tutorials,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "[22, 27, 33]).",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 26,
      "context" : "[22, 27, 33]).",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 32,
      "context" : "[22, 27, 33]).",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 27,
      "context" : ", see [28, 32]).",
      "startOffset" : 6,
      "endOffset" : 14
    }, {
      "referenceID" : 31,
      "context" : ", see [28, 32]).",
      "startOffset" : 6,
      "endOffset" : 14
    }, {
      "referenceID" : 11,
      "context" : "[12, 24]).",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 23,
      "context" : "[12, 24]).",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 3,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 6,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 9,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 13,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 15,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 16,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 17,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 20,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 24,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 25,
      "context" : ", see [4, 7, 10, 14, 16, 17, 18, 21, 25, 26]).",
      "startOffset" : 6,
      "endOffset" : 44
    }, {
      "referenceID" : 18,
      "context" : "The proof is algebraic and based on order techniques, relying on a theorem by Harju and Ilie [19] that enables to characterize regularity from the closure of the sets from a well quasi-order.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 15,
      "context" : "The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 4,
      "context" : "The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6].",
      "startOffset" : 206,
      "endOffset" : 212
    }, {
      "referenceID" : 5,
      "context" : "The idea of representing dynamic graphs as a sequence of (static) graphs, called evolving graph, was introduced in [16], to study basic network problems in dynamic networks from a centralized point of view [5, 6].",
      "startOffset" : 206,
      "endOffset" : 212
    }, {
      "referenceID" : 9,
      "context" : "The equivalent model of time-varying graph (TVG), formalized in [10] and used here, views the dynamics of the system from the local point of view of the entities: for any given entity, the local edges and neighborhood can be considered independently from the entire graph (e.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 2,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 2,
      "endOffset" : 19
    }, {
      "referenceID" : 7,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 2,
      "endOffset" : 19
    }, {
      "referenceID" : 8,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 2,
      "endOffset" : 19
    }, {
      "referenceID" : 14,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 2,
      "endOffset" : 19
    }, {
      "referenceID" : 29,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 2,
      "endOffset" : 19
    }, {
      "referenceID" : 16,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 98,
      "endOffset" : 106
    }, {
      "referenceID" : 20,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 98,
      "endOffset" : 106
    }, {
      "referenceID" : 17,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 24,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 156,
      "endOffset" : 164
    }, {
      "referenceID" : 25,
      "context" : ", [3, 8, 9, 15, 30]); to study problems of exploration in vehicular networks with periodic routes [17, 21]; to examine failure detectors [18] and consensus [25, 26]; for the probabilistic analysis of informations spreading (e.",
      "startOffset" : 156,
      "endOffset" : 164
    }, {
      "referenceID" : 3,
      "context" : ", [4, 13]); and in the investigations of emerging properties in social networks (e.",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 12,
      "context" : ", [4, 13]); and in the investigations of emerging properties in social networks (e.",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 22,
      "context" : ", [23, 31]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 30,
      "context" : ", [23, 31]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 9,
      "context" : "A characterization of classes of TVGs with respect to properties typically assumed in the research can be found in [10].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 1,
      "context" : ", [2, 11]); interestingly, the setting over which population protocols are defined is a particular class of time-varying graphs (recurrent interactions over a connected underlying graph).",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 10,
      "context" : ", [2, 11]); interestingly, the setting over which population protocols are defined is a particular class of time-varying graphs (recurrent interactions over a connected underlying graph).",
      "startOffset" : 2,
      "endOffset" : 9
    }, {
      "referenceID" : 20,
      "context" : "The impact of bounded waiting in dynamic networks has been investigated for exploration [21].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 9,
      "context" : "The time-varying-graph (TVG) formalism can arguably describe a multitude of different scenarios, from transportation networks to communication networks, complex systems, or social networks [10].",
      "startOffset" : 189,
      "endOffset" : 193
    }, {
      "referenceID" : 9,
      "context" : "We use the notation for time-varying graphs introduced in [10]",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 0,
      "context" : "The closest concept to TVG-automata are Timed automata proposed by [1] to model real-time systems.",
      "startOffset" : 67,
      "endOffset" : 70
    }, {
      "referenceID" : 18,
      "context" : "16 in [19]) that enables to characterize regularity from the closure of the sets from a well quasi-order.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 18,
      "context" : "7 ([19]).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 19,
      "context" : "10 ([20]).",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 19,
      "context" : "11 ([20]).",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 28,
      "context" : "We prove this theorem by using a technique similar to the variation by [29] of the proof of [20].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 19,
      "context" : "We prove this theorem by using a technique similar to the variation by [29] of the proof of [20].",
      "startOffset" : 92,
      "endOffset" : 96
    } ],
    "year" : 2014,
    "abstractText" : "In infrastructure-less highly dynamic networks, computing and performing even basic tasks (such as routing and broadcasting) is a very challenging activity due to the fact that connectivity does not necessarily hold, and the network may actually be disconnected at every time instant. Clearly the task of designing protocols for these networks is less difficult if the environment allows waiting (i.e., it provides the nodes with store-carry-forward-like mechanisms such as local buffering) than if waiting is not feasible. No quantitative corroborations of this fact exist (e.g., no answer to the question: how much easier?). In this paper, we consider these qualitative questions about dynamic networks, modeled as time-varying (or evolving) graphs, where edges exist only at some times. We examine the difficulty of the environment in terms of the expressivity of the corresponding time-varying graph; that is in terms of the language generated by the feasible journeys in the graph. We prove that the set of languages Lnowait when no waiting is allowed contains all computable languages. On the other end, using algebraic properties of quasi-orders, we prove that Lwait is just the family of regular languages. In other words, we prove that, when waiting is no longer forbidden, the power of the accepting automaton (difficulty of the environment) drops drastically from being as powerful as a Turing machine, to becoming that of a Finite-State machine. This (perhaps surprisingly large) gap is a measure of the computational power of waiting. We also study bounded waiting; that is when waiting is allowed at a node only for at most d time units. We prove the negative result that Lwait[d] = Lnowait; that is, the expressivity decreases only if the waiting is finite but unpredictable (i.e., under the control of the protocol designer and not of the environment).",
    "creator" : "LaTeX with hyperref package"
  }
}