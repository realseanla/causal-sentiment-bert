We discuss a range of modeling choices that arise when constructing an end-to-end differentiable programming language suitable for learning programs from input-output examples.
Taking cues from programming languages research, we study the effect of memory allocation schemes, immutable data, type systems, and built-in control-flow structures on the success rate of learning algorithms.
We build a range of models leading up to a simple differentiable functional programming language.
Our empirical evaluation shows that this language allows to learn far more programs than existing baselines.
